import * as outputs from "../types/output";
export interface GetAvailabilityZoneFilter {
    /**
     * Name of the filter field. Valid values can be found in the [EC2 DescribeAvailabilityZones API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html).
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}
export interface GetAvailabilityZonesFilter {
    /**
     * Name of the filter field. Valid values can be found in the [EC2 DescribeAvailabilityZones API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html).
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}
export interface GetRegionsFilter {
    /**
     * Name of the filter field. Valid values can be found in the [describe-regions AWS CLI Reference][1].
     */
    name: string;
    /**
     * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
     */
    values: string[];
}
export declare namespace accessanalyzer {
    interface AnalyzerConfiguration {
        /**
         * A block that specifies the configuration of an unused access analyzer for an AWS organization or account. Documented below
         */
        unusedAccess?: outputs.accessanalyzer.AnalyzerConfigurationUnusedAccess;
    }
    interface AnalyzerConfigurationUnusedAccess {
        /**
         * The specified access age in days for which to generate findings for unused access.
         */
        unusedAccessAge?: number;
    }
    interface ArchiveRuleFilter {
        /**
         * Contains comparator.
         */
        contains: string[];
        /**
         * Filter criteria.
         */
        criteria: string;
        /**
         * Equals comparator.
         */
        eqs: string[];
        /**
         * Boolean comparator.
         */
        exists: string;
        /**
         * Not Equals comparator.
         */
        neqs: string[];
    }
}
export declare namespace acm {
    interface CertificateDomainValidationOption {
        /**
         * Fully qualified domain name (FQDN) in the certificate.
         */
        domainName: string;
        /**
         * The name of the DNS record to create to validate the certificate
         */
        resourceRecordName: string;
        /**
         * The type of DNS record to create
         */
        resourceRecordType: string;
        /**
         * The value the DNS record needs to have
         */
        resourceRecordValue: string;
    }
    interface CertificateOptions {
        /**
         * Whether certificate details should be added to a certificate transparency log. Valid values are `ENABLED` or `DISABLED`. See https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency for more details.
         */
        certificateTransparencyLoggingPreference?: string;
    }
    interface CertificateRenewalSummary {
        /**
         * The status of ACM's managed renewal of the certificate
         */
        renewalStatus: string;
        /**
         * The reason that a renewal request was unsuccessful or is pending
         */
        renewalStatusReason: string;
        updatedAt: string;
    }
    interface CertificateValidationOption {
        /**
         * Fully qualified domain name (FQDN) in the certificate.
         */
        domainName: string;
        /**
         * Domain name that you want ACM to use to send you validation emails. This domain name is the suffix of the email addresses that you want ACM to use. This must be the same as the `domainName` value or a superdomain of the `domainName` value. For example, if you request a certificate for `"testing.example.com"`, you can specify `"example.com"` for this value.
         */
        validationDomain: string;
    }
}
export declare namespace acmpca {
    interface CertificateAuthorityCertificateAuthorityConfiguration {
        /**
         * Type of the public key algorithm and size, in bits, of the key pair that your key pair creates when it issues a certificate. Valid values can be found in the [ACM PCA Documentation](https://docs.aws.amazon.com/privateca/latest/APIReference/API_CertificateAuthorityConfiguration.html).
         */
        keyAlgorithm: string;
        /**
         * Name of the algorithm your private CA uses to sign certificate requests. Valid values can be found in the [ACM PCA Documentation](https://docs.aws.amazon.com/privateca/latest/APIReference/API_CertificateAuthorityConfiguration.html).
         */
        signingAlgorithm: string;
        /**
         * Nested argument that contains X.500 distinguished name information. At least one nested attribute must be specified.
         */
        subject: outputs.acmpca.CertificateAuthorityCertificateAuthorityConfigurationSubject;
    }
    interface CertificateAuthorityCertificateAuthorityConfigurationSubject {
        /**
         * Fully qualified domain name (FQDN) associated with the certificate subject. Must be less than or equal to 64 characters in length.
         */
        commonName?: string;
        /**
         * Two digit code that specifies the country in which the certificate subject located. Must be less than or equal to 2 characters in length.
         */
        country?: string;
        /**
         * Disambiguating information for the certificate subject. Must be less than or equal to 64 characters in length.
         */
        distinguishedNameQualifier?: string;
        /**
         * Typically a qualifier appended to the name of an individual. Examples include Jr. for junior, Sr. for senior, and III for third. Must be less than or equal to 3 characters in length.
         */
        generationQualifier?: string;
        /**
         * First name. Must be less than or equal to 16 characters in length.
         */
        givenName?: string;
        /**
         * Concatenation that typically contains the first letter of the `givenName`, the first letter of the middle name if one exists, and the first letter of the `surname`. Must be less than or equal to 5 characters in length.
         */
        initials?: string;
        /**
         * Locality (such as a city or town) in which the certificate subject is located. Must be less than or equal to 128 characters in length.
         */
        locality?: string;
        /**
         * Legal name of the organization with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
         */
        organization?: string;
        /**
         * Subdivision or unit of the organization (such as sales or finance) with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
         */
        organizationalUnit?: string;
        /**
         * Typically a shortened version of a longer `givenName`. For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth, Liz, or Eliza. Must be less than or equal to 128 characters in length.
         */
        pseudonym?: string;
        /**
         * State in which the subject of the certificate is located. Must be less than or equal to 128 characters in length.
         */
        state?: string;
        /**
         * Family name. In the US and the UK for example, the surname of an individual is ordered last. In Asian cultures the surname is typically ordered first. Must be less than or equal to 40 characters in length.
         */
        surname?: string;
        /**
         * Title such as Mr. or Ms. which is pre-pended to the name to refer formally to the certificate subject. Must be less than or equal to 64 characters in length.
         */
        title?: string;
    }
    interface CertificateAuthorityRevocationConfiguration {
        /**
         * Nested argument containing configuration of the certificate revocation list (CRL), if any, maintained by the certificate authority. Defined below.
         */
        crlConfiguration?: outputs.acmpca.CertificateAuthorityRevocationConfigurationCrlConfiguration;
        /**
         * Nested argument containing configuration of
         * the custom OCSP responder endpoint. Defined below.
         */
        ocspConfiguration?: outputs.acmpca.CertificateAuthorityRevocationConfigurationOcspConfiguration;
    }
    interface CertificateAuthorityRevocationConfigurationCrlConfiguration {
        /**
         * Name inserted into the certificate CRL Distribution Points extension that enables the use of an alias for the CRL distribution point. Use this value if you don't want the name of your S3 bucket to be public. Must be less than or equal to 253 characters in length.
         */
        customCname?: string;
        /**
         * Boolean value that specifies whether certificate revocation lists (CRLs) are enabled. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * Number of days until a certificate expires. Must be between 1 and 5000.
         */
        expirationInDays?: number;
        /**
         * Name of the S3 bucket that contains the CRL. If you do not provide a value for the `customCname` argument, the name of your S3 bucket is placed into the CRL Distribution Points extension of the issued certificate. You must specify a bucket policy that allows ACM PCA to write the CRL to your bucket. Must be between 3 and 255 characters in length.
         */
        s3BucketName?: string;
        /**
         * Determines whether the CRL will be publicly readable or privately held in the CRL Amazon S3 bucket. Defaults to `PUBLIC_READ`.
         */
        s3ObjectAcl: string;
    }
    interface CertificateAuthorityRevocationConfigurationOcspConfiguration {
        /**
         * Boolean value that specifies whether a custom OCSP responder is enabled.
         */
        enabled: boolean;
        /**
         * CNAME specifying a customized OCSP domain. Note: The value of the CNAME must not include a protocol prefix such as "http://" or "https://".
         */
        ocspCustomCname?: string;
    }
    interface CertificateValidity {
        /**
         * Determines how `value` is interpreted. Valid values: `DAYS`, `MONTHS`, `YEARS`, `ABSOLUTE`, `END_DATE`.
         */
        type: string;
        /**
         * If `type` is `DAYS`, `MONTHS`, or `YEARS`, the relative time until the certificate expires. If `type` is `ABSOLUTE`, the date in seconds since the Unix epoch. If `type` is `END_DATE`, the  date in RFC 3339 format.
         */
        value: string;
    }
    interface GetCertificateAuthorityRevocationConfiguration {
        /**
         * Nested attribute containing configuration of the certificate revocation list (CRL), if any, maintained by the certificate authority.
         */
        crlConfigurations: outputs.acmpca.GetCertificateAuthorityRevocationConfigurationCrlConfiguration[];
        ocspConfigurations: outputs.acmpca.GetCertificateAuthorityRevocationConfigurationOcspConfiguration[];
    }
    interface GetCertificateAuthorityRevocationConfigurationCrlConfiguration {
        /**
         * Name inserted into the certificate CRL Distribution Points extension that enables the use of an alias for the CRL distribution point.
         */
        customCname: string;
        /**
         * Boolean value that specifies whether certificate revocation lists (CRLs) are enabled.
         */
        enabled: boolean;
        /**
         * Number of days until a certificate expires.
         */
        expirationInDays: number;
        /**
         * Name of the S3 bucket that contains the CRL.
         */
        s3BucketName: string;
        /**
         * Whether the CRL is publicly readable or privately held in the CRL Amazon S3 bucket.
         */
        s3ObjectAcl: string;
    }
    interface GetCertificateAuthorityRevocationConfigurationOcspConfiguration {
        /**
         * Boolean value that specifies whether a custom OCSP responder is enabled.
         */
        enabled: boolean;
        /**
         * A CNAME specifying a customized OCSP domain.
         */
        ocspCustomCname: string;
    }
}
export declare namespace alb {
    interface GetListenerDefaultAction {
        authenticateCognitos: outputs.alb.GetListenerDefaultActionAuthenticateCognito[];
        authenticateOidcs: outputs.alb.GetListenerDefaultActionAuthenticateOidc[];
        fixedResponses: outputs.alb.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.alb.GetListenerDefaultActionForward[];
        order: number;
        redirects: outputs.alb.GetListenerDefaultActionRedirect[];
        targetGroupArn: string;
        type: string;
    }
    interface GetListenerDefaultActionAuthenticateCognito {
        authenticationRequestExtraParams: {
            [key: string]: string;
        };
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }
    interface GetListenerDefaultActionAuthenticateOidc {
        authenticationRequestExtraParams: {
            [key: string]: string;
        };
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        tokenEndpoint: string;
        userInfoEndpoint: string;
    }
    interface GetListenerDefaultActionFixedResponse {
        contentType: string;
        messageBody: string;
        statusCode: string;
    }
    interface GetListenerDefaultActionForward {
        stickinesses: outputs.alb.GetListenerDefaultActionForwardStickiness[];
        targetGroups: outputs.alb.GetListenerDefaultActionForwardTargetGroup[];
    }
    interface GetListenerDefaultActionForwardStickiness {
        duration: number;
        enabled: boolean;
    }
    interface GetListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the listener. Required if `loadBalancerArn` and `port` is not set.
         */
        arn: string;
        weight: number;
    }
    interface GetListenerDefaultActionRedirect {
        host: string;
        path: string;
        /**
         * Port of the listener. Required if `arn` is not set.
         */
        port: string;
        protocol: string;
        query: string;
        statusCode: string;
    }
    interface GetListenerMutualAuthentication {
        ignoreClientCertificateExpiry: boolean;
        mode: string;
        trustStoreArn: string;
    }
    interface GetLoadBalancerAccessLogs {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }
    interface GetLoadBalancerConnectionLog {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }
    interface GetLoadBalancerSubnetMapping {
        allocationId: string;
        ipv6Address: string;
        outpostId: string;
        privateIpv4Address: string;
        subnetId: string;
    }
    interface GetTargetGroupHealthCheck {
        enabled: boolean;
        healthyThreshold: number;
        interval: number;
        matcher: string;
        path: string;
        port: string;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }
    interface GetTargetGroupStickiness {
        cookieDuration: number;
        cookieName: string;
        enabled: boolean;
        type: string;
    }
    interface ListenerDefaultAction {
        /**
         * Configuration block for using Amazon Cognito to authenticate users. Specify only when `type` is `authenticate-cognito`. Detailed below.
         */
        authenticateCognito?: outputs.alb.ListenerDefaultActionAuthenticateCognito;
        /**
         * Configuration block for an identity provider that is compliant with OpenID Connect (OIDC). Specify only when `type` is `authenticate-oidc`. Detailed below.
         */
        authenticateOidc?: outputs.alb.ListenerDefaultActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.alb.ListenerDefaultActionFixedResponse;
        /**
         * Configuration block for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`. Detailed below.
         */
        forward?: outputs.alb.ListenerDefaultActionForward;
        /**
         * Order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first. Valid values are between `1` and `50000`.
         */
        order: number;
        /**
         * Configuration block for creating a redirect action. Required if `type` is `redirect`. Detailed below.
         */
        redirect?: outputs.alb.ListenerDefaultActionRedirect;
        /**
         * ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * Type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         *
         * The following arguments are optional:
         */
        type: string;
    }
    interface ListenerDefaultActionAuthenticateCognito {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10. Detailed below.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * Behavior if the user is not authenticated. Valid values are `deny`, `allow` and `authenticate`.
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * Domain prefix or fully-qualified domain name of the Cognito user pool.
         *
         * The following arguments are optional:
         */
        userPoolDomain: string;
    }
    interface ListenerDefaultActionAuthenticateOidc {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * Authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * Behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * Token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * User info endpoint of the IdP.
         *
         * The following arguments are optional:
         */
        userInfoEndpoint: string;
    }
    interface ListenerDefaultActionFixedResponse {
        /**
         * Content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         *
         * The following arguments are optional:
         */
        contentType: string;
        /**
         * Message body.
         */
        messageBody?: string;
        /**
         * HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }
    interface ListenerDefaultActionForward {
        /**
         * Configuration block for target group stickiness for the rule. Detailed below.
         */
        stickiness?: outputs.alb.ListenerDefaultActionForwardStickiness;
        /**
         * Set of 1-5 target group blocks. Detailed below.
         *
         * The following arguments are optional:
         */
        targetGroups: outputs.alb.ListenerDefaultActionForwardTargetGroup[];
    }
    interface ListenerDefaultActionForwardStickiness {
        /**
         * Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         *
         * The following arguments are optional:
         */
        duration: number;
        /**
         * Whether target group stickiness is enabled. Default is `false`.
         */
        enabled?: boolean;
    }
    interface ListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the target group.
         *
         * The following arguments are optional:
         */
        arn: string;
        /**
         * Weight. The range is 0 to 999.
         */
        weight?: number;
    }
    interface ListenerDefaultActionRedirect {
        /**
         * Hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * Port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * Protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         *
         * The following arguments are optional:
         */
        statusCode: string;
    }
    interface ListenerMutualAuthentication {
        /**
         * Whether client certificate expiry is ignored. Default is `false`.
         */
        ignoreClientCertificateExpiry?: boolean;
        /**
         * Valid values are `off`, `verify` and `passthrough`.
         */
        mode: string;
        /**
         * ARN of the elbv2 Trust Store.
         */
        trustStoreArn?: string;
    }
    interface ListenerRuleAction {
        /**
         * Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
         */
        authenticateCognito?: outputs.alb.ListenerRuleActionAuthenticateCognito;
        /**
         * Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
         */
        authenticateOidc?: outputs.alb.ListenerRuleActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.alb.ListenerRuleActionFixedResponse;
        /**
         * Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`.
         */
        forward?: outputs.alb.ListenerRuleActionForward;
        order: number;
        /**
         * Information for creating a redirect action. Required if `type` is `redirect`.
         */
        redirect?: outputs.alb.ListenerRuleActionRedirect;
        /**
         * The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         */
        type: string;
    }
    interface ListenerRuleActionAuthenticateCognito {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * The ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * The domain prefix or fully-qualified domain name of the Cognito user pool.
         */
        userPoolDomain: string;
    }
    interface ListenerRuleActionAuthenticateOidc {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * The authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * The OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * The OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * The user info endpoint of the IdP.
         */
        userInfoEndpoint: string;
    }
    interface ListenerRuleActionFixedResponse {
        /**
         * The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         */
        contentType: string;
        /**
         * The message body.
         */
        messageBody?: string;
        /**
         * The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }
    interface ListenerRuleActionForward {
        /**
         * The target group stickiness for the rule.
         */
        stickiness?: outputs.alb.ListenerRuleActionForwardStickiness;
        /**
         * One or more target groups block.
         */
        targetGroups: outputs.alb.ListenerRuleActionForwardTargetGroup[];
    }
    interface ListenerRuleActionForwardStickiness {
        /**
         * The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         */
        duration: number;
        /**
         * Indicates whether target group stickiness is enabled.
         */
        enabled?: boolean;
    }
    interface ListenerRuleActionForwardTargetGroup {
        /**
         * The Amazon Resource Name (ARN) of the target group.
         */
        arn: string;
        /**
         * The weight. The range is 0 to 999.
         */
        weight?: number;
    }
    interface ListenerRuleActionRedirect {
        /**
         * The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         */
        statusCode: string;
    }
    interface ListenerRuleCondition {
        /**
         * Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
         */
        hostHeader?: outputs.alb.ListenerRuleConditionHostHeader;
        /**
         * HTTP headers to match. HTTP Header block fields documented below.
         */
        httpHeader?: outputs.alb.ListenerRuleConditionHttpHeader;
        /**
         * Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         */
        httpRequestMethod?: outputs.alb.ListenerRuleConditionHttpRequestMethod;
        /**
         * Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `queryString` condition.
         */
        pathPattern?: outputs.alb.ListenerRuleConditionPathPattern;
        /**
         * Query strings to match. Query String block fields documented below.
         */
        queryStrings?: outputs.alb.ListenerRuleConditionQueryString[];
        /**
         * Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         *
         * > **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         */
        sourceIp?: outputs.alb.ListenerRuleConditionSourceIp;
    }
    interface ListenerRuleConditionHostHeader {
        values: string[];
    }
    interface ListenerRuleConditionHttpHeader {
        /**
         * Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
         */
        httpHeaderName: string;
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         */
        values: string[];
    }
    interface ListenerRuleConditionHttpRequestMethod {
        values: string[];
    }
    interface ListenerRuleConditionPathPattern {
        values: string[];
    }
    interface ListenerRuleConditionQueryString {
        /**
         * Query string key pattern to match.
         */
        key?: string;
        /**
         * Query string value pattern to match.
         */
        value: string;
    }
    interface ListenerRuleConditionSourceIp {
        values: string[];
    }
    interface LoadBalancerAccessLogs {
        /**
         * S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `accessLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }
    interface LoadBalancerConnectionLogs {
        /**
         * S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `connectionLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }
    interface LoadBalancerSubnetMapping {
        /**
         * Allocation ID of the Elastic IP address for an internet-facing load balancer.
         */
        allocationId?: string;
        /**
         * IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
         */
        ipv6Address?: string;
        outpostId: string;
        /**
         * Private IPv4 address for an internal load balancer.
         */
        privateIpv4Address?: string;
        /**
         * ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
         */
        subnetId: string;
    }
    interface TargetGroupHealthCheck {
        /**
         * Whether health checks are enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
         */
        healthyThreshold?: number;
        /**
         * Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For `lambda` target groups, it needs to be greater than the timeout of the underlying `lambda`. Defaults to 30.
         */
        interval?: number;
        /**
         * The HTTP or gRPC codes to use when checking for a successful response from a target.
         * The `health_check.protocol` must be one of `HTTP` or `HTTPS` or the `targetType` must be `lambda`.
         * Values can be comma-separated individual values (e.g., "200,202") or a range of values (e.g., "200-299").
         * * For gRPC-based target groups (i.e., the `protocol` is one of `HTTP` or `HTTPS` and the `protocolVersion` is `GRPC`), values can be between `0` and `99`. The default is `12`.
         * * When used with an Application Load Balancer (i.e., the `protocol` is one of `HTTP` or `HTTPS` and the `protocolVersion` is not `GRPC`), values can be between `200` and `499`. The default is `200`.
         * * When used with a Network Load Balancer (i.e., the `protocol` is one of `TCP`, `TCP_UDP`, `UDP`, or `TLS`), values can be between `200` and `599`. The default is `200-399`.
         * * When the `targetType` is `lambda`, values can be between `200` and `499`. The default is `200`.
         */
        matcher: string;
        /**
         * Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
         * * For HTTP and HTTPS health checks, the default is `/`.
         * * For gRPC health checks, the default is `/Amazon Web Services.ALB/healthcheck`.
         */
        path: string;
        /**
         * The port the load balancer uses when performing health checks on targets.
         * Valid values are either `traffic-port`, to use the same port as the target group, or a valid port number between `1` and `65536`.
         * Default is `traffic-port`.
         */
        port?: string;
        /**
         * Protocol the load balancer uses when performing health checks on targets.
         * Must be one of `TCP`, `HTTP`, or `HTTPS`.
         * The `TCP` protocol is not supported for health checks if the protocol of the target group is `HTTP` or `HTTPS`.
         * Default is `HTTP`.
         * Cannot be specified when the `targetType` is `lambda`.
         */
        protocol?: string;
        /**
         * Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
         */
        timeout: number;
        /**
         * Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
         */
        unhealthyThreshold?: number;
    }
    interface TargetGroupStickiness {
        /**
         * Only used when the type is `lbCookie`. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
         */
        cookieDuration?: number;
        /**
         * Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is `appCookie`.
         */
        cookieName?: string;
        /**
         * Boolean to enable / disable `stickiness`. Default is `true`.
         */
        enabled?: boolean;
        /**
         * The type of sticky sessions. The only current possible values are `lbCookie`, `appCookie` for ALBs, `sourceIp` for NLBs, and `sourceIpDestIp`, `sourceIpDestIpProto` for GWLBs.
         */
        type: string;
    }
    interface TargetGroupTargetFailover {
        /**
         * Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onUnhealthy`. Default: `noRebalance`.
         */
        onDeregistration: string;
        /**
         * Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onDeregistration`. Default: `noRebalance`.
         */
        onUnhealthy: string;
    }
    interface TargetGroupTargetHealthState {
        /**
         * Indicates whether the load balancer terminates connections to unhealthy targets. Possible values are `true` or `false`. Default: `true`.
         */
        enableUnhealthyConnectionTermination: boolean;
    }
}
export declare namespace amp {
    interface ScraperDestination {
        /**
         * Configuration block for an Amazon Managed Prometheus workspace destination. See `amp`.
         */
        amp?: outputs.amp.ScraperDestinationAmp;
    }
    interface ScraperDestinationAmp {
        /**
         * The Amazon Resource Name (ARN) of the prometheus workspace.
         */
        workspaceArn: string;
    }
    interface ScraperSource {
        /**
         * Configuration block for an EKS cluster source. See `eks`.
         */
        eks?: outputs.amp.ScraperSourceEks;
    }
    interface ScraperSourceEks {
        clusterArn: string;
        /**
         * List of the security group IDs for the Amazon EKS cluster VPC configuration.
         */
        securityGroupIds: string[];
        /**
         * List of subnet IDs. Must be in at least two different availability zones.
         */
        subnetIds: string[];
    }
    interface ScraperTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface WorkspaceLoggingConfiguration {
        /**
         * The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
         */
        logGroupArn: string;
    }
}
export declare namespace amplify {
    interface AppAutoBranchCreationConfig {
        /**
         * Basic authorization credentials for the autocreated branch.
         */
        basicAuthCredentials?: string;
        /**
         * Build specification (build spec) for the autocreated branch.
         */
        buildSpec?: string;
        /**
         * Enables auto building for the autocreated branch.
         */
        enableAutoBuild?: boolean;
        /**
         * Enables basic authorization for the autocreated branch.
         */
        enableBasicAuth?: boolean;
        /**
         * Enables performance mode for the branch.
         */
        enablePerformanceMode?: boolean;
        /**
         * Enables pull request previews for the autocreated branch.
         */
        enablePullRequestPreview?: boolean;
        /**
         * Environment variables for the autocreated branch.
         */
        environmentVariables?: {
            [key: string]: string;
        };
        /**
         * Framework for the autocreated branch.
         */
        framework?: string;
        /**
         * Amplify environment name for the pull request.
         */
        pullRequestEnvironmentName?: string;
        /**
         * Describes the current stage for the autocreated branch. Valid values: `PRODUCTION`, `BETA`, `DEVELOPMENT`, `EXPERIMENTAL`, `PULL_REQUEST`.
         */
        stage?: string;
    }
    interface AppCustomRule {
        /**
         * Condition for a URL rewrite or redirect rule, such as a country code.
         */
        condition?: string;
        /**
         * Source pattern for a URL rewrite or redirect rule.
         */
        source: string;
        /**
         * Status code for a URL rewrite or redirect rule. Valid values: `200`, `301`, `302`, `404`, `404-200`.
         */
        status?: string;
        /**
         * Target pattern for a URL rewrite or redirect rule.
         */
        target: string;
    }
    interface AppProductionBranch {
        /**
         * Branch name for the production branch.
         */
        branchName: string;
        /**
         * Last deploy time of the production branch.
         */
        lastDeployTime: string;
        /**
         * Status of the production branch.
         */
        status: string;
        /**
         * Thumbnail URL for the production branch.
         */
        thumbnailUrl: string;
    }
    interface DomainAssociationSubDomain {
        /**
         * Branch name setting for the subdomain.
         */
        branchName: string;
        /**
         * DNS record for the subdomain in a space-prefixed and space-delimited format (` CNAME <target>`).
         */
        dnsRecord: string;
        /**
         * Prefix setting for the subdomain.
         */
        prefix: string;
        /**
         * Verified status of the subdomain.
         */
        verified: boolean;
    }
}
export declare namespace apigateway {
    interface AccountThrottleSetting {
        /**
         * Absolute maximum number of times API Gateway allows the API to be called per second (RPS).
         */
        burstLimit: number;
        /**
         * Number of times API Gateway allows the API to be called per second on average (RPS).
         */
        rateLimit: number;
    }
    interface DocumentationPartLocation {
        /**
         * HTTP verb of a method. The default value is `*` for any method.
         */
        method?: string;
        /**
         * Name of the targeted API entity.
         */
        name?: string;
        /**
         * URL path of the target. The default value is `/` for the root resource.
         */
        path?: string;
        /**
         * HTTP status code of a response. The default value is `*` for any status code.
         */
        statusCode?: string;
        /**
         * Type of API entity to which the documentation content appliesE.g., `API`, `METHOD` or `REQUEST_BODY`
         */
        type: string;
    }
    interface DomainNameEndpointConfiguration {
        /**
         * List of endpoint types. This resource currently only supports managing a single value. Valid values: `EDGE` or `REGIONAL`. If unspecified, defaults to `EDGE`. Must be declared as `REGIONAL` in non-Commercial partitions. Refer to the [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/create-regional-api.html) for more information on the difference between edge-optimized and regional APIs.
         */
        types: string;
    }
    interface DomainNameMutualTlsAuthentication {
        /**
         * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
         */
        truststoreUri: string;
        /**
         * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
         */
        truststoreVersion?: string;
    }
    interface GetDomainNameEndpointConfiguration {
        /**
         * List of endpoint types.
         */
        types: string[];
    }
    interface GetRestApiEndpointConfiguration {
        types: string[];
        vpcEndpointIds: string[];
    }
    interface IntegrationTlsConfig {
        /**
         * Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a [supported certificate authority](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-supported-certificate-authorities-for-http-endpoints.html). This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for `HTTP` and `HTTP_PROXY` integrations.
         */
        insecureSkipVerification?: boolean;
    }
    interface MethodSettingsSettings {
        /**
         * Whether the cached responses are encrypted.
         */
        cacheDataEncrypted: boolean;
        /**
         * Time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
         */
        cacheTtlInSeconds: number;
        /**
         * Whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
         */
        cachingEnabled: boolean;
        /**
         * Whether data trace logging is enabled for this method, which effects the log entries pushed to Amazon CloudWatch Logs.
         */
        dataTraceEnabled: boolean;
        /**
         * Logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. The available levels are `OFF`, `ERROR`, and `INFO`.
         */
        loggingLevel: string;
        /**
         * Whether Amazon CloudWatch metrics are enabled for this method.
         */
        metricsEnabled: boolean;
        /**
         * Whether authorization is required for a cache invalidation request.
         */
        requireAuthorizationForCacheControl: boolean;
        /**
         * Throttling burst limit. Default: `-1` (throttling disabled).
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit. Default: `-1` (throttling disabled).
         */
        throttlingRateLimit?: number;
        /**
         * How to handle unauthorized requests for cache invalidation. The available values are `FAIL_WITH_403`, `SUCCEED_WITH_RESPONSE_HEADER`, `SUCCEED_WITHOUT_RESPONSE_HEADER`.
         */
        unauthorizedCacheControlHeaderStrategy: string;
    }
    interface RestApiEndpointConfiguration {
        /**
         * List of endpoint types. This resource currently only supports managing a single value. Valid values: `EDGE`, `REGIONAL` or `PRIVATE`. If unspecified, defaults to `EDGE`. If set to `PRIVATE` recommend to set `putRestApiMode` = `merge` to not cause the endpoints and associated Route53 records to be deleted. Refer to the [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/create-regional-api.html) for more information on the difference between edge-optimized and regional APIs.
         */
        types: string;
        /**
         * Set of VPC Endpoint identifiers. It is only supported for `PRIVATE` endpoint type. If importing an OpenAPI specification via the `body` argument, this corresponds to the [`x-amazon-apigateway-endpoint-configuration` extension `vpcEndpointIds` property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-endpoint-configuration.html). If the argument value is provided and is different than the OpenAPI value, **the argument value will override the OpenAPI value**.
         */
        vpcEndpointIds: string[];
    }
    interface StageAccessLogSettings {
        /**
         * ARN of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with `amazon-apigateway-`. Automatically removes trailing `:*` if present.
         */
        destinationArn: string;
        /**
         * Formatting and values recorded in the logs.
         * For more information on configuring the log format rules visit the AWS [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html)
         */
        format: string;
    }
    interface StageCanarySettings {
        /**
         * Percent `0.0` - `100.0` of traffic to divert to the canary deployment.
         */
        percentTraffic?: number;
        /**
         * Map of overridden stage `variables` (including new variables) for the canary deployment.
         */
        stageVariableOverrides?: {
            [key: string]: string;
        };
        /**
         * Whether the canary deployment uses the stage cache. Defaults to false.
         */
        useStageCache?: boolean;
    }
    interface UsagePlanApiStage {
        apiId: string;
        stage: string;
        throttles?: outputs.apigateway.UsagePlanApiStageThrottle[];
    }
    interface UsagePlanApiStageThrottle {
        /**
         * The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
         */
        burstLimit?: number;
        /**
         * Method to apply the throttle settings for. Specfiy the path and method, for example `/test/GET`.
         */
        path: string;
        /**
         * The API request steady-state rate limit.
         */
        rateLimit?: number;
    }
    interface UsagePlanQuotaSettings {
        limit: number;
        offset?: number;
        period: string;
    }
    interface UsagePlanThrottleSettings {
        burstLimit?: number;
        rateLimit?: number;
    }
}
export declare namespace apigatewayv2 {
    interface ApiCorsConfiguration {
        /**
         * Whether credentials are included in the CORS request.
         */
        allowCredentials?: boolean;
        /**
         * Set of allowed HTTP headers.
         */
        allowHeaders?: string[];
        /**
         * Set of allowed HTTP methods.
         */
        allowMethods?: string[];
        /**
         * Set of allowed origins.
         */
        allowOrigins?: string[];
        /**
         * Set of exposed HTTP headers.
         */
        exposeHeaders?: string[];
        /**
         * Number of seconds that the browser should cache preflight request results.
         */
        maxAge?: number;
    }
    interface AuthorizerJwtConfiguration {
        /**
         * List of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.
         */
        audiences?: string[];
        /**
         * Base domain of the identity provider that issues JSON Web Tokens, such as the `endpoint` attribute of the `aws.cognito.UserPool` resource.
         */
        issuer?: string;
    }
    interface DomainNameDomainNameConfiguration {
        /**
         * ARN of an AWS-managed certificate that will be used by the endpoint for the domain name. AWS Certificate Manager is the only supported source. Use the `aws.acm.Certificate` resource to configure an ACM certificate.
         */
        certificateArn: string;
        /**
         * Endpoint type. Valid values: `REGIONAL`.
         */
        endpointType: string;
        /**
         * Amazon Route 53 Hosted Zone ID of the endpoint.
         */
        hostedZoneId: string;
        /**
         * ARN of the AWS-issued certificate used to validate custom domain ownership (when `certificateArn` is issued via an ACM Private CA or `mutualTlsAuthentication` is configured with an ACM-imported certificate.)
         */
        ownershipVerificationCertificateArn: string;
        /**
         * Transport Layer Security (TLS) version of the [security policy](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-custom-domain-tls-version.html) for the domain name. Valid values: `TLS_1_2`.
         */
        securityPolicy: string;
        /**
         * Target domain name.
         */
        targetDomainName: string;
    }
    interface DomainNameMutualTlsAuthentication {
        /**
         * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
         */
        truststoreUri: string;
        /**
         * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
         */
        truststoreVersion?: string;
    }
    interface GetApiCorsConfiguration {
        /**
         * Whether credentials are included in the CORS request.
         */
        allowCredentials: boolean;
        /**
         * Set of allowed HTTP headers.
         */
        allowHeaders: string[];
        /**
         * Set of allowed HTTP methods.
         */
        allowMethods: string[];
        /**
         * Set of allowed origins.
         */
        allowOrigins: string[];
        /**
         * Set of exposed HTTP headers.
         */
        exposeHeaders: string[];
        /**
         * Number of seconds that the browser should cache preflight request results.
         */
        maxAge: number;
    }
    interface IntegrationResponseParameter {
        /**
         * Key-value map. The key of this map identifies the location of the request parameter to change, and how to change it. The corresponding value specifies the new data for the parameter.
         * See the [Amazon API Gateway Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html) for details.
         */
        mappings: {
            [key: string]: string;
        };
        /**
         * HTTP status code in the range 200-599.
         */
        statusCode: string;
    }
    interface IntegrationTlsConfig {
        /**
         * If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
         */
        serverNameToVerify?: string;
    }
    interface RouteRequestParameter {
        /**
         * Request parameter key. This is a [request data mapping parameter](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-data-mapping.html#websocket-mapping-request-parameters).
         */
        requestParameterKey: string;
        /**
         * Boolean whether or not the parameter is required.
         */
        required: boolean;
    }
    interface StageAccessLogSettings {
        /**
         * ARN of the CloudWatch Logs log group to receive access logs. Any trailing `:*` is trimmed from the ARN.
         */
        destinationArn: string;
        /**
         * Single line [format](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html#apigateway-cloudwatch-log-formats) of the access logs of data. Refer to log settings for [HTTP](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-logging-variables.html) or [Websocket](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-logging.html).
         */
        format: string;
    }
    interface StageDefaultRouteSettings {
        /**
         * Whether data trace logging is enabled for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Defaults to `false`. Supported only for WebSocket APIs.
         */
        dataTraceEnabled?: boolean;
        /**
         * Whether detailed metrics are enabled for the default route. Defaults to `false`.
         */
        detailedMetricsEnabled?: boolean;
        /**
         * Logging level for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
         */
        loggingLevel: string;
        /**
         * Throttling burst limit for the default route.
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit for the default route.
         */
        throttlingRateLimit?: number;
    }
    interface StageRouteSetting {
        /**
         * Whether data trace logging is enabled for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Defaults to `false`. Supported only for WebSocket APIs.
         */
        dataTraceEnabled?: boolean;
        /**
         * Whether detailed metrics are enabled for the route. Defaults to `false`.
         */
        detailedMetricsEnabled?: boolean;
        /**
         * Logging level for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
         * Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
         */
        loggingLevel: string;
        /**
         * Route key.
         */
        routeKey: string;
        /**
         * Throttling burst limit for the route.
         */
        throttlingBurstLimit?: number;
        /**
         * Throttling rate limit for the route.
         */
        throttlingRateLimit?: number;
    }
}
export declare namespace appautoscaling {
    interface PolicyStepScalingPolicyConfiguration {
        /**
         * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are `ChangeInCapacity`, `ExactCapacity`, and `PercentChangeInCapacity`.
         */
        adjustmentType?: string;
        /**
         * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown?: number;
        /**
         * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
         */
        metricAggregationType?: string;
        /**
         * Minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
         */
        minAdjustmentMagnitude?: number;
        /**
         * Set of adjustments that manage scaling. These have the following structure:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const ecsPolicy = new aws.appautoscaling.Policy("ecs_policy", {stepScalingPolicyConfiguration: {
         *     stepAdjustments: [
         *         {
         *             metricIntervalLowerBound: "1",
         *             metricIntervalUpperBound: "2",
         *             scalingAdjustment: -1,
         *         },
         *         {
         *             metricIntervalLowerBound: "2",
         *             metricIntervalUpperBound: "3",
         *             scalingAdjustment: 1,
         *         },
         *     ],
         * }});
         * ```
         */
        stepAdjustments?: outputs.appautoscaling.PolicyStepScalingPolicyConfigurationStepAdjustment[];
    }
    interface PolicyStepScalingPolicyConfigurationStepAdjustment {
        metricIntervalLowerBound?: string;
        metricIntervalUpperBound?: string;
        scalingAdjustment: number;
    }
    interface PolicyTargetTrackingScalingPolicyConfiguration {
        /**
         * Custom CloudWatch metric. Documentation can be found  at: [AWS Customized Metric Specification](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_CustomizedMetricSpecification.html). See supported fields below.
         */
        customizedMetricSpecification?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification;
        /**
         * Whether scale in by the target tracking policy is disabled. If the value is true, scale in is disabled and the target tracking policy won't remove capacity from the scalable resource. Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource. The default value is `false`.
         */
        disableScaleIn?: boolean;
        /**
         * Predefined metric. See supported fields below.
         */
        predefinedMetricSpecification?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification;
        /**
         * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
         */
        scaleInCooldown?: number;
        /**
         * Amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
         */
        scaleOutCooldown?: number;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension[];
        /**
         * Name of the metric.
         */
        metricName?: string;
        /**
         * Metrics to include, as a metric data query.
         */
        metrics?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetric[];
        /**
         * Namespace of the metric.
         */
        namespace?: string;
        /**
         * Statistic of the metric. Valid values: `Average`, `Minimum`, `Maximum`, `SampleCount`, and `Sum`.
         */
        statistic?: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetric {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in target tracking scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.appautoscaling.PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification {
        /**
         * Metric type.
         */
        predefinedMetricType: string;
        /**
         * Reserved for future use if the `predefinedMetricType` is not `ALBRequestCountPerTarget`. If the `predefinedMetricType` is `ALBRequestCountPerTarget`, you must specify this argument. Documentation can be found at: [AWS Predefined Scaling Metric Specification](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedScalingMetricSpecification.html). Must be less than or equal to 1023 characters in length.
         */
        resourceLabel?: string;
    }
    interface ScheduledActionScalableTargetAction {
        maxCapacity?: number;
        minCapacity?: number;
    }
}
export declare namespace appconfig {
    interface ConfigurationProfileValidator {
        /**
         * Either the JSON Schema content or the ARN of an AWS Lambda function.
         */
        content?: string;
        /**
         * Type of validator. Valid values: `JSON_SCHEMA` and `LAMBDA`.
         */
        type: string;
    }
    interface EnvironmentMonitor {
        /**
         * ARN of the Amazon CloudWatch alarm.
         */
        alarmArn: string;
        /**
         * ARN of an IAM role for AWS AppConfig to monitor `alarmArn`.
         */
        alarmRoleArn?: string;
    }
    interface EventIntegrationEventFilter {
        /**
         * Source of the events.
         */
        source: string;
    }
    interface ExtensionActionPoint {
        /**
         * An action defines the tasks the extension performs during the AppConfig workflow. Detailed below.
         */
        actions: outputs.appconfig.ExtensionActionPointAction[];
        /**
         * The point at which to perform the defined actions. Valid points are `PRE_CREATE_HOSTED_CONFIGURATION_VERSION`, `PRE_START_DEPLOYMENT`, `ON_DEPLOYMENT_START`, `ON_DEPLOYMENT_STEP`, `ON_DEPLOYMENT_BAKING`, `ON_DEPLOYMENT_COMPLETE`, `ON_DEPLOYMENT_ROLLED_BACK`.
         */
        point: string;
    }
    interface ExtensionActionPointAction {
        /**
         * Information about the action.
         */
        description?: string;
        /**
         * The action name.
         */
        name: string;
        /**
         * An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
         */
        roleArn: string;
        /**
         * The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
         */
        uri: string;
    }
    interface ExtensionParameter {
        /**
         * Information about the parameter.
         */
        description?: string;
        /**
         * The parameter name.
         */
        name: string;
        /**
         * Determines if a parameter value must be specified in the extension association.
         */
        required?: boolean;
    }
    interface GetConfigurationProfileValidator {
        /**
         * Either the JSON Schema content or the ARN of an AWS Lambda function.
         */
        content: string;
        /**
         * Type of validator. Valid values: JSON_SCHEMA and LAMBDA.
         */
        type: string;
    }
    interface GetEnvironmentMonitor {
        /**
         * ARN of the Amazon CloudWatch alarm.
         */
        alarmArn: string;
        /**
         * ARN of an IAM role for AWS AppConfig to monitor.
         */
        alarmRoleArn: string;
    }
}
export declare namespace appflow {
    interface ConnectorProfileConnectorProfileConfig {
        /**
         * The connector-specific credentials required by each connector. See Connector Profile Credentials for more details.
         */
        connectorProfileCredentials: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentials;
        /**
         * The connector-specific properties of the profile configuration. See Connector Profile Properties for more details.
         */
        connectorProfileProperties: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileProperties;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentials {
        /**
         * The connector-specific credentials required when using Amplitude. See Amplitude Connector Profile Credentials for more details.
         */
        amplitude?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude;
        /**
         * The connector-specific profile credentials required when using the custom connector. See Custom Connector Profile Credentials for more details.
         */
        customConnector?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector;
        /**
         * Connector-specific credentials required when using Datadog. See Datadog Connector Profile Credentials for more details.
         */
        datadog?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog;
        /**
         * The connector-specific credentials required when using Dynatrace. See Dynatrace Connector Profile Credentials for more details.
         */
        dynatrace?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace;
        /**
         * The connector-specific credentials required when using Google Analytics. See Google Analytics Connector Profile Credentials for more details.
         */
        googleAnalytics?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics;
        /**
         * The connector-specific credentials required when using Amazon Honeycode. See Honeycode Connector Profile Credentials for more details.
         */
        honeycode?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode;
        /**
         * The connector-specific credentials required when using Infor Nexus. See Infor Nexus Connector Profile Credentials for more details.
         */
        inforNexus?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus;
        /**
         * Connector-specific credentials required when using Marketo. See Marketo Connector Profile Credentials for more details.
         */
        marketo?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo;
        /**
         * Connector-specific credentials required when using Amazon Redshift. See Redshift Connector Profile Credentials for more details.
         */
        redshift?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift;
        /**
         * The connector-specific credentials required when using Salesforce. See Salesforce Connector Profile Credentials for more details.
         */
        salesforce?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce;
        /**
         * The connector-specific credentials required when using SAPOData. See SAPOData Connector Profile Credentials for more details.
         */
        sapoData?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData;
        /**
         * The connector-specific credentials required when using ServiceNow. See ServiceNow Connector Profile Credentials for more details.
         */
        serviceNow?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow;
        /**
         * Connector-specific credentials required when using Singular. See Singular Connector Profile Credentials for more details.
         */
        singular?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular;
        /**
         * Connector-specific credentials required when using Slack. See Slack Connector Profile Credentials for more details.
         */
        slack?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack;
        /**
         * The connector-specific credentials required when using Snowflake. See Snowflake Connector Profile Credentials for more details.
         */
        snowflake?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake;
        /**
         * The connector-specific credentials required when using Trend Micro. See Trend Micro Connector Profile Credentials for more details.
         */
        trendmicro?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro;
        /**
         * Connector-specific credentials required when using Veeva. See Veeva Connector Profile Credentials for more details.
         */
        veeva?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva;
        /**
         * Connector-specific credentials required when using Zendesk. See Zendesk Connector Profile Credentials for more details.
         */
        zendesk?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsAmplitude {
        apiKey: string;
        secretKey: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnector {
        apiKey?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey;
        authenticationType: string;
        basic?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic;
        custom?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom;
        oauth2?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorApiKey {
        apiKey: string;
        apiSecretKey?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorBasic {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorCustom {
        credentialsMap?: {
            [key: string]: string;
        };
        customAuthenticationType: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2 {
        accessToken?: string;
        clientId?: string;
        clientSecret?: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsCustomConnectorOauth2OauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDatadog {
        apiKey: string;
        applicationKey: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsDynatrace {
        apiToken: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalytics {
        accessToken?: string;
        clientId: string;
        clientSecret: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsGoogleAnalyticsOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycode {
        accessToken?: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsHoneycodeOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsInforNexus {
        accessKeyId: string;
        datakey: string;
        secretAccessKey: string;
        userId: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketo {
        accessToken?: string;
        clientId: string;
        clientSecret: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsMarketoOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsRedshift {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforce {
        accessToken?: string;
        clientCredentialsArn?: string;
        jwtToken?: string;
        oauth2GrantType?: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSalesforceOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoData {
        basicAuthCredentials?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials;
        oauthCredentials?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataBasicAuthCredentials {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentials {
        accessToken?: string;
        clientId: string;
        clientSecret: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest;
        refreshToken?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSapoDataOauthCredentialsOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsServiceNow {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSingular {
        apiKey: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlack {
        accessToken?: string;
        clientId: string;
        clientSecret: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSlackOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsSnowflake {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsTrendmicro {
        apiSecretKey: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsVeeva {
        password: string;
        username: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendesk {
        accessToken?: string;
        clientId: string;
        clientSecret: string;
        oauthRequest?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileCredentialsZendeskOauthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been granted.
         */
        redirectUri?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfileProperties {
        amplitude?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude;
        /**
         * The connector-specific profile properties required when using the custom connector. See Custom Connector Profile Properties for more details.
         */
        customConnector?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector;
        /**
         * Connector-specific properties required when using Datadog. See Generic Connector Profile Properties for more details.
         */
        datadog?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog;
        /**
         * The connector-specific properties required when using Dynatrace. See Generic Connector Profile Properties for more details.
         */
        dynatrace?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace;
        googleAnalytics?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics;
        honeycode?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode;
        /**
         * The connector-specific properties required when using Infor Nexus. See Generic Connector Profile Properties for more details.
         */
        inforNexus?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus;
        /**
         * Connector-specific properties required when using Marketo. See Generic Connector Profile Properties for more details.
         */
        marketo?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo;
        /**
         * Connector-specific properties required when using Amazon Redshift. See Redshift Connector Profile Properties for more details.
         */
        redshift?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift;
        /**
         * The connector-specific properties required when using Salesforce. See Salesforce Connector Profile Properties for more details.
         */
        salesforce?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce;
        /**
         * The connector-specific properties required when using SAPOData. See SAPOData Connector Profile Properties for more details.
         */
        sapoData?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData;
        /**
         * The connector-specific properties required when using ServiceNow. See Generic Connector Profile Properties for more details.
         */
        serviceNow?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow;
        singular?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular;
        /**
         * Connector-specific properties required when using Slack. See Generic Connector Profile Properties for more details.
         */
        slack?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack;
        /**
         * The connector-specific properties required when using Snowflake. See Snowflake Connector Profile Properties for more details.
         */
        snowflake?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake;
        trendmicro?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro;
        /**
         * Connector-specific properties required when using Veeva. See Generic Connector Profile Properties for more details.
         */
        veeva?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva;
        /**
         * Connector-specific properties required when using Zendesk. See Generic Connector Profile Properties for more details.
         */
        zendesk?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesAmplitude {
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnector {
        oauth2Properties?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties;
        profileProperties?: {
            [key: string]: string;
        };
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesCustomConnectorOauth2Properties {
        oauth2GrantType: string;
        tokenUrl: string;
        tokenUrlCustomProperties?: {
            [key: string]: string;
        };
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDatadog {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesDynatrace {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesGoogleAnalytics {
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesHoneycode {
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesInforNexus {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesMarketo {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesRedshift {
        bucketName: string;
        bucketPrefix?: string;
        clusterIdentifier?: string;
        dataApiRoleArn?: string;
        databaseName?: string;
        databaseUrl?: string;
        roleArn: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSalesforce {
        instanceUrl?: string;
        isSandboxEnvironment?: boolean;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoData {
        applicationHostUrl: string;
        applicationServicePath: string;
        clientNumber: string;
        logonLanguage?: string;
        oauthProperties?: outputs.appflow.ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties;
        portNumber: number;
        privateLinkServiceName?: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSapoDataOauthProperties {
        authCodeUrl: string;
        oauthScopes: string[];
        tokenUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesServiceNow {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSingular {
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSlack {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesSnowflake {
        accountName?: string;
        bucketName: string;
        bucketPrefix?: string;
        privateLinkServiceName?: string;
        region?: string;
        stage: string;
        warehouse: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesTrendmicro {
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesVeeva {
        instanceUrl: string;
    }
    interface ConnectorProfileConnectorProfileConfigConnectorProfilePropertiesZendesk {
        instanceUrl: string;
    }
    interface FlowDestinationFlowConfig {
        /**
         * API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
         */
        connectorProfileName?: string;
        /**
         * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
         */
        connectorType: string;
        /**
         * This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
         */
        destinationConnectorProperties: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorProperties;
    }
    interface FlowDestinationFlowConfigDestinationConnectorProperties {
        /**
         * Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
         */
        customConnector?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector;
        /**
         * Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
         */
        customerProfiles?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles;
        /**
         * Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
         */
        eventBridge?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge;
        /**
         * Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
         */
        honeycode?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode;
        lookoutMetrics?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics;
        /**
         * Properties that are required to query Marketo. See Generic Destination Properties for more details.
         */
        marketo?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo;
        /**
         * Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
         */
        redshift?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift;
        /**
         * Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
         */
        s3: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3;
        /**
         * Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
         */
        salesforce?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce;
        /**
         * Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
         */
        sapoData?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData;
        /**
         * Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
         */
        snowflake?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake;
        /**
         * Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
         */
        upsolver?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver;
        /**
         * Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
         */
        zendesk?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnector {
        customProperties?: {
            [key: string]: string;
        };
        entityName: string;
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig;
        idFieldNames?: string[];
        writeOperationType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles {
        domainName: string;
        objectTypeName?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridge {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig;
        object: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycode {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig;
        object: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesLookoutMetrics {
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesMarketo {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig;
        object: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesRedshift {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3 {
        bucketName: string;
        bucketPrefix: string;
        s3OutputFormatConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig {
        /**
         * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
         */
        aggregationConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig;
        /**
         * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
         */
        fileType?: string;
        /**
         * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
         */
        prefixConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig;
        /**
         * Whether the data types from the source system need to be preserved (Only valid for `Parquet` file type)
         */
        preserveSourceDataTyping: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig {
        /**
         * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
         */
        aggregationType: string;
        /**
         * The desired file size, in MB, for each output file that Amazon AppFlow writes to the flow destination. Integer value.
         */
        targetFileSize: number;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig {
        /**
         * Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
         */
        prefixFormat?: string;
        /**
         * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
         */
        prefixType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforce {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig;
        idFieldNames?: string[];
        object: string;
        writeOperationType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoData {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig;
        idFieldNames?: string[];
        objectPath: string;
        successResponseHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig;
        writeOperationType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflake {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolver {
        bucketName: string;
        bucketPrefix?: string;
        s3OutputFormatConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig {
        /**
         * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
         */
        aggregationConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig;
        /**
         * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are `CSV`, `JSON`, and `PARQUET`.
         */
        fileType?: string;
        /**
         * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
         */
        prefixConfig: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig {
        /**
         * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are `None` and `SingleFile`.
         */
        aggregationType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig {
        /**
         * Determines the level of granularity that's included in the prefix. Valid values are `YEAR`, `MONTH`, `DAY`, `HOUR`, and `MINUTE`.
         */
        prefixFormat?: string;
        /**
         * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are `FILENAME`, `PATH`, and `PATH_AND_FILENAME`.
         */
        prefixType: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesZendesk {
        errorHandlingConfig?: outputs.appflow.FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig;
        idFieldNames?: string[];
        object: string;
        writeOperationType?: string;
    }
    interface FlowDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig {
        /**
         * Name of the Amazon S3 bucket.
         */
        bucketName?: string;
        /**
         * Amazon S3 bucket prefix.
         */
        bucketPrefix?: string;
        /**
         * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
         */
        failOnFirstDestinationError?: boolean;
    }
    interface FlowSourceFlowConfig {
        /**
         * API version that the destination connector uses.
         */
        apiVersion?: string;
        /**
         * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
         */
        connectorProfileName?: string;
        /**
         * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are `Salesforce`, `Singular`, `Slack`, `Redshift`, `S3`, `Marketo`, `Googleanalytics`, `Zendesk`, `Servicenow`, `Datadog`, `Trendmicro`, `Snowflake`, `Dynatrace`, `Infornexus`, `Amplitude`, `Veeva`, `EventBridge`, `LookoutMetrics`, `Upsolver`, `Honeycode`, `CustomerProfiles`, `SAPOData`, and `CustomConnector`.
         */
        connectorType: string;
        /**
         * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
         */
        incrementalPullConfig?: outputs.appflow.FlowSourceFlowConfigIncrementalPullConfig;
        /**
         * Information that is required to query a particular source connector. See Source Connector Properties for details.
         */
        sourceConnectorProperties: outputs.appflow.FlowSourceFlowConfigSourceConnectorProperties;
    }
    interface FlowSourceFlowConfigIncrementalPullConfig {
        /**
         * Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
         */
        datetimeTypeFieldName?: string;
    }
    interface FlowSourceFlowConfigSourceConnectorProperties {
        /**
         * Information that is required for querying Amplitude. See Generic Source Properties for more details.
         */
        amplitude?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesAmplitude;
        /**
         * Properties that are applied when the custom connector is being used as a source. See Custom Connector Source Properties.
         */
        customConnector?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector;
        /**
         * Information that is required for querying Datadog. See Generic Source Properties for more details.
         */
        datadog?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesDatadog;
        dynatrace?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesDynatrace;
        googleAnalytics?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics;
        /**
         * Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
         */
        inforNexus?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesInforNexus;
        /**
         * Information that is required for querying Marketo. See Generic Source Properties for more details.
         */
        marketo?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesMarketo;
        /**
         * Information that is required for querying Amazon S3. See S3 Source Properties for more details.
         */
        s3: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesS3;
        /**
         * Information that is required for querying Salesforce. See Salesforce Source Properties for more details.
         */
        salesforce?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSalesforce;
        /**
         * Information that is required for querying SAPOData as a flow source. See SAPO Source Properties for more details.
         */
        sapoData?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSapoData;
        /**
         * Information that is required for querying ServiceNow. See Generic Source Properties for more details.
         */
        serviceNow?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesServiceNow;
        /**
         * Information that is required for querying Singular. See Generic Source Properties for more details.
         */
        singular?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSingular;
        /**
         * Information that is required for querying Slack. See Generic Source Properties for more details.
         */
        slack?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesSlack;
        trendmicro?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro;
        /**
         * Information that is required for querying Veeva. See Veeva Source Properties for more details.
         */
        veeva?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesVeeva;
        /**
         * Information that is required for querying Zendesk. See Generic Source Properties for more details.
         */
        zendesk?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesZendesk;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesAmplitude {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesCustomConnector {
        customProperties?: {
            [key: string]: string;
        };
        entityName: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesDatadog {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesDynatrace {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesInforNexus {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesMarketo {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesS3 {
        bucketName: string;
        bucketPrefix: string;
        s3InputFormatConfig?: outputs.appflow.FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig {
        /**
         * File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are `CSV` and `JSON`.
         */
        s3InputFileType?: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesSalesforce {
        enableDynamicFieldUpdate?: boolean;
        includeDeletedRecords?: boolean;
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesSapoData {
        objectPath: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesServiceNow {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesSingular {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesSlack {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesTrendmicro {
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesVeeva {
        documentType?: string;
        includeAllVersions?: boolean;
        includeRenditions?: boolean;
        includeSourceFiles?: boolean;
        object: string;
    }
    interface FlowSourceFlowConfigSourceConnectorPropertiesZendesk {
        object: string;
    }
    interface FlowTask {
        /**
         * Operation to be performed on the provided source fields. See Connector Operator for details.
         */
        connectorOperators?: outputs.appflow.FlowTaskConnectorOperator[];
        /**
         * Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
         */
        destinationField?: string;
        /**
         * Source fields to which a particular task is applied.
         */
        sourceFields: string[];
        /**
         * Map used to store task-related information. The execution service looks for particular information based on the `TaskType`. Valid keys are `VALUE`, `VALUES`, `DATA_TYPE`, `UPPER_BOUND`, `LOWER_BOUND`, `SOURCE_DATA_TYPE`, `DESTINATION_DATA_TYPE`, `VALIDATION_ACTION`, `MASK_VALUE`, `MASK_LENGTH`, `TRUNCATE_LENGTH`, `MATH_OPERATION_FIELDS_ORDER`, `CONCAT_FORMAT`, `SUBFIELD_CATEGORY_MAP`, and `EXCLUDE_SOURCE_FIELDS_LIST`.
         */
        taskProperties?: {
            [key: string]: string;
        };
        /**
         * Particular task implementation that Amazon AppFlow performs. Valid values are `Arithmetic`, `Filter`, `Map`, `Map_all`, `Mask`, `Merge`, `Passthrough`, `Truncate`, and `Validate`.
         */
        taskType: string;
    }
    interface FlowTaskConnectorOperator {
        /**
         * Operation to be performed on the provided Amplitude source fields. The only valid value is `BETWEEN`.
         */
        amplitude?: string;
        /**
         * Operators supported by the custom connector. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        customConnector?: string;
        /**
         * Operation to be performed on the provided Datadog source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        datadog?: string;
        /**
         * Operation to be performed on the provided Dynatrace source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        dynatrace?: string;
        /**
         * Operation to be performed on the provided Google Analytics source fields. Valid values are `PROJECTION` and `BETWEEN`.
         */
        googleAnalytics?: string;
        /**
         * Operation to be performed on the provided Infor Nexus source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        inforNexus?: string;
        /**
         * Operation to be performed on the provided Marketo source fields. Valid values are `PROJECTION`, `BETWEEN`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        marketo?: string;
        /**
         * Operation to be performed on the provided Amazon S3 source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        s3?: string;
        /**
         * Operation to be performed on the provided Salesforce source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        salesforce?: string;
        /**
         * Operation to be performed on the provided SAPOData source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        sapoData?: string;
        /**
         * Operation to be performed on the provided ServiceNow source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        serviceNow?: string;
        /**
         * Operation to be performed on the provided Singular source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        singular?: string;
        /**
         * Operation to be performed on the provided Slack source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        slack?: string;
        /**
         * Operation to be performed on the provided Trend Micro source fields. Valid values are `PROJECTION`, `EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        trendmicro?: string;
        /**
         * Operation to be performed on the provided Veeva source fields. Valid values are `PROJECTION`, `LESS_THAN`, `GREATER_THAN`, `CONTAINS`, `BETWEEN`, `LESS_THAN_OR_EQUAL_TO`, `GREATER_THAN_OR_EQUAL_TO`, `EQUAL_TO`, `NOT_EQUAL_TO`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        veeva?: string;
        /**
         * Operation to be performed on the provided Zendesk source fields. Valid values are `PROJECTION`, `GREATER_THAN`, `ADDITION`, `MULTIPLICATION`, `DIVISION`, `SUBTRACTION`, `MASK_ALL`, `MASK_FIRST_N`, `MASK_LAST_N`, `VALIDATE_NON_NULL`, `VALIDATE_NON_ZERO`, `VALIDATE_NON_NEGATIVE`, `VALIDATE_NUMERIC`, and `NO_OP`.
         */
        zendesk?: string;
    }
    interface FlowTriggerConfig {
        /**
         * Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the `Scheduled` trigger type. See Scheduled Trigger Properties for details.
         */
        triggerProperties: outputs.appflow.FlowTriggerConfigTriggerProperties;
        /**
         * Type of flow trigger. Valid values are `Scheduled`, `Event`, and `OnDemand`.
         */
        triggerType: string;
    }
    interface FlowTriggerConfigTriggerProperties {
        scheduled?: outputs.appflow.FlowTriggerConfigTriggerPropertiesScheduled;
    }
    interface FlowTriggerConfigTriggerPropertiesScheduled {
        /**
         * Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are `Incremental` and `Complete`.
         */
        dataPullMode?: string;
        /**
         * Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
         */
        firstExecutionFrom?: string;
        /**
         * Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
         */
        scheduleEndTime?: string;
        /**
         * Scheduling expression that determines the rate at which the schedule will run, for example `rate(5minutes)`.
         */
        scheduleExpression: string;
        /**
         * Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
         */
        scheduleOffset?: number;
        /**
         * Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
         */
        scheduleStartTime?: string;
        /**
         * Time zone used when referring to the date and time of a scheduled-triggered flow, such as `America/New_York`.
         */
        timezone?: string;
    }
}
export declare namespace appintegrations {
    interface DataIntegrationScheduleConfig {
        /**
         * The start date for objects to import in the first flow run as an Unix/epoch timestamp in milliseconds or in ISO-8601 format. This needs to be a time in the past, meaning that the data created or updated before this given date will not be downloaded.
         */
        firstExecutionFrom: string;
        /**
         * The name of the object to pull from the data source. Examples of objects in Salesforce include `Case`, `Account`, or `Lead`.
         */
        object: string;
        /**
         * How often the data should be pulled from data source. Examples include `rate(1 hour)`, `rate(3 hours)`, `rate(1 day)`.
         */
        scheduleExpression: string;
    }
    interface GetEventIntegrationEventFilter {
        /**
         * The source of the events.
         */
        source: string;
    }
}
export declare namespace appmesh {
    interface GatewayRouteSpec {
        /**
         * Specification of a gRPC gateway route.
         */
        grpcRoute?: outputs.appmesh.GatewayRouteSpecGrpcRoute;
        /**
         * Specification of an HTTP/2 gateway route.
         */
        http2Route?: outputs.appmesh.GatewayRouteSpecHttp2Route;
        /**
         * Specification of an HTTP gateway route.
         */
        httpRoute?: outputs.appmesh.GatewayRouteSpecHttpRoute;
        /**
         * Priority for the gateway route, between `0` and `1000`.
         */
        priority?: number;
    }
    interface GatewayRouteSpecGrpcRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecGrpcRouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecGrpcRouteMatch;
    }
    interface GatewayRouteSpecGrpcRouteAction {
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecGrpcRouteActionTarget;
    }
    interface GatewayRouteSpecGrpcRouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecGrpcRouteActionTargetVirtualService;
    }
    interface GatewayRouteSpecGrpcRouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }
    interface GatewayRouteSpecGrpcRouteMatch {
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Fully qualified domain name for the service to match from the request.
         */
        serviceName: string;
    }
    interface GatewayRouteSpecHttp2Route {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecHttp2RouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecHttp2RouteMatch;
    }
    interface GatewayRouteSpecHttp2RouteAction {
        /**
         * Gateway route action to rewrite.
         */
        rewrite?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewrite;
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecHttp2RouteActionTarget;
    }
    interface GatewayRouteSpecHttp2RouteActionRewrite {
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewriteHostname;
        /**
         * Exact path to rewrite.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewritePath;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: outputs.appmesh.GatewayRouteSpecHttp2RouteActionRewritePrefix;
    }
    interface GatewayRouteSpecHttp2RouteActionRewriteHostname {
        /**
         * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultTargetHostname: string;
    }
    interface GatewayRouteSpecHttp2RouteActionRewritePath {
        /**
         * The exact path to match on.
         */
        exact: string;
    }
    interface GatewayRouteSpecHttp2RouteActionRewritePrefix {
        /**
         * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultPrefix?: string;
        /**
         * Value used to replace the incoming route prefix when rewritten.
         */
        value?: string;
    }
    interface GatewayRouteSpecHttp2RouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecHttp2RouteActionTargetVirtualService;
    }
    interface GatewayRouteSpecHttp2RouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }
    interface GatewayRouteSpecHttp2RouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeader[];
        /**
         * Host name to match on.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHostname;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchQueryParameter[];
    }
    interface GatewayRouteSpecHttp2RouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }
    interface GatewayRouteSpecHttp2RouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Header value sent by the client must begin with the specified characters.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }
    interface GatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }
    interface GatewayRouteSpecHttp2RouteMatchHostname {
        /**
         * Exact host name to match on.
         */
        exact?: string;
        /**
         * Specified ending characters of the host name to match on.
         */
        suffix?: string;
    }
    interface GatewayRouteSpecHttp2RouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }
    interface GatewayRouteSpecHttp2RouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttp2RouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }
    interface GatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
        /**
         * The exact query parameter to match on.
         */
        exact?: string;
    }
    interface GatewayRouteSpecHttpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.GatewayRouteSpecHttpRouteAction;
        /**
         * Criteria for determining a request match.
         */
        match: outputs.appmesh.GatewayRouteSpecHttpRouteMatch;
    }
    interface GatewayRouteSpecHttpRouteAction {
        /**
         * Gateway route action to rewrite.
         */
        rewrite?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewrite;
        /**
         * Target that traffic is routed to when a request matches the gateway route.
         */
        target: outputs.appmesh.GatewayRouteSpecHttpRouteActionTarget;
    }
    interface GatewayRouteSpecHttpRouteActionRewrite {
        /**
         * Host name to rewrite.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewriteHostname;
        /**
         * Exact path to rewrite.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewritePath;
        /**
         * Specified beginning characters to rewrite.
         */
        prefix?: outputs.appmesh.GatewayRouteSpecHttpRouteActionRewritePrefix;
    }
    interface GatewayRouteSpecHttpRouteActionRewriteHostname {
        /**
         * Default target host name to write to. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultTargetHostname: string;
    }
    interface GatewayRouteSpecHttpRouteActionRewritePath {
        /**
         * The exact path to match on.
         */
        exact: string;
    }
    interface GatewayRouteSpecHttpRouteActionRewritePrefix {
        /**
         * Default prefix used to replace the incoming route prefix when rewritten. Valid values: `ENABLED`, `DISABLED`.
         */
        defaultPrefix?: string;
        /**
         * Value used to replace the incoming route prefix when rewritten.
         */
        value?: string;
    }
    interface GatewayRouteSpecHttpRouteActionTarget {
        /**
         * The port number that corresponds to the target for Virtual Service provider port. This is required when the provider (router or node) of the Virtual Service has multiple listeners.
         */
        port?: number;
        /**
         * Virtual service gateway route target.
         */
        virtualService: outputs.appmesh.GatewayRouteSpecHttpRouteActionTargetVirtualService;
    }
    interface GatewayRouteSpecHttpRouteActionTargetVirtualService {
        /**
         * Name of the virtual service that traffic is routed to. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }
    interface GatewayRouteSpecHttpRouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeader[];
        /**
         * Host name to match on.
         */
        hostname?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHostname;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Path to match requests with. This parameter must always start with `/`, which by itself matches all requests to the virtual service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchQueryParameter[];
    }
    interface GatewayRouteSpecHttpRouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }
    interface GatewayRouteSpecHttpRouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Header value sent by the client must begin with the specified characters.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }
    interface GatewayRouteSpecHttpRouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }
    interface GatewayRouteSpecHttpRouteMatchHostname {
        /**
         * Exact host name to match on.
         */
        exact?: string;
        /**
         * Specified ending characters of the host name to match on.
         */
        suffix?: string;
    }
    interface GatewayRouteSpecHttpRouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }
    interface GatewayRouteSpecHttpRouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.GatewayRouteSpecHttpRouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }
    interface GatewayRouteSpecHttpRouteMatchQueryParameterMatch {
        /**
         * The exact query parameter to match on.
         */
        exact?: string;
    }
    interface GetGatewayRouteSpec {
        grpcRoutes: outputs.appmesh.GetGatewayRouteSpecGrpcRoute[];
        http2Routes: outputs.appmesh.GetGatewayRouteSpecHttp2Route[];
        httpRoutes: outputs.appmesh.GetGatewayRouteSpecHttpRoute[];
        priority: number;
    }
    interface GetGatewayRouteSpecGrpcRoute {
        actions: outputs.appmesh.GetGatewayRouteSpecGrpcRouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecGrpcRouteMatch[];
    }
    interface GetGatewayRouteSpecGrpcRouteAction {
        targets: outputs.appmesh.GetGatewayRouteSpecGrpcRouteActionTarget[];
    }
    interface GetGatewayRouteSpecGrpcRouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecGrpcRouteActionTargetVirtualService[];
    }
    interface GetGatewayRouteSpecGrpcRouteActionTargetVirtualService {
        virtualServiceName: string;
    }
    interface GetGatewayRouteSpecGrpcRouteMatch {
        port: number;
        serviceName: string;
    }
    interface GetGatewayRouteSpecHttp2Route {
        actions: outputs.appmesh.GetGatewayRouteSpecHttp2RouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatch[];
    }
    interface GetGatewayRouteSpecHttp2RouteAction {
        rewrites: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewrite[];
        targets: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionTarget[];
    }
    interface GetGatewayRouteSpecHttp2RouteActionRewrite {
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewriteHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewritePath[];
        prefixes: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionRewritePrefix[];
    }
    interface GetGatewayRouteSpecHttp2RouteActionRewriteHostname {
        defaultTargetHostname: string;
    }
    interface GetGatewayRouteSpecHttp2RouteActionRewritePath {
        exact: string;
    }
    interface GetGatewayRouteSpecHttp2RouteActionRewritePrefix {
        defaultPrefix: string;
        value: string;
    }
    interface GetGatewayRouteSpecHttp2RouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecHttp2RouteActionTargetVirtualService[];
    }
    interface GetGatewayRouteSpecHttp2RouteActionTargetVirtualService {
        virtualServiceName: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatch {
        headers: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeader[];
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchQueryParameter[];
    }
    interface GetGatewayRouteSpecHttp2RouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeaderMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchHostname {
        exact: string;
        suffix: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchPath {
        exact: string;
        regex: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchQueryParameter {
        matches: outputs.appmesh.GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }
    interface GetGatewayRouteSpecHttp2RouteMatchQueryParameterMatch {
        exact: string;
    }
    interface GetGatewayRouteSpecHttpRoute {
        actions: outputs.appmesh.GetGatewayRouteSpecHttpRouteAction[];
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatch[];
    }
    interface GetGatewayRouteSpecHttpRouteAction {
        rewrites: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewrite[];
        targets: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionTarget[];
    }
    interface GetGatewayRouteSpecHttpRouteActionRewrite {
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewriteHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewritePath[];
        prefixes: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionRewritePrefix[];
    }
    interface GetGatewayRouteSpecHttpRouteActionRewriteHostname {
        defaultTargetHostname: string;
    }
    interface GetGatewayRouteSpecHttpRouteActionRewritePath {
        exact: string;
    }
    interface GetGatewayRouteSpecHttpRouteActionRewritePrefix {
        defaultPrefix: string;
        value: string;
    }
    interface GetGatewayRouteSpecHttpRouteActionTarget {
        port: number;
        virtualServices: outputs.appmesh.GetGatewayRouteSpecHttpRouteActionTargetVirtualService[];
    }
    interface GetGatewayRouteSpecHttpRouteActionTargetVirtualService {
        virtualServiceName: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatch {
        headers: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeader[];
        hostnames: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHostname[];
        paths: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchQueryParameter[];
    }
    interface GetGatewayRouteSpecHttpRouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeaderMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }
    interface GetGatewayRouteSpecHttpRouteMatchHostname {
        exact: string;
        suffix: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatchPath {
        exact: string;
        regex: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatchQueryParameter {
        matches: outputs.appmesh.GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch[];
        /**
         * Name of the gateway route.
         */
        name: string;
    }
    interface GetGatewayRouteSpecHttpRouteMatchQueryParameterMatch {
        exact: string;
    }
    interface GetMeshSpec {
        egressFilters: outputs.appmesh.GetMeshSpecEgressFilter[];
        serviceDiscoveries: outputs.appmesh.GetMeshSpecServiceDiscovery[];
    }
    interface GetMeshSpecEgressFilter {
        type: string;
    }
    interface GetMeshSpecServiceDiscovery {
        ipPreference: string;
    }
    interface GetRouteSpec {
        grpcRoutes: outputs.appmesh.GetRouteSpecGrpcRoute[];
        http2Routes: outputs.appmesh.GetRouteSpecHttp2Route[];
        httpRoutes: outputs.appmesh.GetRouteSpecHttpRoute[];
        priority: number;
        tcpRoutes: outputs.appmesh.GetRouteSpecTcpRoute[];
    }
    interface GetRouteSpecGrpcRoute {
        actions: outputs.appmesh.GetRouteSpecGrpcRouteAction[];
        matches: outputs.appmesh.GetRouteSpecGrpcRouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecGrpcRouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecGrpcRouteTimeout[];
    }
    interface GetRouteSpecGrpcRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecGrpcRouteActionWeightedTarget[];
    }
    interface GetRouteSpecGrpcRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }
    interface GetRouteSpecGrpcRouteMatch {
        metadatas: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadata[];
        methodName: string;
        port: number;
        prefix: string;
        serviceName: string;
    }
    interface GetRouteSpecGrpcRouteMatchMetadata {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadataMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }
    interface GetRouteSpecGrpcRouteMatchMetadataMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecGrpcRouteMatchMetadataMatchRange[];
        regex: string;
        suffix: string;
    }
    interface GetRouteSpecGrpcRouteMatchMetadataMatchRange {
        end: number;
        start: number;
    }
    interface GetRouteSpecGrpcRouteRetryPolicy {
        grpcRetryEvents: string[];
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }
    interface GetRouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }
    interface GetRouteSpecGrpcRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecGrpcRouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecGrpcRouteTimeoutPerRequest[];
    }
    interface GetRouteSpecGrpcRouteTimeoutIdle {
        unit: string;
        value: number;
    }
    interface GetRouteSpecGrpcRouteTimeoutPerRequest {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttp2Route {
        actions: outputs.appmesh.GetRouteSpecHttp2RouteAction[];
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecHttp2RouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecHttp2RouteTimeout[];
    }
    interface GetRouteSpecHttp2RouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecHttp2RouteActionWeightedTarget[];
    }
    interface GetRouteSpecHttp2RouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }
    interface GetRouteSpecHttp2RouteMatch {
        headers: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeader[];
        method: string;
        paths: outputs.appmesh.GetRouteSpecHttp2RouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetRouteSpecHttp2RouteMatchQueryParameter[];
        scheme: string;
    }
    interface GetRouteSpecHttp2RouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeaderMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }
    interface GetRouteSpecHttp2RouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecHttp2RouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }
    interface GetRouteSpecHttp2RouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }
    interface GetRouteSpecHttp2RouteMatchPath {
        exact: string;
        regex: string;
    }
    interface GetRouteSpecHttp2RouteMatchQueryParameter {
        matches: outputs.appmesh.GetRouteSpecHttp2RouteMatchQueryParameterMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }
    interface GetRouteSpecHttp2RouteMatchQueryParameterMatch {
        exact: string;
    }
    interface GetRouteSpecHttp2RouteRetryPolicy {
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }
    interface GetRouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttp2RouteTimeout {
        idles: outputs.appmesh.GetRouteSpecHttp2RouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecHttp2RouteTimeoutPerRequest[];
    }
    interface GetRouteSpecHttp2RouteTimeoutIdle {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttp2RouteTimeoutPerRequest {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttpRoute {
        actions: outputs.appmesh.GetRouteSpecHttpRouteAction[];
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatch[];
        retryPolicies: outputs.appmesh.GetRouteSpecHttpRouteRetryPolicy[];
        timeouts: outputs.appmesh.GetRouteSpecHttpRouteTimeout[];
    }
    interface GetRouteSpecHttpRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecHttpRouteActionWeightedTarget[];
    }
    interface GetRouteSpecHttpRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }
    interface GetRouteSpecHttpRouteMatch {
        headers: outputs.appmesh.GetRouteSpecHttpRouteMatchHeader[];
        method: string;
        paths: outputs.appmesh.GetRouteSpecHttpRouteMatchPath[];
        port: number;
        prefix: string;
        queryParameters: outputs.appmesh.GetRouteSpecHttpRouteMatchQueryParameter[];
        scheme: string;
    }
    interface GetRouteSpecHttpRouteMatchHeader {
        invert: boolean;
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatchHeaderMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }
    interface GetRouteSpecHttpRouteMatchHeaderMatch {
        exact: string;
        prefix: string;
        ranges: outputs.appmesh.GetRouteSpecHttpRouteMatchHeaderMatchRange[];
        regex: string;
        suffix: string;
    }
    interface GetRouteSpecHttpRouteMatchHeaderMatchRange {
        end: number;
        start: number;
    }
    interface GetRouteSpecHttpRouteMatchPath {
        exact: string;
        regex: string;
    }
    interface GetRouteSpecHttpRouteMatchQueryParameter {
        matches: outputs.appmesh.GetRouteSpecHttpRouteMatchQueryParameterMatch[];
        /**
         * Name of the route.
         */
        name: string;
    }
    interface GetRouteSpecHttpRouteMatchQueryParameterMatch {
        exact: string;
    }
    interface GetRouteSpecHttpRouteRetryPolicy {
        httpRetryEvents: string[];
        maxRetries: number;
        perRetryTimeouts: outputs.appmesh.GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout[];
        tcpRetryEvents: string[];
    }
    interface GetRouteSpecHttpRouteRetryPolicyPerRetryTimeout {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttpRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecHttpRouteTimeoutIdle[];
        perRequests: outputs.appmesh.GetRouteSpecHttpRouteTimeoutPerRequest[];
    }
    interface GetRouteSpecHttpRouteTimeoutIdle {
        unit: string;
        value: number;
    }
    interface GetRouteSpecHttpRouteTimeoutPerRequest {
        unit: string;
        value: number;
    }
    interface GetRouteSpecTcpRoute {
        actions: outputs.appmesh.GetRouteSpecTcpRouteAction[];
        matches: outputs.appmesh.GetRouteSpecTcpRouteMatch[];
        timeouts: outputs.appmesh.GetRouteSpecTcpRouteTimeout[];
    }
    interface GetRouteSpecTcpRouteAction {
        weightedTargets: outputs.appmesh.GetRouteSpecTcpRouteActionWeightedTarget[];
    }
    interface GetRouteSpecTcpRouteActionWeightedTarget {
        port: number;
        virtualNode: string;
        weight: number;
    }
    interface GetRouteSpecTcpRouteMatch {
        port: number;
    }
    interface GetRouteSpecTcpRouteTimeout {
        idles: outputs.appmesh.GetRouteSpecTcpRouteTimeoutIdle[];
    }
    interface GetRouteSpecTcpRouteTimeoutIdle {
        unit: string;
        value: number;
    }
    interface GetVirtualGatewaySpec {
        backendDefaults: outputs.appmesh.GetVirtualGatewaySpecBackendDefault[];
        listeners: outputs.appmesh.GetVirtualGatewaySpecListener[];
        loggings: outputs.appmesh.GetVirtualGatewaySpecLogging[];
    }
    interface GetVirtualGatewaySpecBackendDefault {
        clientPolicies: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicy[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicy {
        tls: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTl[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlCertificateSd {
        secretName: string;
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }
    interface GetVirtualGatewaySpecBackendDefaultClientPolicyTlValidationTrustSd {
        secretName: string;
    }
    interface GetVirtualGatewaySpecListener {
        connectionPools: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPool[];
        healthChecks: outputs.appmesh.GetVirtualGatewaySpecListenerHealthCheck[];
        portMappings: outputs.appmesh.GetVirtualGatewaySpecListenerPortMapping[];
        tls: outputs.appmesh.GetVirtualGatewaySpecListenerTl[];
    }
    interface GetVirtualGatewaySpecListenerConnectionPool {
        grpcs: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolGrpc[];
        http2s: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolHttp2[];
        https: outputs.appmesh.GetVirtualGatewaySpecListenerConnectionPoolHttp[];
    }
    interface GetVirtualGatewaySpecListenerConnectionPoolGrpc {
        maxRequests: number;
    }
    interface GetVirtualGatewaySpecListenerConnectionPoolHttp {
        maxConnections: number;
        maxPendingRequests: number;
    }
    interface GetVirtualGatewaySpecListenerConnectionPoolHttp2 {
        maxRequests: number;
    }
    interface GetVirtualGatewaySpecListenerHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path: string;
        port: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }
    interface GetVirtualGatewaySpecListenerPortMapping {
        port: number;
        protocol: string;
    }
    interface GetVirtualGatewaySpecListenerTl {
        certificates: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificate[];
        mode: string;
        validations: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidation[];
    }
    interface GetVirtualGatewaySpecListenerTlCertificate {
        acms: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateAcm[];
        files: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecListenerTlCertificateSd[];
    }
    interface GetVirtualGatewaySpecListenerTlCertificateAcm {
        certificateArn: string;
    }
    interface GetVirtualGatewaySpecListenerTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }
    interface GetVirtualGatewaySpecListenerTlCertificateSd {
        secretName: string;
    }
    interface GetVirtualGatewaySpecListenerTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrust[];
    }
    interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch[];
    }
    interface GetVirtualGatewaySpecListenerTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }
    interface GetVirtualGatewaySpecListenerTlValidationTrust {
        files: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualGatewaySpecListenerTlValidationTrustSd[];
    }
    interface GetVirtualGatewaySpecListenerTlValidationTrustFile {
        certificateChain: string;
    }
    interface GetVirtualGatewaySpecListenerTlValidationTrustSd {
        secretName: string;
    }
    interface GetVirtualGatewaySpecLogging {
        accessLogs: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLog[];
    }
    interface GetVirtualGatewaySpecLoggingAccessLog {
        files: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFile[];
    }
    interface GetVirtualGatewaySpecLoggingAccessLogFile {
        formats: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFileFormat[];
        path: string;
    }
    interface GetVirtualGatewaySpecLoggingAccessLogFileFormat {
        jsons: outputs.appmesh.GetVirtualGatewaySpecLoggingAccessLogFileFormatJson[];
        text: string;
    }
    interface GetVirtualGatewaySpecLoggingAccessLogFileFormatJson {
        key: string;
        value: string;
    }
    interface GetVirtualNodeSpec {
        backendDefaults: outputs.appmesh.GetVirtualNodeSpecBackendDefault[];
        backends: outputs.appmesh.GetVirtualNodeSpecBackend[];
        listeners: outputs.appmesh.GetVirtualNodeSpecListener[];
        loggings: outputs.appmesh.GetVirtualNodeSpecLogging[];
        serviceDiscoveries: outputs.appmesh.GetVirtualNodeSpecServiceDiscovery[];
    }
    interface GetVirtualNodeSpecBackend {
        virtualServices: outputs.appmesh.GetVirtualNodeSpecBackendVirtualService[];
    }
    interface GetVirtualNodeSpecBackendDefault {
        clientPolicies: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicy[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicy {
        tls: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTl[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlCertificateSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }
    interface GetVirtualNodeSpecBackendDefaultClientPolicyTlValidationTrustSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecBackendVirtualService {
        clientPolicies: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicy[];
        virtualServiceName: string;
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicy {
        tls: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate[];
        enforce: boolean;
        ports: number[];
        validations: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificate {
        files: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlCertificateSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrust {
        acms: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustAcm {
        certificateAuthorityArns: string[];
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustFile {
        certificateChain: string;
    }
    interface GetVirtualNodeSpecBackendVirtualServiceClientPolicyTlValidationTrustSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecListener {
        connectionPools: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPool[];
        healthChecks: outputs.appmesh.GetVirtualNodeSpecListenerHealthCheck[];
        outlierDetections: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetection[];
        portMappings: outputs.appmesh.GetVirtualNodeSpecListenerPortMapping[];
        timeouts: outputs.appmesh.GetVirtualNodeSpecListenerTimeout[];
        tls: outputs.appmesh.GetVirtualNodeSpecListenerTl[];
    }
    interface GetVirtualNodeSpecListenerConnectionPool {
        grpcs: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolGrpc[];
        http2s: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolHttp2[];
        https: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolHttp[];
        tcps: outputs.appmesh.GetVirtualNodeSpecListenerConnectionPoolTcp[];
    }
    interface GetVirtualNodeSpecListenerConnectionPoolGrpc {
        maxRequests: number;
    }
    interface GetVirtualNodeSpecListenerConnectionPoolHttp {
        maxConnections: number;
        maxPendingRequests: number;
    }
    interface GetVirtualNodeSpecListenerConnectionPoolHttp2 {
        maxRequests: number;
    }
    interface GetVirtualNodeSpecListenerConnectionPoolTcp {
        maxConnections: number;
    }
    interface GetVirtualNodeSpecListenerHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path: string;
        port: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }
    interface GetVirtualNodeSpecListenerOutlierDetection {
        baseEjectionDurations: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration[];
        intervals: outputs.appmesh.GetVirtualNodeSpecListenerOutlierDetectionInterval[];
        maxEjectionPercent: number;
        maxServerErrors: number;
    }
    interface GetVirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerOutlierDetectionInterval {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerPortMapping {
        port: number;
        protocol: string;
    }
    interface GetVirtualNodeSpecListenerTimeout {
        grpcs: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpc[];
        http2s: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2[];
        https: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp[];
        tcps: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutTcp[];
    }
    interface GetVirtualNodeSpecListenerTimeoutGrpc {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpcIdle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutGrpcPerRequest[];
    }
    interface GetVirtualNodeSpecListenerTimeoutGrpcIdle {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutGrpcPerRequest {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutHttp {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttpIdle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttpPerRequest[];
    }
    interface GetVirtualNodeSpecListenerTimeoutHttp2 {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2Idle[];
        perRequests: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutHttp2PerRequest[];
    }
    interface GetVirtualNodeSpecListenerTimeoutHttp2Idle {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutHttp2PerRequest {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutHttpIdle {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutHttpPerRequest {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTimeoutTcp {
        idles: outputs.appmesh.GetVirtualNodeSpecListenerTimeoutTcpIdle[];
    }
    interface GetVirtualNodeSpecListenerTimeoutTcpIdle {
        unit: string;
        value: number;
    }
    interface GetVirtualNodeSpecListenerTl {
        certificates: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificate[];
        mode: string;
        validations: outputs.appmesh.GetVirtualNodeSpecListenerTlValidation[];
    }
    interface GetVirtualNodeSpecListenerTlCertificate {
        acms: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateAcm[];
        files: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecListenerTlCertificateSd[];
    }
    interface GetVirtualNodeSpecListenerTlCertificateAcm {
        certificateArn: string;
    }
    interface GetVirtualNodeSpecListenerTlCertificateFile {
        certificateChain: string;
        privateKey: string;
    }
    interface GetVirtualNodeSpecListenerTlCertificateSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecListenerTlValidation {
        subjectAlternativeNames: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName[];
        trusts: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrust[];
    }
    interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeName {
        matches: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch[];
    }
    interface GetVirtualNodeSpecListenerTlValidationSubjectAlternativeNameMatch {
        exacts: string[];
    }
    interface GetVirtualNodeSpecListenerTlValidationTrust {
        files: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrustFile[];
        sds: outputs.appmesh.GetVirtualNodeSpecListenerTlValidationTrustSd[];
    }
    interface GetVirtualNodeSpecListenerTlValidationTrustFile {
        certificateChain: string;
    }
    interface GetVirtualNodeSpecListenerTlValidationTrustSd {
        secretName: string;
    }
    interface GetVirtualNodeSpecLogging {
        accessLogs: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLog[];
    }
    interface GetVirtualNodeSpecLoggingAccessLog {
        files: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFile[];
    }
    interface GetVirtualNodeSpecLoggingAccessLogFile {
        formats: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFileFormat[];
        path: string;
    }
    interface GetVirtualNodeSpecLoggingAccessLogFileFormat {
        jsons: outputs.appmesh.GetVirtualNodeSpecLoggingAccessLogFileFormatJson[];
        text: string;
    }
    interface GetVirtualNodeSpecLoggingAccessLogFileFormatJson {
        key: string;
        value: string;
    }
    interface GetVirtualNodeSpecServiceDiscovery {
        awsCloudMaps: outputs.appmesh.GetVirtualNodeSpecServiceDiscoveryAwsCloudMap[];
        dns: outputs.appmesh.GetVirtualNodeSpecServiceDiscoveryDn[];
    }
    interface GetVirtualNodeSpecServiceDiscoveryAwsCloudMap {
        attributes: {
            [key: string]: string;
        };
        namespaceName: string;
        serviceName: string;
    }
    interface GetVirtualNodeSpecServiceDiscoveryDn {
        hostname: string;
        ipPreference: string;
        responseType: string;
    }
    interface GetVirtualRouterSpec {
        listeners: outputs.appmesh.GetVirtualRouterSpecListener[];
    }
    interface GetVirtualRouterSpecListener {
        portMappings: outputs.appmesh.GetVirtualRouterSpecListenerPortMapping[];
    }
    interface GetVirtualRouterSpecListenerPortMapping {
        port: number;
        protocol: string;
    }
    interface GetVirtualServiceSpec {
        providers: outputs.appmesh.GetVirtualServiceSpecProvider[];
    }
    interface GetVirtualServiceSpecProvider {
        virtualNodes: outputs.appmesh.GetVirtualServiceSpecProviderVirtualNode[];
        virtualRouters: outputs.appmesh.GetVirtualServiceSpecProviderVirtualRouter[];
    }
    interface GetVirtualServiceSpecProviderVirtualNode {
        virtualNodeName: string;
    }
    interface GetVirtualServiceSpecProviderVirtualRouter {
        virtualRouterName: string;
    }
    interface MeshSpec {
        /**
         * Egress filter rules for the service mesh.
         */
        egressFilter?: outputs.appmesh.MeshSpecEgressFilter;
        /**
         * The service discovery information for the service mesh.
         */
        serviceDiscovery?: outputs.appmesh.MeshSpecServiceDiscovery;
    }
    interface MeshSpecEgressFilter {
        /**
         * Egress filter type. By default, the type is `DROP_ALL`. Valid values are `ALLOW_ALL` and `DROP_ALL`.
         */
        type?: string;
    }
    interface MeshSpecServiceDiscovery {
        /**
         * The IP version to use to control traffic within the mesh. Valid values are `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, and `IPv6_ONLY`.
         */
        ipPreference?: string;
    }
    interface RouteSpec {
        /**
         * GRPC routing information for the route.
         */
        grpcRoute?: outputs.appmesh.RouteSpecGrpcRoute;
        /**
         * HTTP/2 routing information for the route.
         */
        http2Route?: outputs.appmesh.RouteSpecHttp2Route;
        /**
         * HTTP routing information for the route.
         */
        httpRoute?: outputs.appmesh.RouteSpecHttpRoute;
        /**
         * Priority for the route, between `0` and `1000`.
         * Routes are matched based on the specified value, where `0` is the highest priority.
         */
        priority?: number;
        /**
         * TCP routing information for the route.
         */
        tcpRoute?: outputs.appmesh.RouteSpecTcpRoute;
    }
    interface RouteSpecGrpcRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecGrpcRouteAction;
        /**
         * Criteria for determining an gRPC request match.
         */
        match?: outputs.appmesh.RouteSpecGrpcRouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecGrpcRouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecGrpcRouteTimeout;
    }
    interface RouteSpecGrpcRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecGrpcRouteActionWeightedTarget[];
    }
    interface RouteSpecGrpcRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }
    interface RouteSpecGrpcRouteMatch {
        /**
         * Data to match from the gRPC request.
         */
        metadatas?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadata[];
        /**
         * Method name to match from the request. If you specify a name, you must also specify a `serviceName`.
         */
        methodName?: string;
        /**
         * The port number to match from the request.
         */
        port?: number;
        prefix?: string;
        /**
         * Fully qualified domain name for the service to match from the request.
         */
        serviceName?: string;
    }
    interface RouteSpecGrpcRouteMatchMetadata {
        /**
         * If `true`, the match is on the opposite of the `match` criteria. Default is `false`.
         */
        invert?: boolean;
        /**
         * Data to match from the request.
         */
        match?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatch;
        /**
         * Name of the route. Must be between 1 and 50 characters in length.
         */
        name: string;
    }
    interface RouteSpecGrpcRouteMatchMetadataMatch {
        /**
         * Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
         */
        exact?: string;
        /**
         * Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecGrpcRouteMatchMetadataMatchRange;
        /**
         * Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
         */
        regex?: string;
        /**
         * Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
         */
        suffix?: string;
    }
    interface RouteSpecGrpcRouteMatchMetadataMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }
    interface RouteSpecGrpcRouteRetryPolicy {
        /**
         * List of gRPC retry events.
         * Valid values: `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
         */
        grpcRetryEvents?: string[];
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecGrpcRouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         */
        tcpRetryEvents?: string[];
    }
    interface RouteSpecGrpcRouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }
    interface RouteSpecGrpcRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecGrpcRouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecGrpcRouteTimeoutPerRequest;
    }
    interface RouteSpecGrpcRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecGrpcRouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecHttp2Route {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecHttp2RouteAction;
        /**
         * Criteria for determining an HTTP request match.
         */
        match: outputs.appmesh.RouteSpecHttp2RouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecHttp2RouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecHttp2RouteTimeout;
    }
    interface RouteSpecHttp2RouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecHttp2RouteActionWeightedTarget[];
    }
    interface RouteSpecHttp2RouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }
    interface RouteSpecHttp2RouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.RouteSpecHttp2RouteMatchHeader[];
        /**
         * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
         */
        method?: string;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.RouteSpecHttp2RouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Path with which to match requests.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.RouteSpecHttp2RouteMatchQueryParameter[];
        /**
         * Client request header scheme to match on. Valid values: `http`, `https`.
         */
        scheme?: string;
    }
    interface RouteSpecHttp2RouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }
    interface RouteSpecHttp2RouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Header value sent by the client must begin with the specified characters.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecHttp2RouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }
    interface RouteSpecHttp2RouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }
    interface RouteSpecHttp2RouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }
    interface RouteSpecHttp2RouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.RouteSpecHttp2RouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }
    interface RouteSpecHttp2RouteMatchQueryParameterMatch {
        /**
         * The exact query parameter to match on.
         */
        exact?: string;
    }
    interface RouteSpecHttp2RouteRetryPolicy {
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecHttp2RouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         *
         * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
         */
        tcpRetryEvents?: string[];
    }
    interface RouteSpecHttp2RouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }
    interface RouteSpecHttp2RouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecHttp2RouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecHttp2RouteTimeoutPerRequest;
    }
    interface RouteSpecHttp2RouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecHttp2RouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecHttpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecHttpRouteAction;
        /**
         * Criteria for determining an HTTP request match.
         */
        match: outputs.appmesh.RouteSpecHttpRouteMatch;
        /**
         * Retry policy.
         */
        retryPolicy?: outputs.appmesh.RouteSpecHttpRouteRetryPolicy;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecHttpRouteTimeout;
    }
    interface RouteSpecHttpRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecHttpRouteActionWeightedTarget[];
    }
    interface RouteSpecHttpRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }
    interface RouteSpecHttpRouteMatch {
        /**
         * Client request headers to match on.
         */
        headers?: outputs.appmesh.RouteSpecHttpRouteMatchHeader[];
        /**
         * Client request header method to match on. Valid values: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`.
         */
        method?: string;
        /**
         * Client request path to match on.
         */
        path?: outputs.appmesh.RouteSpecHttpRouteMatchPath;
        /**
         * The port number to match from the request.
         */
        port?: number;
        /**
         * Path with which to match requests.
         * This parameter must always start with /, which by itself matches all requests to the virtual router service name.
         */
        prefix?: string;
        /**
         * Client request query parameters to match on.
         */
        queryParameters?: outputs.appmesh.RouteSpecHttpRouteMatchQueryParameter[];
        /**
         * Client request header scheme to match on. Valid values: `http`, `https`.
         */
        scheme?: string;
    }
    interface RouteSpecHttpRouteMatchHeader {
        /**
         * If `true`, the match is on the opposite of the `match` method and value. Default is `false`.
         */
        invert?: boolean;
        /**
         * Method and value to match the header value sent with a request. Specify one match method.
         */
        match?: outputs.appmesh.RouteSpecHttpRouteMatchHeaderMatch;
        /**
         * Name for the HTTP header in the client request that will be matched on.
         */
        name: string;
    }
    interface RouteSpecHttpRouteMatchHeaderMatch {
        /**
         * Header value sent by the client must match the specified value exactly.
         */
        exact?: string;
        /**
         * Header value sent by the client must begin with the specified characters.
         */
        prefix?: string;
        /**
         * Object that specifies the range of numbers that the header value sent by the client must be included in.
         */
        range?: outputs.appmesh.RouteSpecHttpRouteMatchHeaderMatchRange;
        /**
         * Header value sent by the client must include the specified characters.
         */
        regex?: string;
        /**
         * Header value sent by the client must end with the specified characters.
         */
        suffix?: string;
    }
    interface RouteSpecHttpRouteMatchHeaderMatchRange {
        /**
         * End of the range.
         */
        end: number;
        /**
         * Start of the range.
         */
        start: number;
    }
    interface RouteSpecHttpRouteMatchPath {
        /**
         * The exact path to match on.
         */
        exact?: string;
        /**
         * The regex used to match the path.
         */
        regex?: string;
    }
    interface RouteSpecHttpRouteMatchQueryParameter {
        /**
         * The query parameter to match on.
         */
        match?: outputs.appmesh.RouteSpecHttpRouteMatchQueryParameterMatch;
        /**
         * Name for the query parameter that will be matched on.
         */
        name: string;
    }
    interface RouteSpecHttpRouteMatchQueryParameterMatch {
        /**
         * The exact query parameter to match on.
         */
        exact?: string;
    }
    interface RouteSpecHttpRouteRetryPolicy {
        /**
         * List of HTTP retry events.
         * Valid values: `client-error` (HTTP status code 409), `gateway-error` (HTTP status codes 502, 503, and 504), `server-error` (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), `stream-error` (retry on refused stream).
         */
        httpRetryEvents?: string[];
        /**
         * Maximum number of retries.
         */
        maxRetries: number;
        /**
         * Per-retry timeout.
         */
        perRetryTimeout: outputs.appmesh.RouteSpecHttpRouteRetryPolicyPerRetryTimeout;
        /**
         * List of TCP retry events. The only valid value is `connection-error`.
         *
         * You must specify at least one value for `httpRetryEvents`, or at least one value for `tcpRetryEvents`.
         */
        tcpRetryEvents?: string[];
    }
    interface RouteSpecHttpRouteRetryPolicyPerRetryTimeout {
        /**
         * Retry unit. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Retry value.
         */
        value: number;
    }
    interface RouteSpecHttpRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecHttpRouteTimeoutIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.RouteSpecHttpRouteTimeoutPerRequest;
    }
    interface RouteSpecHttpRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecHttpRouteTimeoutPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface RouteSpecTcpRoute {
        /**
         * Action to take if a match is determined.
         */
        action: outputs.appmesh.RouteSpecTcpRouteAction;
        match?: outputs.appmesh.RouteSpecTcpRouteMatch;
        /**
         * Types of timeouts.
         */
        timeout?: outputs.appmesh.RouteSpecTcpRouteTimeout;
    }
    interface RouteSpecTcpRouteAction {
        /**
         * Targets that traffic is routed to when a request matches the route.
         * You can specify one or more targets and their relative weights with which to distribute traffic.
         */
        weightedTargets: outputs.appmesh.RouteSpecTcpRouteActionWeightedTarget[];
    }
    interface RouteSpecTcpRouteActionWeightedTarget {
        /**
         * The targeted port of the weighted object.
         */
        port?: number;
        /**
         * Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
         */
        virtualNode: string;
        /**
         * Relative weight of the weighted target. An integer between 0 and 100.
         */
        weight: number;
    }
    interface RouteSpecTcpRouteMatch {
        port?: number;
    }
    interface RouteSpecTcpRouteTimeout {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.RouteSpecTcpRouteTimeoutIdle;
    }
    interface RouteSpecTcpRouteTimeoutIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualGatewaySpec {
        /**
         * Defaults for backends.
         */
        backendDefaults?: outputs.appmesh.VirtualGatewaySpecBackendDefaults;
        /**
         * Listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
         */
        listeners: outputs.appmesh.VirtualGatewaySpecListener[];
        /**
         * Inbound and outbound access logging information for the virtual gateway.
         */
        logging?: outputs.appmesh.VirtualGatewaySpecLogging;
    }
    interface VirtualGatewaySpecBackendDefaults {
        /**
         * Default client policy for virtual gateway backends.
         */
        clientPolicy?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicy;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTls;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidation {
        /**
         * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }
    interface VirtualGatewaySpecBackendDefaultsClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualGatewaySpecListener {
        /**
         * Connection pool information for the listener.
         */
        connectionPool?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPool;
        /**
         * Health check information for the listener.
         */
        healthCheck?: outputs.appmesh.VirtualGatewaySpecListenerHealthCheck;
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualGatewaySpecListenerPortMapping;
        /**
         * Transport Layer Security (TLS) properties for the listener
         */
        tls?: outputs.appmesh.VirtualGatewaySpecListenerTls;
    }
    interface VirtualGatewaySpecListenerConnectionPool {
        /**
         * Connection pool information for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolGrpc;
        /**
         * Connection pool information for HTTP listeners.
         */
        http?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp;
        /**
         * Connection pool information for HTTP2 listeners.
         */
        http2?: outputs.appmesh.VirtualGatewaySpecListenerConnectionPoolHttp2;
    }
    interface VirtualGatewaySpecListenerConnectionPoolGrpc {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }
    interface VirtualGatewaySpecListenerConnectionPoolHttp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
        /**
         * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
         */
        maxPendingRequests?: number;
    }
    interface VirtualGatewaySpecListenerConnectionPoolHttp2 {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }
    interface VirtualGatewaySpecListenerHealthCheck {
        /**
         * Number of consecutive successful health checks that must occur before declaring listener healthy.
         */
        healthyThreshold: number;
        /**
         * Time period in milliseconds between each health check execution.
         */
        intervalMillis: number;
        /**
         * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
         */
        path?: string;
        /**
         * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
         */
        port: number;
        /**
         * Protocol for the health check request. Valid values are `http`, `http2`, and `grpc`.
         */
        protocol: string;
        /**
         * Amount of time to wait when receiving a response from the health check, in milliseconds.
         */
        timeoutMillis: number;
        /**
         * Number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
         */
        unhealthyThreshold: number;
    }
    interface VirtualGatewaySpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }
    interface VirtualGatewaySpecListenerTls {
        /**
         * Listener's TLS certificate.
         */
        certificate: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificate;
        /**
         * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
         */
        mode: string;
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidation;
    }
    interface VirtualGatewaySpecListenerTlsCertificate {
        /**
         * An AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateAcm;
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecListenerTlsCertificateSds;
    }
    interface VirtualGatewaySpecListenerTlsCertificateAcm {
        /**
         * ARN for the certificate.
         */
        certificateArn: string;
    }
    interface VirtualGatewaySpecListenerTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }
    interface VirtualGatewaySpecListenerTlsCertificateSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualGatewaySpecListenerTlsValidation {
        /**
         * SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrust;
    }
    interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch;
    }
    interface VirtualGatewaySpecListenerTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }
    interface VirtualGatewaySpecListenerTlsValidationTrust {
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualGatewaySpecListenerTlsValidationTrustSds;
    }
    interface VirtualGatewaySpecListenerTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }
    interface VirtualGatewaySpecListenerTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualGatewaySpecLogging {
        /**
         * Access log configuration for a virtual gateway.
         */
        accessLog?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLog;
    }
    interface VirtualGatewaySpecLoggingAccessLog {
        /**
         * File object to send virtual gateway access logs to.
         */
        file?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFile;
    }
    interface VirtualGatewaySpecLoggingAccessLogFile {
        /**
         * The specified format for the logs.
         */
        format?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFileFormat;
        /**
         * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
         */
        path: string;
    }
    interface VirtualGatewaySpecLoggingAccessLogFileFormat {
        /**
         * The logging format for JSON.
         */
        jsons?: outputs.appmesh.VirtualGatewaySpecLoggingAccessLogFileFormatJson[];
        /**
         * The logging format for text. Must be between 1 and 1000 characters in length.
         */
        text?: string;
    }
    interface VirtualGatewaySpecLoggingAccessLogFileFormatJson {
        /**
         * The specified key for the JSON. Must be between 1 and 100 characters in length.
         */
        key: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: string;
    }
    interface VirtualNodeSpec {
        /**
         * Defaults for backends.
         */
        backendDefaults?: outputs.appmesh.VirtualNodeSpecBackendDefaults;
        /**
         * Backends to which the virtual node is expected to send outbound traffic.
         */
        backends?: outputs.appmesh.VirtualNodeSpecBackend[];
        /**
         * Listeners from which the virtual node is expected to receive inbound traffic.
         */
        listeners?: outputs.appmesh.VirtualNodeSpecListener[];
        /**
         * Inbound and outbound access logging information for the virtual node.
         */
        logging?: outputs.appmesh.VirtualNodeSpecLogging;
        /**
         * Service discovery information for the virtual node.
         */
        serviceDiscovery?: outputs.appmesh.VirtualNodeSpecServiceDiscovery;
    }
    interface VirtualNodeSpecBackend {
        /**
         * Virtual service to use as a backend for a virtual node.
         */
        virtualService: outputs.appmesh.VirtualNodeSpecBackendVirtualService;
    }
    interface VirtualNodeSpecBackendDefaults {
        /**
         * Default client policy for virtual service backends. See above for details.
         */
        clientPolicy?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicy;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTls;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }
    interface VirtualNodeSpecBackendDefaultsClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecBackendVirtualService {
        /**
         * Client policy for the backend.
         */
        clientPolicy?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicy;
        /**
         * Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
         */
        virtualServiceName: string;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicy {
        /**
         * Transport Layer Security (TLS) client policy.
         */
        tls?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTls;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTls {
        /**
         * Listener's TLS certificate.
         */
        certificate?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate;
        /**
         * Whether the policy is enforced. Default is `true`.
         */
        enforce?: boolean;
        /**
         * One or more ports that the policy is enforced for.
         */
        ports?: number[];
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificate {
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrust {
        /**
         * TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm;
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm {
        /**
         * One or more ACM ARNs.
         */
        certificateAuthorityArns: string[];
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }
    interface VirtualNodeSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecListener {
        /**
         * Connection pool information for the listener.
         */
        connectionPool?: outputs.appmesh.VirtualNodeSpecListenerConnectionPool;
        /**
         * Health check information for the listener.
         */
        healthCheck?: outputs.appmesh.VirtualNodeSpecListenerHealthCheck;
        /**
         * Outlier detection information for the listener.
         */
        outlierDetection?: outputs.appmesh.VirtualNodeSpecListenerOutlierDetection;
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualNodeSpecListenerPortMapping;
        /**
         * Timeouts for different protocols.
         */
        timeout?: outputs.appmesh.VirtualNodeSpecListenerTimeout;
        /**
         * Transport Layer Security (TLS) properties for the listener
         */
        tls?: outputs.appmesh.VirtualNodeSpecListenerTls;
    }
    interface VirtualNodeSpecListenerConnectionPool {
        /**
         * Connection pool information for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolGrpc;
        /**
         * Connection pool information for HTTP2 listeners.
         */
        http2s?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp2[];
        /**
         * Connection pool information for HTTP listeners.
         */
        https?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolHttp[];
        /**
         * Connection pool information for TCP listeners.
         */
        tcps?: outputs.appmesh.VirtualNodeSpecListenerConnectionPoolTcp[];
    }
    interface VirtualNodeSpecListenerConnectionPoolGrpc {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }
    interface VirtualNodeSpecListenerConnectionPoolHttp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
        /**
         * Number of overflowing requests after `maxConnections` Envoy will queue to upstream cluster. Minimum value of `1`.
         */
        maxPendingRequests?: number;
    }
    interface VirtualNodeSpecListenerConnectionPoolHttp2 {
        /**
         * Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of `1`.
         */
        maxRequests: number;
    }
    interface VirtualNodeSpecListenerConnectionPoolTcp {
        /**
         * Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of `1`.
         */
        maxConnections: number;
    }
    interface VirtualNodeSpecListenerHealthCheck {
        /**
         * Number of consecutive successful health checks that must occur before declaring listener healthy.
         */
        healthyThreshold: number;
        /**
         * Time period in milliseconds between each health check execution.
         */
        intervalMillis: number;
        /**
         * Destination path for the health check request. This is only required if the specified protocol is `http` or `http2`.
         */
        path?: string;
        /**
         * Destination port for the health check request. This port must match the port defined in the `portMapping` for the listener.
         */
        port: number;
        /**
         * Protocol for the health check request. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
        /**
         * Amount of time to wait when receiving a response from the health check, in milliseconds.
         */
        timeoutMillis: number;
        /**
         * Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
         */
        unhealthyThreshold: number;
    }
    interface VirtualNodeSpecListenerOutlierDetection {
        /**
         * Base amount of time for which a host is ejected.
         */
        baseEjectionDuration: outputs.appmesh.VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration;
        /**
         * Time interval between ejection sweep analysis.
         */
        interval: outputs.appmesh.VirtualNodeSpecListenerOutlierDetectionInterval;
        /**
         * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
         * Minimum value of `0`. Maximum value of `100`.
         */
        maxEjectionPercent: number;
        /**
         * Number of consecutive `5xx` errors required for ejection. Minimum value of `1`.
         */
        maxServerErrors: number;
    }
    interface VirtualNodeSpecListenerOutlierDetectionBaseEjectionDuration {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerOutlierDetectionInterval {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`, `http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }
    interface VirtualNodeSpecListenerTimeout {
        /**
         * Timeouts for gRPC listeners.
         */
        grpc?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpc;
        /**
         * Timeouts for HTTP listeners.
         */
        http?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp;
        /**
         * Timeouts for HTTP2 listeners.
         */
        http2?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2;
        /**
         * Timeouts for TCP listeners.
         */
        tcp?: outputs.appmesh.VirtualNodeSpecListenerTimeoutTcp;
    }
    interface VirtualNodeSpecListenerTimeoutGrpc {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutGrpcPerRequest;
    }
    interface VirtualNodeSpecListenerTimeoutGrpcIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutGrpcPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutHttp {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttpIdle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttpPerRequest;
    }
    interface VirtualNodeSpecListenerTimeoutHttp2 {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2Idle;
        /**
         * Per request timeout.
         */
        perRequest?: outputs.appmesh.VirtualNodeSpecListenerTimeoutHttp2PerRequest;
    }
    interface VirtualNodeSpecListenerTimeoutHttp2Idle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutHttp2PerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutHttpIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutHttpPerRequest {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTimeoutTcp {
        /**
         * Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
         */
        idle?: outputs.appmesh.VirtualNodeSpecListenerTimeoutTcpIdle;
    }
    interface VirtualNodeSpecListenerTimeoutTcpIdle {
        /**
         * Unit of time. Valid values: `ms`, `s`.
         */
        unit: string;
        /**
         * Number of time units. Minimum value of `0`.
         */
        value: number;
    }
    interface VirtualNodeSpecListenerTls {
        /**
         * Listener's TLS certificate.
         */
        certificate: outputs.appmesh.VirtualNodeSpecListenerTlsCertificate;
        /**
         * Listener's TLS mode. Valid values: `DISABLED`, `PERMISSIVE`, `STRICT`.
         */
        mode: string;
        /**
         * Listener's Transport Layer Security (TLS) validation context.
         */
        validation?: outputs.appmesh.VirtualNodeSpecListenerTlsValidation;
    }
    interface VirtualNodeSpecListenerTlsCertificate {
        /**
         * An AWS Certificate Manager (ACM) certificate.
         */
        acm?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateAcm;
        /**
         * Local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateFile;
        /**
         * A [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecListenerTlsCertificateSds;
    }
    interface VirtualNodeSpecListenerTlsCertificateAcm {
        /**
         * ARN for the certificate.
         */
        certificateArn: string;
    }
    interface VirtualNodeSpecListenerTlsCertificateFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
        /**
         * Private key for a certificate stored on the file system of the virtual node that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        privateKey: string;
    }
    interface VirtualNodeSpecListenerTlsCertificateSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecListenerTlsValidation {
        /**
         * SANs for a TLS validation context.
         */
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames;
        /**
         * TLS validation context trust.
         */
        trust: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrust;
    }
    interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNames {
        /**
         * Criteria for determining a SAN's match.
         */
        match: outputs.appmesh.VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch;
    }
    interface VirtualNodeSpecListenerTlsValidationSubjectAlternativeNamesMatch {
        /**
         * Values sent must match the specified values exactly.
         */
        exacts: string[];
    }
    interface VirtualNodeSpecListenerTlsValidationTrust {
        /**
         * TLS validation context trust for a local file certificate.
         */
        file?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustFile;
        /**
         * TLS validation context trust for a [Secret Discovery Service](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds) certificate.
         */
        sds?: outputs.appmesh.VirtualNodeSpecListenerTlsValidationTrustSds;
    }
    interface VirtualNodeSpecListenerTlsValidationTrustFile {
        /**
         * Certificate trust chain for a certificate stored on the file system of the mesh endpoint that the proxy is running on. Must be between 1 and 255 characters in length.
         */
        certificateChain: string;
    }
    interface VirtualNodeSpecListenerTlsValidationTrustSds {
        /**
         * Name of the secret for a virtual node's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
         */
        secretName: string;
    }
    interface VirtualNodeSpecLogging {
        /**
         * Access log configuration for a virtual node.
         */
        accessLog?: outputs.appmesh.VirtualNodeSpecLoggingAccessLog;
    }
    interface VirtualNodeSpecLoggingAccessLog {
        /**
         * File object to send virtual node access logs to.
         */
        file?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFile;
    }
    interface VirtualNodeSpecLoggingAccessLogFile {
        /**
         * The specified format for the logs.
         */
        format?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFileFormat;
        /**
         * File path to write access logs to. You can use `/dev/stdout` to send access logs to standard out. Must be between 1 and 255 characters in length.
         */
        path: string;
    }
    interface VirtualNodeSpecLoggingAccessLogFileFormat {
        /**
         * The logging format for JSON.
         */
        jsons?: outputs.appmesh.VirtualNodeSpecLoggingAccessLogFileFormatJson[];
        /**
         * The logging format for text. Must be between 1 and 1000 characters in length.
         */
        text?: string;
    }
    interface VirtualNodeSpecLoggingAccessLogFileFormatJson {
        /**
         * The specified key for the JSON. Must be between 1 and 100 characters in length.
         */
        key: string;
        /**
         * The specified value for the JSON. Must be between 1 and 100 characters in length.
         */
        value: string;
    }
    interface VirtualNodeSpecServiceDiscovery {
        /**
         * Any AWS Cloud Map information for the virtual node.
         */
        awsCloudMap?: outputs.appmesh.VirtualNodeSpecServiceDiscoveryAwsCloudMap;
        /**
         * DNS service name for the virtual node.
         */
        dns?: outputs.appmesh.VirtualNodeSpecServiceDiscoveryDns;
    }
    interface VirtualNodeSpecServiceDiscoveryAwsCloudMap {
        /**
         * String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
         */
        attributes?: {
            [key: string]: string;
        };
        /**
         * Name of the AWS Cloud Map namespace to use.
         * Use the `aws.servicediscovery.HttpNamespace` resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
         */
        namespaceName: string;
        /**
         * Name of the AWS Cloud Map service to use. Use the `aws.servicediscovery.Service` resource to configure a Cloud Map service. Must be between 1 and 1024 characters in length.
         */
        serviceName: string;
    }
    interface VirtualNodeSpecServiceDiscoveryDns {
        /**
         * DNS host name for your virtual node.
         */
        hostname: string;
        /**
         * The preferred IP version that this virtual node uses. Valid values: `IPv6_PREFERRED`, `IPv4_PREFERRED`, `IPv4_ONLY`, `IPv6_ONLY`.
         */
        ipPreference?: string;
        /**
         * The DNS response type for the virtual node. Valid values: `LOADBALANCER`, `ENDPOINTS`.
         */
        responseType?: string;
    }
    interface VirtualRouterSpec {
        /**
         * Listeners that the virtual router is expected to receive inbound traffic from.
         * Currently only one listener is supported per virtual router.
         */
        listeners?: outputs.appmesh.VirtualRouterSpecListener[];
    }
    interface VirtualRouterSpecListener {
        /**
         * Port mapping information for the listener.
         */
        portMapping: outputs.appmesh.VirtualRouterSpecListenerPortMapping;
    }
    interface VirtualRouterSpecListenerPortMapping {
        /**
         * Port used for the port mapping.
         */
        port: number;
        /**
         * Protocol used for the port mapping. Valid values are `http`,`http2`, `tcp` and `grpc`.
         */
        protocol: string;
    }
    interface VirtualServiceSpec {
        /**
         * App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
         */
        provider?: outputs.appmesh.VirtualServiceSpecProvider;
    }
    interface VirtualServiceSpecProvider {
        /**
         * Virtual node associated with a virtual service.
         */
        virtualNode?: outputs.appmesh.VirtualServiceSpecProviderVirtualNode;
        /**
         * Virtual router associated with a virtual service.
         */
        virtualRouter?: outputs.appmesh.VirtualServiceSpecProviderVirtualRouter;
    }
    interface VirtualServiceSpecProviderVirtualNode {
        /**
         * Name of the virtual node that is acting as a service provider. Must be between 1 and 255 characters in length.
         */
        virtualNodeName: string;
    }
    interface VirtualServiceSpecProviderVirtualRouter {
        /**
         * Name of the virtual router that is acting as a service provider. Must be between 1 and 255 characters in length.
         */
        virtualRouterName: string;
    }
}
export declare namespace apprunner {
    interface CustomDomainAssociationCertificateValidationRecord {
        /**
         * Certificate CNAME record name.
         */
        name: string;
        /**
         * Current state of the certificate CNAME record validation. It should change to `SUCCESS` after App Runner completes validation with your DNS.
         */
        status: string;
        /**
         * Record type, always `CNAME`.
         */
        type: string;
        /**
         * Certificate CNAME record value.
         */
        value: string;
    }
    interface DeploymentTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
    }
    interface ObservabilityConfigurationTraceConfiguration {
        /**
         * Implementation provider chosen for tracing App Runner services. Valid values: `AWSXRAY`.
         */
        vendor?: string;
    }
    interface ServiceEncryptionConfiguration {
        /**
         * ARN of the KMS key used for encryption.
         */
        kmsKey: string;
    }
    interface ServiceHealthCheckConfiguration {
        /**
         * Number of consecutive checks that must succeed before App Runner decides that the service is healthy. Defaults to 1. Minimum value of 1. Maximum value of 20.
         */
        healthyThreshold?: number;
        /**
         * Time interval, in seconds, between health checks. Defaults to 5. Minimum value of 1. Maximum value of 20.
         */
        interval?: number;
        /**
         * URL to send requests to for health checks. Defaults to `/`. Minimum length of 0. Maximum length of 51200.
         */
        path?: string;
        /**
         * IP protocol that App Runner uses to perform health checks for your service. Valid values: `TCP`, `HTTP`. Defaults to `TCP`. If you set protocol to `HTTP`, App Runner sends health check requests to the HTTP path specified by `path`.
         */
        protocol?: string;
        /**
         * Time, in seconds, to wait for a health check response before deciding it failed. Defaults to 2. Minimum value of  1. Maximum value of 20.
         */
        timeout?: number;
        /**
         * Number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Defaults to 5. Minimum value of  1. Maximum value of 20.
         */
        unhealthyThreshold?: number;
    }
    interface ServiceInstanceConfiguration {
        /**
         * Number of CPU units reserved for each instance of your App Runner service represented as a String. Defaults to `1024`. Valid values: `256|512|1024|2048|4096|(0.25|0.5|1|2|4) vCPU`.
         */
        cpu?: string;
        /**
         * ARN of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.
         */
        instanceRoleArn?: string;
        /**
         * Amount of memory, in MB or GB, reserved for each instance of your App Runner service. Defaults to `2048`. Valid values: `512|1024|2048|3072|4096|6144|8192|10240|12288|(0.5|1|2|3|4|6|8|10|12) GB`.
         */
        memory?: string;
    }
    interface ServiceNetworkConfiguration {
        /**
         * Network configuration settings for outbound message traffic. See Egress Configuration below for more details.
         */
        egressConfiguration: outputs.apprunner.ServiceNetworkConfigurationEgressConfiguration;
        /**
         * Network configuration settings for inbound network traffic. See Ingress Configuration below for more details.
         */
        ingressConfiguration: outputs.apprunner.ServiceNetworkConfigurationIngressConfiguration;
        /**
         * App Runner provides you with the option to choose between Internet Protocol version 4 (IPv4) and dual stack (IPv4 and IPv6) for your incoming public network configuration. Valid values: `IPV4`, `DUAL_STACK`. Default: `IPV4`.
         */
        ipAddressType?: string;
    }
    interface ServiceNetworkConfigurationEgressConfiguration {
        /**
         * The type of egress configuration. Valid values are: `DEFAULT` and `VPC`.
         */
        egressType: string;
        /**
         * The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when `EgressType = VPC`.
         */
        vpcConnectorArn?: string;
    }
    interface ServiceNetworkConfigurationIngressConfiguration {
        /**
         * Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to True. To make the service privately accessible, from only within an Amazon VPC set it to False.
         */
        isPubliclyAccessible?: boolean;
    }
    interface ServiceObservabilityConfiguration {
        /**
         * ARN of the observability configuration that is associated with the service. Specified only when `observabilityEnabled` is `true`.
         */
        observabilityConfigurationArn?: string;
        /**
         * When `true`, an observability configuration resource is associated with the service.
         */
        observabilityEnabled: boolean;
    }
    interface ServiceSourceConfiguration {
        /**
         * Describes resources needed to authenticate access to some source repositories. See Authentication Configuration below for more details.
         */
        authenticationConfiguration?: outputs.apprunner.ServiceSourceConfigurationAuthenticationConfiguration;
        /**
         * Whether continuous integration from the source repository is enabled for the App Runner service. If set to `true`, each repository change (source code commit or new image version) starts a deployment. Defaults to `true`.
         */
        autoDeploymentsEnabled?: boolean;
        /**
         * Description of a source code repository. See Code Repository below for more details.
         */
        codeRepository?: outputs.apprunner.ServiceSourceConfigurationCodeRepository;
        /**
         * Description of a source image repository. See Image Repository below for more details.
         */
        imageRepository?: outputs.apprunner.ServiceSourceConfigurationImageRepository;
    }
    interface ServiceSourceConfigurationAuthenticationConfiguration {
        /**
         * ARN of the IAM role that grants the App Runner service access to a source repository. Required for ECR image repositories (but not for ECR Public)
         */
        accessRoleArn?: string;
        /**
         * ARN of the App Runner connection that enables the App Runner service to connect to a source repository. Required for GitHub code repositories.
         */
        connectionArn?: string;
    }
    interface ServiceSourceConfigurationCodeRepository {
        /**
         * Configuration for building and running the service from a source code repository. See Code Configuration below for more details.
         */
        codeConfiguration?: outputs.apprunner.ServiceSourceConfigurationCodeRepositoryCodeConfiguration;
        /**
         * Location of the repository that contains the source code.
         */
        repositoryUrl: string;
        /**
         * Version that should be used within the source code repository. See Source Code Version below for more details.
         */
        sourceCodeVersion: outputs.apprunner.ServiceSourceConfigurationCodeRepositorySourceCodeVersion;
        /**
         * The path of the directory that stores source code and configuration files. The build and start commands also execute from here. The path is absolute from root and, if not specified, defaults to the repository root.
         */
        sourceDirectory: string;
    }
    interface ServiceSourceConfigurationCodeRepositoryCodeConfiguration {
        /**
         * Basic configuration for building and running the App Runner service. Use this parameter to quickly launch an App Runner service without providing an apprunner.yaml file in the source code repository (or ignoring the file if it exists). See Code Configuration Values below for more details.
         */
        codeConfigurationValues?: outputs.apprunner.ServiceSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues;
        /**
         * Source of the App Runner configuration. Valid values: `REPOSITORY`, `API`. Values are interpreted as follows:
         * * `REPOSITORY` - App Runner reads configuration values from the apprunner.yaml file in the
         * source code repository and ignores the CodeConfigurationValues parameter.
         * * `API` - App Runner uses configuration values provided in the CodeConfigurationValues
         * parameter and ignores the apprunner.yaml file in the source code repository.
         */
        configurationSource: string;
    }
    interface ServiceSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues {
        /**
         * Command App Runner runs to build your application.
         */
        buildCommand?: string;
        /**
         * Port that your application listens to in the container. Defaults to `"8080"`.
         */
        port?: string;
        /**
         * Runtime environment type for building and running an App Runner service. Represents a programming language runtime. Valid values: `PYTHON_3`, `NODEJS_12`, `NODEJS_14`, `NODEJS_16`, `CORRETTO_8`, `CORRETTO_11`, `GO_1`, `DOTNET_6`, `PHP_81`, `RUBY_31`.
         */
        runtime: string;
        /**
         * Secrets and parameters available to your service as environment variables. A map of key/value pairs, where the key is the desired name of the Secret in the environment (i.e. it does not have to match the name of the secret in Secrets Manager or SSM Parameter Store), and the value is the ARN of the secret from AWS Secrets Manager or the ARN of the parameter in AWS SSM Parameter Store.
         */
        runtimeEnvironmentSecrets?: {
            [key: string]: string;
        };
        /**
         * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of `AWSAPPRUNNER` are reserved for system use and aren't valid.
         */
        runtimeEnvironmentVariables?: {
            [key: string]: string;
        };
        /**
         * Command App Runner runs to start your application.
         */
        startCommand?: string;
    }
    interface ServiceSourceConfigurationCodeRepositorySourceCodeVersion {
        /**
         * Type of version identifier. For a git-based repository, branches represent versions. Valid values: `BRANCH`.
         */
        type: string;
        /**
         * Source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
         */
        value: string;
    }
    interface ServiceSourceConfigurationImageRepository {
        /**
         * Configuration for running the identified image. See Image Configuration below for more details.
         */
        imageConfiguration?: outputs.apprunner.ServiceSourceConfigurationImageRepositoryImageConfiguration;
        /**
         * Identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the
         * image name format, see Pulling an image in the Amazon ECR User Guide.
         */
        imageIdentifier: string;
        /**
         * Type of the image repository. This reflects the repository provider and whether the repository is private or public. Valid values: `ECR` , `ECR_PUBLIC`.
         */
        imageRepositoryType: string;
    }
    interface ServiceSourceConfigurationImageRepositoryImageConfiguration {
        /**
         * Port that your application listens to in the container. Defaults to `"8080"`.
         */
        port?: string;
        /**
         * Secrets and parameters available to your service as environment variables. A map of key/value pairs, where the key is the desired name of the Secret in the environment (i.e. it does not have to match the name of the secret in Secrets Manager or SSM Parameter Store), and the value is the ARN of the secret from AWS Secrets Manager or the ARN of the parameter in AWS SSM Parameter Store.
         */
        runtimeEnvironmentSecrets?: {
            [key: string]: string;
        };
        /**
         * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of `AWSAPPRUNNER` are reserved for system use and aren't valid.
         */
        runtimeEnvironmentVariables?: {
            [key: string]: string;
        };
        /**
         * Command App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
         */
        startCommand?: string;
    }
    interface VpcIngressConnectionIngressVpcConfiguration {
        /**
         * The ID of the VPC endpoint that your App Runner service connects to.
         */
        vpcEndpointId?: string;
        /**
         * The ID of the VPC that is used for the VPC endpoint.
         */
        vpcId?: string;
    }
}
export declare namespace appstream {
    interface DirectoryConfigServiceAccountCredentials {
        /**
         * User name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
         */
        accountName: string;
        /**
         * Password for the account.
         */
        accountPassword: string;
    }
    interface FleetComputeCapacity {
        /**
         * Number of currently available instances that can be used to stream sessions.
         */
        available: number;
        /**
         * Desired number of streaming instances.
         */
        desiredInstances?: number;
        /**
         * Desired number of user sessions for a multi-session fleet. This is not allowed for single-session fleets.
         */
        desiredSessions?: number;
        /**
         * Number of instances in use for streaming.
         */
        inUse: number;
        /**
         * Total number of simultaneous streaming instances that are running.
         */
        running: number;
    }
    interface FleetDomainJoinInfo {
        /**
         * Fully qualified name of the directory (for example, corp.example.com).
         */
        directoryName: string;
        /**
         * Distinguished name of the organizational unit for computer accounts.
         */
        organizationalUnitDistinguishedName: string;
    }
    interface FleetVpcConfig {
        /**
         * Identifiers of the security groups for the fleet or image builder.
         */
        securityGroupIds: string[];
        /**
         * Identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance.
         */
        subnetIds: string[];
    }
    interface ImageBuilderAccessEndpoint {
        /**
         * Type of interface endpoint. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/appstream2/latest/APIReference/API_AccessEndpoint.html).
         */
        endpointType: string;
        /**
         * Identifier (ID) of the interface VPC endpoint.
         */
        vpceId: string;
    }
    interface ImageBuilderDomainJoinInfo {
        /**
         * Fully qualified name of the directory (for example, corp.example.com).
         */
        directoryName?: string;
        /**
         * Distinguished name of the organizational unit for computer accounts.
         */
        organizationalUnitDistinguishedName?: string;
    }
    interface ImageBuilderVpcConfig {
        /**
         * Identifiers of the security groups for the image builder or image builder.
         */
        securityGroupIds: string[];
        /**
         * Identifier of the subnet to which a network interface is attached from the image builder instance.
         */
        subnetIds: string[];
    }
    interface StackAccessEndpoint {
        /**
         * Type of the interface endpoint.
         * See the [`AccessEndpoint` AWS API documentation](https://docs.aws.amazon.com/appstream2/latest/APIReference/API_AccessEndpoint.html) for valid values.
         */
        endpointType: string;
        /**
         * ID of the VPC in which the interface endpoint is used.
         */
        vpceId: string;
    }
    interface StackApplicationSettings {
        /**
         * Whether application settings should be persisted.
         */
        enabled: boolean;
        /**
         * Name of the settings group.
         * Required when `enabled` is `true`.
         * Can be up to 100 characters.
         */
        settingsGroup?: string;
    }
    interface StackStorageConnector {
        /**
         * Type of storage connector.
         * Valid values are `HOMEFOLDERS`, `GOOGLE_DRIVE`, or `ONE_DRIVE`.
         */
        connectorType: string;
        /**
         * Names of the domains for the account.
         */
        domains: string[];
        /**
         * ARN of the storage connector.
         */
        resourceIdentifier: string;
    }
    interface StackStreamingExperienceSettings {
        /**
         * The preferred protocol that you want to use while streaming your application.
         * Valid values are `TCP` and `UDP`.
         */
        preferredProtocol?: string;
    }
    interface StackUserSetting {
        /**
         * Action that is enabled or disabled.
         * Valid values are `CLIPBOARD_COPY_FROM_LOCAL_DEVICE`,  `CLIPBOARD_COPY_TO_LOCAL_DEVICE`, `FILE_UPLOAD`, `FILE_DOWNLOAD`, `PRINTING_TO_LOCAL_DEVICE`, `DOMAIN_PASSWORD_SIGNIN`, or `DOMAIN_SMART_CARD_SIGNIN`.
         */
        action: string;
        /**
         * Whether the action is enabled or disabled.
         * Valid values are `ENABLED` or `DISABLED`.
         */
        permission: string;
    }
}
export declare namespace appsync {
    interface DataSourceDynamodbConfig {
        /**
         * The DeltaSyncConfig for a versioned data source. See Delta Sync Config
         */
        deltaSyncConfig?: outputs.appsync.DataSourceDynamodbConfigDeltaSyncConfig;
        /**
         * AWS region of the DynamoDB table. Defaults to current region.
         */
        region: string;
        /**
         * Name of the DynamoDB table.
         */
        tableName: string;
        /**
         * Set to `true` to use Amazon Cognito credentials with this data source.
         */
        useCallerCredentials?: boolean;
        /**
         * Detects Conflict Detection and Resolution with this data source.
         */
        versioned?: boolean;
    }
    interface DataSourceDynamodbConfigDeltaSyncConfig {
        /**
         * The number of minutes that an Item is stored in the data source.
         */
        baseTableTtl?: number;
        /**
         * The table name.
         */
        deltaSyncTableName: string;
        /**
         * The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
         */
        deltaSyncTableTtl?: number;
    }
    interface DataSourceElasticsearchConfig {
        /**
         * HTTP endpoint of the Elasticsearch domain.
         */
        endpoint: string;
        /**
         * AWS region of Elasticsearch domain. Defaults to current region.
         */
        region: string;
    }
    interface DataSourceEventBridgeConfig {
        /**
         * ARN for the EventBridge bus.
         */
        eventBusArn: string;
    }
    interface DataSourceHttpConfig {
        /**
         * Authorization configuration in case the HTTP endpoint requires authorization. See Authorization Config.
         */
        authorizationConfig?: outputs.appsync.DataSourceHttpConfigAuthorizationConfig;
        /**
         * HTTP URL.
         */
        endpoint: string;
    }
    interface DataSourceHttpConfigAuthorizationConfig {
        /**
         * Authorization type that the HTTP endpoint requires. Default values is `AWS_IAM`.
         */
        authorizationType?: string;
        /**
         * Identity and Access Management (IAM) settings. See AWS IAM Config.
         */
        awsIamConfig?: outputs.appsync.DataSourceHttpConfigAuthorizationConfigAwsIamConfig;
    }
    interface DataSourceHttpConfigAuthorizationConfigAwsIamConfig {
        /**
         * Signing Amazon Web Services Region for IAM authorization.
         */
        signingRegion?: string;
        /**
         * Signing service name for IAM authorization.
         */
        signingServiceName?: string;
    }
    interface DataSourceLambdaConfig {
        /**
         * ARN for the Lambda function.
         */
        functionArn: string;
    }
    interface DataSourceOpensearchserviceConfig {
        endpoint: string;
        region: string;
    }
    interface DataSourceRelationalDatabaseConfig {
        /**
         * Amazon RDS HTTP endpoint configuration. See HTTP Endpoint Config.
         */
        httpEndpointConfig?: outputs.appsync.DataSourceRelationalDatabaseConfigHttpEndpointConfig;
        /**
         * Source type for the relational database. Valid values: `RDS_HTTP_ENDPOINT`.
         */
        sourceType?: string;
    }
    interface DataSourceRelationalDatabaseConfigHttpEndpointConfig {
        /**
         * AWS secret store ARN for database credentials.
         */
        awsSecretStoreArn: string;
        /**
         * Logical database name.
         */
        databaseName?: string;
        /**
         * Amazon RDS cluster identifier.
         */
        dbClusterIdentifier: string;
        /**
         * AWS Region for RDS HTTP endpoint. Defaults to current region.
         */
        region: string;
        /**
         * Logical schema name.
         */
        schema?: string;
    }
    interface FunctionRuntime {
        /**
         * The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
         */
        name: string;
        /**
         * The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
         */
        runtimeVersion: string;
    }
    interface FunctionSyncConfig {
        /**
         * Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
         */
        conflictDetection?: string;
        /**
         * Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
         */
        conflictHandler?: string;
        /**
         * Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
         */
        lambdaConflictHandlerConfig?: outputs.appsync.FunctionSyncConfigLambdaConflictHandlerConfig;
    }
    interface FunctionSyncConfigLambdaConflictHandlerConfig {
        /**
         * ARN for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: string;
    }
    interface GraphQLApiAdditionalAuthenticationProvider {
        /**
         * Authentication type. Valid values: `API_KEY`, `AWS_IAM`, `AMAZON_COGNITO_USER_POOLS`, `OPENID_CONNECT`, `AWS_LAMBDA`
         */
        authenticationType: string;
        /**
         * Nested argument containing Lambda authorizer configuration. Defined below.
         */
        lambdaAuthorizerConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfig;
        /**
         * Nested argument containing OpenID Connect configuration. Defined below.
         */
        openidConnectConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfig;
        /**
         * Amazon Cognito User Pool configuration. Defined below.
         */
        userPoolConfig?: outputs.appsync.GraphQLApiAdditionalAuthenticationProviderUserPoolConfig;
    }
    interface GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfig {
        /**
         * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
         */
        authorizerResultTtlInSeconds?: number;
        /**
         * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
         */
        authorizerUri: string;
        /**
         * Regular expression for validation of tokens before the Lambda function is called.
         */
        identityValidationExpression?: string;
    }
    interface GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfig {
        /**
         * Number of milliseconds a token is valid after being authenticated.
         */
        authTtl?: number;
        /**
         * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
         */
        clientId?: string;
        /**
         * Number of milliseconds a token is valid after being issued to a user.
         */
        iatTtl?: number;
        /**
         * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
         */
        issuer: string;
    }
    interface GraphQLApiAdditionalAuthenticationProviderUserPoolConfig {
        /**
         * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
         */
        appIdClientRegex?: string;
        /**
         * AWS region in which the user pool was created.
         */
        awsRegion: string;
        /**
         * User pool ID.
         */
        userPoolId: string;
    }
    interface GraphQLApiLambdaAuthorizerConfig {
        /**
         * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
         */
        authorizerResultTtlInSeconds?: number;
        /**
         * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
         */
        authorizerUri: string;
        /**
         * Regular expression for validation of tokens before the Lambda function is called.
         */
        identityValidationExpression?: string;
    }
    interface GraphQLApiLogConfig {
        /**
         * Amazon Resource Name of the service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account.
         */
        cloudwatchLogsRoleArn: string;
        /**
         * Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging  level. Valid values: `true`, `false`. Default value: `false`
         */
        excludeVerboseContent?: boolean;
        /**
         * Field logging level. Valid values: `ALL`, `ERROR`, `NONE`.
         */
        fieldLogLevel: string;
    }
    interface GraphQLApiOpenidConnectConfig {
        /**
         * Number of milliseconds a token is valid after being authenticated.
         */
        authTtl?: number;
        /**
         * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
         */
        clientId?: string;
        /**
         * Number of milliseconds a token is valid after being issued to a user.
         */
        iatTtl?: number;
        /**
         * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
         */
        issuer: string;
    }
    interface GraphQLApiUserPoolConfig {
        /**
         * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
         */
        appIdClientRegex?: string;
        /**
         * AWS region in which the user pool was created.
         */
        awsRegion: string;
        /**
         * Action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration. Valid: `ALLOW` and `DENY`
         */
        defaultAction: string;
        /**
         * User pool ID.
         */
        userPoolId: string;
    }
    interface ResolverCachingConfig {
        /**
         * The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
         */
        cachingKeys?: string[];
        /**
         * The TTL in seconds for a resolver that has caching activated. Valid values are between `1` and `3600` seconds.
         */
        ttl?: number;
    }
    interface ResolverPipelineConfig {
        /**
         * A list of Function objects.
         */
        functions?: string[];
    }
    interface ResolverRuntime {
        /**
         * The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
         */
        name: string;
        /**
         * The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
         */
        runtimeVersion: string;
    }
    interface ResolverSyncConfig {
        /**
         * Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
         */
        conflictDetection?: string;
        /**
         * Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
         */
        conflictHandler?: string;
        /**
         * Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
         */
        lambdaConflictHandlerConfig?: outputs.appsync.ResolverSyncConfigLambdaConflictHandlerConfig;
    }
    interface ResolverSyncConfigLambdaConflictHandlerConfig {
        /**
         * ARN for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: string;
    }
}
export declare namespace athena {
    interface DatabaseAclConfiguration {
        /**
         * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
         *
         * > **NOTE:** When Athena queries are executed, result files may be created in the specified bucket. Consider using `forceDestroy` on the bucket too in order to avoid any problems when destroying the bucket.
         */
        s3AclOption: string;
    }
    interface DatabaseEncryptionConfiguration {
        /**
         * Type of key; one of `SSE_S3`, `SSE_KMS`, `CSE_KMS`
         */
        encryptionOption: string;
        /**
         * KMS key ARN or ID; required for key types `SSE_KMS` and `CSE_KMS`.
         */
        kmsKey?: string;
    }
    interface WorkgroupConfiguration {
        /**
         * Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least `10485760`.
         */
        bytesScannedCutoffPerQuery?: number;
        /**
         * Boolean whether the settings for the workgroup override client-side settings. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html). Defaults to `true`.
         */
        enforceWorkgroupConfiguration?: boolean;
        /**
         * Configuration block for the Athena Engine Versioning. For more information, see [Athena Engine Versioning](https://docs.aws.amazon.com/athena/latest/ug/engine-versions.html). See Engine Version below.
         */
        engineVersion?: outputs.athena.WorkgroupConfigurationEngineVersion;
        /**
         * Role used in a notebook session for accessing the user's resources.
         */
        executionRole?: string;
        /**
         * Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to `true`.
         */
        publishCloudwatchMetricsEnabled?: boolean;
        /**
         * If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
         */
        requesterPaysEnabled?: boolean;
        /**
         * Configuration block with result settings. See Result Configuration below.
         */
        resultConfiguration?: outputs.athena.WorkgroupConfigurationResultConfiguration;
    }
    interface WorkgroupConfigurationEngineVersion {
        /**
         * The engine version on which the query runs. If `selectedEngineVersion` is set to `AUTO`, the effective engine version is chosen by Athena.
         */
        effectiveEngineVersion: string;
        /**
         * Requested engine version. Defaults to `AUTO`.
         */
        selectedEngineVersion?: string;
    }
    interface WorkgroupConfigurationResultConfiguration {
        /**
         * That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
         */
        aclConfiguration?: outputs.athena.WorkgroupConfigurationResultConfigurationAclConfiguration;
        /**
         * Configuration block with encryption settings. See Encryption Configuration below.
         */
        encryptionConfiguration?: outputs.athena.WorkgroupConfigurationResultConfigurationEncryptionConfiguration;
        /**
         * AWS account ID that you expect to be the owner of the Amazon S3 bucket.
         */
        expectedBucketOwner?: string;
        /**
         * Location in Amazon S3 where your query results are stored, such as `s3://path/to/query/bucket/`. For more information, see [Queries and Query Result Files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
         */
        outputLocation?: string;
    }
    interface WorkgroupConfigurationResultConfigurationAclConfiguration {
        /**
         * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
         */
        s3AclOption: string;
    }
    interface WorkgroupConfigurationResultConfigurationEncryptionConfiguration {
        /**
         * Whether Amazon S3 server-side encryption with Amazon S3-managed keys (`SSE_S3`), server-side encryption with KMS-managed keys (`SSE_KMS`), or client-side encryption with KMS-managed keys (`CSE_KMS`) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
         */
        encryptionOption?: string;
        /**
         * For `SSE_KMS` and `CSE_KMS`, this is the KMS key ARN.
         */
        kmsKeyArn?: string;
    }
}
export declare namespace auditmanager {
    interface AssessmentAssessmentReportsDestination {
        /**
         * Destination of the assessment report. This value be in the form `s3://{bucket_name}`.
         */
        destination: string;
        /**
         * Destination type. Currently, `S3` is the only valid value.
         */
        destinationType: string;
    }
    interface AssessmentRole {
        /**
         * Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: string;
        /**
         * Type of customer persona. For assessment creation, type must always be `PROCESS_OWNER`.
         */
        roleType: string;
    }
    interface AssessmentRolesAll {
        roleArn: string;
        roleType: string;
    }
    interface AssessmentScope {
        /**
         * Amazon Web Services accounts that are in scope for the assessment. See `awsAccounts` below.
         */
        awsAccounts?: outputs.auditmanager.AssessmentScopeAwsAccount[];
        /**
         * Amazon Web Services services that are included in the scope of the assessment. See `awsServices` below.
         */
        awsServices?: outputs.auditmanager.AssessmentScopeAwsService[];
    }
    interface AssessmentScopeAwsAccount {
        /**
         * Identifier for the Amazon Web Services account.
         */
        id: string;
    }
    interface AssessmentScopeAwsService {
        /**
         * Name of the Amazon Web Service.
         */
        serviceName: string;
    }
    interface ControlControlMappingSource {
        /**
         * Description of the source.
         */
        sourceDescription?: string;
        /**
         * Frequency of evidence collection. Valid values are `DAILY`, `WEEKLY`, or `MONTHLY`.
         */
        sourceFrequency?: string;
        sourceId: string;
        /**
         * The keyword to search for in CloudTrail logs, Config rules, Security Hub checks, and Amazon Web Services API names. See `sourceKeyword` below.
         */
        sourceKeyword?: outputs.auditmanager.ControlControlMappingSourceSourceKeyword;
        /**
         * Name of the source.
         */
        sourceName: string;
        /**
         * The setup option for the data source. This option reflects if the evidence collection is automated or manual. Valid values are `System_Controls_Mapping` (automated) and `Procedural_Controls_Mapping` (manual).
         */
        sourceSetUpOption: string;
        /**
         * Type of data source for evidence collection. If `sourceSetUpOption` is manual, the only valid value is `MANUAL`. If `sourceSetUpOption` is automated, valid values are `AWS_Cloudtrail`, `AWS_Config`, `AWS_Security_Hub`, or `AWS_API_Call`.
         *
         * The following arguments are optional:
         */
        sourceType: string;
        /**
         * Instructions for troubleshooting the control.
         */
        troubleshootingText?: string;
    }
    interface ControlControlMappingSourceSourceKeyword {
        /**
         * Input method for the keyword. Valid values are `SELECT_FROM_LIST`.
         */
        keywordInputType: string;
        /**
         * The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call. See the [Audit Manager supported control data sources documentation](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources.html) for more information.
         */
        keywordValue: string;
    }
    interface FrameworkControlSet {
        /**
         * Configuration block(s) for the controls within the control set. See `controls` Block below for details.
         */
        controls?: outputs.auditmanager.FrameworkControlSetControl[];
        /**
         * Unique identifier for the framework.
         */
        id: string;
        /**
         * Name of the control set.
         */
        name: string;
    }
    interface FrameworkControlSetControl {
        /**
         * Unique identifier of the control.
         */
        id: string;
    }
    interface GetControlControlMappingSource {
        sourceDescription: string;
        sourceFrequency: string;
        sourceId: string;
        sourceKeyword?: outputs.auditmanager.GetControlControlMappingSourceSourceKeyword;
        sourceName: string;
        sourceSetUpOption: string;
        sourceType: string;
        troubleshootingText: string;
    }
    interface GetControlControlMappingSourceSourceKeyword {
        keywordInputType: string;
        keywordValue: string;
    }
    interface GetFrameworkControlSet {
        controls?: outputs.auditmanager.GetFrameworkControlSetControl[];
        id: string;
        /**
         * Name of the framework.
         */
        name: string;
    }
    interface GetFrameworkControlSetControl {
        id: string;
    }
}
export declare namespace autoscaling {
    interface GetAmiIdsFilter {
        /**
         * Name of the DescribeAutoScalingGroup filter. The recommended values are: `tag-key`, `tag-value`, and `tag:<tag name>`
         */
        name: string;
        /**
         * Value of the filter.
         */
        values: string[];
    }
    interface GetGroupInstanceMaintenancePolicy {
        /**
         * Specifies the upper limit on the number of instances that are in the InService or Pending state with a healthy status during an instance replacement activity.
         */
        maxHealthyPercentage: number;
        /**
         * Specifies the lower limit on the number of instances that must be in the InService state with a healthy status during an instance replacement activity.
         */
        minHealthyPercentage: number;
    }
    interface GetGroupLaunchTemplate {
        /**
         * ID of the launch template.
         */
        id: string;
        /**
         * Specify the exact name of the desired autoscaling group.
         */
        name: string;
        /**
         * Template version.
         */
        version: string;
    }
    interface GetGroupMixedInstancesPolicy {
        /**
         * List of instances distribution objects.
         */
        instancesDistributions: outputs.autoscaling.GetGroupMixedInstancesPolicyInstancesDistribution[];
        /**
         * List of launch templates along with the overrides.
         */
        launchTemplates: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplate[];
    }
    interface GetGroupMixedInstancesPolicyInstancesDistribution {
        /**
         * Strategy used when launching on-demand instances.
         */
        onDemandAllocationStrategy: string;
        /**
         * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances.
         */
        onDemandBaseCapacity: number;
        onDemandPercentageAboveBaseCapacity: number;
        /**
         * Strategy used when launching Spot instances.
         */
        spotAllocationStrategy: string;
        /**
         * Number of Spot pools per availability zone to allocate capacity.
         */
        spotInstancePools: number;
        /**
         * Maximum price per unit hour that the user is willing to pay for the Spot instances.
         */
        spotMaxPrice: string;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplate {
        /**
         * List of overriding launch template specification objects.
         */
        launchTemplateSpecifications: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification[];
        /**
         * List of properties overriding the same properties in the launch template.
         */
        overrides: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverride[];
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        /**
         * ID of the launch template.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName: string;
        /**
         * Template version.
         */
        version: string;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverride {
        /**
         * List of instance requirements objects.
         * * `acceleratorCount - List of objects describing the minimum and maximum number of accelerators for an instance type.
         */
        instanceRequirements: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirement[];
        /**
         * Overriding instance type.
         */
        instanceType: string;
        /**
         * List of overriding launch template specification objects.
         */
        launchTemplateSpecifications: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification[];
        /**
         * Number of capacity units, which gives the instance type a proportional weight to other instance types.
         */
        weightedCapacity: string;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirement {
        acceleratorCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCount[];
        /**
         * List of accelerator manufacturer names.
         */
        acceleratorManufacturers: string[];
        /**
         * List of accelerator names.
         */
        acceleratorNames: string[];
        /**
         * List of objects describing the minimum and maximum total memory of the accelerators.
         */
        acceleratorTotalMemoryMibs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMib[];
        /**
         * List of accelerator types.
         */
        acceleratorTypes: string[];
        /**
         * List of instance types to apply the specified attributes against.
         */
        allowedInstanceTypes: string[];
        /**
         * Indicates whether bare metal instances are included, excluded, or required.
         */
        bareMetal: string;
        /**
         * List of objects describing the minimum and maximum baseline EBS bandwidth (Mbps).
         */
        baselineEbsBandwidthMbps: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbp[];
        /**
         * Indicates whether burstable performance instance types are included, excluded, or required.
         */
        burstablePerformance: string;
        /**
         * List of CPU manufacturer names.
         */
        cpuManufacturers: string[];
        /**
         * List of excluded instance types.
         */
        excludedInstanceTypes: string[];
        /**
         * List of instance generation names.
         */
        instanceGenerations: string[];
        /**
         * Indicates whether instance types with instance store volumes are included, excluded, or required.
         */
        localStorage: string;
        /**
         * List of local storage type names.
         */
        localStorageTypes: string[];
        /**
         * List of objects describing the minimum and maximum amount of memory (GiB) per vCPU.
         */
        memoryGibPerVcpus: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpus[];
        /**
         * List of objects describing the minimum and maximum amount of memory (MiB).
         */
        memoryMibs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMib[];
        /**
         * List of objects describing the minimum and maximum amount of network bandwidth (Gbps).
         */
        networkBandwidthGbps: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbp[];
        /**
         * List of objects describing the minimum and maximum amount of network interfaces.
         */
        networkInterfaceCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCount[];
        /**
         * Price protection threshold for On-Demand Instances.
         */
        onDemandMaxPricePercentageOverLowestPrice: number;
        /**
         * Indicates whether instance types must support On-Demand Instance Hibernation.
         */
        requireHibernateSupport: boolean;
        /**
         * Price protection threshold for Spot Instances.
         */
        spotMaxPricePercentageOverLowestPrice: number;
        /**
         * List of objects describing the minimum and maximum total storage (GB).
         */
        totalLocalStorageGbs: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGb[];
        /**
         * List of objects describing the minimum and maximum number of vCPUs.
         */
        vcpuCounts: outputs.autoscaling.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCount[];
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMib {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbp {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpus {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMib {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbp {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGb {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCount {
        /**
         * Maximum.
         */
        max: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
        /**
         * ID of the launch template.
         */
        launchTemplateId: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName: string;
        /**
         * Template version.
         */
        version: string;
    }
    interface GetGroupTag {
        /**
         * Key.
         */
        key: string;
        /**
         * Whether the tag is propagated to Amazon EC2 instances launched via this ASG.
         */
        propagateAtLaunch: boolean;
        /**
         * Value.
         */
        value: string;
    }
    interface GetGroupTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Traffic source type.
         */
        type: string;
    }
    interface GetGroupWarmPool {
        /**
         * List of instance reuse policy objects.
         */
        instanceReusePolicies: outputs.autoscaling.GetGroupWarmPoolInstanceReusePolicy[];
        maxGroupPreparedCapacity: number;
        /**
         * Minimum number of instances to maintain in the warm pool.
         */
        minSize: number;
        /**
         * Instance state to transition to after the lifecycle actions are complete.
         */
        poolState: string;
    }
    interface GetGroupWarmPoolInstanceReusePolicy {
        /**
         * Indicates whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
         */
        reuseOnScaleIn: boolean;
    }
    interface GroupInitialLifecycleHook {
        defaultResult: string;
        heartbeatTimeout?: number;
        lifecycleTransition: string;
        /**
         * Name of the Auto Scaling Group. By default generated by Pulumi. Conflicts with `namePrefix`.
         */
        name: string;
        notificationMetadata?: string;
        notificationTargetArn?: string;
        roleArn?: string;
    }
    interface GroupInstanceMaintenancePolicy {
        /**
         * Specifies the upper limit on the number of instances that are in the InService or Pending state with a healthy status during an instance replacement activity.
         */
        maxHealthyPercentage: number;
        /**
         * Specifies the lower limit on the number of instances that must be in the InService state with a healthy status during an instance replacement activity.
         */
        minHealthyPercentage: number;
    }
    interface GroupInstanceRefresh {
        /**
         * Override default parameters for Instance Refresh.
         */
        preferences?: outputs.autoscaling.GroupInstanceRefreshPreferences;
        /**
         * Strategy to use for instance refresh. The only allowed value is `Rolling`. See [StartInstanceRefresh Action](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_StartInstanceRefresh.html#API_StartInstanceRefresh_RequestParameters) for more information.
         */
        strategy: string;
        /**
         * Set of additional property names that will trigger an Instance Refresh. A refresh will always be triggered by a change in any of `launchConfiguration`, `launchTemplate`, or `mixedInstancesPolicy`.
         *
         * > **NOTE:** A refresh is started when any of the following Auto Scaling Group properties change: `launchConfiguration`, `launchTemplate`, `mixedInstancesPolicy`. Additional properties can be specified in the `triggers` property of `instanceRefresh`.
         *
         * > **NOTE:** A refresh will not start when `version = "$Latest"` is configured in the `launchTemplate` block. To trigger the instance refresh when a launch template is changed, configure `version` to use the `latestVersion` attribute of the `aws.ec2.LaunchTemplate` resource.
         *
         * > **NOTE:** Auto Scaling Groups support up to one active instance refresh at a time. When this resource is updated, any existing refresh is cancelled.
         *
         * > **NOTE:** Depending on health check settings and group size, an instance refresh may take a long time or fail. This resource does not wait for the instance refresh to complete.
         */
        triggers?: string[];
    }
    interface GroupInstanceRefreshPreferences {
        /**
         * Alarm Specification for Instance Refresh.
         */
        alarmSpecification?: outputs.autoscaling.GroupInstanceRefreshPreferencesAlarmSpecification;
        /**
         * Automatically rollback if instance refresh fails. Defaults to `false`. This option may only be set to `true` when specifying a `launchTemplate` or `mixedInstancesPolicy`.
         */
        autoRollback?: boolean;
        /**
         * Number of seconds to wait after a checkpoint. Defaults to `3600`.
         */
        checkpointDelay?: string;
        /**
         * List of percentages for each checkpoint. Values must be unique and in ascending order. To replace all instances, the final number must be `100`.
         */
        checkpointPercentages?: number[];
        /**
         * Number of seconds until a newly launched instance is configured and ready to use. Default behavior is to use the Auto Scaling Group's health check grace period.
         */
        instanceWarmup?: string;
        /**
         * Amount of capacity in the Auto Scaling group that can be in service and healthy, or pending, to support your workload when an instance refresh is in place, as a percentage of the desired capacity of the Auto Scaling group. Values must be between `100` and `200`, defaults to `100`.
         */
        maxHealthyPercentage?: number;
        /**
         * Amount of capacity in the Auto Scaling group that must remain healthy during an instance refresh to allow the operation to continue, as a percentage of the desired capacity of the Auto Scaling group. Defaults to `90`.
         */
        minHealthyPercentage?: number;
        /**
         * Behavior when encountering instances protected from scale in are found. Available behaviors are `Refresh`, `Ignore`, and `Wait`. Default is `Ignore`.
         */
        scaleInProtectedInstances?: string;
        /**
         * Replace instances that already have your desired configuration. Defaults to `false`.
         */
        skipMatching?: boolean;
        /**
         * Behavior when encountering instances in the `Standby` state in are found. Available behaviors are `Terminate`, `Ignore`, and `Wait`. Default is `Ignore`.
         */
        standbyInstances?: string;
    }
    interface GroupInstanceRefreshPreferencesAlarmSpecification {
        /**
         * List of Cloudwatch alarms. If any of these alarms goes into ALARM state, Instance Refresh is failed.
         */
        alarms?: string[];
    }
    interface GroupLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
         */
        version: string;
    }
    interface GroupMixedInstancesPolicy {
        /**
         * Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
         */
        instancesDistribution: outputs.autoscaling.GroupMixedInstancesPolicyInstancesDistribution;
        /**
         * Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
         */
        launchTemplate: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplate;
    }
    interface GroupMixedInstancesPolicyInstancesDistribution {
        onDemandAllocationStrategy: string;
        onDemandBaseCapacity: number;
        onDemandPercentageAboveBaseCapacity: number;
        spotAllocationStrategy: string;
        spotInstancePools: number;
        spotMaxPrice?: string;
    }
    interface GroupMixedInstancesPolicyLaunchTemplate {
        launchTemplateSpecification: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification;
        overrides: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverride[];
    }
    interface GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        launchTemplateId: string;
        launchTemplateName: string;
        version: string;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverride {
        instanceRequirements?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements;
        instanceType?: string;
        launchTemplateSpecification?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification;
        weightedCapacity?: string;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements {
        acceleratorCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount;
        acceleratorManufacturers?: string[];
        acceleratorNames?: string[];
        acceleratorTotalMemoryMib?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        acceleratorTypes?: string[];
        allowedInstanceTypes?: string[];
        bareMetal?: string;
        baselineEbsBandwidthMbps?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        burstablePerformance?: string;
        cpuManufacturers?: string[];
        excludedInstanceTypes?: string[];
        instanceGenerations?: string[];
        localStorage?: string;
        localStorageTypes?: string[];
        memoryGibPerVcpu?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu;
        memoryMib?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib;
        networkBandwidthGbps?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps;
        networkInterfaceCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount;
        onDemandMaxPricePercentageOverLowestPrice?: number;
        requireHibernateSupport?: boolean;
        spotMaxPricePercentageOverLowestPrice?: number;
        totalLocalStorageGb?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb;
        vcpuCount?: outputs.autoscaling.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount {
        max?: number;
        min?: number;
    }
    interface GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification {
        launchTemplateId: string;
        launchTemplateName: string;
        version: string;
    }
    interface GroupTag {
        /**
         * Key
         */
        key: string;
        /**
         * Enables propagation of the tag to
         * Amazon EC2 instances launched via this ASG
         *
         * To declare multiple tags, additional `tag` blocks can be specified.
         *
         * > **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so the provider does not attempt to remove them and so if the `minSize` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service.
         */
        propagateAtLaunch: boolean;
        /**
         * Value
         */
        value: string;
    }
    interface GroupTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Provides additional context for the value of Identifier.
         * The following lists the valid values:
         * `elb` if `identifier` is the name of a Classic Load Balancer.
         * `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
         * `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
         */
        type?: string;
    }
    interface GroupWarmPool {
        /**
         * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in. The default is to terminate instances in the Auto Scaling group when the group scales in.
         */
        instanceReusePolicy?: outputs.autoscaling.GroupWarmPoolInstanceReusePolicy;
        /**
         * Total maximum number of instances that are allowed to be in the warm pool or in any state except Terminated for the Auto Scaling group.
         */
        maxGroupPreparedCapacity?: number;
        /**
         * Minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
         */
        minSize?: number;
        /**
         * Sets the instance state to transition to after the lifecycle hooks finish. Valid values are: Stopped (default), Running or Hibernated.
         */
        poolState?: string;
    }
    interface GroupWarmPoolInstanceReusePolicy {
        /**
         * Whether instances in the Auto Scaling group can be returned to the warm pool on scale in.
         */
        reuseOnScaleIn?: boolean;
    }
    interface PolicyPredictiveScalingConfiguration {
        /**
         * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity of the Auto Scaling group. Valid values are `HonorMaxCapacity` or `IncreaseMaxCapacity`. Default is `HonorMaxCapacity`.
         */
        maxCapacityBreachBehavior?: string;
        /**
         * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity. Valid range is `0` to `100`. If set to `0`, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but not exceed forecast capacity.
         */
        maxCapacityBuffer?: string;
        /**
         * This structure includes the metrics and target utilization to use for predictive scaling.
         */
        metricSpecification: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecification;
        /**
         * Predictive scaling mode. Valid values are `ForecastAndScale` and `ForecastOnly`. Default is `ForecastOnly`.
         */
        mode?: string;
        /**
         * Amount of time, in seconds, by which the instance launch time can be advanced. Minimum is `0`.
         */
        schedulingBufferTime?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecification {
        /**
         * Customized capacity metric specification. The field is only valid when you use `customizedLoadMetricSpecification`
         */
        customizedCapacityMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification;
        /**
         * Customized load metric specification.
         */
        customizedLoadMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification;
        /**
         * Customized scaling metric specification.
         */
        customizedScalingMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification;
        /**
         * Predefined load metric specification.
         */
        predefinedLoadMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification;
        /**
         * Metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling metric and load metric to use.
         */
        predefinedMetricPairSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification;
        /**
         * Predefined scaling metric specification.
         */
        predefinedScalingMetricSpecification?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification {
        /**
         * List of up to 10 structures that defines custom capacity metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery[];
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification {
        /**
         * List of up to 10 structures that defines custom load metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery[];
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification {
        /**
         * List of up to 10 structures that defines custom scaling metric in predictive scaling policy
         */
        metricDataQueries: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery[];
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in predictive scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in predictive scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification {
        /**
         * Metric type. Valid values are `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`, or `ALBTargetGroupRequestCount`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group. You create the resource label by appending the final portion of the load balancer ARN and the final portion of the target group ARN into a single value, separated by a forward slash (/). Refer to [PredefinedMetricSpecification](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_PredefinedMetricSpecification.html) for more information.
         */
        resourceLabel?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification {
        /**
         * Which metrics to use. There are two different types of metrics for each metric type: one is a load metric and one is a scaling metric. For example, if the metric type is `ASGCPUUtilization`, the Auto Scaling group's total CPU metric is used as the load metric, and the average CPU metric is used for the scaling metric. Valid values are `ASGCPUUtilization`, `ASGNetworkIn`, `ASGNetworkOut`, or `ALBRequestCount`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group. You create the resource label by appending the final portion of the load balancer ARN and the final portion of the target group ARN into a single value, separated by a forward slash (/). Refer to [PredefinedMetricSpecification](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_PredefinedMetricSpecification.html) for more information.
         */
        resourceLabel?: string;
    }
    interface PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification {
        /**
         * Describes a scaling metric for a predictive scaling policy. Valid values are `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, or `ALBRequestCountPerTarget`.
         */
        predefinedMetricType: string;
        /**
         * Label that uniquely identifies a specific Application Load Balancer target group from which to determine the request count served by your Auto Scaling group. You create the resource label by appending the final portion of the load balancer ARN and the final portion of the target group ARN into a single value, separated by a forward slash (/). Refer to [PredefinedMetricSpecification](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_PredefinedMetricSpecification.html) for more information.
         */
        resourceLabel?: string;
    }
    interface PolicyStepAdjustment {
        /**
         * Lower bound for the
         * difference between the alarm threshold and the CloudWatch metric.
         * Without a value, AWS will treat this bound as negative infinity.
         */
        metricIntervalLowerBound?: string;
        /**
         * Upper bound for the
         * difference between the alarm threshold and the CloudWatch metric.
         * Without a value, AWS will treat this bound as positive infinity. The upper bound
         * must be greater than the lower bound.
         *
         * Notice the bounds are **relative** to the alarm threshold, meaning that the starting point is not 0%, but the alarm threshold. Check the official [docs](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-steps) for a detailed example.
         *
         * The following arguments are only available to "TargetTrackingScaling" type policies:
         */
        metricIntervalUpperBound?: string;
        /**
         * Number of members by which to
         * scale, when the adjustment bounds are breached. A positive value scales
         * up. A negative value scales down.
         */
        scalingAdjustment: number;
    }
    interface PolicyTargetTrackingConfiguration {
        /**
         * Customized metric. Conflicts with `predefinedMetricSpecification`.
         */
        customizedMetricSpecification?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecification;
        /**
         * Whether scale in by the target tracking policy is disabled.
         */
        disableScaleIn?: boolean;
        /**
         * Predefined metric. Conflicts with `customizedMetricSpecification`.
         */
        predefinedMetricSpecification?: outputs.autoscaling.PolicyTargetTrackingConfigurationPredefinedMetricSpecification;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        metricDimensions?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName?: string;
        /**
         * Metrics to include, as a metric data query.
         */
        metrics?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric[];
        /**
         * Namespace of the metric.
         */
        namespace?: string;
        /**
         * Statistic of the metric.
         */
        statistic?: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric {
        /**
         * Math expression used on the returned metric. You must specify either `expression` or `metricStat`, but not both.
         */
        expression?: string;
        /**
         * Short name for the metric used in target tracking scaling policy.
         */
        id: string;
        /**
         * Human-readable label for this metric or expression.
         */
        label?: string;
        /**
         * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either `expression` or `metricStat`, but not both.
         */
        metricStat?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat;
        /**
         * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
         */
        returnData?: boolean;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat {
        /**
         * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
         */
        metric: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric;
        /**
         * Statistic of the metrics to return.
         */
        stat: string;
        /**
         * Unit of the metrics to return.
         */
        unit?: string;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric {
        /**
         * Dimensions of the metric.
         */
        dimensions?: outputs.autoscaling.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
    }
    interface PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Value of the dimension.
         */
        value: string;
    }
    interface PolicyTargetTrackingConfigurationPredefinedMetricSpecification {
        /**
         * Metric type.
         */
        predefinedMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }
    interface TagTag {
        /**
         * Tag name.
         */
        key: string;
        /**
         * Whether to propagate the tags to instances launched by the ASG.
         */
        propagateAtLaunch: boolean;
        /**
         * Tag value.
         */
        value: string;
    }
    interface TrafficSourceAttachmentTrafficSource {
        /**
         * Identifies the traffic source. For Application Load Balancers, Gateway Load Balancers, Network Load Balancers, and VPC Lattice, this will be the Amazon Resource Name (ARN) for a target group in this account and Region. For Classic Load Balancers, this will be the name of the Classic Load Balancer in this account and Region.
         */
        identifier: string;
        /**
         * Provides additional context for the value of `identifier`.
         * The following lists the valid values:
         * `elb` if `identifier` is the name of a Classic Load Balancer.
         * `elbv2` if `identifier` is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.
         * `vpc-lattice` if `identifier` is the ARN of a VPC Lattice target group.
         */
        type: string;
    }
}
export declare namespace autoscalingplans {
    interface ScalingPlanApplicationSource {
        /**
         * ARN of a AWS CloudFormation stack.
         */
        cloudformationStackArn?: string;
        /**
         * Set of tags.
         */
        tagFilters?: outputs.autoscalingplans.ScalingPlanApplicationSourceTagFilter[];
    }
    interface ScalingPlanApplicationSourceTagFilter {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag values.
         */
        values?: string[];
    }
    interface ScalingPlanScalingInstruction {
        /**
         * Customized load metric to use for predictive scaling. You must specify either `customizedLoadMetricSpecification` or `predefinedLoadMetricSpecification` when configuring predictive scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedLoadMetricSpecification.html).
         */
        customizedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionCustomizedLoadMetricSpecification;
        /**
         * Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to `false`.
         */
        disableDynamicScaling?: boolean;
        /**
         * Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for `predictiveScalingMaxCapacityBehavior`.
         */
        maxCapacity: number;
        /**
         * Minimum capacity of the resource.
         */
        minCapacity: number;
        /**
         * Predefined load metric to use for predictive scaling. You must specify either `predefinedLoadMetricSpecification` or `customizedLoadMetricSpecification` when configuring predictive scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedLoadMetricSpecification.html).
         */
        predefinedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionPredefinedLoadMetricSpecification;
        /**
         * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource.
         * Valid values: `SetForecastCapacityToMaxCapacity`, `SetMaxCapacityAboveForecastCapacity`, `SetMaxCapacityToForecastCapacity`.
         */
        predictiveScalingMaxCapacityBehavior?: string;
        /**
         * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
         */
        predictiveScalingMaxCapacityBuffer: number;
        /**
         * Predictive scaling mode. Valid values: `ForecastAndScale`, `ForecastOnly`.
         */
        predictiveScalingMode?: string;
        /**
         * ID of the resource. This string consists of the resource type and unique identifier.
         */
        resourceId: string;
        /**
         * Scalable dimension associated with the resource. Valid values: `autoscaling:autoScalingGroup:DesiredCapacity`, `dynamodb:index:ReadCapacityUnits`, `dynamodb:index:WriteCapacityUnits`, `dynamodb:table:ReadCapacityUnits`, `dynamodb:table:WriteCapacityUnits`, `ecs:service:DesiredCount`, `ec2:spot-fleet-request:TargetCapacity`, `rds:cluster:ReadReplicaCount`.
         */
        scalableDimension: string;
        /**
         * Controls whether a resource's externally created scaling policies are kept or replaced. Valid values: `KeepExternalPolicies`, `ReplaceExternalPolicies`. Defaults to `KeepExternalPolicies`.
         */
        scalingPolicyUpdateBehavior?: string;
        /**
         * Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.
         */
        scheduledActionBufferTime?: number;
        /**
         * Namespace of the AWS service. Valid values: `autoscaling`, `dynamodb`, `ecs`, `ec2`, `rds`.
         */
        serviceNamespace: string;
        /**
         * Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_TargetTrackingConfiguration.html).
         */
        targetTrackingConfigurations: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfiguration[];
    }
    interface ScalingPlanScalingInstructionCustomizedLoadMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        dimensions?: {
            [key: string]: string;
        };
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
        /**
         * Statistic of the metric. Currently, the value must always be `Sum`.
         */
        statistic: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }
    interface ScalingPlanScalingInstructionPredefinedLoadMetricSpecification {
        /**
         * Metric type. Valid values: `ALBTargetGroupRequestCount`, `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`.
         */
        predefinedLoadMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }
    interface ScalingPlanScalingInstructionTargetTrackingConfiguration {
        /**
         * Customized metric. You can specify either `customizedScalingMetricSpecification` or `predefinedScalingMetricSpecification`.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedScalingMetricSpecification.html).
         */
        customizedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification;
        /**
         * Boolean indicating whether scale in by the target tracking scaling policy is disabled. Defaults to `false`.
         */
        disableScaleIn?: boolean;
        /**
         * Estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics.
         * This value is used only if the resource is an Auto Scaling group.
         */
        estimatedInstanceWarmup?: number;
        /**
         * Predefined metric. You can specify either `predefinedScalingMetricSpecification` or `customizedScalingMetricSpecification`.
         * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedScalingMetricSpecification.html).
         */
        predefinedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification;
        /**
         * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
         * This value is not used if the scalable resource is an Auto Scaling group.
         */
        scaleInCooldown?: number;
        /**
         * Amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
         * This value is not used if the scalable resource is an Auto Scaling group.
         */
        scaleOutCooldown?: number;
        /**
         * Target value for the metric.
         */
        targetValue: number;
    }
    interface ScalingPlanScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification {
        /**
         * Dimensions of the metric.
         */
        dimensions?: {
            [key: string]: string;
        };
        /**
         * Name of the metric.
         */
        metricName: string;
        /**
         * Namespace of the metric.
         */
        namespace: string;
        /**
         * Statistic of the metric. Valid values: `Average`, `Maximum`, `Minimum`, `SampleCount`, `Sum`.
         */
        statistic: string;
        /**
         * Unit of the metric.
         */
        unit?: string;
    }
    interface ScalingPlanScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification {
        /**
         * Metric type. Valid values: `ALBRequestCountPerTarget`, `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, `DynamoDBReadCapacityUtilization`, `DynamoDBWriteCapacityUtilization`, `ECSServiceAverageCPUUtilization`, `ECSServiceAverageMemoryUtilization`, `EC2SpotFleetRequestAverageCPUUtilization`, `EC2SpotFleetRequestAverageNetworkIn`, `EC2SpotFleetRequestAverageNetworkOut`, `RDSReaderAverageCPUUtilization`, `RDSReaderAverageDatabaseConnections`.
         */
        predefinedScalingMetricType: string;
        /**
         * Identifies the resource associated with the metric type.
         */
        resourceLabel?: string;
    }
}
export declare namespace backup {
    interface FrameworkControl {
        /**
         * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
         */
        inputParameters?: outputs.backup.FrameworkControlInputParameter[];
        /**
         * The name of a control. This name is between 1 and 256 characters.
         */
        name: string;
        /**
         * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
         */
        scope?: outputs.backup.FrameworkControlScope;
    }
    interface FrameworkControlInputParameter {
        /**
         * The name of a parameter, for example, BackupPlanFrequency.
         */
        name?: string;
        /**
         * The value of parameter, for example, hourly.
         */
        value?: string;
    }
    interface FrameworkControlScope {
        /**
         * The ID of the only AWS resource that you want your control scope to contain. Minimum number of 1 item. Maximum number of 100 items.
         */
        complianceResourceIds?: string[];
        /**
         * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
         */
        complianceResourceTypes?: string[];
        /**
         * The tag key-value pair applied to those AWS resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface GetFrameworkControl {
        /**
         * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
         */
        inputParameters: outputs.backup.GetFrameworkControlInputParameter[];
        /**
         * Backup framework name.
         */
        name: string;
        /**
         * Scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
         */
        scopes: outputs.backup.GetFrameworkControlScope[];
    }
    interface GetFrameworkControlInputParameter {
        /**
         * Backup framework name.
         */
        name: string;
        /**
         * Value of parameter, for example, hourly.
         */
        value: string;
    }
    interface GetFrameworkControlScope {
        /**
         * The ID of the only AWS resource that you want your control scope to contain.
         */
        complianceResourceIds: string[];
        /**
         * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
         */
        complianceResourceTypes: string[];
        /**
         * Tag key-value pair applied to those AWS resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetReportPlanReportDeliveryChannel {
        /**
         * List of the format of your reports: CSV, JSON, or both.
         */
        formats: string[];
        /**
         * Unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: string;
        /**
         * Prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name.
         */
        s3KeyPrefix: string;
    }
    interface GetReportPlanReportSetting {
        /**
         * (Optional) Specifies the list of accounts a report covers.
         */
        accounts: string[];
        /**
         * ARNs of the frameworks a report covers.
         */
        frameworkArns: string[];
        /**
         * Specifies the number of frameworks a report covers.
         */
        numberOfFrameworks: number;
        /**
         * (Optional) Specifies the list of Organizational Units a report covers.
         */
        organizationUnits: string[];
        /**
         * (Optional) Specifies the list of regions a report covers.
         */
        regions: string[];
        /**
         * Identifies the report template for the report. Reports are built using a report template.
         */
        reportTemplate: string;
    }
    interface PlanAdvancedBackupSetting {
        /**
         * Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Set to `{ WindowsVSS = "enabled" }` to enable Windows VSS backup option and create a VSS Windows backup.
         */
        backupOptions: {
            [key: string]: string;
        };
        /**
         * The type of AWS resource to be backed up. For VSS Windows backups, the only supported resource type is Amazon EC2. Valid values: `EC2`.
         */
        resourceType: string;
    }
    interface PlanRule {
        /**
         * The amount of time in minutes AWS Backup attempts a backup before canceling the job and returning an error.
         */
        completionWindow?: number;
        /**
         * Configuration block(s) with copy operation settings. Detailed below.
         */
        copyActions?: outputs.backup.PlanRuleCopyAction[];
        /**
         * Enable continuous backups for supported resources.
         */
        enableContinuousBackup?: boolean;
        /**
         * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
         */
        lifecycle?: outputs.backup.PlanRuleLifecycle;
        /**
         * Metadata that you can assign to help organize the resources that you create.
         */
        recoveryPointTags?: {
            [key: string]: string;
        };
        /**
         * An display name for a backup rule.
         */
        ruleName: string;
        /**
         * A CRON expression specifying when AWS Backup initiates a backup job.
         */
        schedule?: string;
        /**
         * The amount of time in minutes before beginning a backup.
         */
        startWindow?: number;
        /**
         * The name of a logical container where backups are stored.
         */
        targetVaultName: string;
    }
    interface PlanRuleCopyAction {
        /**
         * An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
         */
        destinationVaultArn: string;
        /**
         * The lifecycle defines when a protected resource is copied over to a backup vault and when it expires.  Fields documented above.
         */
        lifecycle?: outputs.backup.PlanRuleCopyActionLifecycle;
    }
    interface PlanRuleCopyActionLifecycle {
        /**
         * Specifies the number of days after creation that a recovery point is moved to cold storage.
         */
        coldStorageAfter?: number;
        /**
         * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than `coldStorageAfter`.
         */
        deleteAfter?: number;
        /**
         * This setting will instruct your backup plan to transition supported resources to archive (cold) storage tier in accordance with your lifecycle settings.
         */
        optInToArchiveForSupportedResources: boolean;
    }
    interface PlanRuleLifecycle {
        /**
         * Specifies the number of days after creation that a recovery point is moved to cold storage.
         */
        coldStorageAfter?: number;
        /**
         * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than `coldStorageAfter`.
         */
        deleteAfter?: number;
        /**
         * This setting will instruct your backup plan to transition supported resources to archive (cold) storage tier in accordance with your lifecycle settings.
         */
        optInToArchiveForSupportedResources: boolean;
    }
    interface ReportPlanReportDeliveryChannel {
        /**
         * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
         */
        formats?: string[];
        /**
         * The unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: string;
        /**
         * The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
         */
        s3KeyPrefix?: string;
    }
    interface ReportPlanReportSetting {
        /**
         * Specifies the list of accounts a report covers.
         */
        accounts?: string[];
        /**
         * Specifies the Amazon Resource Names (ARNs) of the frameworks a report covers.
         */
        frameworkArns?: string[];
        /**
         * Specifies the number of frameworks a report covers.
         */
        numberOfFrameworks?: number;
        /**
         * Specifies the list of Organizational Units a report covers.
         */
        organizationUnits?: string[];
        /**
         * Specifies the list of regions a report covers.
         */
        regions?: string[];
        /**
         * Identifies the report template for the report. Reports are built using a report template. The report templates are: `RESOURCE_COMPLIANCE_REPORT` | `CONTROL_COMPLIANCE_REPORT` | `BACKUP_JOB_REPORT` | `COPY_JOB_REPORT` | `RESTORE_JOB_REPORT`.
         */
        reportTemplate: string;
    }
    interface SelectionCondition {
        stringEquals?: outputs.backup.SelectionConditionStringEqual[];
        stringLikes?: outputs.backup.SelectionConditionStringLike[];
        stringNotEquals?: outputs.backup.SelectionConditionStringNotEqual[];
        stringNotLikes?: outputs.backup.SelectionConditionStringNotLike[];
    }
    interface SelectionConditionStringEqual {
        key: string;
        value: string;
    }
    interface SelectionConditionStringLike {
        key: string;
        value: string;
    }
    interface SelectionConditionStringNotEqual {
        key: string;
        value: string;
    }
    interface SelectionConditionStringNotLike {
        key: string;
        value: string;
    }
    interface SelectionSelectionTag {
        /**
         * The key in a key-value pair.
         */
        key: string;
        /**
         * An operation, such as `StringEquals`, that is applied to a key-value pair used to filter resources in a selection.
         */
        type: string;
        /**
         * The value in a key-value pair.
         */
        value: string;
    }
}
export declare namespace batch {
    interface ComputeEnvironmentComputeResources {
        /**
         * The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-allocationStrategy). Defaults to `BEST_FIT`. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        allocationStrategy?: string;
        /**
         * Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20% (`20`), then the Spot price must be below 20% of the current On-Demand price for that EC2 instance. If you leave this field empty, the default value is 100% of the On-Demand price. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        bidPercentage?: number;
        /**
         * The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        desiredVcpus: number;
        /**
         * Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment. If Ec2Configuration isn't specified, the default is ECS_AL2. This parameter isn't applicable to jobs that are running on Fargate resources, and shouldn't be specified.
         */
        ec2Configurations: outputs.batch.ComputeEnvironmentComputeResourcesEc2Configuration[];
        /**
         * The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        ec2KeyPair?: string;
        /**
         * The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use `ec2Configuration` `imageIdOverride` instead)
         */
        imageId?: string;
        /**
         * The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        instanceRole?: string;
        /**
         * A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        instanceTypes?: string[];
        /**
         * The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        launchTemplate?: outputs.batch.ComputeEnvironmentComputeResourcesLaunchTemplate;
        /**
         * The maximum number of EC2 vCPUs that an environment can reach.
         */
        maxVcpus: number;
        /**
         * The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        minVcpus?: number;
        /**
         * The Amazon EC2 placement group to associate with your compute resources.
         */
        placementGroup?: string;
        /**
         * A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
         */
        securityGroupIds?: string[];
        /**
         * The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        spotIamFleetRole?: string;
        /**
         * A list of VPC subnets into which the compute resources are launched.
         */
        subnets: string[];
        /**
         * Key-value pair tags to be applied to resources that are launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.
         */
        type: string;
    }
    interface ComputeEnvironmentComputeResourcesEc2Configuration {
        /**
         * The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `imageId` argument in the `computeResources` block.
         */
        imageIdOverride: string;
        /**
         * The image type to match with the instance type to select an AMI. If the `imageIdOverride` parameter isn't specified, then a recent [Amazon ECS-optimized Amazon Linux 2 AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html#al2ami) (`ECS_AL2`) is used.
         */
        imageType?: string;
    }
    interface ComputeEnvironmentComputeResourcesLaunchTemplate {
        /**
         * ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
         */
        launchTemplateId?: string;
        /**
         * Name of the launch template.
         */
        launchTemplateName?: string;
        /**
         * The version number of the launch template. Default: The default version of the launch template.
         */
        version: string;
    }
    interface ComputeEnvironmentEksConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the Amazon EKS cluster.
         */
        eksClusterArn: string;
        /**
         * The namespace of the Amazon EKS cluster. AWS Batch manages pods in this namespace.
         */
        kubernetesNamespace: string;
    }
    interface ComputeEnvironmentUpdatePolicy {
        /**
         * Specifies the job timeout (in minutes) when the compute environment infrastructure is updated.
         */
        jobExecutionTimeoutMinutes: number;
        /**
         * Specifies whether jobs are automatically terminated when the computer environment infrastructure is updated.
         */
        terminateJobsOnUpdate: boolean;
    }
    interface GetComputeEnvironmentUpdatePolicy {
        jobExecutionTimeoutMinutes: number;
        terminateJobsOnUpdate: boolean;
    }
    interface GetJobDefinitionEksProperty {
        /**
         * The properties for the Kubernetes pod resources of a job.
         */
        podProperties: any[];
    }
    interface GetJobDefinitionNodeProperty {
        /**
         * Specifies the node index for the main node of a multi-node parallel job. This node index value must be fewer than the number of nodes.
         */
        mainNode: number;
        /**
         * A list of node ranges and their properties that are associated with a multi-node parallel job.
         */
        nodeRangeProperties: any[];
        /**
         * The number of nodes that are associated with a multi-node parallel job.
         */
        numNodes: number;
    }
    interface GetJobDefinitionRetryStrategy {
        /**
         * The number of times to move a job to the RUNNABLE status.
         */
        attempts: number;
        /**
         * Array of up to 5 objects that specify the conditions where jobs are retried or failed.
         */
        evaluateOnExits: any[];
    }
    interface GetJobDefinitionTimeout {
        /**
         * The job timeout time (in seconds) that's measured from the job attempt's startedAt timestamp.
         */
        attemptDurationSeconds: number;
    }
    interface GetJobQueueComputeEnvironmentOrder {
        computeEnvironment: string;
        order: number;
    }
    interface GetSchedulingPolicyFairSharePolicy {
        /**
         * Value used to reserve some of the available maximum vCPU for fair share identifiers that have not yet been used. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html).
         */
        computeReservation: number;
        shareDecaySeconds: number;
        /**
         * One or more share distribution blocks which define the weights for the fair share identifiers for the fair share policy. For more information, see [FairsharePolicy](https://docs.aws.amazon.com/batch/latest/APIReference/API_FairsharePolicy.html). The `shareDistribution` block is documented below.
         */
        shareDistributions: outputs.batch.GetSchedulingPolicyFairSharePolicyShareDistribution[];
    }
    interface GetSchedulingPolicyFairSharePolicyShareDistribution {
        /**
         * Fair share identifier or fair share identifier prefix. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        shareIdentifier: string;
        /**
         * Weight factor for the fair share identifier. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        weightFactor: number;
    }
    interface JobDefinitionEksProperties {
        /**
         * The properties for the Kubernetes pod resources of a job. See `podProperties` below.
         */
        podProperties: outputs.batch.JobDefinitionEksPropertiesPodProperties;
    }
    interface JobDefinitionEksPropertiesPodProperties {
        /**
         * The properties of the container that's used on the Amazon EKS pod. See containers below.
         */
        containers: outputs.batch.JobDefinitionEksPropertiesPodPropertiesContainers;
        /**
         * The DNS policy for the pod. The default value is `ClusterFirst`. If the `hostNetwork` argument is not specified, the default is `ClusterFirstWithHostNet`. `ClusterFirst` indicates that any DNS query that does not match the configured cluster domain suffix is forwarded to the upstream nameserver inherited from the node. For more information, see Pod's DNS policy in the Kubernetes documentation.
         */
        dnsPolicy?: string;
        /**
         * Indicates if the pod uses the hosts' network IP address. The default value is `true`. Setting this to `false` enables the Kubernetes pod networking model. Most AWS Batch workloads are egress-only and don't require the overhead of IP allocation for each pod for incoming connections.
         */
        hostNetwork?: boolean;
        /**
         * Metadata about the Kubernetes pod.
         */
        metadata?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesMetadata;
        /**
         * The name of the service account that's used to run the pod.
         */
        serviceAccountName?: string;
        /**
         * Specifies the volumes for a job definition that uses Amazon EKS resources. AWS Batch supports emptyDir, hostPath, and secret volume types.
         */
        volumes?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesVolume[];
    }
    interface JobDefinitionEksPropertiesPodPropertiesContainers {
        /**
         * An array of arguments to the entrypoint. If this isn't specified, the CMD of the container image is used. This corresponds to the args member in the Entrypoint portion of the Pod in Kubernetes. Environment variable references are expanded using the container's environment.
         */
        args?: string[];
        /**
         * The entrypoint for the container. This isn't run within a shell. If this isn't specified, the ENTRYPOINT of the container image is used. Environment variable references are expanded using the container's environment.
         */
        commands?: string[];
        /**
         * The environment variables to pass to a container. See EKS Environment below.
         */
        envs?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesContainersEnv[];
        /**
         * The Docker image used to start the container.
         */
        image: string;
        /**
         * The image pull policy for the container. Supported values are `Always`, `IfNotPresent`, and `Never`.
         */
        imagePullPolicy?: string;
        /**
         * The name of the container. If the name isn't specified, the default name "Default" is used. Each container in a pod must have a unique name.
         */
        name?: string;
        /**
         * The type and amount of resources to assign to a container. The supported resources include `memory`, `cpu`, and `nvidia.com/gpu`.
         */
        resources?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesContainersResources;
        /**
         * The security context for a job.
         */
        securityContext?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesContainersSecurityContext;
        /**
         * The volume mounts for the container.
         */
        volumeMounts?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesContainersVolumeMount[];
    }
    interface JobDefinitionEksPropertiesPodPropertiesContainersEnv {
        /**
         * Specifies the name of the job definition.
         */
        name: string;
        value: string;
    }
    interface JobDefinitionEksPropertiesPodPropertiesContainersResources {
        limits?: {
            [key: string]: string;
        };
        requests?: {
            [key: string]: string;
        };
    }
    interface JobDefinitionEksPropertiesPodPropertiesContainersSecurityContext {
        privileged?: boolean;
        readOnlyRootFileSystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
    }
    interface JobDefinitionEksPropertiesPodPropertiesContainersVolumeMount {
        mountPath: string;
        /**
         * Specifies the name of the job definition.
         */
        name: string;
        readOnly?: boolean;
    }
    interface JobDefinitionEksPropertiesPodPropertiesMetadata {
        labels?: {
            [key: string]: string;
        };
    }
    interface JobDefinitionEksPropertiesPodPropertiesVolume {
        emptyDir?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesVolumeEmptyDir;
        hostPath?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesVolumeHostPath;
        /**
         * Specifies the name of the job definition.
         */
        name?: string;
        secret?: outputs.batch.JobDefinitionEksPropertiesPodPropertiesVolumeSecret;
    }
    interface JobDefinitionEksPropertiesPodPropertiesVolumeEmptyDir {
        medium?: string;
        sizeLimit: string;
    }
    interface JobDefinitionEksPropertiesPodPropertiesVolumeHostPath {
        path: string;
    }
    interface JobDefinitionEksPropertiesPodPropertiesVolumeSecret {
        optional?: boolean;
        secretName: string;
    }
    interface JobDefinitionRetryStrategy {
        /**
         * The number of times to move a job to the `RUNNABLE` status. You may specify between `1` and `10` attempts.
         */
        attempts?: number;
        /**
         * The evaluate on exit conditions under which the job should be retried or failed. If this parameter is specified, then the `attempts` parameter must also be specified. You may specify up to 5 configuration blocks.
         */
        evaluateOnExits?: outputs.batch.JobDefinitionRetryStrategyEvaluateOnExit[];
    }
    interface JobDefinitionRetryStrategyEvaluateOnExit {
        /**
         * Specifies the action to take if all of the specified conditions are met. The values are not case sensitive. Valid values: `retry`, `exit`.
         */
        action: string;
        /**
         * A glob pattern to match against the decimal representation of the exit code returned for a job.
         */
        onExitCode?: string;
        /**
         * A glob pattern to match against the reason returned for a job.
         */
        onReason?: string;
        /**
         * A glob pattern to match against the status reason returned for a job.
         */
        onStatusReason?: string;
    }
    interface JobDefinitionTimeout {
        /**
         * The time duration in seconds after which AWS Batch terminates your jobs if they have not finished. The minimum value for the timeout is `60` seconds.
         */
        attemptDurationSeconds?: number;
    }
    interface JobQueueComputeEnvironmentOrder {
        /**
         * The Amazon Resource Name (ARN) of the compute environment.
         */
        computeEnvironment: string;
        /**
         * The order of the compute environment. Compute environments are tried in ascending order. For example, if two compute environments are associated with a job queue, the compute environment with a lower order integer value is tried for job placement first.
         */
        order: number;
    }
    interface JobQueueTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface SchedulingPolicyFairSharePolicy {
        computeReservation?: number;
        shareDecaySeconds?: number;
        shareDistributions?: outputs.batch.SchedulingPolicyFairSharePolicyShareDistribution[];
    }
    interface SchedulingPolicyFairSharePolicyShareDistribution {
        /**
         * A fair share identifier or fair share identifier prefix. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        shareIdentifier: string;
        /**
         * The weight factor for the fair share identifier. For more information, see [ShareAttributes](https://docs.aws.amazon.com/batch/latest/APIReference/API_ShareAttributes.html).
         */
        weightFactor?: number;
    }
}
export declare namespace bcmdata {
    interface ExportExport {
        /**
         * Data query for this specific data export. See the `dataQuery` argument reference below.
         */
        dataQueries?: outputs.bcmdata.ExportExportDataQuery[];
        /**
         * Description for this specific data export.
         */
        description?: string;
        /**
         * Destination configuration for this specific data export. See the `destinationConfigurations` argument reference below.
         */
        destinationConfigurations?: outputs.bcmdata.ExportExportDestinationConfiguration[];
        /**
         * Amazon Resource Name (ARN) for this export.
         */
        exportArn: string;
        /**
         * Name of this specific data export.
         */
        name: string;
        /**
         * Cadence for Amazon Web Services to update the export in your S3 bucket. See the `refreshCadence` argument reference below.
         */
        refreshCadences?: outputs.bcmdata.ExportExportRefreshCadence[];
    }
    interface ExportExportDataQuery {
        /**
         * Query statement.
         */
        queryStatement: string;
        /**
         * Table configuration.
         */
        tableConfigurations?: {
            [key: string]: {
                [key: string]: any;
            };
        };
    }
    interface ExportExportDestinationConfiguration {
        /**
         * Object that describes the destination of the data exports file. See the `s3Destination` argument reference below.
         */
        s3Destinations?: outputs.bcmdata.ExportExportDestinationConfigurationS3Destination[];
    }
    interface ExportExportDestinationConfigurationS3Destination {
        /**
         * Name of the Amazon S3 bucket used as the destination of a data export file.
         */
        s3Bucket: string;
        /**
         * Output configuration for the data export. See the `s3OutputConfigurations` argument reference below.
         */
        s3OutputConfigurations?: outputs.bcmdata.ExportExportDestinationConfigurationS3DestinationS3OutputConfiguration[];
        /**
         * S3 path prefix you want prepended to the name of your data export.
         */
        s3Prefix: string;
        /**
         * S3 bucket region.
         */
        s3Region: string;
    }
    interface ExportExportDestinationConfigurationS3DestinationS3OutputConfiguration {
        /**
         * Compression type for the data export. Valid values `GZIP`, `PARQUET`.
         */
        compression: string;
        /**
         * File format for the data export. Valid values `TEXT_OR_CSV` or `PARQUET`.
         */
        format: string;
        /**
         * Output type for the data export. Valid value `CUSTOM`.
         */
        outputType: string;
        /**
         * The rule to follow when generating a version of the data export file. You have the choice to overwrite the previous version or to be delivered in addition to the previous versions. Overwriting exports can save on Amazon S3 storage costs. Creating new export versions allows you to track the changes in cost and usage data over time. Valid values `CREATE_NEW_REPORT` or `OVERWRITE_REPORT`.
         */
        overwrite: string;
    }
    interface ExportExportRefreshCadence {
        /**
         * Frequency that data exports are updated. The export refreshes each time the source data updates, up to three times daily. Valid values `SYNCHRONOUS`.
         */
        frequency: string;
    }
    interface ExportTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
}
export declare namespace bedrock {
    interface AgentAgentActionGroupActionGroupExecutor {
        /**
         * ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
         */
        lambda?: string;
    }
    interface AgentAgentActionGroupApiSchema {
        /**
         * JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
         */
        payload?: string;
        /**
         * Details about the S3 object containing the OpenAPI schema for the action group. See `s3` block for details.
         */
        s3?: outputs.bedrock.AgentAgentActionGroupApiSchemaS3;
    }
    interface AgentAgentActionGroupApiSchemaS3 {
        /**
         * Name of the S3 bucket.
         */
        s3BucketName?: string;
        /**
         * S3 object key containing the resource.
         */
        s3ObjectKey?: string;
    }
    interface AgentAgentAliasRoutingConfiguration {
        /**
         * Version of the agent with which the alias is associated.
         */
        agentVersion: string;
    }
    interface AgentAgentAliasTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface AgentAgentPromptOverrideConfiguration {
        /**
         * ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `promptConfigurations` block must contain a `parserMode` value that is set to `OVERRIDDEN`.
         */
        overrideLambda: string;
        /**
         * Configurations to override a prompt template in one part of an agent sequence. See `promptConfigurations` block for details.
         */
        promptConfigurations: any[];
    }
    interface AgentAgentTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface AgentDataSourceDataSourceConfiguration {
        /**
         * Details about the configuration of the S3 object containing the data source. See `s3DataSourceConfiguration` block for details.
         */
        s3Configuration?: outputs.bedrock.AgentDataSourceDataSourceConfigurationS3Configuration;
        /**
         * Type of storage for the data source. Valid values: `S3`.
         */
        type: string;
    }
    interface AgentDataSourceDataSourceConfigurationS3Configuration {
        bucketArn: string;
        bucketOwnerAccountId?: string;
        inclusionPrefixes?: string[];
    }
    interface AgentDataSourceServerSideEncryptionConfiguration {
        /**
         * ARN of the AWS KMS key used to encrypt the resource.
         */
        kmsKeyArn?: string;
    }
    interface AgentDataSourceTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface AgentDataSourceVectorIngestionConfiguration {
        /**
         * Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunkingConfiguration` block for details.
         */
        chunkingConfiguration?: outputs.bedrock.AgentDataSourceVectorIngestionConfigurationChunkingConfiguration;
    }
    interface AgentDataSourceVectorIngestionConfigurationChunkingConfiguration {
        /**
         * Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIX_SIZE`, `NONE`.
         */
        chunkingStrategy: string;
        /**
         * Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as `NONE`, exclude this field. See `fixedSizeChunkingConfiguration` for details.
         */
        fixedSizeChunkingConfiguration?: outputs.bedrock.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration;
    }
    interface AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration {
        /**
         * Maximum number of tokens to include in a chunk.
         */
        maxTokens: number;
        /**
         * Percentage of overlap between adjacent chunks of a data source.
         */
        overlapPercentage: number;
    }
    interface AgentKnowledgeBaseKnowledgeBaseConfiguration {
        /**
         * Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
         */
        type: string;
        /**
         * Details about the embeddings model that'sused to convert the data source. See `vectorKnowledgeBaseConfiguration` block for details.
         */
        vectorKnowledgeBaseConfiguration?: outputs.bedrock.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration;
    }
    interface AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration {
        /**
         * ARN of the model used to create vector embeddings for the knowledge base.
         */
        embeddingModelArn: string;
    }
    interface AgentKnowledgeBaseStorageConfiguration {
        /**
         * The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearchServerlessConfiguration` block for details.
         */
        opensearchServerlessConfiguration?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration;
        /**
         * The storage configuration of the knowledge base in Pinecone. See `pineconeConfiguration` block for details.
         */
        pineconeConfiguration?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationPineconeConfiguration;
        /**
         * Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rdsConfiguration` block for details.
         */
        rdsConfiguration?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationRdsConfiguration;
        /**
         * The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redisEnterpriseCloudConfiguration` block for details.
         */
        redisEnterpriseCloudConfiguration?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration;
        /**
         * Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
         */
        type: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration {
        /**
         * ARN of the OpenSearch Service vector store.
         */
        collectionArn: string;
        /**
         * The names of the fields to which to map information about the vector store. This block supports the following arguments:
         */
        fieldMapping?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping;
        /**
         * Name of the vector store.
         */
        vectorIndexName: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping {
        /**
         * Name of the field in which Amazon Bedrock stores metadata about the vector store.
         */
        metadataField?: string;
        /**
         * Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
         */
        textField?: string;
        /**
         * Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
         */
        vectorField?: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationPineconeConfiguration {
        /**
         * Endpoint URL for your index management page.
         */
        connectionString: string;
        /**
         * ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
         */
        credentialsSecretArn: string;
        /**
         * The names of the fields to which to map information about the vector store. This block supports the following arguments:
         */
        fieldMapping?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping;
        /**
         * Namespace to be used to write new data to your database.
         */
        namespace?: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping {
        /**
         * Name of the field in which Amazon Bedrock stores metadata about the vector store.
         */
        metadataField?: string;
        /**
         * Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
         */
        textField?: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationRdsConfiguration {
        /**
         * ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
         */
        credentialsSecretArn: string;
        /**
         * Name of your Amazon RDS database.
         */
        databaseName: string;
        /**
         * Names of the fields to which to map information about the vector store. This block supports the following arguments:
         */
        fieldMapping?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping;
        /**
         * ARN of the vector store.
         */
        resourceArn: string;
        /**
         * Name of the table in the database.
         */
        tableName: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping {
        /**
         * Name of the field in which Amazon Bedrock stores metadata about the vector store.
         */
        metadataField: string;
        /**
         * Name of the field in which Amazon Bedrock stores the ID for each entry.
         */
        primaryKeyField: string;
        /**
         * Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
         */
        textField: string;
        /**
         * Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
         */
        vectorField: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration {
        /**
         * ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
         */
        credentialsSecretArn: string;
        /**
         * Endpoint URL of the Redis Enterprise Cloud database.
         */
        endpoint: string;
        /**
         * The names of the fields to which to map information about the vector store. This block supports the following arguments:
         */
        fieldMapping?: outputs.bedrock.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping;
        /**
         * Name of the vector index.
         */
        vectorIndexName: string;
    }
    interface AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping {
        /**
         * Name of the field in which Amazon Bedrock stores metadata about the vector store.
         */
        metadataField?: string;
        /**
         * Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
         */
        textField?: string;
        /**
         * Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
         */
        vectorField?: string;
    }
    interface AgentKnowledgeBaseTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface CustomModelOutputDataConfig {
        /**
         * The S3 URI where the output data is stored.
         */
        s3Uri: string;
    }
    interface CustomModelTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface CustomModelTrainingDataConfig {
        /**
         * The S3 URI where the training data is stored.
         */
        s3Uri: string;
    }
    interface CustomModelTrainingMetric {
        /**
         * Loss metric associated with the customization job.
         */
        trainingLoss: number;
    }
    interface CustomModelValidationDataConfig {
        /**
         * Information about the validators.
         */
        validators?: outputs.bedrock.CustomModelValidationDataConfigValidator[];
    }
    interface CustomModelValidationDataConfigValidator {
        /**
         * The S3 URI where the validation data is stored.
         */
        s3Uri: string;
    }
    interface CustomModelValidationMetric {
        /**
         * The validation loss associated with the validator.
         */
        validationLoss: number;
    }
    interface CustomModelVpcConfig {
        /**
         * VPC configuration security group IDs.
         */
        securityGroupIds: string[];
        /**
         * VPC configuration subnets.
         */
        subnetIds: string[];
    }
    interface GetCustomModelOutputDataConfig {
        /**
         * The S3 URI where the validation data is stored..
         */
        s3Uri: string;
    }
    interface GetCustomModelTrainingDataConfig {
        /**
         * The S3 URI where the validation data is stored..
         */
        s3Uri: string;
    }
    interface GetCustomModelTrainingMetric {
        /**
         * Loss metric associated with the customization job.
         */
        trainingLoss: number;
    }
    interface GetCustomModelValidationDataConfig {
        /**
         * Information about the validators.
         */
        validators: any[];
    }
    interface GetCustomModelValidationMetric {
        /**
         * The validation loss associated with the validator.
         */
        validationLoss: number;
    }
    interface GetCustomModelsModelSummary {
        /**
         * Creation time of the model.
         */
        creationTime: string;
        /**
         * The ARN of the custom model.
         */
        modelArn: string;
        /**
         * The name of the custom model.
         */
        modelName: string;
    }
    interface ProvisionedModelThroughputTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
    }
}
export declare namespace bedrockfoundation {
    interface GetModelsModelSummary {
        /**
         * Customizations that the model supports.
         */
        customizationsSupporteds: any[];
        /**
         * Inference types that the model supports.
         */
        inferenceTypesSupporteds: any[];
        /**
         * Input modalities that the model supports.
         */
        inputModalities: any[];
        /**
         * Model ARN.
         */
        modelArn: string;
        /**
         * Model identifier.
         */
        modelId: string;
        /**
         * Model name.
         */
        modelName: string;
        /**
         * Output modalities that the model supports.
         */
        outputModalities: any[];
        /**
         * Model provider name.
         */
        providerName: string;
        /**
         * Indicates whether the model supports streaming.
         */
        responseStreamingSupported: boolean;
    }
}
export declare namespace bedrockmodel {
    interface InvocationLoggingConfigurationLoggingConfig {
        /**
         * CloudWatch logging configuration.
         */
        cloudwatchConfig?: outputs.bedrockmodel.InvocationLoggingConfigurationLoggingConfigCloudwatchConfig;
        /**
         * Set to include embeddings data in the log delivery.
         */
        embeddingDataDeliveryEnabled: boolean;
        /**
         * Set to include image data in the log delivery.
         */
        imageDataDeliveryEnabled: boolean;
        /**
         * S3 configuration for storing log data.
         */
        s3Config?: outputs.bedrockmodel.InvocationLoggingConfigurationLoggingConfigS3Config;
        /**
         * Set to include text data in the log delivery.
         */
        textDataDeliveryEnabled: boolean;
    }
    interface InvocationLoggingConfigurationLoggingConfigCloudwatchConfig {
        /**
         * S3 configuration for delivering a large amount of data.
         */
        largeDataDeliveryS3Config?: outputs.bedrockmodel.InvocationLoggingConfigurationLoggingConfigCloudwatchConfigLargeDataDeliveryS3Config;
        /**
         * Log group name.
         */
        logGroupName?: string;
        /**
         * The role ARN.
         */
        roleArn?: string;
    }
    interface InvocationLoggingConfigurationLoggingConfigCloudwatchConfigLargeDataDeliveryS3Config {
        /**
         * S3 bucket name.
         */
        bucketName?: string;
        /**
         * S3 prefix.
         */
        keyPrefix?: string;
    }
    interface InvocationLoggingConfigurationLoggingConfigS3Config {
        /**
         * S3 bucket name.
         */
        bucketName?: string;
        /**
         * S3 prefix.
         */
        keyPrefix?: string;
    }
}
export declare namespace budgets {
    interface BudgetActionActionThreshold {
        /**
         * The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
         */
        actionThresholdType: string;
        /**
         * The threshold of a notification.
         */
        actionThresholdValue: number;
    }
    interface BudgetActionDefinition {
        /**
         * The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
         */
        iamActionDefinition?: outputs.budgets.BudgetActionDefinitionIamActionDefinition;
        /**
         * The service control policies (SCPs) action definition details. See SCP Action Definition.
         */
        scpActionDefinition?: outputs.budgets.BudgetActionDefinitionScpActionDefinition;
        /**
         * The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
         */
        ssmActionDefinition?: outputs.budgets.BudgetActionDefinitionSsmActionDefinition;
    }
    interface BudgetActionDefinitionIamActionDefinition {
        /**
         * A list of groups to be attached. There must be at least one group.
         */
        groups?: string[];
        /**
         * The Amazon Resource Name (ARN) of the policy to be attached.
         */
        policyArn: string;
        /**
         * A list of roles to be attached. There must be at least one role.
         */
        roles?: string[];
        /**
         * A list of users to be attached. There must be at least one user.
         */
        users?: string[];
    }
    interface BudgetActionDefinitionScpActionDefinition {
        /**
         * The policy ID attached.
         */
        policyId: string;
        /**
         * A list of target IDs.
         */
        targetIds: string[];
    }
    interface BudgetActionDefinitionSsmActionDefinition {
        /**
         * The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
         */
        actionSubType: string;
        /**
         * The EC2 and RDS instance IDs.
         */
        instanceIds: string[];
        /**
         * The Region to run the SSM document.
         */
        region: string;
    }
    interface BudgetActionSubscriber {
        /**
         * The address that AWS sends budget notifications to, either an SNS topic or an email.
         */
        address: string;
        /**
         * The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
         */
        subscriptionType: string;
    }
    interface BudgetAutoAdjustData {
        /**
         * (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
         */
        autoAdjustType: string;
        /**
         * (Optional) - Configuration block of Historical Options. Required for `autoAdjustType` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
         */
        historicalOptions?: outputs.budgets.BudgetAutoAdjustDataHistoricalOptions;
        /**
         * (Optional) - The last time that your budget was auto-adjusted.
         */
        lastAutoAdjustTime: string;
    }
    interface BudgetAutoAdjustDataHistoricalOptions {
        /**
         * (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
         */
        budgetAdjustmentPeriod: number;
        /**
         * (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budgetAdjustmentPeriod` and your historical cost data.
         */
        lookbackAvailablePeriods: number;
    }
    interface BudgetCostFilter {
        /**
         * The name of a budget. Unique within accounts.
         */
        name: string;
        values: string[];
    }
    interface BudgetCostTypes {
        /**
         * A boolean value whether to include credits in the cost budget. Defaults to `true`
         */
        includeCredit?: boolean;
        /**
         * Whether a budget includes discounts. Defaults to `true`
         */
        includeDiscount?: boolean;
        /**
         * A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
         */
        includeOtherSubscription?: boolean;
        /**
         * A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
         */
        includeRecurring?: boolean;
        /**
         * A boolean value whether to include refunds in the cost budget. Defaults to `true`
         */
        includeRefund?: boolean;
        /**
         * A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
         */
        includeSubscription?: boolean;
        /**
         * A boolean value whether to include support costs in the cost budget. Defaults to `true`
         */
        includeSupport?: boolean;
        /**
         * A boolean value whether to include tax in the cost budget. Defaults to `true`
         */
        includeTax?: boolean;
        /**
         * A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
         */
        includeUpfront?: boolean;
        /**
         * Whether a budget uses the amortized rate. Defaults to `false`
         */
        useAmortized?: boolean;
        /**
         * A boolean value whether to use blended costs in the cost budget. Defaults to `false`
         */
        useBlended?: boolean;
    }
    interface BudgetNotification {
        /**
         * (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
         */
        comparisonOperator: string;
        /**
         * (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
         */
        notificationType: string;
        /**
         * (Optional) E-Mail addresses to notify. Either this or `subscriberSnsTopicArns` is required.
         */
        subscriberEmailAddresses?: string[];
        /**
         * (Optional) SNS topics to notify. Either this or `subscriberEmailAddresses` is required.
         */
        subscriberSnsTopicArns?: string[];
        /**
         * (Required) Threshold when the notification should be sent.
         */
        threshold: number;
        /**
         * (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
         */
        thresholdType: string;
    }
    interface BudgetPlannedLimit {
        /**
         * (Required) The amount of cost or usage being measured for a budget.
         */
        amount: string;
        /**
         * (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
         */
        startTime: string;
        /**
         * (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
         */
        unit: string;
    }
    interface GetBudgetAutoAdjustData {
        /**
         * (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`.
         */
        autoAdjustType: string;
        /**
         * (Optional) - Configuration block of Historical Options. Required for `autoAdjustType` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
         */
        historicalOptions: outputs.budgets.GetBudgetAutoAdjustDataHistoricalOption[];
        /**
         * (Optional) - The last time that your budget was auto-adjusted.
         */
        lastAutoAdjustTime: string;
    }
    interface GetBudgetAutoAdjustDataHistoricalOption {
        /**
         * (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
         */
        budgetAdjustmentPeriod: number;
        /**
         * (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budgetAdjustmentPeriod` and your historical cost data.
         */
        lookbackAvailablePeriods: number;
    }
    interface GetBudgetBudgetLimit {
        /**
         * The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        amount: string;
        /**
         * The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        unit: string;
    }
    interface GetBudgetCalculatedSpend {
        actualSpends: outputs.budgets.GetBudgetCalculatedSpendActualSpend[];
    }
    interface GetBudgetCalculatedSpendActualSpend {
        /**
         * The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        amount: string;
        /**
         * The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        unit: string;
    }
    interface GetBudgetCostFilter {
        /**
         * The name of a budget. Unique within accounts.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }
    interface GetBudgetCostType {
        /**
         * A boolean value whether to include credits in the cost budget. Defaults to `true`.
         */
        includeCredit: boolean;
        /**
         * Whether a budget includes discounts. Defaults to `true`.
         */
        includeDiscount: boolean;
        /**
         * A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`.
         */
        includeOtherSubscription: boolean;
        /**
         * A boolean value whether to include recurring costs in the cost budget. Defaults to `true`.
         */
        includeRecurring: boolean;
        /**
         * A boolean value whether to include refunds in the cost budget. Defaults to `true`.
         */
        includeRefund: boolean;
        /**
         * A boolean value whether to include subscriptions in the cost budget. Defaults to `true`.
         */
        includeSubscription: boolean;
        /**
         * A boolean value whether to include support costs in the cost budget. Defaults to `true`.
         */
        includeSupport: boolean;
        /**
         * A boolean value whether to include tax in the cost budget. Defaults to `true`.
         */
        includeTax: boolean;
        /**
         * A boolean value whether to include upfront costs in the cost budget. Defaults to `true`.
         */
        includeUpfront: boolean;
        /**
         * Whether a budget uses the amortized rate. Defaults to `false`.
         */
        useAmortized: boolean;
        /**
         * A boolean value whether to use blended costs in the cost budget. Defaults to `false`.
         */
        useBlended: boolean;
    }
    interface GetBudgetNotification {
        /**
         * (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
         */
        comparisonOperator: string;
        /**
         * (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`.
         */
        notificationType: string;
        /**
         * (Optional) E-Mail addresses to notify. Either this or `subscriberSnsTopicArns` is required.
         */
        subscriberEmailAddresses: string[];
        /**
         * (Optional) SNS topics to notify. Either this or `subscriberEmailAddresses` is required.
         */
        subscriberSnsTopicArns: string[];
        /**
         * (Required) Threshold when the notification should be sent.
         */
        threshold: number;
        /**
         * (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
         */
        thresholdType: string;
    }
    interface GetBudgetPlannedLimit {
        /**
         * The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        amount: string;
        /**
         * (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
         */
        startTime: string;
        /**
         * The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
         */
        unit: string;
    }
}
export declare namespace cfg {
    interface ConfigurationAggregatorAccountAggregationSource {
        /**
         * List of 12-digit account IDs of the account(s) being aggregated.
         */
        accountIds: string[];
        /**
         * If true, aggregate existing AWS Config regions and future regions.
         */
        allRegions?: boolean;
        /**
         * List of source regions being aggregated.
         *
         * Either `regions` or `allRegions` (as true) must be specified.
         */
        regions?: string[];
    }
    interface ConfigurationAggregatorOrganizationAggregationSource {
        /**
         * If true, aggregate existing AWS Config regions and future regions.
         */
        allRegions?: boolean;
        /**
         * List of source regions being aggregated.
         */
        regions?: string[];
        /**
         * ARN of the IAM role used to retrieve AWS Organization details associated with the aggregator account.
         *
         * Either `regions` or `allRegions` (as true) must be specified.
         */
        roleArn: string;
    }
    interface ConformancePackInputParameter {
        /**
         * The input key.
         */
        parameterName: string;
        /**
         * The input value.
         */
        parameterValue: string;
    }
    interface DeliveryChannelSnapshotDeliveryProperties {
        /**
         * The frequency with which AWS Config recurringly delivers configuration snapshotsE.g., `One_Hour` or `Three_Hours`. Valid values are listed [here](https://docs.aws.amazon.com/config/latest/APIReference/API_ConfigSnapshotDeliveryProperties.html#API_ConfigSnapshotDeliveryProperties_Contents).
         */
        deliveryFrequency?: string;
    }
    interface OrganizationConformancePackInputParameter {
        /**
         * The input key.
         */
        parameterName: string;
        /**
         * The input value.
         */
        parameterValue: string;
    }
    interface RecorderRecordingGroup {
        /**
         * Specifies whether AWS Config records configuration changes for every supported type of regional resource (which includes any new type that will become supported in the future). Conflicts with `resourceTypes`. Defaults to `true`.
         */
        allSupported?: boolean;
        /**
         * An object that specifies how AWS Config excludes resource types from being recorded by the configuration recorder.To use this option, you must set the useOnly field of RecordingStrategy to `EXCLUSION_BY_RESOURCE_TYPES` Requires `allSupported = false`. Conflicts with `resourceTypes`.
         */
        exclusionByResourceTypes: outputs.cfg.RecorderRecordingGroupExclusionByResourceType[];
        /**
         * Specifies whether AWS Config includes all supported types of _global resources_ with the resources that it records. Requires `allSupported = true`. Conflicts with `resourceTypes`.
         */
        includeGlobalResourceTypes?: boolean;
        /**
         * Recording Strategy. Detailed below.
         */
        recordingStrategies: outputs.cfg.RecorderRecordingGroupRecordingStrategy[];
        /**
         * A list that specifies the types of AWS resources for which AWS Config records configuration changes (for example, `AWS::EC2::Instance` or `AWS::CloudTrail::Trail`). See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types. In order to use this attribute, `allSupported` must be set to false.
         */
        resourceTypes?: string[];
    }
    interface RecorderRecordingGroupExclusionByResourceType {
        /**
         * A list that specifies the types of AWS resources for which AWS Config excludes records configuration changes. See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types.
         */
        resourceTypes?: string[];
    }
    interface RecorderRecordingGroupRecordingStrategy {
        useOnly?: string;
    }
    interface RecorderRecordingMode {
        /**
         * Default reecording frequency. `CONTINUOUS` or `DAILY`.
         */
        recordingFrequency?: string;
        /**
         * Recording mode overrides. Detailed below.
         */
        recordingModeOverride?: outputs.cfg.RecorderRecordingModeRecordingModeOverride;
    }
    interface RecorderRecordingModeRecordingModeOverride {
        /**
         * A description you provide of the override.
         */
        description?: string;
        /**
         * The recording frequency for the resources in the override block. `CONTINUOUS` or `DAILY`.
         */
        recordingFrequency: string;
        /**
         * A list that specifies the types of AWS resources for which the override applies to.  See [restrictions in the AWS Docs](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingModeOverride.html)
         */
        resourceTypes: string[];
    }
    interface RemediationConfigurationExecutionControls {
        /**
         * Configuration block for SSM controls. See below.
         */
        ssmControls?: outputs.cfg.RemediationConfigurationExecutionControlsSsmControls;
    }
    interface RemediationConfigurationExecutionControlsSsmControls {
        /**
         * Maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. The default value is 10%.
         */
        concurrentExecutionRatePercentage?: number;
        /**
         * Percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. The default is 50%.
         */
        errorPercentage?: number;
    }
    interface RemediationConfigurationParameter {
        /**
         * Name of the attribute.
         */
        name: string;
        /**
         * Value is dynamic and changes at run-time.
         */
        resourceValue?: string;
        /**
         * Value is static and does not change at run-time.
         */
        staticValue?: string;
        /**
         * List of static values.
         */
        staticValues: string[];
    }
    interface RuleEvaluationMode {
        /**
         * The mode of an evaluation.
         */
        mode: string;
    }
    interface RuleScope {
        /**
         * The IDs of the only AWS resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for `complianceResourceTypes`.
         */
        complianceResourceId?: string;
        /**
         * A list of resource types of only those AWS resources that you want to trigger an evaluation for the ruleE.g., `AWS::EC2::Instance`. You can only specify one type if you also specify a resource ID for `complianceResourceId`. See [relevant part of AWS Docs](http://docs.aws.amazon.com/config/latest/APIReference/API_ResourceIdentifier.html#config-Type-ResourceIdentifier-resourceType) for available types.
         */
        complianceResourceTypes?: string[];
        /**
         * The tag key that is applied to only those AWS resources that you want you want to trigger an evaluation for the rule.
         */
        tagKey?: string;
        /**
         * The tag value applied to only those AWS resources that you want to trigger an evaluation for the rule.
         */
        tagValue?: string;
    }
    interface RuleSource {
        /**
         * Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to `CUSTOM_POLICY`. See Custom Policy Details Below.
         */
        customPolicyDetails?: outputs.cfg.RuleSourceCustomPolicyDetails;
        /**
         * Indicates whether AWS or the customer owns and manages the AWS Config rule. Valid values are `AWS`, `CUSTOM_LAMBDA` or `CUSTOM_POLICY`. For more information about managed rules, see the [AWS Config Managed Rules documentation](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html). For more information about custom rules, see the [AWS Config Custom Rules documentation](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html). Custom Lambda Functions require permissions to allow the AWS Config service to invoke them, e.g., via the `aws.lambda.Permission` resource.
         */
        owner: string;
        /**
         * Provides the source and type of the event that causes AWS Config to evaluate your AWS resources. Only valid if `owner` is `CUSTOM_LAMBDA` or `CUSTOM_POLICY`. See Source Detail Below.
         */
        sourceDetails?: outputs.cfg.RuleSourceSourceDetail[];
        /**
         * For AWS Config managed rules, a predefined identifier, e.g `IAM_PASSWORD_POLICY`. For custom Lambda rules, the identifier is the ARN of the Lambda Function, such as `arn:aws:lambda:us-east-1:123456789012:function:custom_rule_name` or the `arn` attribute of the `aws.lambda.Function` resource.
         */
        sourceIdentifier?: string;
    }
    interface RuleSourceCustomPolicyDetails {
        /**
         * The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is `false`.
         */
        enableDebugLogDelivery?: boolean;
        /**
         * The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
         */
        policyRuntime: string;
        /**
         * The policy definition containing the logic for your Config Custom Policy rule.
         */
        policyText: string;
    }
    interface RuleSourceSourceDetail {
        /**
         * The source of the event, such as an AWS service, that triggers AWS Config to evaluate your AWSresources. This defaults to `aws.config` and is the only valid value.
         */
        eventSource?: string;
        /**
         * The frequency that you want AWS Config to run evaluations for a rule that istriggered periodically. If specified, requires `messageType` to be `ScheduledNotification`.
         */
        maximumExecutionFrequency?: string;
        /**
         * The type of notification that triggers AWS Config to run an evaluation for a rule. You canspecify the following notification types:
         * * `ConfigurationItemChangeNotification` - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change.
         * * `OversizedConfigurationItemChangeNotification` - Triggers an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
         * * `ScheduledNotification` - Triggers a periodic evaluation at the frequency specified for `maximumExecutionFrequency`.
         * * `ConfigurationSnapshotDeliveryCompleted` - Triggers a periodic evaluation when AWS Config delivers a configuration snapshot.
         */
        messageType?: string;
    }
}
export declare namespace chime {
    interface SdkvoiceGlobalSettingsVoiceConnector {
        /**
         * The S3 bucket that stores the Voice Connector's call detail records.
         */
        cdrBucket?: string;
    }
    interface SdkvoiceSipMediaApplicationEndpoints {
        /**
         * Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
         */
        lambdaArn: string;
    }
    interface SdkvoiceSipRuleTargetApplication {
        /**
         * The AWS Region of the target application.
         */
        awsRegion: string;
        /**
         * Priority of the SIP media application in the target list.
         */
        priority: number;
        /**
         * The SIP media application ID.
         */
        sipMediaApplicationId: string;
    }
    interface SdkvoiceVoiceProfileDomainServerSideEncryptionConfiguration {
        /**
         * ARN for KMS Key.
         *
         * The following arguments are optional:
         */
        kmsKeyArn: string;
    }
    interface VoiceConnectorGroupConnector {
        /**
         * The priority associated with the Amazon Chime Voice Connector, with 1 being the highest priority. Higher priority Amazon Chime Voice Connectors are attempted first.
         */
        priority: number;
        /**
         * The Amazon Chime Voice Connector ID.
         */
        voiceConnectorId: string;
    }
    interface VoiceConnectorOrganizationRoute {
        /**
         * The FQDN or IP address to contact for origination traffic.
         */
        host: string;
        /**
         * The designated origination route port. Defaults to `5060`.
         */
        port?: number;
        /**
         * The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
         */
        priority: number;
        /**
         * The protocol to use for the origination route. Encryption-enabled Amazon Chime Voice Connectors use TCP protocol by default.
         */
        protocol: string;
        /**
         * The weight associated with the host. If hosts are equal in priority, calls are redistributed among them based on their relative weight.
         */
        weight: number;
    }
    interface VoiceConnectorStreamingMediaInsightsConfiguration {
        /**
         * The media insights configuration that will be invoked by the Voice Connector.
         */
        configurationArn?: string;
        /**
         * When `true`, the media insights configuration is not enabled. Defaults to `false`.
         */
        disabled?: boolean;
    }
    interface VoiceConnectorTerminationCredentialsCredential {
        /**
         * RFC2617 compliant password associated with the SIP credentials.
         */
        password: string;
        /**
         * RFC2617 compliant username associated with the SIP credentials.
         */
        username: string;
    }
}
export declare namespace chimesdkmediapipelines {
    interface MediaInsightsPipelineConfigurationElement {
        /**
         * Configuration for Amazon Transcribe Call Analytics processor.
         */
        amazonTranscribeCallAnalyticsProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfiguration;
        /**
         * Configuration for Amazon Transcribe processor.
         */
        amazonTranscribeProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfiguration;
        /**
         * Configuration for Kinesis Data Stream sink.
         */
        kinesisDataStreamSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfiguration;
        /**
         * Configuration for Lambda Function sink.
         */
        lambdaFunctionSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfiguration;
        /**
         * Configuration for S3 recording sink.
         */
        s3RecordingSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementS3RecordingSinkConfiguration;
        /**
         * Configuration for SNS Topic sink.
         */
        snsTopicSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementSnsTopicSinkConfiguration;
        /**
         * Configuration for SQS Queue sink.
         */
        sqsQueueSinkConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementSqsQueueSinkConfiguration;
        /**
         * Element type.
         */
        type: string;
        /**
         * Configuration for Voice analytics processor.
         */
        voiceAnalyticsProcessorConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfiguration;
    }
    interface MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfiguration {
        /**
         * Filter for category events to be delivered to insights target.
         */
        callAnalyticsStreamCategories?: string[];
        /**
         * Labels all personally identifiable information (PII) identified in Utterance events.
         */
        contentIdentificationType?: string;
        /**
         * Redacts all personally identifiable information (PII) identified in Utterance events.
         */
        contentRedactionType?: string;
        /**
         * Enables partial result stabilization in Utterance events.
         */
        enablePartialResultsStabilization?: boolean;
        /**
         * Filters partial Utterance events from delivery to the insights target.
         */
        filterPartialResults?: boolean;
        /**
         * Language code for the transcription model.
         */
        languageCode: string;
        /**
         * Name of custom language model for transcription.
         */
        languageModelName?: string;
        /**
         * Level of stability to use when partial results stabilization is enabled.
         */
        partialResultsStability?: string;
        /**
         * Types of personally identifiable information (PII) to redact from an Utterance event.
         */
        piiEntityTypes?: string;
        /**
         * Settings for post call analytics.
         */
        postCallAnalyticsSettings?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettings;
        /**
         * Method for applying a vocabulary filter to Utterance events.
         */
        vocabularyFilterMethod?: string;
        /**
         * Name of the custom vocabulary filter to use when processing Utterance events.
         */
        vocabularyFilterName?: string;
        /**
         * Name of the custom vocabulary to use when processing Utterance events.
         */
        vocabularyName?: string;
    }
    interface MediaInsightsPipelineConfigurationElementAmazonTranscribeCallAnalyticsProcessorConfigurationPostCallAnalyticsSettings {
        /**
         * Should output be redacted.
         */
        contentRedactionOutput?: string;
        /**
         * ARN of the role used by AWS Transcribe to upload your post call analysis.
         */
        dataAccessRoleArn: string;
        /**
         * ID of the KMS key used to encrypt the output.
         */
        outputEncryptionKmsKeyId?: string;
        /**
         * The Amazon S3 location where you want your Call Analytics post-call transcription output stored.
         */
        outputLocation: string;
    }
    interface MediaInsightsPipelineConfigurationElementAmazonTranscribeProcessorConfiguration {
        /**
         * Labels all personally identifiable information (PII) identified in Transcript events.
         */
        contentIdentificationType?: string;
        /**
         * Redacts all personally identifiable information (PII) identified in Transcript events.
         */
        contentRedactionType?: string;
        /**
         * Enables partial result stabilization in Transcript events.
         */
        enablePartialResultsStabilization?: boolean;
        /**
         * Filters partial Utterance events from delivery to the insights target.
         */
        filterPartialResults?: boolean;
        /**
         * Language code for the transcription model.
         */
        languageCode: string;
        /**
         * Name of custom language model for transcription.
         */
        languageModelName?: string;
        /**
         * Level of stability to use when partial results stabilization is enabled.
         */
        partialResultsStability?: string;
        /**
         * Types of personally identifiable information (PII) to redact from a Transcript event.
         */
        piiEntityTypes?: string;
        /**
         * Enables speaker partitioning (diarization) in your Transcript events.
         */
        showSpeakerLabel?: boolean;
        /**
         * Method for applying a vocabulary filter to Transcript events.
         */
        vocabularyFilterMethod?: string;
        /**
         * Name of the custom vocabulary filter to use when processing Transcript events.
         */
        vocabularyFilterName?: string;
        /**
         * Name of the custom vocabulary to use when processing Transcript events.
         */
        vocabularyName?: string;
    }
    interface MediaInsightsPipelineConfigurationElementKinesisDataStreamSinkConfiguration {
        /**
         * Kinesis Data Stream to deliver results.
         */
        insightsTarget: string;
    }
    interface MediaInsightsPipelineConfigurationElementLambdaFunctionSinkConfiguration {
        /**
         * Lambda Function to deliver results.
         */
        insightsTarget: string;
    }
    interface MediaInsightsPipelineConfigurationElementS3RecordingSinkConfiguration {
        /**
         * S3 URI to deliver recordings.
         */
        destination?: string;
    }
    interface MediaInsightsPipelineConfigurationElementSnsTopicSinkConfiguration {
        /**
         * SNS topic to deliver results.
         */
        insightsTarget: string;
    }
    interface MediaInsightsPipelineConfigurationElementSqsQueueSinkConfiguration {
        /**
         * SQS queue to deliver results.
         */
        insightsTarget: string;
    }
    interface MediaInsightsPipelineConfigurationElementVoiceAnalyticsProcessorConfiguration {
        /**
         * Enable speaker search.
         */
        speakerSearchStatus: string;
        /**
         * Enable voice tone analysis.
         */
        voiceToneAnalysisStatus: string;
    }
    interface MediaInsightsPipelineConfigurationRealTimeAlertConfiguration {
        /**
         * Disables real time alert rules.
         */
        disabled: boolean;
        /**
         * Collection of real time alert rules
         */
        rules: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRule[];
    }
    interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRule {
        /**
         * Configuration for an issue detection rule.
         */
        issueDetectionConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfiguration;
        /**
         * Configuration for a keyword match rule.
         */
        keywordMatchConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfiguration;
        /**
         * Configuration for a sentiment rule.
         */
        sentimentConfiguration?: outputs.chimesdkmediapipelines.MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfiguration;
        /**
         * Rule type.
         */
        type: string;
    }
    interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleIssueDetectionConfiguration {
        /**
         * Rule name.
         */
        ruleName: string;
    }
    interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleKeywordMatchConfiguration {
        /**
         * Collection of keywords to match.
         */
        keywords: string[];
        /**
         * Negate the rule.
         */
        negate: boolean;
        /**
         * Rule name.
         */
        ruleName: string;
    }
    interface MediaInsightsPipelineConfigurationRealTimeAlertConfigurationRuleSentimentConfiguration {
        /**
         * Rule name.
         */
        ruleName: string;
        /**
         * Sentiment type to match.
         */
        sentimentType: string;
        /**
         * Analysis interval.
         */
        timePeriod: number;
    }
}
export declare namespace cleanrooms {
    interface CollaborationDataEncryptionMetadata {
        allowClearText: boolean;
        allowDuplicates: boolean;
        allowJoinsOnColumnsWithDifferentNames: boolean;
        preserveNulls: boolean;
    }
    interface CollaborationMember {
        accountId: string;
        displayName: string;
        memberAbilities: string[];
        status: string;
    }
    interface ConfiguredTableTableReference {
        databaseName: string;
        tableName: string;
    }
}
export declare namespace cloudformation {
    interface CloudFormationTypeLoggingConfig {
        /**
         * Name of the CloudWatch Log Group where CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName: string;
        /**
         * Amazon Resource Name (ARN) of the IAM Role CloudFormation assumes when sending error logging information to CloudWatch Logs.
         */
        logRoleArn: string;
    }
    interface GetCloudFormationTypeLoggingConfig {
        /**
         * Name of the CloudWatch Log Group where CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName: string;
        /**
         * ARN of the IAM Role CloudFormation assumes when sending error logging information to CloudWatch Logs.
         */
        logRoleArn: string;
    }
    interface StackSetAutoDeployment {
        /**
         * Whether or not auto-deployment is enabled.
         */
        enabled?: boolean;
        /**
         * Whether or not to retain stacks when the account is removed.
         */
        retainStacksOnAccountRemoval?: boolean;
    }
    interface StackSetInstanceDeploymentTargets {
        /**
         * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
         */
        organizationalUnitIds?: string[];
    }
    interface StackSetInstanceOperationPreferences {
        /**
         * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureToleranceCount?: number;
        /**
         * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureTolerancePercentage?: number;
        /**
         * The maximum number of accounts in which to perform this operation at one time.
         */
        maxConcurrentCount?: number;
        /**
         * The maximum percentage of accounts in which to perform this operation at one time.
         */
        maxConcurrentPercentage?: number;
        /**
         * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are `SEQUENTIAL` and `PARALLEL`.
         */
        regionConcurrencyType?: string;
        /**
         * The order of the Regions in where you want to perform the stack operation.
         */
        regionOrders?: string[];
    }
    interface StackSetInstanceStackInstanceSummary {
        /**
         * Target AWS Account ID to create a Stack based on the StackSet. Defaults to current account.
         */
        accountId: string;
        /**
         * Organizational unit ID in which the stack is deployed.
         */
        organizationalUnitId: string;
        /**
         * Stack identifier.
         */
        stackId: string;
    }
    interface StackSetManagedExecution {
        /**
         * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
         */
        active?: boolean;
    }
    interface StackSetOperationPreferences {
        /**
         * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureToleranceCount?: number;
        /**
         * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
         */
        failureTolerancePercentage?: number;
        /**
         * The maximum number of accounts in which to perform this operation at one time.
         */
        maxConcurrentCount?: number;
        /**
         * The maximum percentage of accounts in which to perform this operation at one time.
         */
        maxConcurrentPercentage?: number;
        /**
         * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
         */
        regionConcurrencyType?: string;
        /**
         * The order of the Regions in where you want to perform the stack operation.
         */
        regionOrders?: string[];
    }
}
export declare namespace cloudfront {
    interface CachePolicyParametersInCacheKeyAndForwardedToOrigin {
        /**
         * Whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
         */
        cookiesConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig;
        /**
         * Flag determines whether the Accept-Encoding HTTP header is included in the cache key and in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingBrotli?: boolean;
        /**
         * Whether the Accept-Encoding HTTP header is included in the cache key and in requests sent to the origin by CloudFront.
         */
        enableAcceptEncodingGzip?: boolean;
        /**
         * Whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
         */
        headersConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig;
        /**
         * Whether any URL query strings in viewer requests are included in the cache key. It also automatically includes these query strings in requests that CloudFront sends to the origin. Please refer to the Query String Config for more information.
         */
        queryStringsConfig: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig;
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig {
        /**
         * Whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values for `cookieBehavior` are `none`, `whitelist`, `allExcept`, and `all`.
         */
        cookieBehavior: string;
        /**
         * Object that contains a list of cookie names. See Items for more information.
         */
        cookies?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies;
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies {
        items?: string[];
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig {
        /**
         * Whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values for `headerBehavior` are `none` and `whitelist`.
         */
        headerBehavior?: string;
        /**
         * Object contains a list of header names. See Items for more information.
         */
        headers?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders;
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders {
        items?: string[];
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings;
    }
    interface CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings {
        items?: string[];
    }
    interface ContinuousDeploymentPolicyStagingDistributionDnsNames {
        /**
         * A list of CloudFront domain names for the staging distribution.
         */
        items?: string[];
        /**
         * Number of CloudFront domain names in the staging distribution.
         */
        quantity: number;
    }
    interface ContinuousDeploymentPolicyTrafficConfig {
        /**
         * Determines which HTTP requests are sent to the staging distribution. See `singleHeaderConfig`.
         */
        singleHeaderConfig?: outputs.cloudfront.ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig;
        /**
         * Contains the percentage of traffic to send to the staging distribution. See `singleWeightConfig`.
         */
        singleWeightConfig?: outputs.cloudfront.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig;
        /**
         * Type of traffic configuration. Valid values are `SingleWeight` and `SingleHeader`.
         */
        type: string;
    }
    interface ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig {
        /**
         * Request header name to send to the staging distribution. The header must contain the prefix `aws-cf-cd-`.
         */
        header: string;
        /**
         * Request header value.
         */
        value: string;
    }
    interface ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig {
        /**
         * Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to the staging distribution, while others are sent to the primary distribution. Define the session duration using TTL values. See `sessionStickinessConfig`.
         */
        sessionStickinessConfig?: outputs.cloudfront.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig;
        /**
         * The percentage of traffic to send to a staging distribution, expressed as a decimal number between `0` and `.15`.
         */
        weight: number;
    }
    interface ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig {
        /**
         * The amount of time in seconds after which sessions will cease if no requests are received. Valid values are `300` – `3600` (5–60 minutes). The value must be less than or equal to `maximumTtl`.
         */
        idleTtl: number;
        /**
         * The maximum amount of time in seconds to consider requests from the viewer as being part of the same session. Valid values are `300` – `3600` (5–60 minutes). The value must be greater than or equal to `idleTtl`.
         */
        maximumTtl: number;
    }
    interface DistributionCustomErrorResponse {
        errorCachingMinTtl?: number;
        errorCode: number;
        responseCode?: number;
        responsePagePath?: string;
    }
    interface DistributionDefaultCacheBehavior {
        allowedMethods: string[];
        cachePolicyId?: string;
        cachedMethods: string[];
        compress?: boolean;
        defaultTtl: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionDefaultCacheBehaviorForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionDefaultCacheBehaviorFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionDefaultCacheBehaviorLambdaFunctionAssociation[];
        maxTtl: number;
        minTtl?: number;
        originRequestPolicyId?: string;
        realtimeLogConfigArn?: string;
        responseHeadersPolicyId?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        /**
         * List of nested attributes for active trusted key groups, if the distribution is set up to serve private content with signed URLs.
         */
        trustedKeyGroups: string[];
        /**
         * List of nested attributes for active trusted signers, if the distribution is set up to serve private content with signed URLs.
         */
        trustedSigners: string[];
        viewerProtocolPolicy: string;
    }
    interface DistributionDefaultCacheBehaviorForwardedValues {
        cookies: outputs.cloudfront.DistributionDefaultCacheBehaviorForwardedValuesCookies;
        headers: string[];
        queryString: boolean;
        queryStringCacheKeys: string[];
    }
    interface DistributionDefaultCacheBehaviorForwardedValuesCookies {
        forward: string;
        whitelistedNames: string[];
    }
    interface DistributionDefaultCacheBehaviorFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request` or `viewer-response`.
         */
        eventType: string;
        /**
         * ARN of the CloudFront function.
         */
        functionArn: string;
    }
    interface DistributionDefaultCacheBehaviorLambdaFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request`, `origin-request`, `viewer-response`, `origin-response`.
         */
        eventType: string;
        /**
         * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: `true`, `false`.
         */
        includeBody?: boolean;
        /**
         * ARN of the Lambda function.
         */
        lambdaArn: string;
    }
    interface DistributionLoggingConfig {
        bucket: string;
        includeCookies?: boolean;
        prefix?: string;
    }
    interface DistributionOrderedCacheBehavior {
        allowedMethods: string[];
        cachePolicyId?: string;
        cachedMethods: string[];
        compress?: boolean;
        defaultTtl: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionOrderedCacheBehaviorForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionOrderedCacheBehaviorFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionOrderedCacheBehaviorLambdaFunctionAssociation[];
        maxTtl: number;
        minTtl?: number;
        originRequestPolicyId?: string;
        pathPattern: string;
        realtimeLogConfigArn?: string;
        responseHeadersPolicyId?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        /**
         * List of nested attributes for active trusted key groups, if the distribution is set up to serve private content with signed URLs.
         */
        trustedKeyGroups?: string[];
        /**
         * List of nested attributes for active trusted signers, if the distribution is set up to serve private content with signed URLs.
         */
        trustedSigners?: string[];
        viewerProtocolPolicy: string;
    }
    interface DistributionOrderedCacheBehaviorForwardedValues {
        cookies: outputs.cloudfront.DistributionOrderedCacheBehaviorForwardedValuesCookies;
        headers: string[];
        queryString: boolean;
        queryStringCacheKeys: string[];
    }
    interface DistributionOrderedCacheBehaviorForwardedValuesCookies {
        forward: string;
        whitelistedNames?: string[];
    }
    interface DistributionOrderedCacheBehaviorFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request` or `viewer-response`.
         */
        eventType: string;
        /**
         * ARN of the CloudFront function.
         */
        functionArn: string;
    }
    interface DistributionOrderedCacheBehaviorLambdaFunctionAssociation {
        /**
         * Specific event to trigger this function. Valid values: `viewer-request`, `origin-request`, `viewer-response`, `origin-response`.
         */
        eventType: string;
        /**
         * When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: `true`, `false`.
         */
        includeBody?: boolean;
        /**
         * ARN of the Lambda function.
         */
        lambdaArn: string;
    }
    interface DistributionOrigin {
        connectionAttempts?: number;
        connectionTimeout?: number;
        customHeaders?: outputs.cloudfront.DistributionOriginCustomHeader[];
        customOriginConfig?: outputs.cloudfront.DistributionOriginCustomOriginConfig;
        /**
         * Domain name corresponding to the distribution. For example: `d604721fxaaqy9.cloudfront.net`.
         */
        domainName: string;
        originAccessControlId?: string;
        originId: string;
        originPath?: string;
        originShield?: outputs.cloudfront.DistributionOriginOriginShield;
        s3OriginConfig?: outputs.cloudfront.DistributionOriginS3OriginConfig;
    }
    interface DistributionOriginCustomHeader {
        name: string;
        value: string;
    }
    interface DistributionOriginCustomOriginConfig {
        httpPort: number;
        httpsPort: number;
        originKeepaliveTimeout?: number;
        originProtocolPolicy: string;
        originReadTimeout?: number;
        originSslProtocols: string[];
    }
    interface DistributionOriginGroup {
        failoverCriteria: outputs.cloudfront.DistributionOriginGroupFailoverCriteria;
        members: outputs.cloudfront.DistributionOriginGroupMember[];
        originId: string;
    }
    interface DistributionOriginGroupFailoverCriteria {
        statusCodes: number[];
    }
    interface DistributionOriginGroupMember {
        originId: string;
    }
    interface DistributionOriginOriginShield {
        /**
         * `true` if any of the AWS accounts listed as trusted signers have active CloudFront key pairs
         */
        enabled: boolean;
        originShieldRegion?: string;
    }
    interface DistributionOriginS3OriginConfig {
        originAccessIdentity: string;
    }
    interface DistributionRestrictions {
        geoRestriction: outputs.cloudfront.DistributionRestrictionsGeoRestriction;
    }
    interface DistributionRestrictionsGeoRestriction {
        locations: string[];
        restrictionType: string;
    }
    interface DistributionTrustedKeyGroup {
        /**
         * `true` if any of the AWS accounts listed as trusted signers have active CloudFront key pairs
         */
        enabled: boolean;
        /**
         * List of nested attributes for each trusted signer
         */
        items: outputs.cloudfront.DistributionTrustedKeyGroupItem[];
    }
    interface DistributionTrustedKeyGroupItem {
        /**
         * ID of the key group that contains the public keys.
         */
        keyGroupId: string;
        /**
         * Set of active CloudFront key pairs associated with the signer account
         */
        keyPairIds: string[];
    }
    interface DistributionTrustedSigner {
        /**
         * `true` if any of the AWS accounts listed as trusted signers have active CloudFront key pairs
         */
        enabled: boolean;
        /**
         * List of nested attributes for each trusted signer
         */
        items: outputs.cloudfront.DistributionTrustedSignerItem[];
    }
    interface DistributionTrustedSignerItem {
        /**
         * AWS account ID or `self`
         */
        awsAccountNumber: string;
        /**
         * Set of active CloudFront key pairs associated with the signer account
         */
        keyPairIds: string[];
    }
    interface DistributionViewerCertificate {
        acmCertificateArn?: string;
        cloudfrontDefaultCertificate?: boolean;
        iamCertificateId?: string;
        minimumProtocolVersion?: string;
        sslSupportMethod?: string;
    }
    interface FieldLevelEncryptionConfigContentTypeProfileConfig {
        /**
         * Object that contains an attribute `items` that contains the list of configurations for a field-level encryption content type-profile. See Content Type Profile.
         */
        contentTypeProfiles: outputs.cloudfront.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles;
        /**
         * specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
         */
        forwardWhenContentTypeIsUnknown: boolean;
    }
    interface FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles {
        items: outputs.cloudfront.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem[];
    }
    interface FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem {
        contentType: string;
        format: string;
        profileId?: string;
    }
    interface FieldLevelEncryptionConfigQueryArgProfileConfig {
        /**
         * Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
         */
        forwardWhenQueryArgProfileIsUnknown: boolean;
        /**
         * Object that contains an attribute `items` that contains the list ofrofiles specified for query argument-profile mapping for field-level encryption. see Query Arg Profile.
         */
        queryArgProfiles?: outputs.cloudfront.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles;
    }
    interface FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles {
        items?: outputs.cloudfront.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem[];
    }
    interface FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem {
        profileId: string;
        queryArg: string;
    }
    interface FieldLevelEncryptionProfileEncryptionEntities {
        items?: outputs.cloudfront.FieldLevelEncryptionProfileEncryptionEntitiesItem[];
    }
    interface FieldLevelEncryptionProfileEncryptionEntitiesItem {
        fieldPatterns: outputs.cloudfront.FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns;
        providerId: string;
        publicKeyId: string;
    }
    interface FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns {
        items?: string[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOrigin {
        /**
         * Object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Cookies Config for more information.
         */
        cookiesConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig[];
        /**
         * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingBrotli: boolean;
        /**
         * A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin.
         */
        enableAcceptEncodingGzip: boolean;
        /**
         * Object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Headers Config for more information.
         */
        headersConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig[];
        /**
         * Object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin. See Query String Config for more information.
         */
        queryStringsConfigs: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig {
        /**
         * Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`, `allExcept`, `all`.
         */
        cookieBehavior: string;
        /**
         * Object that contains a list of cookie names. See Items for more information.
         */
        cookies: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookie[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookie {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig {
        /**
         * Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`.
         */
        headerBehavior: string;
        /**
         * Object that contains a list of header names. See Items for more information.
         */
        headers: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeader[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeader {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig {
        /**
         * Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are `none`, `whitelist`, `allExcept`, `all`.
         */
        queryStringBehavior: string;
        /**
         * Object that contains a list of query string names. See Items for more information.
         */
        queryStrings: outputs.cloudfront.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryString[];
    }
    interface GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryString {
        /**
         * List of item names (`cookies`, `headers`, or `queryStrings`).
         */
        items: string[];
    }
    interface GetOriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies: outputs.cloudfront.GetOriginRequestPolicyCookiesConfigCookie[];
    }
    interface GetOriginRequestPolicyCookiesConfigCookie {
        items: string[];
    }
    interface GetOriginRequestPolicyHeadersConfig {
        headerBehavior: string;
        headers: outputs.cloudfront.GetOriginRequestPolicyHeadersConfigHeader[];
    }
    interface GetOriginRequestPolicyHeadersConfigHeader {
        items: string[];
    }
    interface GetOriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings: outputs.cloudfront.GetOriginRequestPolicyQueryStringsConfigQueryString[];
    }
    interface GetOriginRequestPolicyQueryStringsConfigQueryString {
        items: string[];
    }
    interface GetRealtimeLogConfigEndpoint {
        /**
         * (Required) Amazon Kinesis data stream configuration.
         */
        kinesisStreamConfigs: outputs.cloudfront.GetRealtimeLogConfigEndpointKinesisStreamConfig[];
        /**
         * (Required) Type of data stream where real-time log data is sent. The only valid value is `Kinesis`.
         */
        streamType: string;
    }
    interface GetRealtimeLogConfigEndpointKinesisStreamConfig {
        /**
         * (Required) ARN of an IAM role that CloudFront can use to send real-time log data to the Kinesis data stream.
         * See the [AWS documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) for more information.
         */
        roleArn: string;
        /**
         * (Required) ARN of the Kinesis data stream.
         */
        streamArn: string;
    }
    interface GetResponseHeadersPolicyCorsConfig {
        /**
         * A Boolean value that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header.
         */
        accessControlAllowCredentials: boolean;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header.
         */
        accessControlAllowHeaders: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowHeader[];
        /**
         * Object that contains an attribute `items` that contains a list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. Valid values: `GET` | `POST` | `OPTIONS` | `PUT` | `DELETE` | `HEAD` | `ALL`
         */
        accessControlAllowMethods: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowMethod[];
        /**
         * Object that contains an attribute `items` that contains a list of origins that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header.
         */
        accessControlAllowOrigins: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlAllowOrigin[];
        /**
         * Object that contains an attribute `items` that contains a list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header.
         */
        accessControlExposeHeaders: outputs.cloudfront.GetResponseHeadersPolicyCorsConfigAccessControlExposeHeader[];
        /**
         * A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
         */
        accessControlMaxAgeSec: number;
        originOverride: boolean;
    }
    interface GetResponseHeadersPolicyCorsConfigAccessControlAllowHeader {
        items: string[];
    }
    interface GetResponseHeadersPolicyCorsConfigAccessControlAllowMethod {
        items: string[];
    }
    interface GetResponseHeadersPolicyCorsConfigAccessControlAllowOrigin {
        items: string[];
    }
    interface GetResponseHeadersPolicyCorsConfigAccessControlExposeHeader {
        items: string[];
    }
    interface GetResponseHeadersPolicyCustomHeadersConfig {
        items: outputs.cloudfront.GetResponseHeadersPolicyCustomHeadersConfigItem[];
    }
    interface GetResponseHeadersPolicyCustomHeadersConfigItem {
        /**
         * The HTTP header name.
         */
        header: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Value for the HTTP response header.
         */
        value: string;
    }
    interface GetResponseHeadersPolicyRemoveHeadersConfig {
        items: outputs.cloudfront.GetResponseHeadersPolicyRemoveHeadersConfigItem[];
    }
    interface GetResponseHeadersPolicyRemoveHeadersConfigItem {
        /**
         * The HTTP header name.
         */
        header: string;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfig {
        /**
         * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
         */
        contentSecurityPolicies: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy[];
        /**
         * A setting that determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. See Content Type Options for more information.
         */
        contentTypeOptions: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigContentTypeOption[];
        /**
         * Setting that determines whether CloudFront includes the X-Frame-Options HTTP response header and the header’s value. See Frame Options for more information.
         */
        frameOptions: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigFrameOption[];
        /**
         * Value of the Referrer-Policy HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicies: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicy[];
        /**
         * Settings that determine whether CloudFront includes the Strict-Transport-Security HTTP response header and the header’s value. See Strict Transport Security for more information.
         */
        strictTransportSecurities: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity[];
        /**
         * Settings that determine whether CloudFront includes the X-XSS-Protection HTTP response header and the header’s value. See XSS Protection for more information.
         */
        xssProtections: outputs.cloudfront.GetResponseHeadersPolicySecurityHeadersConfigXssProtection[];
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy {
        /**
         * The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
         */
        contentSecurityPolicy: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigContentTypeOption {
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigFrameOption {
        /**
         * Value of the X-Frame-Options HTTP response header. Valid values: `DENY` | `SAMEORIGIN`
         */
        frameOption: string;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicy {
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Value of the Referrer-Policy HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicy: string;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity {
        /**
         * A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
         */
        accessControlMaxAgeSec: number;
        /**
         * Whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
         */
        includeSubdomains: boolean;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
         */
        preload: boolean;
    }
    interface GetResponseHeadersPolicySecurityHeadersConfigXssProtection {
        /**
         * Whether CloudFront includes the mode=block directive in the X-XSS-Protection header.
         */
        modeBlock: boolean;
        /**
         * Whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Boolean value that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0.
         */
        protection: boolean;
        /**
         * Whether CloudFront sets a reporting URI in the X-XSS-Protection header.
         */
        reportUri: string;
    }
    interface GetResponseHeadersPolicyServerTimingHeadersConfig {
        /**
         * Whether CloudFront adds the `Server-Timing` header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
         */
        enabled: boolean;
        /**
         * Number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to.
         */
        samplingRate: number;
    }
    interface KeyValueStoreTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
    }
    interface MonitoringSubscriptionMonitoringSubscription {
        /**
         * A subscription configuration for additional CloudWatch metrics. See below.
         */
        realtimeMetricsSubscriptionConfig: outputs.cloudfront.MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig;
    }
    interface MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig {
        /**
         * A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution. Valid values are `Enabled` and `Disabled`. See below.
         */
        realtimeMetricsSubscriptionStatus: string;
    }
    interface OriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: outputs.cloudfront.OriginRequestPolicyCookiesConfigCookies;
    }
    interface OriginRequestPolicyCookiesConfigCookies {
        items?: string[];
    }
    interface OriginRequestPolicyHeadersConfig {
        headerBehavior?: string;
        headers?: outputs.cloudfront.OriginRequestPolicyHeadersConfigHeaders;
    }
    interface OriginRequestPolicyHeadersConfigHeaders {
        items?: string[];
    }
    interface OriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: outputs.cloudfront.OriginRequestPolicyQueryStringsConfigQueryStrings;
    }
    interface OriginRequestPolicyQueryStringsConfigQueryStrings {
        items?: string[];
    }
    interface RealtimeLogConfigEndpoint {
        /**
         * The Amazon Kinesis data stream configuration.
         */
        kinesisStreamConfig: outputs.cloudfront.RealtimeLogConfigEndpointKinesisStreamConfig;
        /**
         * The type of data stream where real-time log data is sent. The only valid value is `Kinesis`.
         */
        streamType: string;
    }
    interface RealtimeLogConfigEndpointKinesisStreamConfig {
        /**
         * The ARN of an IAM role that CloudFront can use to send real-time log data to the Kinesis data stream.
         * See the [AWS documentation](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) for more information.
         */
        roleArn: string;
        /**
         * The ARN of the Kinesis data stream.
         */
        streamArn: string;
    }
    interface ResponseHeadersPolicyCorsConfig {
        /**
         * A Boolean value that CloudFront uses as the value for the `Access-Control-Allow-Credentials` HTTP response header.
         */
        accessControlAllowCredentials: boolean;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP header names that CloudFront includes as values for the `Access-Control-Allow-Headers` HTTP response header.
         */
        accessControlAllowHeaders: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP methods that CloudFront includes as values for the `Access-Control-Allow-Methods` HTTP response header. Valid values: `GET` | `POST` | `OPTIONS` | `PUT` | `DELETE` | `HEAD` | `ALL`
         */
        accessControlAllowMethods: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowMethods;
        /**
         * Object that contains an attribute `items` that contains a list of origins that CloudFront can use as the value for the `Access-Control-Allow-Origin` HTTP response header.
         */
        accessControlAllowOrigins: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins;
        /**
         * Object that contains an attribute `items` that contains a list of HTTP headers that CloudFront includes as values for the `Access-Control-Expose-Headers` HTTP response header.
         */
        accessControlExposeHeaders?: outputs.cloudfront.ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders;
        /**
         * A number that CloudFront uses as the value for the `Access-Control-Max-Age` HTTP response header.
         */
        accessControlMaxAgeSec?: number;
        /**
         * A Boolean value that determines how CloudFront behaves for the HTTP response header.
         */
        originOverride: boolean;
    }
    interface ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders {
        items?: string[];
    }
    interface ResponseHeadersPolicyCorsConfigAccessControlAllowMethods {
        items?: string[];
    }
    interface ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins {
        items?: string[];
    }
    interface ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders {
        items?: string[];
    }
    interface ResponseHeadersPolicyCustomHeadersConfig {
        items?: outputs.cloudfront.ResponseHeadersPolicyCustomHeadersConfigItem[];
    }
    interface ResponseHeadersPolicyCustomHeadersConfigItem {
        header: string;
        override: boolean;
        value: string;
    }
    interface ResponseHeadersPolicyRemoveHeadersConfig {
        items?: outputs.cloudfront.ResponseHeadersPolicyRemoveHeadersConfigItem[];
    }
    interface ResponseHeadersPolicyRemoveHeadersConfigItem {
        header: string;
    }
    interface ResponseHeadersPolicySecurityHeadersConfig {
        /**
         * The policy directives and their values that CloudFront includes as values for the `Content-Security-Policy` HTTP response header. See Content Security Policy for more information.
         */
        contentSecurityPolicy?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy;
        /**
         * Determines whether CloudFront includes the `X-Content-Type-Options` HTTP response header with its value set to `nosniff`. See Content Type Options for more information.
         */
        contentTypeOptions?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions;
        /**
         * Determines whether CloudFront includes the `X-Frame-Options` HTTP response header and the header’s value. See Frame Options for more information.
         */
        frameOptions?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigFrameOptions;
        /**
         * Determines whether CloudFront includes the `Referrer-Policy` HTTP response header and the header’s value. See Referrer Policy for more information.
         */
        referrerPolicy?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy;
        /**
         * Determines whether CloudFront includes the `Strict-Transport-Security` HTTP response header and the header’s value. See Strict Transport Security for more information.
         */
        strictTransportSecurity?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity;
        /**
         * Determine whether CloudFront includes the `X-XSS-Protection` HTTP response header and the header’s value. See XSS Protection for more information.
         */
        xssProtection?: outputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigXssProtection;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy {
        /**
         * The policy directives and their values that CloudFront includes as values for the `Content-Security-Policy` HTTP response header.
         */
        contentSecurityPolicy: string;
        /**
         * Whether CloudFront overrides the `Content-Security-Policy` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions {
        /**
         * Whether CloudFront overrides the `X-Content-Type-Options` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigFrameOptions {
        /**
         * The value of the `X-Frame-Options` HTTP response header. Valid values: `DENY` | `SAMEORIGIN`
         */
        frameOption: string;
        /**
         * Whether CloudFront overrides the `X-Frame-Options` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy {
        /**
         * Whether CloudFront overrides the `Referrer-Policy` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * The value of the `Referrer-Policy` HTTP response header. Valid Values: `no-referrer` | `no-referrer-when-downgrade` | `origin` | `origin-when-cross-origin` | `same-origin` | `strict-origin` | `strict-origin-when-cross-origin` | `unsafe-url`
         */
        referrerPolicy: string;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity {
        /**
         * A number that CloudFront uses as the value for the `max-age` directive in the `Strict-Transport-Security` HTTP response header.
         */
        accessControlMaxAgeSec: number;
        /**
         * Whether CloudFront includes the `includeSubDomains` directive in the `Strict-Transport-Security` HTTP response header.
         */
        includeSubdomains?: boolean;
        /**
         * Whether CloudFront overrides the `Strict-Transport-Security` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * Whether CloudFront includes the `preload` directive in the `Strict-Transport-Security` HTTP response header.
         */
        preload?: boolean;
    }
    interface ResponseHeadersPolicySecurityHeadersConfigXssProtection {
        /**
         * Whether CloudFront includes the `mode=block` directive in the `X-XSS-Protection` header.
         */
        modeBlock?: boolean;
        /**
         * Whether CloudFront overrides the `X-XSS-Protection` HTTP response header received from the origin with the one specified in this response headers policy.
         */
        override: boolean;
        /**
         * A Boolean value that determines the value of the `X-XSS-Protection` HTTP response header. When this setting is `true`, the value of the `X-XSS-Protection` header is `1`. When this setting is `false`, the value of the `X-XSS-Protection` header is `0`.
         */
        protection: boolean;
        /**
         * A reporting URI, which CloudFront uses as the value of the report directive in the `X-XSS-Protection` header. You cannot specify a `reportUri` when `modeBlock` is `true`.
         */
        reportUri?: string;
    }
    interface ResponseHeadersPolicyServerTimingHeadersConfig {
        /**
         * A Whether CloudFront adds the `Server-Timing` header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
         */
        enabled: boolean;
        /**
         * A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. Valid range: Minimum value of 0.0. Maximum value of 100.0.
         */
        samplingRate: number;
    }
}
export declare namespace cloudhsmv2 {
    interface ClusterClusterCertificate {
        /**
         * The HSM hardware certificate issued (signed) by AWS CloudHSM.
         */
        awsHardwareCertificate: string;
        /**
         * The cluster certificate issued (signed) by the issuing certificate authority (CA) of the cluster's owner.
         */
        clusterCertificate: string;
        /**
         * The certificate signing request (CSR). Available only in `UNINITIALIZED` state after an HSM instance is added to the cluster.
         */
        clusterCsr: string;
        /**
         * The HSM certificate issued (signed) by the HSM hardware.
         */
        hsmCertificate: string;
        /**
         * The HSM hardware certificate issued (signed) by the hardware manufacturer.
         */
        manufacturerHardwareCertificate: string;
    }
    interface GetClusterClusterCertificate {
        /**
         * The HSM hardware certificate issued (signed) by AWS CloudHSM.
         */
        awsHardwareCertificate: string;
        /**
         * The cluster certificate issued (signed) by the issuing certificate authority (CA) of the cluster's owner.
         */
        clusterCertificate: string;
        /**
         * The certificate signing request (CSR). Available only in UNINITIALIZED state.
         */
        clusterCsr: string;
        /**
         * The HSM certificate issued (signed) by the HSM hardware.
         */
        hsmCertificate: string;
        /**
         * The HSM hardware certificate issued (signed) by the hardware manufacturer.
         * The number of available cluster certificates may vary depending on state of the cluster.
         */
        manufacturerHardwareCertificate: string;
    }
}
export declare namespace cloudsearch {
    interface DomainEndpointOptions {
        /**
         * Enables or disables the requirement that all requests to the domain arrive over HTTPS.
         */
        enforceHttps: boolean;
        /**
         * The minimum required TLS version. See the [AWS documentation](https://docs.aws.amazon.com/cloudsearch/latest/developerguide/API_DomainEndpointOptions.html) for valid values.
         */
        tlsSecurityPolicy: string;
    }
    interface DomainIndexField {
        /**
         * The analysis scheme you want to use for a `text` field. The analysis scheme specifies the language-specific text processing options that are used during indexing.
         */
        analysisScheme?: string;
        /**
         * The default value for the field. This value is used when no value is specified for the field in the document data.
         */
        defaultValue?: string;
        /**
         * You can get facet information by enabling this.
         */
        facet?: boolean;
        /**
         * You can highlight information.
         */
        highlight?: boolean;
        /**
         * A unique name for the field. Field names must begin with a letter and be at least 3 and no more than 64 characters long. The allowed characters are: `a`-`z` (lower-case letters), `0`-`9`, and `_` (underscore). The name `score` is reserved and cannot be used as a field name.
         */
        name: string;
        /**
         * You can enable returning the value of all searchable fields.
         */
        return?: boolean;
        /**
         * You can set whether this index should be searchable or not.
         */
        search?: boolean;
        /**
         * You can enable the property to be sortable.
         */
        sort?: boolean;
        /**
         * A comma-separated list of source fields to map to the field. Specifying a source field copies data from one field to another, enabling you to use the same source data in different ways by configuring different options for the fields.
         */
        sourceFields?: string;
        /**
         * The field type. Valid values: `date`, `date-array`, `double`, `double-array`, `int`, `int-array`, `literal`, `literal-array`, `text`, `text-array`.
         */
        type: string;
    }
    interface DomainScalingParameters {
        /**
         * The instance type that you want to preconfigure for your domain. See the [AWS documentation](https://docs.aws.amazon.com/cloudsearch/latest/developerguide/API_ScalingParameters.html) for valid values.
         */
        desiredInstanceType: string;
        /**
         * The number of partitions you want to preconfigure for your domain. Only valid when you select `search.2xlarge` as the instance type.
         */
        desiredPartitionCount: number;
        /**
         * The number of replicas you want to preconfigure for each index partition.
         */
        desiredReplicationCount: number;
    }
}
export declare namespace cloudtrail {
    interface EventDataStoreAdvancedEventSelector {
        /**
         * Specifies the selector statements in an advanced event selector. Fields documented below.
         */
        fieldSelectors: outputs.cloudtrail.EventDataStoreAdvancedEventSelectorFieldSelector[];
        /**
         * Specifies the name of the advanced event selector.
         */
        name: string;
    }
    interface EventDataStoreAdvancedEventSelectorFieldSelector {
        /**
         * A list of values that includes events that match the last few characters of the event record field specified as the value of `field`.
         */
        endsWiths: string[];
        /**
         * A list of values that includes events that match the exact value of the event record field specified as the value of `field`. This is the only valid operator that you can use with the `readOnly`, `eventCategory`, and `resources.type` fields.
         */
        equals: string[];
        /**
         * Specifies a field in an event record on which to filter events to be logged. You can specify only the following values: `readOnly`, `eventSource`, `eventName`, `eventCategory`, `resources.type`, `resources.ARN`.
         */
        field: string;
        /**
         * A list of values that excludes events that match the last few characters of the event record field specified as the value of `field`.
         */
        notEndsWiths: string[];
        /**
         * A list of values that excludes events that match the exact value of the event record field specified as the value of `field`.
         */
        notEquals: string[];
        /**
         * A list of values that excludes events that match the first few characters of the event record field specified as the value of `field`.
         */
        notStartsWiths: string[];
        /**
         * A list of values that includes events that match the first few characters of the event record field specified as the value of `field`.
         */
        startsWiths: string[];
    }
    interface TrailAdvancedEventSelector {
        fieldSelectors: outputs.cloudtrail.TrailAdvancedEventSelectorFieldSelector[];
        /**
         * Name of the trail.
         */
        name?: string;
    }
    interface TrailAdvancedEventSelectorFieldSelector {
        endsWiths?: string[];
        equals?: string[];
        field: string;
        notEndsWiths?: string[];
        notEquals?: string[];
        notStartsWiths?: string[];
        startsWiths?: string[];
    }
    interface TrailEventSelector {
        /**
         * Configuration block for data events. See details below.
         */
        dataResources?: outputs.cloudtrail.TrailEventSelectorDataResource[];
        /**
         * A set of event sources to exclude. Valid values include: `kms.amazonaws.com` and `rdsdata.amazonaws.com`. `includeManagementEvents` must be set to`true` to allow this.
         */
        excludeManagementEventSources?: string[];
        /**
         * Whether to include management events for your trail. Defaults to `true`.
         */
        includeManagementEvents?: boolean;
        /**
         * Type of events to log. Valid values are `ReadOnly`, `WriteOnly`, `All`. Default value is `All`.
         */
        readWriteType?: string;
    }
    interface TrailEventSelectorDataResource {
        /**
         * Resource type in which you want to log data events. You can specify only the following value: "AWS::S3::Object", "AWS::Lambda::Function" and "AWS::DynamoDB::Table".
         */
        type: string;
        /**
         * List of ARN strings or partial ARN strings to specify selectors for data audit events over data resources. ARN list is specific to single-valued `type`. For example, `arn:aws:s3:::<bucket name>/` for all objects in a bucket, `arn:aws:s3:::<bucket name>/key` for specific objects, `arn:aws:lambda` for all lambda events within an account, `arn:aws:lambda:<region>:<account number>:function:<function name>` for a specific Lambda function, `arn:aws:dynamodb` for all DDB events for all tables within an account, or `arn:aws:dynamodb:<region>:<account number>:table/<table name>` for a specific DynamoDB table.
         */
        values: string[];
    }
    interface TrailInsightSelector {
        /**
         * Type of insights to log on a trail. Valid values are: `ApiCallRateInsight` and `ApiErrorRateInsight`.
         */
        insightType: string;
    }
}
export declare namespace cloudwatch {
    interface CompositeAlarmActionsSuppressor {
        /**
         * Can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.
         */
        alarm: string;
        /**
         * The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the `ALARM` state. After this time, the composite alarm performs its actions.
         */
        extensionPeriod: number;
        /**
         * The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the `ALARM` state. After this time, the composite alarm performs its actions.
         */
        waitPeriod: number;
    }
    interface EventConnectionAuthParameters {
        /**
         * Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with `basic` and `oauth`. Documented below.
         */
        apiKey?: outputs.cloudwatch.EventConnectionAuthParametersApiKey;
        /**
         * Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with `apiKey` and `oauth`. Documented below.
         */
        basic?: outputs.cloudwatch.EventConnectionAuthParametersBasic;
        /**
         * Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
         */
        invocationHttpParameters?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParameters;
        /**
         * Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with `basic` and `apiKey`. Documented below.
         */
        oauth?: outputs.cloudwatch.EventConnectionAuthParametersOauth;
    }
    interface EventConnectionAuthParametersApiKey {
        /**
         * Header Name.
         */
        key: string;
        /**
         * Header Value. Created and stored in AWS Secrets Manager.
         */
        value: string;
    }
    interface EventConnectionAuthParametersBasic {
        /**
         * A password for the authorization. Created and stored in AWS Secrets Manager.
         */
        password: string;
        /**
         * A username for the authorization.
         */
        username: string;
    }
    interface EventConnectionAuthParametersInvocationHttpParameters {
        /**
         * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        bodies?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersBody[];
        /**
         * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        headers?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersHeader[];
        /**
         * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        queryStrings?: outputs.cloudwatch.EventConnectionAuthParametersInvocationHttpParametersQueryString[];
    }
    interface EventConnectionAuthParametersInvocationHttpParametersBody {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventConnectionAuthParametersInvocationHttpParametersHeader {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventConnectionAuthParametersInvocationHttpParametersQueryString {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventConnectionAuthParametersOauth {
        /**
         * The URL to the authorization endpoint.
         */
        authorizationEndpoint: string;
        /**
         * Contains the client parameters for OAuth authorization. Contains the following two parameters.
         */
        clientParameters?: outputs.cloudwatch.EventConnectionAuthParametersOauthClientParameters;
        /**
         * A password for the authorization. Created and stored in AWS Secrets Manager.
         */
        httpMethod: string;
        /**
         * OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
         */
        oauthHttpParameters: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParameters;
    }
    interface EventConnectionAuthParametersOauthClientParameters {
        /**
         * The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
         */
        clientId: string;
        /**
         * The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
         */
        clientSecret: string;
    }
    interface EventConnectionAuthParametersOauthOauthHttpParameters {
        /**
         * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        bodies?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersBody[];
        /**
         * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        headers?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersHeader[];
        /**
         * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
         */
        queryStrings?: outputs.cloudwatch.EventConnectionAuthParametersOauthOauthHttpParametersQueryString[];
    }
    interface EventConnectionAuthParametersOauthOauthHttpParametersBody {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventConnectionAuthParametersOauthOauthHttpParametersHeader {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventConnectionAuthParametersOauthOauthHttpParametersQueryString {
        /**
         * Specified whether the value is secret.
         */
        isValueSecret?: boolean;
        /**
         * The key for the parameter.
         */
        key?: string;
        /**
         * The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
         */
        value?: string;
    }
    interface EventEndpointEventBus {
        /**
         * The ARN of the event bus the endpoint is associated with.
         */
        eventBusArn: string;
    }
    interface EventEndpointReplicationConfig {
        /**
         * The state of event replication. Valid values: `ENABLED`, `DISABLED`. The default state is `ENABLED`, which means you must supply a `roleArn`. If you don't have a `roleArn` or you don't want event replication enabled, set `state` to `DISABLED`.
         */
        state?: string;
    }
    interface EventEndpointRoutingConfig {
        /**
         * Parameters used for failover. This includes what triggers failover and what happens when it's triggered. Documented below.
         */
        failoverConfig: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfig;
    }
    interface EventEndpointRoutingConfigFailoverConfig {
        /**
         * Parameters used for the primary Region. Documented below.
         */
        primary: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfigPrimary;
        /**
         * Parameters used for the secondary Region, the Region that events are routed to when failover is triggered or event replication is enabled. Documented below.
         */
        secondary: outputs.cloudwatch.EventEndpointRoutingConfigFailoverConfigSecondary;
    }
    interface EventEndpointRoutingConfigFailoverConfigPrimary {
        /**
         * The ARN of the health check used by the endpoint to determine whether failover is triggered.
         */
        healthCheck?: string;
    }
    interface EventEndpointRoutingConfigFailoverConfigSecondary {
        /**
         * The name of the secondary Region.
         */
        route?: string;
    }
    interface EventPermissionCondition {
        /**
         * Key for the condition. Valid values: `aws:PrincipalOrgID`.
         */
        key: string;
        /**
         * Type of condition. Value values: `StringEquals`.
         */
        type: string;
        /**
         * Value for the key.
         */
        value: string;
    }
    interface EventTargetBatchTarget {
        /**
         * The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
         */
        arraySize?: number;
        /**
         * The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
         */
        jobAttempts?: number;
        /**
         * The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
         */
        jobDefinition: string;
        /**
         * The name to use for this execution of the job, if the target is an AWS Batch job.
         */
        jobName: string;
    }
    interface EventTargetDeadLetterConfig {
        /**
         * ARN of the SQS queue specified as the target for the dead-letter queue.
         */
        arn?: string;
    }
    interface EventTargetEcsTarget {
        /**
         * The capacity provider strategy to use for the task. If a `capacityProviderStrategy` specified, the `launchType` parameter must be omitted. If no `capacityProviderStrategy` or `launchType` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
         */
        capacityProviderStrategies?: outputs.cloudwatch.EventTargetEcsTargetCapacityProviderStrategy[];
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task.
         */
        enableEcsManagedTags?: boolean;
        /**
         * Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
         */
        enableExecuteCommand?: boolean;
        /**
         * Specifies an ECS task group for the task. The maximum length is 255 characters.
         */
        group?: string;
        /**
         * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
         */
        launchType?: string;
        /**
         * Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launchType` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
         */
        networkConfiguration?: outputs.cloudwatch.EventTargetEcsTargetNetworkConfiguration;
        /**
         * An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
         */
        orderedPlacementStrategies?: outputs.cloudwatch.EventTargetEcsTargetOrderedPlacementStrategy[];
        /**
         * An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
         */
        placementConstraints?: outputs.cloudwatch.EventTargetEcsTargetPlacementConstraint[];
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
         */
        platformVersion?: string;
        /**
         * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
         */
        propagateTags?: string;
        /**
         * A map of tags to assign to ecs resources.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * The number of tasks to create based on the TaskDefinition. Defaults to `1`.
         */
        taskCount?: number;
        /**
         * The ARN of the task definition to use if the event target is an Amazon ECS cluster.
         */
        taskDefinitionArn: string;
    }
    interface EventTargetEcsTargetCapacityProviderStrategy {
        /**
         * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
         */
        weight?: number;
    }
    interface EventTargetEcsTargetNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
         */
        assignPublicIp?: boolean;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service.
         */
        subnets: string[];
    }
    interface EventTargetEcsTargetOrderedPlacementStrategy {
        /**
         * The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).
         */
        field?: string;
        /**
         * Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
         */
        type: string;
    }
    interface EventTargetEcsTargetPlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
         */
        type: string;
    }
    interface EventTargetHttpTarget {
        /**
         * Enables you to specify HTTP headers to add to the request.
         */
        headerParameters?: {
            [key: string]: string;
        };
        /**
         * The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*&#47;POST/pets/*`).
         */
        pathParameterValues?: string[];
        /**
         * Represents keys/values of query string parameters that are appended to the invoked endpoint.
         */
        queryStringParameters?: {
            [key: string]: string;
        };
    }
    interface EventTargetInputTransformer {
        /**
         * Key value pairs specified in the form of JSONPath (for example, time = $.time)
         * * You can have as many as 100 key-value pairs.
         * * You must use JSON dot notation, not bracket notation.
         * * The keys can't start with "AWS".
         */
        inputPaths?: {
            [key: string]: string;
        };
        /**
         * Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.
         */
        inputTemplate: string;
    }
    interface EventTargetKinesisTarget {
        /**
         * The JSON path to be extracted from the event and used as the partition key.
         */
        partitionKeyPath?: string;
    }
    interface EventTargetRedshiftTarget {
        /**
         * The name of the database.
         */
        database: string;
        /**
         * The database user name.
         */
        dbUser?: string;
        /**
         * The name or ARN of the secret that enables access to the database.
         */
        secretsManagerArn?: string;
        /**
         * The SQL statement text to run.
         */
        sql?: string;
        /**
         * The name of the SQL statement.
         */
        statementName?: string;
        /**
         * Indicates whether to send an event back to EventBridge after the SQL statement runs.
         */
        withEvent?: boolean;
    }
    interface EventTargetRetryPolicy {
        /**
         * The age in seconds to continue to make retry attempts.
         */
        maximumEventAgeInSeconds?: number;
        /**
         * maximum number of retry attempts to make before the request fails
         */
        maximumRetryAttempts?: number;
    }
    interface EventTargetRunCommandTarget {
        /**
         * Can be either `tag:tag-key` or `InstanceIds`.
         */
        key: string;
        /**
         * If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.
         */
        values: string[];
    }
    interface EventTargetSagemakerPipelineTarget {
        /**
         * List of Parameter names and values for SageMaker Model Building Pipeline execution.
         */
        pipelineParameterLists?: outputs.cloudwatch.EventTargetSagemakerPipelineTargetPipelineParameterList[];
    }
    interface EventTargetSagemakerPipelineTargetPipelineParameterList {
        /**
         * Name of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        name: string;
        /**
         * Value of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        value: string;
    }
    interface EventTargetSqsTarget {
        /**
         * The FIFO message group ID to use as the target.
         */
        messageGroupId?: string;
    }
    interface GetLogDataProtectionPolicyDocumentStatement {
        /**
         * Set of at least 1 sensitive data identifiers that you want to mask. Read more in [Types of data that you can protect](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/protect-sensitive-log-data-types.html).
         */
        dataIdentifiers: string[];
        /**
         * Configures the data protection operation applied by this statement.
         */
        operation: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperation;
        /**
         * Name of this statement.
         */
        sid?: string;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperation {
        /**
         * Configures the detection of sensitive data.
         */
        audit?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAudit;
        /**
         * Configures the masking of sensitive data.
         *
         * > Every policy statement must specify exactly one operation.
         */
        deidentify?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationDeidentify;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationAudit {
        /**
         * Configures destinations to send audit findings to.
         */
        findingsDestination: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestination;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestination {
        /**
         * Configures CloudWatch Logs as a findings destination.
         */
        cloudwatchLogs?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogs;
        /**
         * Configures Kinesis Firehose as a findings destination.
         */
        firehose?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehose;
        /**
         * Configures S3 as a findings destination.
         */
        s3?: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogs {
        /**
         * Name of the CloudWatch Log Group to send findings to.
         */
        logGroup: string;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehose {
        /**
         * Name of the Kinesis Firehose Delivery Stream to send findings to.
         */
        deliveryStream: string;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3 {
        /**
         * Name of the S3 Bucket to send findings to.
         */
        bucket: string;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationDeidentify {
        /**
         * An empty object that configures masking.
         */
        maskConfig: outputs.cloudwatch.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfig;
    }
    interface GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfig {
    }
    interface InternetMonitorHealthEventsConfig {
        /**
         * The health event threshold percentage set for availability scores.
         */
        availabilityScoreThreshold?: number;
        /**
         * The health event threshold percentage set for performance scores.
         */
        performanceScoreThreshold?: number;
    }
    interface InternetMonitorInternetMeasurementsLogDelivery {
        s3Config?: outputs.cloudwatch.InternetMonitorInternetMeasurementsLogDeliveryS3Config;
    }
    interface InternetMonitorInternetMeasurementsLogDeliveryS3Config {
        bucketName: string;
        bucketPrefix?: string;
        logDeliveryStatus?: string;
    }
    interface LogMetricFilterMetricTransformation {
        /**
         * The value to emit when a filter pattern does not match a log event. Conflicts with `dimensions`.
         */
        defaultValue?: string;
        /**
         * Map of fields to use as dimensions for the metric. Up to 3 dimensions are allowed. Conflicts with `defaultValue`.
         */
        dimensions?: {
            [key: string]: string;
        };
        /**
         * The name of the CloudWatch metric to which the monitored log information should be published (e.g., `ErrorCount`)
         */
        name: string;
        /**
         * The destination namespace of the CloudWatch metric.
         */
        namespace: string;
        /**
         * The unit to assign to the metric. If you omit this, the unit is set as `None`.
         */
        unit?: string;
        /**
         * What to publish to the metric. For example, if you're counting the occurrences of a particular term like "Error", the value will be "1" for each occurrence. If you're counting the bytes transferred the published value will be the value in the log event.
         */
        value: string;
    }
    interface MetricAlarmMetricQuery {
        /**
         * The ID of the account where the metrics are located, if this is a cross-account alarm.
         */
        accountId?: string;
        /**
         * The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the id of the other metrics to refer to those metrics, and can also use the id of other expressions to use the result of those expressions. For more information about metric math expressions, see Metric Math Syntax and Functions in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax).
         */
        expression?: string;
        /**
         * A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
         */
        id: string;
        /**
         * A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
         */
        label?: string;
        /**
         * The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
         */
        metric?: outputs.cloudwatch.MetricAlarmMetricQueryMetric;
        /**
         * Granularity in seconds of returned data points.
         * For metrics with regular resolution, valid values are any multiple of `60`.
         * For high-resolution metrics, valid values are `1`, `5`, `10`, `30`, or any multiple of `60`.
         */
        period?: number;
        /**
         * Specify exactly one `metricQuery` to be `true` to use that `metricQuery` result as the alarm.
         *
         * > **NOTE:**  You must specify either `metric` or `expression`. Not both.
         */
        returnData?: boolean;
    }
    interface MetricAlarmMetricQueryMetric {
        /**
         * The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        dimensions?: {
            [key: string]: string;
        };
        /**
         * The name for this metric.
         * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        metricName: string;
        /**
         * The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
         * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
         */
        namespace?: string;
        /**
         * Granularity in seconds of returned data points.
         * For metrics with regular resolution, valid values are any multiple of `60`.
         * For high-resolution metrics, valid values are `1`, `5`, `10`, `30`, or any multiple of `60`.
         */
        period: number;
        /**
         * The statistic to apply to this metric.
         * See docs for [supported statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
         */
        stat: string;
        /**
         * The unit for this metric.
         */
        unit?: string;
    }
    interface MetricStreamExcludeFilter {
        /**
         * An array that defines the metrics you want to exclude for this metric namespace
         */
        metricNames?: string[];
        /**
         * Name of the metric namespace in the filter.
         */
        namespace: string;
    }
    interface MetricStreamIncludeFilter {
        /**
         * An array that defines the metrics you want to include for this metric namespace
         */
        metricNames?: string[];
        /**
         * Name of the metric namespace in the filter.
         */
        namespace: string;
    }
    interface MetricStreamStatisticsConfiguration {
        additionalStatistics: string[];
        includeMetrics: outputs.cloudwatch.MetricStreamStatisticsConfigurationIncludeMetric[];
    }
    interface MetricStreamStatisticsConfigurationIncludeMetric {
        metricName: string;
        namespace: string;
    }
}
export declare namespace codeartifact {
    interface RepositoryExternalConnections {
        /**
         * The name of the external connection associated with a repository.
         */
        externalConnectionName: string;
        packageFormat: string;
        status: string;
    }
    interface RepositoryUpstream {
        /**
         * The name of an upstream repository.
         */
        repositoryName: string;
    }
}
export declare namespace codebuild {
    interface ProjectArtifacts {
        /**
         * Artifact identifier. Must be the same specified inside the AWS CodeBuild build specification.
         */
        artifactIdentifier?: string;
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. your CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting output artifacts. If `type` is set to `NO_ARTIFACTS`, this value is ignored. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Information about the build output artifact location. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored. If `type` is set to `S3`, this is the name of the output bucket.
         */
        location?: string;
        /**
         * Name of the project. If `type` is set to `S3`, this is the name of the output artifact object
         */
        name?: string;
        /**
         * Namespace to use in storing build artifacts. If `type` is set to `S3`, then valid values are `BUILD_ID`, `NONE`.
         */
        namespaceType?: string;
        /**
         * Whether a name specified in the build specification overrides the artifact name.
         */
        overrideArtifactName?: boolean;
        /**
         * Type of build output artifact to create. If `type` is set to `S3`, valid values are `NONE`, `ZIP`
         */
        packaging?: string;
        /**
         * If `type` is set to `S3`, this is the path to the output artifact.
         */
        path?: string;
        /**
         * Build output artifact's type. Valid values: `CODEPIPELINE`, `NO_ARTIFACTS`, `S3`.
         */
        type: string;
    }
    interface ProjectBuildBatchConfig {
        /**
         * Specifies if the build artifacts for the batch build should be combined into a single artifact location.
         */
        combineArtifacts?: boolean;
        /**
         * Configuration block specifying the restrictions for the batch build. Detailed below.
         */
        restrictions?: outputs.codebuild.ProjectBuildBatchConfigRestrictions;
        /**
         * Specifies the service role ARN for the batch build project.
         */
        serviceRole: string;
        /**
         * Specifies the maximum amount of time, in minutes, that the batch build must be completed in.
         */
        timeoutInMins?: number;
    }
    interface ProjectBuildBatchConfigRestrictions {
        /**
         * An array of strings that specify the compute types that are allowed for the batch build. See [Build environment compute types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the AWS CodeBuild User Guide for these values.
         */
        computeTypesAlloweds?: string[];
        /**
         * Specifies the maximum number of builds allowed.
         */
        maximumBuildsAllowed?: number;
    }
    interface ProjectCache {
        /**
         * Location where the AWS CodeBuild project stores cached resources. For type `S3`, the value must be a valid S3 bucket name/prefix.
         */
        location?: string;
        /**
         * Specifies settings that AWS CodeBuild uses to store and reuse build dependencies. Valid values:  `LOCAL_SOURCE_CACHE`, `LOCAL_DOCKER_LAYER_CACHE`, `LOCAL_CUSTOM_CACHE`.
         */
        modes?: string[];
        /**
         * Type of storage that will be used for the AWS CodeBuild project cache. Valid values: `NO_CACHE`, `LOCAL`, `S3`. Defaults to `NO_CACHE`.
         */
        type?: string;
    }
    interface ProjectEnvironment {
        /**
         * ARN of the S3 bucket, path prefix and object key that contains the PEM-encoded certificate.
         */
        certificate?: string;
        /**
         * Information about the compute resources the build project will use. Valid values: `BUILD_GENERAL1_SMALL`, `BUILD_GENERAL1_MEDIUM`, `BUILD_GENERAL1_LARGE`, `BUILD_GENERAL1_2XLARGE`, `BUILD_LAMBDA_1GB`, `BUILD_LAMBDA_2GB`, `BUILD_LAMBDA_4GB`, `BUILD_LAMBDA_8GB`, `BUILD_LAMBDA_10GB`. `BUILD_GENERAL1_SMALL` is only valid if `type` is set to `LINUX_CONTAINER`. When `type` is set to `LINUX_GPU_CONTAINER`, `computeType` must be `BUILD_GENERAL1_LARGE`. When `type` is set to `LINUX_LAMBDA_CONTAINER` or `ARM_LAMBDA_CONTAINER`, `computeType` must be `BUILD_LAMBDA_XGB`.`
         */
        computeType: string;
        /**
         * Configuration block. Detailed below.
         */
        environmentVariables?: outputs.codebuild.ProjectEnvironmentEnvironmentVariable[];
        /**
         * Docker image to use for this build project. Valid values include Docker images provided by CodeBuild, and full Docker repository URIs such as those for ECR (e.g., `137112412989.dkr.ecr.us-west-2.amazonaws.com/amazonlinux:latest`).
         */
        image: string;
        /**
         * Type of credentials AWS CodeBuild uses to pull images in your build. Valid values: `CODEBUILD`, `SERVICE_ROLE`. When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an AWS CodeBuild curated image, you must use CodeBuild credentials. Defaults to `CODEBUILD`.
         */
        imagePullCredentialsType?: string;
        /**
         * Whether to enable running the Docker daemon inside a Docker container. Defaults to `false`.
         */
        privilegedMode?: boolean;
        /**
         * Configuration block. Detailed below.
         */
        registryCredential?: outputs.codebuild.ProjectEnvironmentRegistryCredential;
        /**
         * Type of build environment to use for related builds. Valid values: `LINUX_CONTAINER`, `LINUX_GPU_CONTAINER`, `WINDOWS_CONTAINER` (deprecated), `WINDOWS_SERVER_2019_CONTAINER`, `ARM_CONTAINER`, `LINUX_LAMBDA_CONTAINER`, `ARM_LAMBDA_CONTAINER`. For additional information, see the [CodeBuild User Guide](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html).
         */
        type: string;
    }
    interface ProjectEnvironmentEnvironmentVariable {
        /**
         * Environment variable's name or key.
         */
        name: string;
        /**
         * Type of environment variable. Valid values: `PARAMETER_STORE`, `PLAINTEXT`, `SECRETS_MANAGER`.
         */
        type?: string;
        /**
         * Environment variable's value.
         */
        value: string;
    }
    interface ProjectEnvironmentRegistryCredential {
        /**
         * ARN or name of credentials created using AWS Secrets Manager.
         */
        credential: string;
        /**
         * Service that created the credentials to access a private Docker registry. Valid value: `SECRETS_MANAGER` (AWS Secrets Manager).
         */
        credentialProvider: string;
    }
    interface ProjectFileSystemLocation {
        /**
         * The name used to access a file system created by Amazon EFS. CodeBuild creates an environment variable by appending the identifier in all capital letters to CODEBUILD\_. For example, if you specify my-efs for identifier, a new environment variable is create named CODEBUILD_MY-EFS.
         */
        identifier?: string;
        /**
         * A string that specifies the location of the file system created by Amazon EFS. Its format is `efs-dns-name:/directory-path`.
         */
        location?: string;
        /**
         * The mount options for a file system created by AWS EFS.
         */
        mountOptions?: string;
        /**
         * The location in the container where you mount the file system.
         */
        mountPoint?: string;
        /**
         * The type of the file system. The one supported type is `EFS`.
         */
        type?: string;
    }
    interface ProjectLogsConfig {
        /**
         * Configuration block. Detailed below.
         */
        cloudwatchLogs?: outputs.codebuild.ProjectLogsConfigCloudwatchLogs;
        /**
         * Configuration block. Detailed below.
         */
        s3Logs?: outputs.codebuild.ProjectLogsConfigS3Logs;
    }
    interface ProjectLogsConfigCloudwatchLogs {
        /**
         * Group name of the logs in CloudWatch Logs.
         */
        groupName?: string;
        /**
         * Current status of logs in CloudWatch Logs for a build project. Valid values: `ENABLED`, `DISABLED`. Defaults to `ENABLED`.
         */
        status?: string;
        /**
         * Prefix of the log stream name of the logs in CloudWatch Logs.
         */
        streamName?: string;
    }
    interface ProjectLogsConfigS3Logs {
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. your CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting S3 logs. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Name of the S3 bucket and the path prefix for S3 logs. Must be set if status is `ENABLED`, otherwise it must be empty.
         */
        location?: string;
        /**
         * Current status of logs in S3 for a build project. Valid values: `ENABLED`, `DISABLED`. Defaults to `DISABLED`.
         */
        status?: string;
    }
    interface ProjectSecondaryArtifact {
        /**
         * Artifact identifier. Must be the same specified inside the AWS CodeBuild build specification.
         */
        artifactIdentifier: string;
        /**
         * Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. Valid values are `NONE`, `READ_ONLY`, and `FULL`. The CodeBuild service role must have the `s3:PutBucketAcl` permission. This permission allows CodeBuild to modify the access control list for the bucket.
         */
        bucketOwnerAccess?: string;
        /**
         * Whether to disable encrypting output artifacts. If `type` is set to `NO_ARTIFACTS`, this value is ignored. Defaults to `false`.
         */
        encryptionDisabled?: boolean;
        /**
         * Information about the build output artifact location. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the name of the output bucket. If `path` is not specified, `location` can specify the path of the output artifact in the output bucket.
         */
        location?: string;
        /**
         * Name of the project. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the name of the output artifact object.
         */
        name?: string;
        /**
         * Namespace to use in storing build artifacts. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, valid values are `BUILD_ID` or `NONE`.
         */
        namespaceType?: string;
        /**
         * Whether a name specified in the build specification overrides the artifact name.
         */
        overrideArtifactName?: boolean;
        /**
         * Type of build output artifact to create. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, valid values are `NONE` or `ZIP`.
         */
        packaging?: string;
        /**
         * Along with `namespaceType` and `name`, the pattern that AWS CodeBuild uses to name and store the output artifact. If `type` is set to `CODEPIPELINE` or `NO_ARTIFACTS`, this value is ignored if specified. If `type` is set to `S3`, this is the path to the output artifact.
         */
        path?: string;
        /**
         * Build output artifact's type. Valid values `CODEPIPELINE`, `NO_ARTIFACTS`, and `S3`.
         */
        type: string;
    }
    interface ProjectSecondarySource {
        /**
         * Configuration block that contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket. `buildStatusConfig` blocks are documented below.
         */
        buildStatusConfig?: outputs.codebuild.ProjectSecondarySourceBuildStatusConfig;
        /**
         * The build spec declaration to use for this build project's related builds. This must be set when `type` is `NO_SOURCE`. It can either be a path to a file residing in the repository to be built or a local file path leveraging the `file()` built-in.
         */
        buildspec?: string;
        /**
         * Truncate git history to this many commits. Use `0` for a `Full` checkout which you need to run commands like `git branch --show-current`. See [AWS CodePipeline User Guide: Tutorial: Use full clone with a GitHub pipeline source](https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-github-gitclone.html) for details.
         */
        gitCloneDepth?: number;
        /**
         * Configuration block. Detailed below.
         */
        gitSubmodulesConfig?: outputs.codebuild.ProjectSecondarySourceGitSubmodulesConfig;
        /**
         * Ignore SSL warnings when connecting to source control.
         */
        insecureSsl?: boolean;
        /**
         * Location of the source code from git or s3.
         */
        location?: string;
        /**
         * Whether to report the status of a build's start and finish to your source provider. This option is valid only when your source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket.
         */
        reportBuildStatus?: boolean;
        /**
         * An identifier for this project source. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
         */
        sourceIdentifier: string;
        /**
         * Type of repository that contains the source code to be built. Valid values: `BITBUCKET`, `CODECOMMIT`, `CODEPIPELINE`, `GITHUB`, `GITHUB_ENTERPRISE`, `GITLAB`, `GITLAB_SELF_MANAGED`, `NO_SOURCE`, `S3`.
         */
        type: string;
    }
    interface ProjectSecondarySourceBuildStatusConfig {
        /**
         * Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        context?: string;
        /**
         * Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        targetUrl?: string;
    }
    interface ProjectSecondarySourceGitSubmodulesConfig {
        /**
         * Whether to fetch Git submodules for the AWS CodeBuild build project.
         */
        fetchSubmodules: boolean;
    }
    interface ProjectSecondarySourceVersion {
        /**
         * An identifier for a source in the build project.
         */
        sourceIdentifier: string;
        /**
         * The source version for the corresponding source identifier. See [AWS docs](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_ProjectSourceVersion.html#CodeBuild-Type-ProjectSourceVersion-sourceVersion) for more details.
         */
        sourceVersion: string;
    }
    interface ProjectSource {
        /**
         * Configuration block that contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket. `buildStatusConfig` blocks are documented below.
         */
        buildStatusConfig?: outputs.codebuild.ProjectSourceBuildStatusConfig;
        /**
         * Build specification to use for this build project's related builds. This must be set when `type` is `NO_SOURCE`. Also, if a non-default buildspec file name or file path aside from the root is used, it must be specified.
         */
        buildspec?: string;
        /**
         * Truncate git history to this many commits. Use `0` for a `Full` checkout which you need to run commands like `git branch --show-current`. See [AWS CodePipeline User Guide: Tutorial: Use full clone with a GitHub pipeline source](https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-github-gitclone.html) for details.
         */
        gitCloneDepth?: number;
        /**
         * Configuration block. Detailed below.
         */
        gitSubmodulesConfig?: outputs.codebuild.ProjectSourceGitSubmodulesConfig;
        /**
         * Ignore SSL warnings when connecting to source control.
         */
        insecureSsl?: boolean;
        /**
         * Location of the source code from git or s3.
         */
        location?: string;
        /**
         * Whether to report the status of a build's start and finish to your source provider. This option is valid only when your source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket.
         */
        reportBuildStatus?: boolean;
        /**
         * Type of repository that contains the source code to be built. Valid values: `BITBUCKET`, `CODECOMMIT`, `CODEPIPELINE`, `GITHUB`, `GITHUB_ENTERPRISE`, `GITLAB`, `GITLAB_SELF_MANAGED`, `NO_SOURCE`, `S3`.
         */
        type: string;
    }
    interface ProjectSourceBuildStatusConfig {
        /**
         * Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        context?: string;
        /**
         * Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.
         */
        targetUrl?: string;
    }
    interface ProjectSourceGitSubmodulesConfig {
        /**
         * Whether to fetch Git submodules for the AWS CodeBuild build project.
         */
        fetchSubmodules: boolean;
    }
    interface ProjectVpcConfig {
        /**
         * Security group IDs to assign to running builds.
         */
        securityGroupIds: string[];
        /**
         * Subnet IDs within which to run builds.
         */
        subnets: string[];
        /**
         * ID of the VPC within which to run builds.
         */
        vpcId: string;
    }
    interface ReportGroupExportConfig {
        /**
         * contains information about the S3 bucket where the run of a report is exported. see S3 Destination documented below.
         */
        s3Destination?: outputs.codebuild.ReportGroupExportConfigS3Destination;
        /**
         * The export configuration type. Valid values are `S3` and `NO_EXPORT`.
         */
        type: string;
    }
    interface ReportGroupExportConfigS3Destination {
        /**
         * The name of the S3 bucket where the raw data of a report are exported.
         */
        bucket: string;
        /**
         * A boolean value that specifies if the results of a report are encrypted.
         * **Note: the API does not currently allow setting encryption as disabled**
         */
        encryptionDisabled?: boolean;
        /**
         * The encryption key for the report's encrypted raw data. The KMS key ARN.
         */
        encryptionKey: string;
        /**
         * The type of build output artifact to create. Valid values are: `NONE` (default) and `ZIP`.
         */
        packaging?: string;
        /**
         * The path to the exported report's raw data results.
         */
        path?: string;
    }
    interface WebhookFilterGroup {
        /**
         * A webhook filter for the group. Filter blocks are documented below.
         */
        filters?: outputs.codebuild.WebhookFilterGroupFilter[];
    }
    interface WebhookFilterGroupFilter {
        /**
         * If set to `true`, the specified filter does *not* trigger a build. Defaults to `false`.
         */
        excludeMatchedPattern?: boolean;
        /**
         * For a filter that uses `EVENT` type, a comma-separated string that specifies one event: `PUSH`, `PULL_REQUEST_CREATED`, `PULL_REQUEST_UPDATED`, `PULL_REQUEST_REOPENED`. `PULL_REQUEST_MERGED` works with GitHub & GitHub Enterprise only. For a filter that uses any of the other filter types, a regular expression.
         */
        pattern: string;
        /**
         * The webhook filter group's type. Valid values for this parameter are: `EVENT`, `BASE_REF`, `HEAD_REF`, `ACTOR_ACCOUNT_ID`, `FILE_PATH`, `COMMIT_MESSAGE`, `WORKFLOW_NAME`, `TAG_NAME`, `RELEASE_NAME`. At least one filter group must specify `EVENT` as its type.
         */
        type: string;
    }
}
export declare namespace codecatalyst {
    interface DevEnvironmentIdes {
        /**
         * The name of the IDE. Valid values include Cloud9, IntelliJ, PyCharm, GoLand, and VSCode.
         */
        name?: string;
        /**
         * A link to the IDE runtime image. This parameter is not required if the name is VSCode. Values of the runtime can be for example public.ecr.aws/jetbrains/py,public.ecr.aws/jetbrains/go
         */
        runtime?: string;
    }
    interface DevEnvironmentPersistentStorage {
        size: number;
    }
    interface DevEnvironmentRepository {
        /**
         * The name of the branch in a source repository.
         *
         * persistent storage (` persistentStorage`) supports the following:
         */
        branchName?: string;
        /**
         * The name of the source repository.
         */
        repositoryName: string;
    }
    interface GetDevEnvironmentIde {
        name: string;
        runtime: string;
    }
    interface GetDevEnvironmentPersistentStorage {
        size: number;
    }
    interface GetDevEnvironmentRepository {
        branchName: string;
        repositoryName: string;
    }
}
export declare namespace codecommit {
    interface TriggerTrigger {
        /**
         * The branches that will be included in the trigger configuration. If no branches   are specified, the trigger will apply to all branches.
         */
        branches?: string[];
        /**
         * Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
         */
        customData?: string;
        /**
         * The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
         */
        destinationArn: string;
        /**
         * The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS). If no events are specified, the trigger will run for all repository events. Event types include: `all`, `updateReference`, `createReference`, `deleteReference`.
         */
        events: string[];
        /**
         * The name of the trigger.
         */
        name: string;
    }
}
export declare namespace codedeploy {
    interface DeploymentConfigMinimumHealthyHosts {
        /**
         * The type can either be `FLEET_PERCENT` or `HOST_COUNT`.
         */
        type?: string;
        /**
         * The value when the type is `FLEET_PERCENT` represents the minimum number of healthy instances as
         * a percentage of the total number of instances in the deployment. If you specify FLEET_PERCENT, at the start of the
         * deployment, AWS CodeDeploy converts the percentage to the equivalent number of instance and rounds up fractional instances.
         * When the type is `HOST_COUNT`, the value represents the minimum number of healthy instances as an absolute value.
         */
        value?: number;
    }
    interface DeploymentConfigTrafficRoutingConfig {
        /**
         * The time based canary configuration information. If `type` is `TimeBasedLinear`, use `timeBasedLinear` instead.
         */
        timeBasedCanary?: outputs.codedeploy.DeploymentConfigTrafficRoutingConfigTimeBasedCanary;
        /**
         * The time based linear configuration information. If `type` is `TimeBasedCanary`, use `timeBasedCanary` instead.
         */
        timeBasedLinear?: outputs.codedeploy.DeploymentConfigTrafficRoutingConfigTimeBasedLinear;
        /**
         * Type of traffic routing config. One of `TimeBasedCanary`, `TimeBasedLinear`, `AllAtOnce`.
         */
        type?: string;
    }
    interface DeploymentConfigTrafficRoutingConfigTimeBasedCanary {
        /**
         * The number of minutes between the first and second traffic shifts of a `TimeBasedCanary` deployment.
         */
        interval?: number;
        /**
         * The percentage of traffic to shift in the first increment of a `TimeBasedCanary` deployment.
         */
        percentage?: number;
    }
    interface DeploymentConfigTrafficRoutingConfigTimeBasedLinear {
        /**
         * The number of minutes between each incremental traffic shift of a `TimeBasedLinear` deployment.
         */
        interval?: number;
        /**
         * The percentage of traffic that is shifted at the start of each increment of a `TimeBasedLinear` deployment.
         */
        percentage?: number;
    }
    interface DeploymentGroupAlarmConfiguration {
        /**
         * A list of alarms configured for the deployment group. _A maximum of 10 alarms can be added to a deployment group_.
         */
        alarms?: string[];
        /**
         * Indicates whether the alarm configuration is enabled. This option is useful when you want to temporarily deactivate alarm monitoring for a deployment group without having to add the same alarms again later.
         */
        enabled?: boolean;
        /**
         * Indicates whether a deployment should continue if information about the current state of alarms cannot be retrieved from CloudWatch. The default value is `false`.
         */
        ignorePollAlarmFailure?: boolean;
    }
    interface DeploymentGroupAutoRollbackConfiguration {
        /**
         * Indicates whether a defined automatic rollback configuration is currently enabled for this Deployment Group. If you enable automatic rollback, you must specify at least one event type.
         */
        enabled?: boolean;
        /**
         * The event type or types that trigger a rollback. Supported types are `DEPLOYMENT_FAILURE`, `DEPLOYMENT_STOP_ON_ALARM` and `DEPLOYMENT_STOP_ON_REQUEST`.
         *
         * _Only one `autoRollbackConfiguration` is allowed_.
         */
        events?: string[];
    }
    interface DeploymentGroupBlueGreenDeploymentConfig {
        /**
         * Information about the action to take when newly provisioned instances are ready to receive traffic in a blue/green deployment (documented below).
         */
        deploymentReadyOption?: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigDeploymentReadyOption;
        /**
         * Information about how instances are provisioned for a replacement environment in a blue/green deployment (documented below).
         */
        greenFleetProvisioningOption: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigGreenFleetProvisioningOption;
        /**
         * Information about whether to terminate instances in the original fleet during a blue/green deployment (documented below).
         *
         * _Only one `blueGreenDeploymentConfig` is allowed_.
         */
        terminateBlueInstancesOnDeploymentSuccess?: outputs.codedeploy.DeploymentGroupBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess;
    }
    interface DeploymentGroupBlueGreenDeploymentConfigDeploymentReadyOption {
        /**
         * When to reroute traffic from an original environment to a replacement environment in a blue/green deployment.
         * * `CONTINUE_DEPLOYMENT`: Register new instances with the load balancer immediately after the new application revision is installed on the instances in the replacement environment.
         * * `STOP_DEPLOYMENT`: Do not register new instances with load balancer unless traffic is rerouted manually. If traffic is not rerouted manually before the end of the specified wait period, the deployment status is changed to Stopped.
         */
        actionOnTimeout?: string;
        /**
         * The number of minutes to wait before the status of a blue/green deployment changed to Stopped if rerouting is not started manually. Applies only to the `STOP_DEPLOYMENT` option for `actionOnTimeout`.
         */
        waitTimeInMinutes?: number;
    }
    interface DeploymentGroupBlueGreenDeploymentConfigGreenFleetProvisioningOption {
        /**
         * The method used to add instances to a replacement environment.
         * * `DISCOVER_EXISTING`: Use instances that already exist or will be created manually.
         * * `COPY_AUTO_SCALING_GROUP`: Use settings from a specified **Auto Scaling** group to define and create instances in a new Auto Scaling group. _Exactly one Auto Scaling group must be specified_ when selecting `COPY_AUTO_SCALING_GROUP`. Use `autoscalingGroups` to specify the Auto Scaling group.
         */
        action?: string;
    }
    interface DeploymentGroupBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess {
        /**
         * The action to take on instances in the original environment after a successful blue/green deployment.
         * * `TERMINATE`: Instances are terminated after a specified wait time.
         * * `KEEP_ALIVE`: Instances are left running after they are deregistered from the load balancer and removed from the deployment group.
         */
        action?: string;
        /**
         * The number of minutes to wait after a successful blue/green deployment before terminating instances from the original environment.
         */
        terminationWaitTimeInMinutes?: number;
    }
    interface DeploymentGroupDeploymentStyle {
        /**
         * Indicates whether to route deployment traffic behind a load balancer. Valid Values are `WITH_TRAFFIC_CONTROL` or `WITHOUT_TRAFFIC_CONTROL`. Default is `WITHOUT_TRAFFIC_CONTROL`.
         */
        deploymentOption?: string;
        /**
         * Indicates whether to run an in-place deployment or a blue/green deployment. Valid Values are `IN_PLACE` or `BLUE_GREEN`. Default is `IN_PLACE`.
         *
         * _Only one `deploymentStyle` is allowed_.
         */
        deploymentType?: string;
    }
    interface DeploymentGroupEc2TagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         *
         * Multiple occurrences of `ec2TagFilter` are allowed, where any instance that matches to at least one of the tag filters is selected.
         */
        value?: string;
    }
    interface DeploymentGroupEc2TagSet {
        /**
         * Tag filters associated with the deployment group. See the AWS docs for details.
         */
        ec2TagFilters?: outputs.codedeploy.DeploymentGroupEc2TagSetEc2TagFilter[];
    }
    interface DeploymentGroupEc2TagSetEc2TagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         *
         * Multiple occurrences of `ec2TagFilter` are allowed, where any instance that matches to at least one of the tag filters is selected.
         */
        value?: string;
    }
    interface DeploymentGroupEcsService {
        /**
         * The name of the ECS cluster.
         */
        clusterName: string;
        /**
         * The name of the ECS service.
         */
        serviceName: string;
    }
    interface DeploymentGroupLoadBalancerInfo {
        /**
         * The Classic Elastic Load Balancer to use in a deployment. Conflicts with `targetGroupInfo` and `targetGroupPairInfo`.
         */
        elbInfos?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoElbInfo[];
        /**
         * The (Application/Network Load Balancer) target group to use in a deployment. Conflicts with `elbInfo` and `targetGroupPairInfo`.
         */
        targetGroupInfos?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupInfo[];
        /**
         * The (Application/Network Load Balancer) target group pair to use in a deployment. Conflicts with `elbInfo` and `targetGroupInfo`.
         */
        targetGroupPairInfo?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfo;
    }
    interface DeploymentGroupLoadBalancerInfoElbInfo {
        /**
         * The name of the load balancer that will be used to route traffic from original instances to replacement instances in a blue/green deployment. For in-place deployments, the name of the load balancer that instances are deregistered from so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
         */
        name?: string;
    }
    interface DeploymentGroupLoadBalancerInfoTargetGroupInfo {
        /**
         * The name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
         */
        name?: string;
    }
    interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfo {
        /**
         * Configuration block for the production traffic route (documented below).
         */
        prodTrafficRoute: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute;
        /**
         * Configuration blocks for a target group within a target group pair (documented below).
         */
        targetGroups: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTargetGroup[];
        /**
         * Configuration block for the test traffic route (documented below).
         */
        testTrafficRoute?: outputs.codedeploy.DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute;
    }
    interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute {
        /**
         * List of Amazon Resource Names (ARNs) of the load balancer listeners. Must contain exactly one listener ARN.
         */
        listenerArns: string[];
    }
    interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTargetGroup {
        /**
         * Name of the target group.
         */
        name: string;
    }
    interface DeploymentGroupLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute {
        /**
         * List of Amazon Resource Names (ARNs) of the load balancer listeners.
         */
        listenerArns: string[];
    }
    interface DeploymentGroupOnPremisesInstanceTagFilter {
        /**
         * The key of the tag filter.
         */
        key?: string;
        /**
         * The type of the tag filter, either `KEY_ONLY`, `VALUE_ONLY`, or `KEY_AND_VALUE`.
         */
        type?: string;
        /**
         * The value of the tag filter.
         */
        value?: string;
    }
    interface DeploymentGroupTriggerConfiguration {
        /**
         * The event type or types for which notifications are triggered. Some values that are supported: `DeploymentStart`, `DeploymentSuccess`, `DeploymentFailure`, `DeploymentStop`, `DeploymentRollback`, `InstanceStart`, `InstanceSuccess`, `InstanceFailure`.  See [the CodeDeploy documentation](http://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-sns-event-notifications-create-trigger.html) for all possible values.
         */
        triggerEvents: string[];
        /**
         * The name of the notification trigger.
         */
        triggerName: string;
        /**
         * The ARN of the SNS topic through which notifications are sent.
         */
        triggerTargetArn: string;
    }
}
export declare namespace codeguruprofiler {
    interface GetProfilingGroupAgentOrchestrationConfig {
        profilingEnabled: boolean;
    }
    interface GetProfilingGroupProfilingStatus {
        latestAgentOrchestratedAt: string;
        latestAgentProfileReportedAt: string;
        latestAggregatedProfiles: any[];
    }
    interface ProfilingGroupAgentOrchestrationConfig {
        /**
         * (Required) Boolean that specifies whether the profiling agent collects profiling data or
         */
        profilingEnabled: boolean;
    }
}
export declare namespace codegurureviewer {
    interface RepositoryAssociationKmsKeyDetails {
        /**
         * The encryption option for a repository association. It is either owned by AWS Key Management Service (KMS) (`AWS_OWNED_CMK`) or customer managed (`CUSTOMER_MANAGED_CMK`).
         */
        encryptionOption?: string;
        /**
         * The ID of the AWS KMS key that is associated with a repository association.
         */
        kmsKeyId?: string;
    }
    interface RepositoryAssociationRepository {
        bitbucket?: outputs.codegurureviewer.RepositoryAssociationRepositoryBitbucket;
        codecommit?: outputs.codegurureviewer.RepositoryAssociationRepositoryCodecommit;
        githubEnterpriseServer?: outputs.codegurureviewer.RepositoryAssociationRepositoryGithubEnterpriseServer;
        s3Bucket?: outputs.codegurureviewer.RepositoryAssociationRepositoryS3Bucket;
    }
    interface RepositoryAssociationRepositoryBitbucket {
        /**
         * The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection.
         */
        connectionArn: string;
        /**
         * The name of the third party source repository.
         */
        name: string;
        /**
         * The username for the account that owns the repository.
         */
        owner: string;
    }
    interface RepositoryAssociationRepositoryCodecommit {
        /**
         * The name of the AWS CodeCommit repository.
         */
        name: string;
    }
    interface RepositoryAssociationRepositoryGithubEnterpriseServer {
        /**
         * The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection.
         */
        connectionArn: string;
        /**
         * The name of the third party source repository.
         */
        name: string;
        /**
         * The username for the account that owns the repository.
         */
        owner: string;
    }
    interface RepositoryAssociationRepositoryS3Bucket {
        /**
         * The name of the S3 bucket used for associating a new S3 repository. Note: The name must begin with `codeguru-reviewer-`.
         */
        bucketName: string;
        /**
         * The name of the repository in the S3 bucket.
         */
        name: string;
    }
    interface RepositoryAssociationS3RepositoryDetail {
        bucketName: string;
        codeArtifacts: outputs.codegurureviewer.RepositoryAssociationS3RepositoryDetailCodeArtifact[];
    }
    interface RepositoryAssociationS3RepositoryDetailCodeArtifact {
        buildArtifactsObjectKey: string;
        sourceCodeArtifactsObjectKey: string;
    }
}
export declare namespace codepipeline {
    interface CustomActionTypeConfigurationProperty {
        /**
         * The description of the action configuration property.
         */
        description?: string;
        /**
         * Whether the configuration property is a key.
         */
        key: boolean;
        /**
         * The name of the action configuration property.
         */
        name: string;
        /**
         * Indicates that the property will be used in conjunction with PollForJobs.
         */
        queryable?: boolean;
        /**
         * Whether the configuration property is a required value.
         */
        required: boolean;
        /**
         * Whether the configuration property is secret.
         */
        secret: boolean;
        /**
         * The type of the configuration property. Valid values: `String`, `Number`, `Boolean`
         */
        type?: string;
    }
    interface CustomActionTypeInputArtifactDetails {
        /**
         * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        maximumCount: number;
        /**
         * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        minimumCount: number;
    }
    interface CustomActionTypeOutputArtifactDetails {
        /**
         * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        maximumCount: number;
        /**
         * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
         */
        minimumCount: number;
    }
    interface CustomActionTypeSettings {
        /**
         * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
         */
        entityUrlTemplate?: string;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
         */
        executionUrlTemplate?: string;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
         */
        revisionUrlTemplate?: string;
        /**
         * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
         */
        thirdPartyConfigurationUrl?: string;
    }
    interface PipelineArtifactStore {
        /**
         * The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An `encryptionKey` block is documented below.
         */
        encryptionKey?: outputs.codepipeline.PipelineArtifactStoreEncryptionKey;
        /**
         * The location where AWS CodePipeline stores artifacts for a pipeline; currently only `S3` is supported.
         */
        location: string;
        /**
         * The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
         */
        region?: string;
        /**
         * The type of the artifact store, such as Amazon S3
         */
        type: string;
    }
    interface PipelineArtifactStoreEncryptionKey {
        /**
         * The KMS key ARN or ID
         */
        id: string;
        /**
         * The type of key; currently only `KMS` is supported
         */
        type: string;
    }
    interface PipelineStage {
        /**
         * The action(s) to include in the stage. Defined as an `action` block below
         */
        actions: outputs.codepipeline.PipelineStageAction[];
        /**
         * The name of the stage.
         */
        name: string;
    }
    interface PipelineStageAction {
        /**
         * A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are `Approval`, `Build`, `Deploy`, `Invoke`, `Source` and `Test`.
         */
        category: string;
        /**
         * A map of the action declaration's configuration. Configurations options for action types and providers can be found in the [Pipeline Structure Reference](http://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements) and [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
         */
        configuration?: {
            [key: string]: string;
        };
        /**
         * A list of artifact names to be worked on.
         */
        inputArtifacts?: string[];
        /**
         * The action declaration's name.
         */
        name: string;
        /**
         * The namespace all output variables will be accessed from.
         */
        namespace?: string;
        /**
         * A list of artifact names to output. Output artifact names must be unique within a pipeline.
         */
        outputArtifacts?: string[];
        /**
         * The creator of the action being called. Possible values are `AWS`, `Custom` and `ThirdParty`.
         */
        owner: string;
        /**
         * The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
         */
        provider: string;
        /**
         * The region in which to run the action.
         */
        region: string;
        /**
         * The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
         */
        roleArn?: string;
        /**
         * The order in which actions are run.
         */
        runOrder: number;
        /**
         * A string that identifies the action type.
         */
        version: string;
    }
    interface PipelineTrigger {
        /**
         * Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `gitConfiguration` block is documented below.
         */
        gitConfiguration: outputs.codepipeline.PipelineTriggerGitConfiguration;
        /**
         * The source provider for the event. Possible value is `CodeStarSourceConnection`.
         */
        providerType: string;
    }
    interface PipelineTriggerGitConfiguration {
        /**
         * The field where the repository event that will start the pipeline is specified as pull requests. A `pullRequest` block is documented below.
         */
        pullRequests?: outputs.codepipeline.PipelineTriggerGitConfigurationPullRequest[];
        /**
         * The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
         */
        pushes?: outputs.codepipeline.PipelineTriggerGitConfigurationPush[];
        /**
         * The name of the pipeline source action where the trigger configuration.
         */
        sourceActionName: string;
    }
    interface PipelineTriggerGitConfigurationPullRequest {
        /**
         * The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
         */
        branches?: outputs.codepipeline.PipelineTriggerGitConfigurationPullRequestBranches;
        /**
         * A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
         */
        events?: string[];
        /**
         * The field that specifies to filter on file paths for the pull request trigger configuration. A `filePaths` block is documented below.
         */
        filePaths?: outputs.codepipeline.PipelineTriggerGitConfigurationPullRequestFilePaths;
    }
    interface PipelineTriggerGitConfigurationPullRequestBranches {
        /**
         * A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
         */
        excludes?: string[];
        /**
         * A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
         */
        includes?: string[];
    }
    interface PipelineTriggerGitConfigurationPullRequestFilePaths {
        /**
         * A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
         */
        excludes?: string[];
        /**
         * A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
         */
        includes?: string[];
    }
    interface PipelineTriggerGitConfigurationPush {
        /**
         * The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
         */
        branches?: outputs.codepipeline.PipelineTriggerGitConfigurationPushBranches;
        /**
         * The field that specifies to filter on file paths for the push trigger configuration. A `filePaths` block is documented below.
         */
        filePaths?: outputs.codepipeline.PipelineTriggerGitConfigurationPushFilePaths;
        /**
         * The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
         */
        tags?: outputs.codepipeline.PipelineTriggerGitConfigurationPushTags;
    }
    interface PipelineTriggerGitConfigurationPushBranches {
        /**
         * A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
         */
        excludes?: string[];
        /**
         * A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
         */
        includes?: string[];
    }
    interface PipelineTriggerGitConfigurationPushFilePaths {
        /**
         * A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
         */
        excludes?: string[];
        /**
         * A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
         */
        includes?: string[];
    }
    interface PipelineTriggerGitConfigurationPushTags {
        /**
         * A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
         */
        excludes?: string[];
        /**
         * A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
         */
        includes?: string[];
    }
    interface PipelineVariable {
        /**
         * The default value of a pipeline-level variable.
         */
        defaultValue?: string;
        /**
         * The description of a pipeline-level variable.
         *
         * > **Note:** The input artifact of an action must exactly match the output artifact declared in a preceding action, but the input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions.
         */
        description?: string;
        /**
         * The name of a pipeline-level variable.
         */
        name: string;
    }
    interface WebhookAuthenticationConfiguration {
        /**
         * A valid CIDR block for `IP` filtering. Required for `IP`.
         */
        allowedIpRange?: string;
        /**
         * The shared secret for the GitHub repository webhook. Set this as `secret` in your `githubRepositoryWebhook`'s `configuration` block. Required for `GITHUB_HMAC`.
         */
        secretToken?: string;
    }
    interface WebhookFilter {
        /**
         * The [JSON path](https://github.com/json-path/JsonPath) to filter on.
         */
        jsonPath: string;
        /**
         * The value to match on (e.g., `refs/heads/{Branch}`). See [AWS docs](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_WebhookFilterRule.html) for details.
         */
        matchEquals: string;
    }
}
export declare namespace codestarconnections {
    interface HostVpcConfiguration {
        /**
         * ID of the security group or security groups associated with the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnet or subnets associated with the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        subnetIds: string[];
        /**
         * The value of the Transport Layer Security (TLS) certificate associated with the infrastructure where your provider type is installed.
         */
        tlsCertificate?: string;
        /**
         * The ID of the Amazon VPC connected to the infrastructure where your provider type is installed.
         */
        vpcId: string;
    }
}
export declare namespace codestarnotifications {
    interface NotificationRuleTarget {
        /**
         * The ARN of notification rule target. For example, a SNS Topic ARN.
         */
        address: string;
        /**
         * The status of the notification rule. Possible values are `ENABLED` and `DISABLED`, default is `ENABLED`.
         */
        status: string;
        /**
         * The type of the notification target. Default value is `SNS`.
         */
        type?: string;
    }
}
export declare namespace cognito {
    interface GetIdentityPoolCognitoIdentityProvider {
        clientId: string;
        providerName: string;
        serverSideTokenCheck: boolean;
    }
    interface GetUserGroupsGroup {
        /**
         * Description of the user group.
         */
        description: string;
        /**
         * Name of the user group.
         */
        groupName: string;
        /**
         * Precedence of the user group.
         */
        precedence: number;
        /**
         * ARN of the IAM role to be associated with the user group.
         */
        roleArn: string;
    }
    interface GetUserPoolClientAnalyticsConfiguration {
        /**
         * (Optional) Application ARN for an Amazon Pinpoint application. Conflicts with `externalId` and `roleArn`.
         */
        applicationArn: string;
        /**
         * (Optional) Application ID for an Amazon Pinpoint application.
         */
        applicationId: string;
        /**
         * (Optional) ID for the Analytics Configuration. Conflicts with `applicationArn`.
         */
        externalId: string;
        /**
         * (Optional) ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * (Optional) If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }
    interface GetUserPoolClientTokenValidityUnit {
        /**
         * (Optional) Time unit in for the value in `accessTokenValidity`, defaults to `hours`.
         */
        accessToken: string;
        /**
         * (Optional) Time unit in for the value in `idTokenValidity`, defaults to `hours`.
         */
        idToken: string;
        /**
         * (Optional) Time unit in for the value in `refreshTokenValidity`, defaults to `days`.
         */
        refreshToken: string;
    }
    interface IdentityPoolCognitoIdentityProvider {
        /**
         * The client ID for the Amazon Cognito Identity User Pool.
         */
        clientId?: string;
        /**
         * The provider name for an Amazon Cognito Identity User Pool.
         */
        providerName?: string;
        /**
         * Whether server-side token validation is enabled for the identity provider’s token or not.
         */
        serverSideTokenCheck?: boolean;
    }
    interface IdentityPoolRoleAttachmentRoleMapping {
        ambiguousRoleResolution?: string;
        identityProvider: string;
        mappingRules?: outputs.cognito.IdentityPoolRoleAttachmentRoleMappingMappingRule[];
        type: string;
    }
    interface IdentityPoolRoleAttachmentRoleMappingMappingRule {
        claim: string;
        matchType: string;
        roleArn: string;
        value: string;
    }
    interface ManagedUserPoolClientAnalyticsConfiguration {
        /**
         * Application ARN for an Amazon Pinpoint application. It conflicts with `externalId` and `roleArn`.
         */
        applicationArn?: string;
        /**
         * Unique identifier for an Amazon Pinpoint application.
         */
        applicationId?: string;
        /**
         * ID for the Analytics Configuration and conflicts with `applicationArn`.
         */
        externalId?: string;
        /**
         * ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. It conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * If `userDataShared` is set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }
    interface ManagedUserPoolClientTokenValidityUnits {
        /**
         * Time unit for the value in `accessTokenValidity` and defaults to `hours`.
         */
        accessToken: string;
        /**
         * Time unit for the value in `idTokenValidity`, and it defaults to `hours`.
         */
        idToken: string;
        /**
         * Time unit for the value in `refreshTokenValidity` and defaults to `days`.
         */
        refreshToken: string;
    }
    interface ResourceServerScope {
        scopeDescription: string;
        scopeName: string;
    }
    interface RiskConfigurationAccountTakeoverRiskConfiguration {
        /**
         * Account takeover risk configuration actions. See details below.
         */
        actions: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActions;
        /**
         * The notify configuration used to construct email notifications. See details below.
         */
        notifyConfiguration: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationActions {
        /**
         * Action to take for a high risk. See action block below.
         */
        highAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction;
        /**
         * Action to take for a low risk. See action block below.
         */
        lowAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction;
        /**
         * Action to take for a medium risk. See action block below.
         */
        mediumAction?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction {
        eventAction: string;
        notify: boolean;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction {
        eventAction: string;
        notify: boolean;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction {
        eventAction: string;
        notify: boolean;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration {
        /**
         * Email template used when a detected risk event is blocked. See notify email type below.
         */
        blockEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail;
        /**
         * The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
         */
        from?: string;
        /**
         * The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
         */
        mfaEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail;
        /**
         * The email template used when a detected risk event is allowed. See notify email type below.
         */
        noActionEmail?: outputs.cognito.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail;
        /**
         * The destination to which the receiver of an email should reply to.
         */
        replyTo?: string;
        /**
         * The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
         */
        sourceArn: string;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail {
        htmlBody: string;
        subject: string;
        textBody: string;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail {
        htmlBody: string;
        subject: string;
        textBody: string;
    }
    interface RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail {
        htmlBody: string;
        subject: string;
        textBody: string;
    }
    interface RiskConfigurationCompromisedCredentialsRiskConfiguration {
        /**
         * The compromised credentials risk configuration actions. See details below.
         */
        actions: outputs.cognito.RiskConfigurationCompromisedCredentialsRiskConfigurationActions;
        /**
         * Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are `SIGN_IN`, `PASSWORD_CHANGE`, and `SIGN_UP`.
         */
        eventFilters: string[];
    }
    interface RiskConfigurationCompromisedCredentialsRiskConfigurationActions {
        /**
         * The event action. Valid values are `BLOCK` or `NO_ACTION`.
         */
        eventAction: string;
    }
    interface RiskConfigurationRiskExceptionConfiguration {
        /**
         * Overrides the risk decision to always block the pre-authentication requests.
         * The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
         * Can contain a maximum of 200 items.
         */
        blockedIpRangeLists?: string[];
        /**
         * Risk detection isn't performed on the IP addresses in this range list.
         * The IP range is in CIDR notation.
         * Can contain a maximum of 200 items.
         */
        skippedIpRangeLists?: string[];
    }
    interface UserPoolAccountRecoverySetting {
        /**
         * List of Account Recovery Options of the following structure:
         */
        recoveryMechanisms: outputs.cognito.UserPoolAccountRecoverySettingRecoveryMechanism[];
    }
    interface UserPoolAccountRecoverySettingRecoveryMechanism {
        /**
         * Recovery method for a user. Can be of the following: `verifiedEmail`, `verifiedPhoneNumber`, and `adminOnly`.
         */
        name: string;
        /**
         * Positive integer specifying priority of a method with 1 being the highest priority.
         */
        priority: number;
    }
    interface UserPoolAdminCreateUserConfig {
        /**
         * Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
         */
        allowAdminCreateUserOnly?: boolean;
        /**
         * Invite message template structure. Detailed below.
         */
        inviteMessageTemplate?: outputs.cognito.UserPoolAdminCreateUserConfigInviteMessageTemplate;
    }
    interface UserPoolAdminCreateUserConfigInviteMessageTemplate {
        /**
         * Message template for email messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
         */
        emailMessage?: string;
        /**
         * Subject line for email messages.
         */
        emailSubject?: string;
        /**
         * Message template for SMS messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
         */
        smsMessage?: string;
    }
    interface UserPoolClientAnalyticsConfiguration {
        /**
         * Application ARN for an Amazon Pinpoint application. Conflicts with `externalId` and `roleArn`.
         */
        applicationArn?: string;
        /**
         * Application ID for an Amazon Pinpoint application.
         */
        applicationId?: string;
        /**
         * ID for the Analytics Configuration. Conflicts with `applicationArn`.
         */
        externalId?: string;
        /**
         * ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `applicationArn`.
         */
        roleArn: string;
        /**
         * If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
         */
        userDataShared: boolean;
    }
    interface UserPoolClientTokenValidityUnits {
        /**
         * Time unit in for the value in `accessTokenValidity`, defaults to `hours`.
         */
        accessToken: string;
        /**
         * Time unit in for the value in `idTokenValidity`, defaults to `hours`.
         */
        idToken: string;
        /**
         * Time unit in for the value in `refreshTokenValidity`, defaults to `days`.
         */
        refreshToken: string;
    }
    interface UserPoolDeviceConfiguration {
        /**
         * Whether a challenge is required on a new device. Only applicable to a new device.
         */
        challengeRequiredOnNewDevice?: boolean;
        /**
         * Whether a device is only remembered on user prompt. `false` equates to "Always" remember, `true` is "User Opt In," and not using a `deviceConfiguration` block is "No."
         */
        deviceOnlyRememberedOnUserPrompt?: boolean;
    }
    interface UserPoolEmailConfiguration {
        /**
         * Email configuration set name from SES.
         */
        configurationSet?: string;
        /**
         * Email delivery method to use. `COGNITO_DEFAULT` for the default email functionality built into Cognito or `DEVELOPER` to use your Amazon SES configuration. Required to be `DEVELOPER` if `fromEmailAddress` is set.
         */
        emailSendingAccount?: string;
        /**
         * Sender’s email address or sender’s display name with their email address (e.g., `john@example.com`, `John Smith <john@example.com>` or `\"John Smith Ph.D.\" <john@example.com>`). Escaped double quotes are required around display names that contain certain characters as specified in [RFC 5322](https://tools.ietf.org/html/rfc5322).
         */
        fromEmailAddress?: string;
        /**
         * REPLY-TO email address.
         */
        replyToEmailAddress?: string;
        /**
         * ARN of the SES verified email identity to use. Required if `emailSendingAccount` is set to `DEVELOPER`.
         */
        sourceArn?: string;
    }
    interface UserPoolLambdaConfig {
        /**
         * ARN of the lambda creating an authentication challenge.
         */
        createAuthChallenge?: string;
        /**
         * A custom email sender AWS Lambda trigger. See customEmailSender Below.
         */
        customEmailSender?: outputs.cognito.UserPoolLambdaConfigCustomEmailSender;
        /**
         * Custom Message AWS Lambda trigger.
         */
        customMessage?: string;
        /**
         * A custom SMS sender AWS Lambda trigger. See customSmsSender Below.
         */
        customSmsSender?: outputs.cognito.UserPoolLambdaConfigCustomSmsSender;
        /**
         * Defines the authentication challenge.
         */
        defineAuthChallenge?: string;
        /**
         * The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
         */
        kmsKeyId?: string;
        /**
         * Post-authentication AWS Lambda trigger.
         */
        postAuthentication?: string;
        /**
         * Post-confirmation AWS Lambda trigger.
         */
        postConfirmation?: string;
        /**
         * Pre-authentication AWS Lambda trigger.
         */
        preAuthentication?: string;
        /**
         * Pre-registration AWS Lambda trigger.
         */
        preSignUp?: string;
        /**
         * Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambdaArn of `preTokenGenerationConfig`.
         */
        preTokenGeneration: string;
        /**
         * Allow to customize access tokens. See pre_token_configuration_type
         */
        preTokenGenerationConfig: outputs.cognito.UserPoolLambdaConfigPreTokenGenerationConfig;
        /**
         * User migration Lambda config type.
         */
        userMigration?: string;
        /**
         * Verifies the authentication challenge response.
         */
        verifyAuthChallengeResponse?: string;
    }
    interface UserPoolLambdaConfigCustomEmailSender {
        /**
         * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
         */
        lambdaArn: string;
        /**
         * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is `V1_0`.
         */
        lambdaVersion: string;
    }
    interface UserPoolLambdaConfigCustomSmsSender {
        /**
         * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
         */
        lambdaArn: string;
        /**
         * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is `V1_0`.
         */
        lambdaVersion: string;
    }
    interface UserPoolLambdaConfigPreTokenGenerationConfig {
        lambdaArn: string;
        lambdaVersion: string;
    }
    interface UserPoolPasswordPolicy {
        /**
         * Minimum length of the password policy that you have set.
         */
        minimumLength?: number;
        /**
         * Whether you have required users to use at least one lowercase letter in their password.
         */
        requireLowercase?: boolean;
        /**
         * Whether you have required users to use at least one number in their password.
         */
        requireNumbers?: boolean;
        /**
         * Whether you have required users to use at least one symbol in their password.
         */
        requireSymbols?: boolean;
        /**
         * Whether you have required users to use at least one uppercase letter in their password.
         */
        requireUppercase?: boolean;
        /**
         * In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
         */
        temporaryPasswordValidityDays?: number;
    }
    interface UserPoolSchema {
        /**
         * Attribute data type. Must be one of `Boolean`, `Number`, `String`, `DateTime`.
         */
        attributeDataType: string;
        /**
         * Whether the attribute type is developer only.
         */
        developerOnlyAttribute?: boolean;
        /**
         * Whether the attribute can be changed once it has been created.
         */
        mutable?: boolean;
        /**
         * Name of the attribute.
         */
        name: string;
        /**
         * Configuration block for the constraints for an attribute of the number type. Detailed below.
         */
        numberAttributeConstraints?: outputs.cognito.UserPoolSchemaNumberAttributeConstraints;
        /**
         * Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
         */
        required?: boolean;
        /**
         * Constraints for an attribute of the string type. Detailed below.
         */
        stringAttributeConstraints?: outputs.cognito.UserPoolSchemaStringAttributeConstraints;
    }
    interface UserPoolSchemaNumberAttributeConstraints {
        /**
         * Maximum value of an attribute that is of the number data type.
         */
        maxValue?: string;
        /**
         * Minimum value of an attribute that is of the number data type.
         */
        minValue?: string;
    }
    interface UserPoolSchemaStringAttributeConstraints {
        /**
         * Maximum length of an attribute value of the string type.
         */
        maxLength?: string;
        /**
         * Minimum length of an attribute value of the string type.
         */
        minLength?: string;
    }
    interface UserPoolSmsConfiguration {
        /**
         * External ID used in IAM role trust relationships. For more information about using external IDs, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html).
         */
        externalId: string;
        /**
         * ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
         */
        snsCallerArn: string;
        /**
         * The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see [SMS message settings for Amazon Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-sms-settings.html).
         */
        snsRegion: string;
    }
    interface UserPoolSoftwareTokenMfaConfiguration {
        /**
         * Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When `smsConfiguration` is not present, the `mfaConfiguration` argument must be set to `OFF` and the `softwareTokenMfaConfiguration` configuration block must be fully removed.
         */
        enabled: boolean;
    }
    interface UserPoolUserAttributeUpdateSettings {
        /**
         * A list of attributes requiring verification before update. If set, the provided value(s) must also be set in `autoVerifiedAttributes`. Valid values: `email`, `phoneNumber`.
         */
        attributesRequireVerificationBeforeUpdates: string[];
    }
    interface UserPoolUserPoolAddOns {
        /**
         * Mode for advanced security, must be one of `OFF`, `AUDIT` or `ENFORCED`.
         */
        advancedSecurityMode: string;
    }
    interface UserPoolUsernameConfiguration {
        /**
         * Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
         */
        caseSensitive: boolean;
    }
    interface UserPoolVerificationMessageTemplate {
        /**
         * Default email option. Must be either `CONFIRM_WITH_CODE` or `CONFIRM_WITH_LINK`. Defaults to `CONFIRM_WITH_CODE`.
         */
        defaultEmailOption?: string;
        /**
         * Email message template. Must contain the `{####}` placeholder. Conflicts with `emailVerificationMessage` argument.
         */
        emailMessage: string;
        /**
         * Email message template for sending a confirmation link to the user, it must contain the `{##Click Here##}` placeholder.
         */
        emailMessageByLink: string;
        /**
         * Subject line for the email message template. Conflicts with `emailVerificationSubject` argument.
         */
        emailSubject: string;
        /**
         * Subject line for the email message template for sending a confirmation link to the user.
         */
        emailSubjectByLink: string;
        /**
         * SMS message template. Must contain the `{####}` placeholder. Conflicts with `smsVerificationMessage` argument.
         */
        smsMessage: string;
    }
}
export declare namespace comprehend {
    interface DocumentClassifierInputDataConfig {
        /**
         * List of training datasets produced by Amazon SageMaker Ground Truth.
         * Used if `dataFormat` is `AUGMENTED_MANIFEST`.
         * See the `augmentedManifests` Configuration Block section below.
         */
        augmentedManifests?: outputs.comprehend.DocumentClassifierInputDataConfigAugmentedManifest[];
        /**
         * The format for the training data.
         * One of `COMPREHEND_CSV` or `AUGMENTED_MANIFEST`.
         */
        dataFormat?: string;
        /**
         * Delimiter between labels when training a multi-label classifier.
         * Valid values are `|`, `~`, `!`, `@`, `#`, `$`, `%`, `^`, `*`, `-`, `_`, `+`, `=`, `\`, `:`, `;`, `>`, `?`, `/`, `<space>`, and `<tab>`.
         * Default is `|`.
         */
        labelDelimiter: string;
        /**
         * Location of training documents.
         * Used if `dataFormat` is `COMPREHEND_CSV`.
         */
        s3Uri?: string;
        testS3Uri?: string;
    }
    interface DocumentClassifierInputDataConfigAugmentedManifest {
        /**
         * Location of annotation files.
         */
        annotationDataS3Uri?: string;
        /**
         * The JSON attribute that contains the annotations for the training documents.
         */
        attributeNames: string[];
        /**
         * Type of augmented manifest.
         * One of `PLAIN_TEXT_DOCUMENT` or `SEMI_STRUCTURED_DOCUMENT`.
         */
        documentType?: string;
        /**
         * Location of augmented manifest file.
         */
        s3Uri: string;
        /**
         * Location of source PDF files.
         */
        sourceDocumentsS3Uri?: string;
        /**
         * Purpose of data in augmented manifest.
         * One of `TRAIN` or `TEST`.
         */
        split?: string;
    }
    interface DocumentClassifierOutputDataConfig {
        /**
         * KMS Key used to encrypt the output documents.
         * Can be a KMS Key ID, a KMS Key ARN, a KMS Alias name, or a KMS Alias ARN.
         */
        kmsKeyId?: string;
        /**
         * Full path for the output documents.
         */
        outputS3Uri: string;
        /**
         * Destination path for the output documents.
         * The full path to the output file will be returned in `outputS3Uri`.
         */
        s3Uri: string;
    }
    interface DocumentClassifierVpcConfig {
        /**
         * List of security group IDs.
         */
        securityGroupIds: string[];
        /**
         * List of VPC subnets.
         */
        subnets: string[];
    }
    interface EntityRecognizerInputDataConfig {
        /**
         * Specifies location of the document annotation data.
         * See the `annotations` Configuration Block section below.
         * One of `annotations` or `entityList` is required.
         */
        annotations?: outputs.comprehend.EntityRecognizerInputDataConfigAnnotations;
        /**
         * List of training datasets produced by Amazon SageMaker Ground Truth.
         * Used if `dataFormat` is `AUGMENTED_MANIFEST`.
         * See the `augmentedManifests` Configuration Block section below.
         */
        augmentedManifests?: outputs.comprehend.EntityRecognizerInputDataConfigAugmentedManifest[];
        /**
         * The format for the training data.
         * One of `COMPREHEND_CSV` or `AUGMENTED_MANIFEST`.
         */
        dataFormat?: string;
        /**
         * Specifies a collection of training documents.
         * Used if `dataFormat` is `COMPREHEND_CSV`.
         * See the `documents` Configuration Block section below.
         */
        documents?: outputs.comprehend.EntityRecognizerInputDataConfigDocuments;
        /**
         * Specifies location of the entity list data.
         * See the `entityList` Configuration Block section below.
         * One of `entityList` or `annotations` is required.
         */
        entityList?: outputs.comprehend.EntityRecognizerInputDataConfigEntityList;
        /**
         * Set of entity types to be recognized.
         * Has a maximum of 25 items.
         * See the `entityTypes` Configuration Block section below.
         */
        entityTypes: outputs.comprehend.EntityRecognizerInputDataConfigEntityType[];
    }
    interface EntityRecognizerInputDataConfigAnnotations {
        /**
         * Location of training annotations.
         */
        s3Uri: string;
        testS3Uri?: string;
    }
    interface EntityRecognizerInputDataConfigAugmentedManifest {
        /**
         * Location of annotation files.
         */
        annotationDataS3Uri?: string;
        /**
         * The JSON attribute that contains the annotations for the training documents.
         */
        attributeNames: string[];
        /**
         * Type of augmented manifest.
         * One of `PLAIN_TEXT_DOCUMENT` or `SEMI_STRUCTURED_DOCUMENT`.
         */
        documentType?: string;
        /**
         * Location of augmented manifest file.
         */
        s3Uri: string;
        /**
         * Location of source PDF files.
         */
        sourceDocumentsS3Uri?: string;
        /**
         * Purpose of data in augmented manifest.
         * One of `TRAIN` or `TEST`.
         */
        split?: string;
    }
    interface EntityRecognizerInputDataConfigDocuments {
        /**
         * Specifies how the input files should be processed.
         * One of `ONE_DOC_PER_LINE` or `ONE_DOC_PER_FILE`.
         */
        inputFormat?: string;
        /**
         * Location of training documents.
         */
        s3Uri: string;
        testS3Uri?: string;
    }
    interface EntityRecognizerInputDataConfigEntityList {
        /**
         * Location of entity list.
         */
        s3Uri: string;
    }
    interface EntityRecognizerInputDataConfigEntityType {
        /**
         * An entity type to be matched by the Entity Recognizer.
         * Cannot contain a newline (`\n`), carriage return (`\r`), or tab (`\t`).
         */
        type: string;
    }
    interface EntityRecognizerVpcConfig {
        /**
         * List of security group IDs.
         */
        securityGroupIds: string[];
        /**
         * List of VPC subnets.
         */
        subnets: string[];
    }
}
export declare namespace config {
    interface AssumeRole {
        /**
         * The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
         */
        duration?: string;
        /**
         * A unique identifier that might be required when you assume a role in another account.
         */
        externalId?: string;
        /**
         * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
         */
        policy?: string;
        /**
         * Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
         */
        policyArns?: string[];
        /**
         * Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
         */
        roleArn?: string;
        /**
         * An identifier for the assumed role session.
         */
        sessionName?: string;
        /**
         * Source identity specified by the principal assuming the role.
         */
        sourceIdentity?: string;
        /**
         * Assume role session tags.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * Assume role session tag keys to pass to any subsequent sessions.
         */
        transitiveTagKeys?: string[];
    }
    interface AssumeRoleWithWebIdentity {
        /**
         * The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
         */
        duration?: string;
        /**
         * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
         */
        policy?: string;
        /**
         * Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
         */
        policyArns?: string[];
        /**
         * Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
         */
        roleArn?: string;
        /**
         * An identifier for the assumed role session.
         */
        sessionName?: string;
        webIdentityToken?: string;
        webIdentityTokenFile?: string;
    }
    interface DefaultTags {
        /**
         * Resource tags to default across all resources
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface Endpoints {
        /**
         * Use this to override the default service endpoint URL
         */
        accessanalyzer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        account?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        acm?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        acmpca?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        amg?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        amp?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        amplify?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        apigateway?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        apigatewayv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appautoscaling?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appconfig?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appfabric?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appflow?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appintegrations?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appintegrationsservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        applicationautoscaling?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        applicationinsights?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appmesh?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appregistry?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        apprunner?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appstream?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        appsync?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        athena?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        auditmanager?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        autoscaling?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        autoscalingplans?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        backup?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        batch?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        bcmdataexports?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        beanstalk?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        bedrock?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        bedrockagent?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        budgets?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ce?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        chatbot?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        chime?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        chimesdkmediapipelines?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        chimesdkvoice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cleanrooms?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloud9?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudcontrol?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudcontrolapi?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudformation?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudfront?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudfrontkeyvaluestore?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudhsm?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudhsmv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudsearch?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudtrail?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatch?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchevents?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchevidently?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchlog?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchlogs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchobservabilityaccessmanager?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cloudwatchrum?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codeartifact?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codebuild?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codecatalyst?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codecommit?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codedeploy?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codeguruprofiler?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codegurureviewer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codepipeline?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codestarconnections?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        codestarnotifications?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cognitoidentity?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cognitoidentityprovider?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cognitoidp?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        comprehend?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        computeoptimizer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        config?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        configservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        connect?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        connectcases?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        controltower?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        costandusagereportservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        costexplorer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        costoptimizationhub?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        cur?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        customerprofiles?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        databasemigration?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        databasemigrationservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        dataexchange?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        datapipeline?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        datasync?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        datazone?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        dax?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        deploy?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        detective?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        devicefarm?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        devopsguru?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        directconnect?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        directoryservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        dlm?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        dms?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        docdb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        docdbelastic?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ds?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        dynamodb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ec2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ecr?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ecrpublic?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ecs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        efs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        eks?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticache?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticbeanstalk?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticloadbalancing?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticloadbalancingv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticsearch?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elasticsearchservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elastictranscoder?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        elbv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        emr?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        emrcontainers?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        emrserverless?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        es?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        eventbridge?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        events?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        evidently?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        finspace?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        firehose?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        fis?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        fms?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        fsx?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        gamelift?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        glacier?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        globalaccelerator?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        glue?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        grafana?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        greengrass?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        groundstation?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        guardduty?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        healthlake?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        iam?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        identitystore?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        imagebuilder?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        inspector?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        inspector2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        inspectorv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        internetmonitor?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        iot?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        iotanalytics?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        iotevents?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ivs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ivschat?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kafka?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kafkaconnect?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kendra?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        keyspaces?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kinesis?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kinesisanalytics?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kinesisanalyticsv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kinesisvideo?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        kms?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lakeformation?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lambda?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        launchwizard?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lex?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lexmodelbuilding?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lexmodelbuildingservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lexmodels?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lexmodelsv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lexv2models?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        licensemanager?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lightsail?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        location?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        locationservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        logs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        lookoutmetrics?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        m2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        macie2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        managedgrafana?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mediaconnect?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mediaconvert?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        medialive?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mediapackage?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mediapackagev2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mediastore?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        memorydb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mq?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        msk?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        mwaa?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        neptune?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        neptunegraph?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        networkfirewall?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        networkmanager?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        oam?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        opensearch?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        opensearchingestion?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        opensearchserverless?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        opensearchservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        opsworks?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        organizations?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        osis?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        outposts?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        paymentcryptography?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        pcaconnectorad?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        pinpoint?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        pipes?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        polly?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        pricing?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        prometheus?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        prometheusservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        qbusiness?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        qldb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        quicksight?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ram?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        rbin?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        rds?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        recyclebin?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        redshift?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        redshiftdata?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        redshiftdataapiservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        redshiftserverless?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        rekognition?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        resourceexplorer2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        resourcegroups?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        resourcegroupstagging?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        resourcegroupstaggingapi?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        rolesanywhere?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53domains?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53profiles?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53recoverycontrolconfig?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53recoveryreadiness?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        route53resolver?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        rum?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        s3?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        s3api?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        s3control?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        s3outposts?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sagemaker?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        scheduler?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        schemas?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sdb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        secretsmanager?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        securityhub?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        securitylake?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        serverlessapplicationrepository?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        serverlessapprepo?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        serverlessrepo?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        servicecatalog?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        servicecatalogappregistry?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        servicediscovery?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        servicequotas?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ses?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sesv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sfn?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        shield?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        signer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        simpledb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sns?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sqs?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ssm?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ssmcontacts?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ssmincidents?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ssmsap?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sso?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        ssoadmin?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        stepfunctions?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        storagegateway?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        sts?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        swf?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        synthetics?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        timestreamwrite?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        transcribe?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        transcribeservice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        transfer?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        verifiedpermissions?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        vpclattice?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        waf?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        wafregional?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        wafv2?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        wellarchitected?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        worklink?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        workspaces?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        workspacesweb?: string;
        /**
         * Use this to override the default service endpoint URL
         */
        xray?: string;
    }
    interface IgnoreTags {
        /**
         * Resource tag key prefixes to ignore across all resources.
         */
        keyPrefixes?: string[];
        /**
         * Resource tag keys to ignore across all resources.
         */
        keys?: string[];
    }
}
export declare namespace connect {
    interface BotAssociationLexBot {
        /**
         * The Region that the Amazon Lex (V1) bot was created in. Defaults to current region.
         */
        lexRegion: string;
        /**
         * The name of the Amazon Lex (V1) bot.
         */
        name: string;
    }
    interface GetBotAssociationLexBot {
        /**
         * Region that the Amazon Lex (V1) bot was created in.
         */
        lexRegion: string;
        /**
         * Name of the Amazon Lex (V1) bot.
         */
        name: string;
    }
    interface GetHoursOfOperationConfig {
        /**
         * Day that the hours of operation applies to.
         */
        day: string;
        /**
         * End time block specifies the time that your contact center closes. The `endTime` is documented below.
         */
        endTimes: outputs.connect.GetHoursOfOperationConfigEndTime[];
        /**
         * Start time block specifies the time that your contact center opens. The `startTime` is documented below.
         */
        startTimes: outputs.connect.GetHoursOfOperationConfigStartTime[];
    }
    interface GetHoursOfOperationConfigEndTime {
        /**
         * Hour of opening.
         */
        hours: number;
        /**
         * Minute of opening.
         */
        minutes: number;
    }
    interface GetHoursOfOperationConfigStartTime {
        /**
         * Hour of opening.
         */
        hours: number;
        /**
         * Minute of opening.
         */
        minutes: number;
    }
    interface GetInstanceStorageConfigStorageConfig {
        /**
         * A block that specifies the configuration of the Kinesis Firehose delivery stream. Documented below.
         */
        kinesisFirehoseConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisFirehoseConfig[];
        /**
         * A block that specifies the configuration of the Kinesis data stream. Documented below.
         */
        kinesisStreamConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisStreamConfig[];
        /**
         * A block that specifies the configuration of the Kinesis video stream. Documented below.
         */
        kinesisVideoStreamConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfig[];
        /**
         * A block that specifies the configuration of S3 Bucket. Documented below.
         */
        s3Configs: outputs.connect.GetInstanceStorageConfigStorageConfigS3Config[];
        /**
         * A valid storage type. Valid Values: `S3` | `KINESIS_VIDEO_STREAM` | `KINESIS_STREAM` | `KINESIS_FIREHOSE`.
         */
        storageType: string;
    }
    interface GetInstanceStorageConfigStorageConfigKinesisFirehoseConfig {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        firehoseArn: string;
    }
    interface GetInstanceStorageConfigStorageConfigKinesisStreamConfig {
        /**
         * The Amazon Resource Name (ARN) of the data stream.
         */
        streamArn: string;
    }
    interface GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfig {
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig[];
        /**
         * The prefix of the video stream. Minimum length of `1`. Maximum length of `128`. When read from the state, the value returned is `<prefix>-connect-<connect_instance_alias>-contact-` since the API appends additional details to the `prefix`.
         */
        prefix: string;
        /**
         * The number of hours to retain the data in a data store associated with the stream. Minimum value of `0`. Maximum value of `87600`. A value of `0` indicates that the stream does not persist data.
         */
        retentionPeriodHours: number;
    }
    interface GetInstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }
    interface GetInstanceStorageConfigStorageConfigS3Config {
        /**
         * The S3 bucket name.
         */
        bucketName: string;
        /**
         * The S3 bucket prefix.
         */
        bucketPrefix: string;
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfigs: outputs.connect.GetInstanceStorageConfigStorageConfigS3ConfigEncryptionConfig[];
    }
    interface GetInstanceStorageConfigStorageConfigS3ConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }
    interface GetQueueOutboundCallerConfig {
        /**
         * Specifies the caller ID name.
         */
        outboundCallerIdName: string;
        /**
         * Specifies the caller ID number.
         */
        outboundCallerIdNumberId: string;
        /**
         * Outbound whisper flow to be used during an outbound call.
         */
        outboundFlowId: string;
    }
    interface GetQuickConnectQuickConnectConfig {
        /**
         * Phone configuration of the Quick Connect. This is returned only if `quickConnectType` is `PHONE_NUMBER`. The `phoneConfig` block is documented below.
         */
        phoneConfigs: outputs.connect.GetQuickConnectQuickConnectConfigPhoneConfig[];
        /**
         * Queue configuration of the Quick Connect. This is returned only if `quickConnectType` is `QUEUE`. The `queueConfig` block is documented below.
         */
        queueConfigs: outputs.connect.GetQuickConnectQuickConnectConfigQueueConfig[];
        /**
         * Configuration type of the Quick Connect. Valid values are `PHONE_NUMBER`, `QUEUE`, `USER`.
         */
        quickConnectType: string;
        /**
         * User configuration of the Quick Connect. This is returned only if `quickConnectType` is `USER`. The `userConfig` block is documented below.
         */
        userConfigs: outputs.connect.GetQuickConnectQuickConnectConfigUserConfig[];
    }
    interface GetQuickConnectQuickConnectConfigPhoneConfig {
        /**
         * Phone number in in E.164 format.
         */
        phoneNumber: string;
    }
    interface GetQuickConnectQuickConnectConfigQueueConfig {
        /**
         * Identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Identifier for the queue.
         */
        queueId: string;
    }
    interface GetQuickConnectQuickConnectConfigUserConfig {
        /**
         * Identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Identifier for the user.
         */
        userId: string;
    }
    interface GetRoutingProfileMediaConcurrency {
        /**
         * Channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Number of contacts an agent can have on a channel simultaneously. Valid Range for `VOICE`: Minimum value of 1. Maximum value of 1. Valid Range for `CHAT`: Minimum value of 1. Maximum value of 10. Valid Range for `TASK`: Minimum value of 1. Maximum value of 10.
         */
        concurrency: number;
    }
    interface GetRoutingProfileQueueConfig {
        /**
         * Channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Delay, in seconds, that a contact should be in the queue before they are routed to an available agent
         */
        delay: number;
        /**
         * Order in which contacts are to be handled for the queue.
         */
        priority: number;
        /**
         * ARN for the queue.
         */
        queueArn: string;
        /**
         * Identifier for the queue.
         */
        queueId: string;
        /**
         * Name for the queue.
         */
        queueName: string;
    }
    interface GetUserHierarchyGroupHierarchyPath {
        /**
         * Details of level five. See below.
         */
        levelFives: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelFife[];
        /**
         * Details of level four. See below.
         */
        levelFours: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelFour[];
        /**
         * Details of level one. See below.
         */
        levelOnes: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelOne[];
        /**
         * Details of level three. See below.
         */
        levelThrees: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelThree[];
        /**
         * Details of level two. See below.
         */
        levelTwos: outputs.connect.GetUserHierarchyGroupHierarchyPathLevelTwo[];
    }
    interface GetUserHierarchyGroupHierarchyPathLevelFife {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }
    interface GetUserHierarchyGroupHierarchyPathLevelFour {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }
    interface GetUserHierarchyGroupHierarchyPathLevelOne {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }
    interface GetUserHierarchyGroupHierarchyPathLevelThree {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }
    interface GetUserHierarchyGroupHierarchyPathLevelTwo {
        /**
         * ARN of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * Returns information on a specific hierarchy group by name
         */
        name: string;
    }
    interface GetUserHierarchyStructureHierarchyStructure {
        /**
         * Details of level five. See below.
         */
        levelFives: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelFife[];
        /**
         * Details of level four. See below.
         */
        levelFours: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelFour[];
        /**
         * Details of level one. See below.
         */
        levelOnes: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelOne[];
        /**
         * Details of level three. See below.
         */
        levelThrees: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelThree[];
        /**
         * Details of level two. See below.
         */
        levelTwos: outputs.connect.GetUserHierarchyStructureHierarchyStructureLevelTwo[];
    }
    interface GetUserHierarchyStructureHierarchyStructureLevelFife {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }
    interface GetUserHierarchyStructureHierarchyStructureLevelFour {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }
    interface GetUserHierarchyStructureHierarchyStructureLevelOne {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }
    interface GetUserHierarchyStructureHierarchyStructureLevelThree {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }
    interface GetUserHierarchyStructureHierarchyStructureLevelTwo {
        /**
         * ARN of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        /**
         * Name of the user hierarchy level. Must not be more than 50 characters.
         */
        name: string;
    }
    interface GetUserIdentityInfo {
        /**
         * The email address.
         */
        email: string;
        /**
         * The first name.
         */
        firstName: string;
        /**
         * The last name.
         */
        lastName: string;
    }
    interface GetUserPhoneConfig {
        /**
         * The After Call Work (ACW) timeout setting, in seconds.
         */
        afterContactWorkTimeLimit: number;
        /**
         * When Auto-Accept Call is enabled for an available agent, the agent connects to contacts automatically.
         */
        autoAccept: boolean;
        /**
         * The phone number for the user's desk phone.
         */
        deskPhoneNumber: string;
        /**
         * The phone type. Valid values are `DESK_PHONE` and `SOFT_PHONE`.
         */
        phoneType: string;
    }
    interface HoursOfOperationConfig {
        /**
         * Specifies the day that the hours of operation applies to.
         */
        day: string;
        /**
         * A end time block specifies the time that your contact center closes. The `endTime` is documented below.
         */
        endTime: outputs.connect.HoursOfOperationConfigEndTime;
        /**
         * A start time block specifies the time that your contact center opens. The `startTime` is documented below.
         */
        startTime: outputs.connect.HoursOfOperationConfigStartTime;
    }
    interface HoursOfOperationConfigEndTime {
        /**
         * Specifies the hour of closing.
         */
        hours: number;
        /**
         * Specifies the minute of closing.
         */
        minutes: number;
    }
    interface HoursOfOperationConfigStartTime {
        /**
         * Specifies the hour of opening.
         */
        hours: number;
        /**
         * Specifies the minute of opening.
         */
        minutes: number;
    }
    interface InstanceStorageConfigStorageConfig {
        /**
         * A block that specifies the configuration of the Kinesis Firehose delivery stream. Documented below.
         */
        kinesisFirehoseConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisFirehoseConfig;
        /**
         * A block that specifies the configuration of the Kinesis data stream. Documented below.
         */
        kinesisStreamConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisStreamConfig;
        /**
         * A block that specifies the configuration of the Kinesis video stream. Documented below.
         */
        kinesisVideoStreamConfig?: outputs.connect.InstanceStorageConfigStorageConfigKinesisVideoStreamConfig;
        /**
         * A block that specifies the configuration of S3 Bucket. Documented below.
         */
        s3Config?: outputs.connect.InstanceStorageConfigStorageConfigS3Config;
        /**
         * A valid storage type. Valid Values: `S3` | `KINESIS_VIDEO_STREAM` | `KINESIS_STREAM` | `KINESIS_FIREHOSE`.
         */
        storageType: string;
    }
    interface InstanceStorageConfigStorageConfigKinesisFirehoseConfig {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        firehoseArn: string;
    }
    interface InstanceStorageConfigStorageConfigKinesisStreamConfig {
        /**
         * The Amazon Resource Name (ARN) of the data stream.
         */
        streamArn: string;
    }
    interface InstanceStorageConfigStorageConfigKinesisVideoStreamConfig {
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfig: outputs.connect.InstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig;
        /**
         * The prefix of the video stream. Minimum length of `1`. Maximum length of `128`. When read from the state, the value returned is `<prefix>-connect-<connect_instance_alias>-contact-` since the API appends additional details to the `prefix`.
         */
        prefix: string;
        /**
         * The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. Minimum value of `0`. Maximum value of `87600`. A value of `0`, indicates that the stream does not persist data.
         */
        retentionPeriodHours: number;
    }
    interface InstanceStorageConfigStorageConfigKinesisVideoStreamConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }
    interface InstanceStorageConfigStorageConfigS3Config {
        /**
         * The S3 bucket name.
         */
        bucketName: string;
        /**
         * The S3 bucket prefix.
         */
        bucketPrefix: string;
        /**
         * The encryption configuration. Documented below.
         */
        encryptionConfig?: outputs.connect.InstanceStorageConfigStorageConfigS3ConfigEncryptionConfig;
    }
    interface InstanceStorageConfigStorageConfigS3ConfigEncryptionConfig {
        /**
         * The type of encryption. Valid Values: `KMS`.
         */
        encryptionType: string;
        /**
         * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
         */
        keyId: string;
    }
    interface PhoneNumberStatus {
        /**
         * The status message.
         */
        message: string;
        /**
         * The status of the phone number. Valid Values: `CLAIMED` | `IN_PROGRESS` | `FAILED`.
         */
        status: string;
    }
    interface QueueOutboundCallerConfig {
        /**
         * Specifies the caller ID name.
         */
        outboundCallerIdName?: string;
        /**
         * Specifies the caller ID number.
         */
        outboundCallerIdNumberId?: string;
        /**
         * Specifies outbound whisper flow to be used during an outbound call.
         */
        outboundFlowId?: string;
    }
    interface QuickConnectQuickConnectConfig {
        /**
         * Specifies the phone configuration of the Quick Connect. This is required only if `quickConnectType` is `PHONE_NUMBER`. The `phoneConfig` block is documented below.
         */
        phoneConfigs?: outputs.connect.QuickConnectQuickConnectConfigPhoneConfig[];
        /**
         * Specifies the queue configuration of the Quick Connect. This is required only if `quickConnectType` is `QUEUE`. The `queueConfig` block is documented below.
         */
        queueConfigs?: outputs.connect.QuickConnectQuickConnectConfigQueueConfig[];
        /**
         * Specifies the configuration type of the quick connect. valid values are `PHONE_NUMBER`, `QUEUE`, `USER`.
         */
        quickConnectType: string;
        /**
         * Specifies the user configuration of the Quick Connect. This is required only if `quickConnectType` is `USER`. The `userConfig` block is documented below.
         */
        userConfigs?: outputs.connect.QuickConnectQuickConnectConfigUserConfig[];
    }
    interface QuickConnectQuickConnectConfigPhoneConfig {
        /**
         * Specifies the phone number in in E.164 format.
         */
        phoneNumber: string;
    }
    interface QuickConnectQuickConnectConfigQueueConfig {
        /**
         * Specifies the identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Specifies the identifier for the queue.
         */
        queueId: string;
    }
    interface QuickConnectQuickConnectConfigUserConfig {
        /**
         * Specifies the identifier of the contact flow.
         */
        contactFlowId: string;
        /**
         * Specifies the identifier for the user.
         */
        userId: string;
    }
    interface RoutingProfileMediaConcurrency {
        /**
         * Specifies the channels that agents can handle in the Contact Control Panel (CCP). Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Specifies the number of contacts an agent can have on a channel simultaneously. Valid Range for `VOICE`: Minimum value of 1. Maximum value of 1. Valid Range for `CHAT`: Minimum value of 1. Maximum value of 10. Valid Range for `TASK`: Minimum value of 1. Maximum value of 10.
         */
        concurrency: number;
    }
    interface RoutingProfileQueueConfig {
        /**
         * Specifies the channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are `VOICE`, `CHAT`, `TASK`.
         */
        channel: string;
        /**
         * Specifies the delay, in seconds, that a contact should be in the queue before they are routed to an available agent
         */
        delay: number;
        /**
         * Specifies the order in which contacts are to be handled for the queue.
         */
        priority: number;
        /**
         * ARN for the queue.
         */
        queueArn: string;
        /**
         * Specifies the identifier for the queue.
         */
        queueId: string;
        /**
         * Name for the queue.
         */
        queueName: string;
    }
    interface UserHierarchyGroupHierarchyPath {
        /**
         * A block that defines the details of level five. The level block is documented below.
         */
        levelFives: outputs.connect.UserHierarchyGroupHierarchyPathLevelFife[];
        /**
         * A block that defines the details of level four. The level block is documented below.
         */
        levelFours: outputs.connect.UserHierarchyGroupHierarchyPathLevelFour[];
        /**
         * A block that defines the details of level one. The level block is documented below.
         */
        levelOnes: outputs.connect.UserHierarchyGroupHierarchyPathLevelOne[];
        /**
         * A block that defines the details of level three. The level block is documented below.
         */
        levelThrees: outputs.connect.UserHierarchyGroupHierarchyPathLevelThree[];
        /**
         * A block that defines the details of level two. The level block is documented below.
         */
        levelTwos: outputs.connect.UserHierarchyGroupHierarchyPathLevelTwo[];
    }
    interface UserHierarchyGroupHierarchyPathLevelFife {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }
    interface UserHierarchyGroupHierarchyPathLevelFour {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }
    interface UserHierarchyGroupHierarchyPathLevelOne {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }
    interface UserHierarchyGroupHierarchyPathLevelThree {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }
    interface UserHierarchyGroupHierarchyPathLevelTwo {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy group.
         */
        arn: string;
        /**
         * The identifier of the hierarchy group.
         */
        id: string;
        /**
         * The name of the user hierarchy group. Must not be more than 100 characters.
         */
        name: string;
    }
    interface UserHierarchyStructureHierarchyStructure {
        /**
         * A block that defines the details of level five. The level block is documented below.
         *
         * Each level block supports the following arguments:
         */
        levelFive: outputs.connect.UserHierarchyStructureHierarchyStructureLevelFive;
        /**
         * A block that defines the details of level four. The level block is documented below.
         */
        levelFour: outputs.connect.UserHierarchyStructureHierarchyStructureLevelFour;
        /**
         * A block that defines the details of level one. The level block is documented below.
         */
        levelOne: outputs.connect.UserHierarchyStructureHierarchyStructureLevelOne;
        /**
         * A block that defines the details of level three. The level block is documented below.
         */
        levelThree: outputs.connect.UserHierarchyStructureHierarchyStructureLevelThree;
        /**
         * A block that defines the details of level two. The level block is documented below.
         */
        levelTwo: outputs.connect.UserHierarchyStructureHierarchyStructureLevelTwo;
    }
    interface UserHierarchyStructureHierarchyStructureLevelFive {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        name: string;
    }
    interface UserHierarchyStructureHierarchyStructureLevelFour {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        name: string;
    }
    interface UserHierarchyStructureHierarchyStructureLevelOne {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        name: string;
    }
    interface UserHierarchyStructureHierarchyStructureLevelThree {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        name: string;
    }
    interface UserHierarchyStructureHierarchyStructureLevelTwo {
        /**
         * The Amazon Resource Name (ARN) of the hierarchy level.
         */
        arn: string;
        /**
         * The identifier of the hierarchy level.
         */
        id: string;
        name: string;
    }
    interface UserIdentityInfo {
        /**
         * The email address. If you are using SAML for identity management and include this parameter, an error is returned. Note that updates to the `email` is supported. From the [UpdateUserIdentityInfo API documentation](https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateUserIdentityInfo.html) it is strongly recommended to limit who has the ability to invoke `UpdateUserIdentityInfo`. Someone with that ability can change the login credentials of other users by changing their email address. This poses a security risk to your organization. They can change the email address of a user to the attacker's email address, and then reset the password through email. For more information, see [Best Practices for Security Profiles](https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-best-practices.html) in the Amazon Connect Administrator Guide.
         */
        email?: string;
        /**
         * The first name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
         */
        firstName?: string;
        /**
         * The last name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
         */
        lastName?: string;
    }
    interface UserPhoneConfig {
        /**
         * The After Call Work (ACW) timeout setting, in seconds. Minimum value of 0.
         */
        afterContactWorkTimeLimit?: number;
        /**
         * When Auto-Accept Call is enabled for an available agent, the agent connects to contacts automatically.
         */
        autoAccept?: boolean;
        /**
         * The phone number for the user's desk phone. Required if `phoneType` is set as `DESK_PHONE`.
         */
        deskPhoneNumber?: string;
        /**
         * The phone type. Valid values are `DESK_PHONE` and `SOFT_PHONE`.
         */
        phoneType: string;
    }
}
export declare namespace controltower {
    interface LandingZoneDriftStatus {
        /**
         * The drift status of the landing zone.
         */
        status: string;
    }
}
export declare namespace costexplorer {
    interface AnomalySubscriptionSubscriber {
        /**
         * The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
         */
        address: string;
        /**
         * The type of subscription. Valid Values: `SNS` | `EMAIL`.
         */
        type: string;
    }
    interface AnomalySubscriptionThresholdExpression {
        /**
         * Return results that match both Dimension objects.
         */
        ands?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAnd[];
        /**
         * Configuration block for the filter that's based on  values. See Cost Category below.
         */
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionCostCategory;
        /**
         * Configuration block for the specific Dimension to use for.
         */
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionDimension;
        /**
         * Return results that match both Dimension object.
         */
        not?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNot;
        /**
         * Return results that match both Dimension object.
         */
        ors?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOr[];
        /**
         * Configuration block for the specific Tag to use for. See Tags below.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionTags;
    }
    interface AnomalySubscriptionThresholdExpressionAnd {
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndCostCategory;
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionAndTags;
    }
    interface AnomalySubscriptionThresholdExpressionAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionNot {
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotCostCategory;
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionNotTags;
    }
    interface AnomalySubscriptionThresholdExpressionNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionOr {
        costCategory?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrCostCategory;
        dimension?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrDimension;
        /**
         * A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.AnomalySubscriptionThresholdExpressionOrTags;
    }
    interface AnomalySubscriptionThresholdExpressionOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface AnomalySubscriptionThresholdExpressionTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRule {
        /**
         * Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
         */
        inheritedValue?: outputs.costexplorer.CostCategoryRuleInheritedValue;
        /**
         * Configuration block for the `Expression` object used to categorize costs. See below.
         */
        rule?: outputs.costexplorer.CostCategoryRuleRule;
        /**
         * You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
         */
        type?: string;
        /**
         * Default value for the cost category.
         */
        value?: string;
    }
    interface CostCategoryRuleInheritedValue {
        /**
         * Key to extract cost category values.
         */
        dimensionKey?: string;
        /**
         * Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
         */
        dimensionName?: string;
    }
    interface CostCategoryRuleRule {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands?: outputs.costexplorer.CostCategoryRuleRuleAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimension?: outputs.costexplorer.CostCategoryRuleRuleDimension;
        /**
         * Return results that match both `Dimension` object.
         */
        not?: outputs.costexplorer.CostCategoryRuleRuleNot;
        /**
         * Return results that match both `Dimension` object.
         */
        ors?: outputs.costexplorer.CostCategoryRuleRuleOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleTags;
    }
    interface CostCategoryRuleRuleAnd {
        ands?: outputs.costexplorer.CostCategoryRuleRuleAndAnd[];
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleAndCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleAndDimension;
        not?: outputs.costexplorer.CostCategoryRuleRuleAndNot;
        ors?: outputs.costexplorer.CostCategoryRuleRuleAndOr[];
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleAndTags;
    }
    interface CostCategoryRuleRuleAndAnd {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleAndAndCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleAndAndDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleAndAndTags;
    }
    interface CostCategoryRuleRuleAndAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndNot {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleAndNotCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleAndNotDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleAndNotTags;
    }
    interface CostCategoryRuleRuleAndNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndOr {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleAndOrCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleAndOrDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleAndOrTags;
    }
    interface CostCategoryRuleRuleAndOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNot {
        ands?: outputs.costexplorer.CostCategoryRuleRuleNotAnd[];
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleNotCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleNotDimension;
        not?: outputs.costexplorer.CostCategoryRuleRuleNotNot;
        ors?: outputs.costexplorer.CostCategoryRuleRuleNotOr[];
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleNotTags;
    }
    interface CostCategoryRuleRuleNotAnd {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleNotAndCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleNotAndDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleNotAndTags;
    }
    interface CostCategoryRuleRuleNotAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotNot {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleNotNotCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleNotNotDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleNotNotTags;
    }
    interface CostCategoryRuleRuleNotNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotOr {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleNotOrCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleNotOrDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleNotOrTags;
    }
    interface CostCategoryRuleRuleNotOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOr {
        ands?: outputs.costexplorer.CostCategoryRuleRuleOrAnd[];
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleOrCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleOrDimension;
        not?: outputs.costexplorer.CostCategoryRuleRuleOrNot;
        ors?: outputs.costexplorer.CostCategoryRuleRuleOrOr[];
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleOrTags;
    }
    interface CostCategoryRuleRuleOrAnd {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleOrAndCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleOrAndDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleOrAndTags;
    }
    interface CostCategoryRuleRuleOrAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrAndTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrNot {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleOrNotCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleOrNotDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleOrNotTags;
    }
    interface CostCategoryRuleRuleOrNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrNotTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrOr {
        costCategory?: outputs.costexplorer.CostCategoryRuleRuleOrOrCostCategory;
        dimension?: outputs.costexplorer.CostCategoryRuleRuleOrOrDimension;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: outputs.costexplorer.CostCategoryRuleRuleOrOrTags;
    }
    interface CostCategoryRuleRuleOrOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleOrTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategoryRuleRuleTags {
        /**
         * Key for the tag.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface CostCategorySplitChargeRule {
        /**
         * Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
         */
        method: string;
        /**
         * Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
         */
        parameters?: outputs.costexplorer.CostCategorySplitChargeRuleParameter[];
        /**
         * Cost Category value that you want to split.
         */
        source: string;
        /**
         * Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
         */
        targets: string[];
    }
    interface CostCategorySplitChargeRuleParameter {
        /**
         * Parameter type.
         */
        type?: string;
        /**
         * Parameter values.
         */
        values?: string[];
    }
    interface GetCostCategoryRule {
        /**
         * Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
         */
        inheritedValues: outputs.costexplorer.GetCostCategoryRuleInheritedValue[];
        /**
         * Configuration block for the `Expression` object used to categorize costs. See below.
         */
        rules: outputs.costexplorer.GetCostCategoryRuleRule[];
        /**
         * Parameter type.
         */
        type: string;
        /**
         * Default value for the cost category.
         */
        value: string;
    }
    interface GetCostCategoryRuleInheritedValue {
        /**
         * Key to extract cost category values.
         */
        dimensionKey: string;
        /**
         * Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
         */
        dimensionName: string;
    }
    interface GetCostCategoryRuleRule {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands: outputs.costexplorer.GetCostCategoryRuleRuleAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleDimension[];
        /**
         * Return results that do not match the `Dimension` object.
         */
        nots: outputs.costexplorer.GetCostCategoryRuleRuleNot[];
        /**
         * Return results that match either `Dimension` object.
         */
        ors: outputs.costexplorer.GetCostCategoryRuleRuleOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleTag[];
    }
    interface GetCostCategoryRuleRuleAnd {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands: outputs.costexplorer.GetCostCategoryRuleRuleAndAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleAndCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleAndDimension[];
        /**
         * Return results that do not match the `Dimension` object.
         */
        nots: outputs.costexplorer.GetCostCategoryRuleRuleAndNot[];
        /**
         * Return results that match either `Dimension` object.
         */
        ors: outputs.costexplorer.GetCostCategoryRuleRuleAndOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleAndTag[];
    }
    interface GetCostCategoryRuleRuleAndAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleAndAndCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleAndAndDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleAndAndTag[];
    }
    interface GetCostCategoryRuleRuleAndAndCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndAndDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndAndTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleAndNotCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleAndNotDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleAndNotTag[];
    }
    interface GetCostCategoryRuleRuleAndNotCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndNotDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndNotTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleAndOrCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleAndOrDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleAndOrTag[];
    }
    interface GetCostCategoryRuleRuleAndOrCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndOrDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndOrTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleAndTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNot {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands: outputs.costexplorer.GetCostCategoryRuleRuleNotAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleNotCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleNotDimension[];
        /**
         * Return results that do not match the `Dimension` object.
         */
        nots: outputs.costexplorer.GetCostCategoryRuleRuleNotNot[];
        /**
         * Return results that match either `Dimension` object.
         */
        ors: outputs.costexplorer.GetCostCategoryRuleRuleNotOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleNotTag[];
    }
    interface GetCostCategoryRuleRuleNotAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleNotAndCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleNotAndDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleNotAndTag[];
    }
    interface GetCostCategoryRuleRuleNotAndCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotAndDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotAndTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleNotNotCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleNotNotDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleNotNotTag[];
    }
    interface GetCostCategoryRuleRuleNotNotCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotNotDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotNotTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleNotOrCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleNotOrDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleNotOrTag[];
    }
    interface GetCostCategoryRuleRuleNotOrCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotOrDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotOrTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleNotTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOr {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands: outputs.costexplorer.GetCostCategoryRuleRuleOrAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleOrCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleOrDimension[];
        /**
         * Return results that do not match the `Dimension` object.
         */
        nots: outputs.costexplorer.GetCostCategoryRuleRuleOrNot[];
        /**
         * Return results that match either `Dimension` object.
         */
        ors: outputs.costexplorer.GetCostCategoryRuleRuleOrOr[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleOrTag[];
    }
    interface GetCostCategoryRuleRuleOrAnd {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleOrAndCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleOrAndDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleOrAndTag[];
    }
    interface GetCostCategoryRuleRuleOrAndCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrAndDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrAndTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrNot {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleOrNotCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleOrNotDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleOrNotTag[];
    }
    interface GetCostCategoryRuleRuleOrNotCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrNotDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrNotTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrOr {
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See below.
         */
        costCategories: outputs.costexplorer.GetCostCategoryRuleRuleOrOrCostCategory[];
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See below.
         */
        dimensions: outputs.costexplorer.GetCostCategoryRuleRuleOrOrDimension[];
        /**
         * Configuration block for the specific `Tag` to use for `Expression`. See below.
         */
        tags: outputs.costexplorer.GetCostCategoryRuleRuleOrOrTag[];
    }
    interface GetCostCategoryRuleRuleOrOrCostCategory {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrOrDimension {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrOrTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleOrTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategoryRuleRuleTag {
        /**
         * Key for the tag.
         */
        key: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions: string[];
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetCostCategorySplitChargeRule {
        /**
         * Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
         */
        method: string;
        /**
         * Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
         */
        parameters: outputs.costexplorer.GetCostCategorySplitChargeRuleParameter[];
        /**
         * Cost Category value that you want to split.
         */
        source: string;
        /**
         * Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
         */
        targets: string[];
    }
    interface GetCostCategorySplitChargeRuleParameter {
        /**
         * Parameter type.
         */
        type: string;
        /**
         * Parameter values.
         */
        values: string[];
    }
    interface GetTagsFilter {
        /**
         * Return results that match both `Dimension` objects.
         */
        ands?: outputs.costexplorer.GetTagsFilterAnd[];
        /**
         * Configuration block for the filter that's based on `CostCategory` values. See `costCategory` block below for details.
         */
        costCategory?: outputs.costexplorer.GetTagsFilterCostCategory;
        /**
         * Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
         */
        dimension?: outputs.costexplorer.GetTagsFilterDimension;
        /**
         * Return results that match both `Dimension` object.
         */
        not?: outputs.costexplorer.GetTagsFilterNot;
        /**
         * Return results that match both `Dimension` object.
         */
        ors?: outputs.costexplorer.GetTagsFilterOr[];
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterTags;
    }
    interface GetTagsFilterAnd {
        costCategory?: outputs.costexplorer.GetTagsFilterAndCostCategory;
        dimension?: outputs.costexplorer.GetTagsFilterAndDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterAndTags;
    }
    interface GetTagsFilterAndCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterAndDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterAndTags {
        key?: string;
        matchOptions?: string[];
        values?: string[];
    }
    interface GetTagsFilterCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterNot {
        costCategory?: outputs.costexplorer.GetTagsFilterNotCostCategory;
        dimension?: outputs.costexplorer.GetTagsFilterNotDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterNotTags;
    }
    interface GetTagsFilterNotCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterNotDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterNotTags {
        key?: string;
        matchOptions?: string[];
        values?: string[];
    }
    interface GetTagsFilterOr {
        costCategory?: outputs.costexplorer.GetTagsFilterOrCostCategory;
        dimension?: outputs.costexplorer.GetTagsFilterOrDimension;
        /**
         * Tags that match your request.
         */
        tags?: outputs.costexplorer.GetTagsFilterOrTags;
    }
    interface GetTagsFilterOrCostCategory {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterOrDimension {
        /**
         * Unique name of the Cost Category.
         */
        key?: string;
        /**
         * Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
         */
        matchOptions?: string[];
        /**
         * Specific value of the Cost Category.
         */
        values?: string[];
    }
    interface GetTagsFilterOrTags {
        key?: string;
        matchOptions?: string[];
        values?: string[];
    }
    interface GetTagsFilterTags {
        key?: string;
        matchOptions?: string[];
        values?: string[];
    }
    interface GetTagsSortBy {
        /**
         * key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
         */
        key?: string;
        /**
         * order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
         */
        sortOrder?: string;
    }
    interface GetTagsTimePeriod {
        /**
         * Beginning of the time period.
         */
        end: string;
        /**
         * End of the time period.
         */
        start: string;
    }
}
export declare namespace customerprofiles {
    interface DomainMatching {
        /**
         * A block that specifies the configuration about the auto-merging process. Documented below.
         */
        autoMerging: outputs.customerprofiles.DomainMatchingAutoMerging;
        /**
         * The flag that enables the matching process of duplicate profiles.
         */
        enabled: boolean;
        /**
         * A block that specifies the configuration for exporting Identity Resolution results. Documented below.
         */
        exportingConfig?: outputs.customerprofiles.DomainMatchingExportingConfig;
        /**
         * A block that specifies the day and time when you want to start the Identity Resolution Job every week. Documented below.
         */
        jobSchedule?: outputs.customerprofiles.DomainMatchingJobSchedule;
    }
    interface DomainMatchingAutoMerging {
        /**
         * A block that specifies how the auto-merging process should resolve conflicts between different profiles. Documented below.
         */
        conflictResolution?: outputs.customerprofiles.DomainMatchingAutoMergingConflictResolution;
        /**
         * A block that specifies a list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged. Documented below.
         * * `minAllowedConfidenceScoreForMerging ` - (Optional) A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
         */
        consolidation?: outputs.customerprofiles.DomainMatchingAutoMergingConsolidation;
        /**
         * The flag that enables the auto-merging of duplicate profiles.
         */
        enabled: boolean;
        minAllowedConfidenceScoreForMerging?: number;
    }
    interface DomainMatchingAutoMergingConflictResolution {
        /**
         * How the auto-merging process should resolve conflicts between different profiles. Valid values are `RECENCY` and `SOURCE`
         */
        conflictResolvingModel: string;
        /**
         * The `ObjectType` name that is used to resolve profile merging conflicts when choosing `SOURCE` as the `ConflictResolvingModel`.
         */
        sourceName?: string;
    }
    interface DomainMatchingAutoMergingConsolidation {
        /**
         * A list of matching criteria.
         */
        matchingAttributesLists: string[][];
    }
    interface DomainMatchingExportingConfig {
        s3Exporting?: outputs.customerprofiles.DomainMatchingExportingConfigS3Exporting;
    }
    interface DomainMatchingExportingConfigS3Exporting {
        s3BucketName: string;
        s3KeyName?: string;
    }
    interface DomainMatchingJobSchedule {
        /**
         * The day when the Identity Resolution Job should run every week.
         */
        dayOfTheWeek: string;
        /**
         * The time when the Identity Resolution Job should run every week.
         */
        time: string;
    }
    interface DomainRuleBasedMatching {
        /**
         * A block that configures information about the `AttributeTypesSelector` where the rule-based identity resolution uses to match profiles. Documented below.
         */
        attributeTypesSelector?: outputs.customerprofiles.DomainRuleBasedMatchingAttributeTypesSelector;
        /**
         * A block that specifies how the auto-merging process should resolve conflicts between different profiles. Documented below.
         */
        conflictResolution?: outputs.customerprofiles.DomainRuleBasedMatchingConflictResolution;
        /**
         * The flag that enables the rule-based matching process of duplicate profiles.
         */
        enabled: boolean;
        /**
         * A block that specifies the configuration for exporting Identity Resolution results. Documented below.
         */
        exportingConfig?: outputs.customerprofiles.DomainRuleBasedMatchingExportingConfig;
        /**
         * A block that configures how the rule-based matching process should match profiles. You can have up to 15 `rule` in the `natchingRules`. Documented below.
         */
        matchingRules?: outputs.customerprofiles.DomainRuleBasedMatchingMatchingRule[];
        /**
         * Indicates the maximum allowed rule level for matching.
         */
        maxAllowedRuleLevelForMatching?: number;
        /**
         * Indicates the maximum allowed rule level for merging.
         */
        maxAllowedRuleLevelForMerging?: number;
        status: string;
    }
    interface DomainRuleBasedMatchingAttributeTypesSelector {
        /**
         * The `Address` type. You can choose from `Address`, `BusinessAddress`, `MaillingAddress`, and `ShippingAddress`.
         */
        addresses?: string[];
        /**
         * Configures the `AttributeMatchingModel`, you can either choose `ONE_TO_ONE` or `MANY_TO_MANY`.
         */
        attributeMatchingModel: string;
        /**
         * The `Email` type. You can choose from `EmailAddress`, `BusinessEmailAddress` and `PersonalEmailAddress`.
         */
        emailAddresses?: string[];
        /**
         * The `PhoneNumber` type. You can choose from `PhoneNumber`, `HomePhoneNumber`, and `MobilePhoneNumber`.
         */
        phoneNumbers?: string[];
    }
    interface DomainRuleBasedMatchingConflictResolution {
        /**
         * How the auto-merging process should resolve conflicts between different profiles. Valid values are `RECENCY` and `SOURCE`
         */
        conflictResolvingModel: string;
        /**
         * The `ObjectType` name that is used to resolve profile merging conflicts when choosing `SOURCE` as the `ConflictResolvingModel`.
         */
        sourceName?: string;
    }
    interface DomainRuleBasedMatchingExportingConfig {
        s3Exporting?: outputs.customerprofiles.DomainRuleBasedMatchingExportingConfigS3Exporting;
    }
    interface DomainRuleBasedMatchingExportingConfigS3Exporting {
        s3BucketName: string;
        s3KeyName?: string;
    }
    interface DomainRuleBasedMatchingMatchingRule {
        /**
         * A single rule level of the `matchRules`. Configures how the rule-based matching process should match profiles.
         */
        rules: string[];
    }
    interface ProfileAddress {
        /**
         * The first line of a customer address.
         */
        address1?: string;
        /**
         * The second line of a customer address.
         */
        address2?: string;
        /**
         * The third line of a customer address.
         */
        address3?: string;
        /**
         * The fourth line of a customer address.
         */
        address4?: string;
        /**
         * The city in which a customer lives.
         */
        city?: string;
        /**
         * The country in which a customer lives.
         */
        country?: string;
        /**
         * The county in which a customer lives.
         */
        county?: string;
        /**
         * The postal code of a customer address.
         */
        postalCode?: string;
        /**
         * The province in which a customer lives.
         */
        province?: string;
        /**
         * The state in which a customer lives.
         */
        state?: string;
    }
    interface ProfileBillingAddress {
        address1?: string;
        address2?: string;
        address3?: string;
        address4?: string;
        city?: string;
        country?: string;
        county?: string;
        postalCode?: string;
        province?: string;
        state?: string;
    }
    interface ProfileMailingAddress {
        address1?: string;
        address2?: string;
        address3?: string;
        address4?: string;
        city?: string;
        country?: string;
        county?: string;
        postalCode?: string;
        province?: string;
        state?: string;
    }
    interface ProfileShippingAddress {
        address1?: string;
        address2?: string;
        address3?: string;
        address4?: string;
        city?: string;
        country?: string;
        county?: string;
        postalCode?: string;
        province?: string;
        state?: string;
    }
}
export declare namespace datapipeline {
    interface GetPipelineDefinitionParameterObject {
        attributes: outputs.datapipeline.GetPipelineDefinitionParameterObjectAttribute[];
        /**
         * ID of the object.
         */
        id: string;
    }
    interface GetPipelineDefinitionParameterObjectAttribute {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }
    interface GetPipelineDefinitionParameterValue {
        /**
         * ID of the object.
         */
        id: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }
    interface GetPipelineDefinitionPipelineObject {
        /**
         * Key-value pairs that define the properties of the object. See below
         */
        fields?: outputs.datapipeline.GetPipelineDefinitionPipelineObjectField[];
        /**
         * ID of the object.
         */
        id: string;
        /**
         * ARN of the storage connector.
         */
        name: string;
    }
    interface GetPipelineDefinitionPipelineObjectField {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as the identifier of another object
         */
        refValue: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }
    interface PipelineDefinitionParameterObject {
        /**
         * Configuration block for attributes of the parameter object. See below
         */
        attributes?: outputs.datapipeline.PipelineDefinitionParameterObjectAttribute[];
        /**
         * ID of the parameter object.
         */
        id: string;
    }
    interface PipelineDefinitionParameterObjectAttribute {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }
    interface PipelineDefinitionParameterValue {
        /**
         * ID of the parameter value.
         */
        id: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue: string;
    }
    interface PipelineDefinitionPipelineObject {
        /**
         * Configuration block for Key-value pairs that define the properties of the object. See below
         */
        fields?: outputs.datapipeline.PipelineDefinitionPipelineObjectField[];
        /**
         * ID of the object.
         */
        id: string;
        /**
         * ARN of the storage connector.
         */
        name: string;
    }
    interface PipelineDefinitionPipelineObjectField {
        /**
         * Field identifier.
         */
        key: string;
        /**
         * Field value, expressed as the identifier of another object
         */
        refValue?: string;
        /**
         * Field value, expressed as a String.
         */
        stringValue?: string;
    }
}
export declare namespace datasync {
    interface EfsLocationEc2Config {
        /**
         * List of Amazon Resource Names (ARNs) of the EC2 Security Groups that are associated with the EFS Mount Target.
         */
        securityGroupArns: string[];
        /**
         * Amazon Resource Name (ARN) of the EC2 Subnet that is associated with the EFS Mount Target.
         */
        subnetArn: string;
    }
    interface FsxOpenZfsFileSystemProtocol {
        /**
         * Represents the Network File System (NFS) protocol that DataSync uses to access your FSx for OpenZFS file system. See below.
         */
        nfs: outputs.datasync.FsxOpenZfsFileSystemProtocolNfs;
    }
    interface FsxOpenZfsFileSystemProtocolNfs {
        /**
         * Represents the mount options that are available for DataSync to access an NFS location. See below.
         */
        mountOptions: outputs.datasync.FsxOpenZfsFileSystemProtocolNfsMountOptions;
    }
    interface FsxOpenZfsFileSystemProtocolNfsMountOptions {
        /**
         * The specific NFS version that you want DataSync to use for mounting your NFS share. Valid values: `AUTOMATIC`, `NFS3`, `NFS4_0` and `NFS4_1`. Default: `AUTOMATIC`
         */
        version?: string;
    }
    interface LocationAzureBlobSasConfiguration {
        /**
         * A SAS token that provides permissions to access your Azure Blob Storage.
         */
        token: string;
    }
    interface LocationFsxOntapFileSystemProtocol {
        /**
         * Network File System (NFS) protocol that DataSync uses to access your FSx ONTAP file system. See NFS below.
         */
        nfs?: outputs.datasync.LocationFsxOntapFileSystemProtocolNfs;
        /**
         * Server Message Block (SMB) protocol that DataSync uses to access your FSx ONTAP file system. See [SMB] (#smb) below.
         */
        smb?: outputs.datasync.LocationFsxOntapFileSystemProtocolSmb;
    }
    interface LocationFsxOntapFileSystemProtocolNfs {
        /**
         * Mount options that are available for DataSync to access an NFS location. See NFS Mount Options below.
         */
        mountOptions: outputs.datasync.LocationFsxOntapFileSystemProtocolNfsMountOptions;
    }
    interface LocationFsxOntapFileSystemProtocolNfsMountOptions {
        version?: string;
    }
    interface LocationFsxOntapFileSystemProtocolSmb {
        /**
         * Fully qualified domain name of the Microsoft Active Directory (AD) that your storage virtual machine belongs to.
         */
        domain?: string;
        /**
         * Mount options that are available for DataSync to access an SMB location. See SMB Mount Options below.
         */
        mountOptions: outputs.datasync.LocationFsxOntapFileSystemProtocolSmbMountOptions;
        /**
         * Password of a user who has permission to access your SVM.
         */
        password: string;
        /**
         * Username that can mount the location and access the files, folders, and metadata that you need in the SVM.
         */
        user: string;
    }
    interface LocationFsxOntapFileSystemProtocolSmbMountOptions {
        version?: string;
    }
    interface LocationHdfsNameNode {
        /**
         * The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.
         */
        hostname: string;
        /**
         * The port that the NameNode uses to listen to client requests.
         */
        port: number;
    }
    interface LocationHdfsQopConfiguration {
        /**
         * The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your dfs.data.transfer.protection setting in the hdfs-site.xml file on your Hadoop cluster. Valid values are `DISABLED`, `AUTHENTICATION`, `INTEGRITY` and `PRIVACY`.
         */
        dataTransferProtection: string;
        /**
         * The RPC protection setting configured on the HDFS cluster. This setting corresponds to your hadoop.rpc.protection setting in your core-site.xml file on your Hadoop cluster. Valid values are `DISABLED`, `AUTHENTICATION`, `INTEGRITY` and `PRIVACY`.
         */
        rpcProtection: string;
    }
    interface LocationSmbMountOptions {
        /**
         * The specific SMB version that you want DataSync to use for mounting your SMB share. Valid values: `AUTOMATIC`, `SMB2`, and `SMB3`. Default: `AUTOMATIC`
         */
        version?: string;
    }
    interface NfsLocationMountOptions {
        /**
         * The specific NFS version that you want DataSync to use for mounting your NFS share. Valid values: `AUTOMATIC`, `NFS3`, `NFS4_0` and `NFS4_1`. Default: `AUTOMATIC`
         */
        version?: string;
    }
    interface NfsLocationOnPremConfig {
        /**
         * List of Amazon Resource Names (ARNs) of the DataSync Agents used to connect to the NFS server.
         */
        agentArns: string[];
    }
    interface S3LocationS3Config {
        /**
         * ARN of the IAM Role used to connect to the S3 Bucket.
         */
        bucketAccessRoleArn: string;
    }
    interface TaskExcludes {
        /**
         * The type of filter rule to apply. Valid values: `SIMPLE_PATTERN`.
         */
        filterType?: string;
        /**
         * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: `/folder1|/folder2`
         */
        value?: string;
    }
    interface TaskIncludes {
        /**
         * The type of filter rule to apply. Valid values: `SIMPLE_PATTERN`.
         */
        filterType?: string;
        /**
         * A single filter string that consists of the patterns to include. The patterns are delimited by "|" (that is, a pipe), for example: `/folder1|/folder2`
         */
        value?: string;
    }
    interface TaskOptions {
        /**
         * A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to `BEST_EFFORT`, the DataSync Task attempts to preserve the original (that is, the version before sync `PREPARING` phase) `atime` attribute on all source files. Valid values: `BEST_EFFORT`, `NONE`. Default: `BEST_EFFORT`.
         */
        atime?: string;
        /**
         * Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to `1048576`. Value values: `-1` or greater. Default: `-1` (unlimited).
         */
        bytesPerSecond?: number;
        /**
         * Group identifier of the file's owners. Valid values: `BOTH`, `INT_VALUE`, `NAME`, `NONE`. Default: `INT_VALUE` (preserve integer value of the ID).
         */
        gid?: string;
        /**
         * Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: `OFF`, `BASIC`, `TRANSFER`. Default: `OFF`.
         */
        logLevel?: string;
        /**
         * A file metadata that indicates the last time a file was modified (written to) before the sync `PREPARING` phase. Value values: `NONE`, `PRESERVE`. Default: `PRESERVE`.
         */
        mtime?: string;
        /**
         * Specifies whether object tags are maintained when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the NONE value. Valid values: `PRESERVE`, `NONE`. Default value: `PRESERVE`.
         */
        objectTags?: string;
        /**
         * Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: `ALWAYS`, `NEVER`. Default: `ALWAYS`.
         */
        overwriteMode?: string;
        /**
         * Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: `NONE`, `PRESERVE`. Default: `PRESERVE`.
         */
        posixPermissions?: string;
        /**
         * Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: `PRESERVE`, `REMOVE`. Default: `PRESERVE`.
         */
        preserveDeletedFiles?: string;
        /**
         * Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task can’t sync the actual contents of such devices, because many of the devices are non-terminal and don’t return an end of file (EOF) marker. Valid values: `NONE`, `PRESERVE`. Default: `NONE` (ignore special devices).
         */
        preserveDevices?: string;
        /**
         * Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: `NONE`, `OWNER_DACL`, `OWNER_DACL_SACL`. Default: `OWNER_DACL`.
         */
        securityDescriptorCopyFlags: string;
        /**
         * Determines whether tasks should be queued before executing the tasks. Valid values: `ENABLED`, `DISABLED`. Default `ENABLED`.
         */
        taskQueueing?: string;
        /**
         * Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: `CHANGED`, `ALL`. Default: `CHANGED`
         */
        transferMode?: string;
        /**
         * User identifier of the file's owners. Valid values: `BOTH`, `INT_VALUE`, `NAME`, `NONE`. Default: `INT_VALUE` (preserve integer value of the ID).
         */
        uid?: string;
        /**
         * Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: `NONE`, `POINT_IN_TIME_CONSISTENT`, `ONLY_FILES_TRANSFERRED`. Default: `POINT_IN_TIME_CONSISTENT`.
         */
        verifyMode?: string;
    }
    interface TaskSchedule {
        /**
         * Specifies the schedule you want your task to use for repeated executions. For more information, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html).
         */
        scheduleExpression: string;
    }
    interface TaskTaskReportConfig {
        /**
         * Specifies the type of task report you'd like. Valid values: `SUMMARY_ONLY` and `STANDARD`.
         */
        outputType?: string;
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't. Valid values: `ERRORS_ONLY` and `SUCCESSES_AND_ERRORS`.
         */
        reportLevel?: string;
        /**
         * Configuration block containing the configuration of the reporting level for aspects of your task report. See `reportOverrides` below.
         */
        reportOverrides?: outputs.datasync.TaskTaskReportConfigReportOverrides;
        /**
         * Configuration block containing the configuration for the Amazon S3 bucket where DataSync uploads your task report. See `s3Destination` below.
         */
        s3Destination: outputs.datasync.TaskTaskReportConfigS3Destination;
        /**
         * Specifies whether your task report includes the new version of each object transferred into an S3 bucket. This only applies if you enable versioning on your bucket. Keep in mind that setting this to INCLUDE can increase the duration of your task execution. Valid values: `INCLUDE` and `NONE`.
         */
        s3ObjectVersioning?: string;
    }
    interface TaskTaskReportConfigReportOverrides {
        /**
         * Specifies the level of reporting for the files, objects, and directories that DataSync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source. Valid values: `ERRORS_ONLY` and `SUCCESSES_AND_ERRORS`.
         */
        deletedOverride?: string;
        /**
         * Specifies the level of reporting for the files, objects, and directories that DataSync attempted to skip during your transfer. Valid values: `ERRORS_ONLY` and `SUCCESSES_AND_ERRORS`.
         */
        skippedOverride?: string;
        /**
         * Specifies the level of reporting for the files, objects, and directories that DataSync attempted to transfer. Valid values: `ERRORS_ONLY` and `SUCCESSES_AND_ERRORS`.
         */
        transferredOverride?: string;
        /**
         * Specifies the level of reporting for the files, objects, and directories that DataSync attempted to verify at the end of your transfer. Valid values: `ERRORS_ONLY` and `SUCCESSES_AND_ERRORS`.
         *
         * > **NOTE:** If any `reportOverrides` are set to the same value as `task_report_config.report_level`, they will always be flagged as changed. Only set overrides to a value that differs from `task_report_config.report_level`.
         */
        verifiedOverride?: string;
    }
    interface TaskTaskReportConfigS3Destination {
        /**
         * Specifies the Amazon Resource Name (ARN) of the IAM policy that allows DataSync to upload a task report to your S3 bucket.
         */
        bucketAccessRoleArn: string;
        /**
         * Specifies the ARN of the S3 bucket where DataSync uploads your report.
         */
        s3BucketArn: string;
        /**
         * Specifies a bucket prefix for your report.
         */
        subdirectory?: string;
    }
}
export declare namespace datazone {
    interface DomainSingleSignOn {
        type: string;
        userAssignment?: string;
    }
    interface DomainTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
}
export declare namespace dax {
    interface ClusterNode {
        address: string;
        availabilityZone: string;
        id: string;
        /**
         * The port used by the configuration endpoint
         */
        port: number;
    }
    interface ClusterServerSideEncryption {
        /**
         * Whether to enable encryption at rest. Defaults to `false`.
         */
        enabled?: boolean;
    }
    interface ParameterGroupParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value for the parameter.
         */
        value: string;
    }
}
export declare namespace devicefarm {
    interface DevicePoolRule {
        /**
         * The rule's stringified attribute. Valid values are: `APPIUM_VERSION`, `ARN`, `AVAILABILITY`, `FLEET_TYPE`, `FORM_FACTOR`, `INSTANCE_ARN`, `INSTANCE_LABELS`, `MANUFACTURER`, `MODEL`, `OS_VERSION`, `PLATFORM`, `REMOTE_ACCESS_ENABLED`, `REMOTE_DEBUG_ENABLED`.
         */
        attribute?: string;
        /**
         * Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute. Valid values are: `EQUALS`, `NOT_IN`, `IN`, `GREATER_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN`, `LESS_THAN_OR_EQUALS`, `CONTAINS`.
         */
        operator?: string;
        /**
         * The rule's value.
         */
        value?: string;
    }
    interface TestGridProjectVpcConfig {
        /**
         * A list of VPC security group IDs in your Amazon VPC.
         */
        securityGroupIds: string[];
        /**
         * A list of VPC subnet IDs in your Amazon VPC.
         */
        subnetIds: string[];
        /**
         * The ID of the Amazon VPC.
         */
        vpcId: string;
    }
}
export declare namespace devopsguru {
    interface EventSourcesConfigEventSource {
        /**
         * Stores whether DevOps Guru is configured to consume recommendations which are generated from AWS CodeGuru Profiler. See `amazonCodeGuruProfiler` below.
         */
        amazonCodeGuruProfilers?: outputs.devopsguru.EventSourcesConfigEventSourceAmazonCodeGuruProfiler[];
    }
    interface EventSourcesConfigEventSourceAmazonCodeGuruProfiler {
        /**
         * Status of the CodeGuru Profiler integration. Valid values are `ENABLED` and `DISABLED`.
         */
        status: string;
    }
    interface GetNotificationChannelFilter {
        /**
         * Events to receive notifications for.
         */
        messageTypes: string[];
        /**
         * Severity levels to receive notifications for.
         */
        severities: string[];
    }
    interface GetNotificationChannelSn {
        /**
         * Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
         */
        topicArn: string;
    }
    interface GetResourceCollectionCloudformation {
        /**
         * Array of the names of the AWS CloudFormation stacks.
         */
        stackNames: string[];
    }
    interface GetResourceCollectionTag {
        /**
         * An AWS tag key that is used to identify the AWS resources that DevOps Guru analyzes.
         */
        appBoundaryKey: string;
        /**
         * Array of tag values.
         */
        tagValues: string[];
    }
    interface NotificationChannelFilters {
        /**
         * Events to receive notifications for. Valid values are `NEW_INSIGHT`, `CLOSED_INSIGHT`, `NEW_ASSOCIATION`, `SEVERITY_UPGRADED`, and `NEW_RECOMMENDATION`.
         */
        messageTypes?: string[];
        /**
         * Severity levels to receive notifications for. Valid values are `LOW`, `MEDIUM`, and `HIGH`.
         */
        severities?: string[];
    }
    interface NotificationChannelSns {
        /**
         * Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
         */
        topicArn: string;
    }
    interface ResourceCollectionCloudformation {
        /**
         * Array of the names of the AWS CloudFormation stacks. If `type` is `AWS_SERVICE` (all acccount resources) this array should be a single item containing a wildcard (`"*"`).
         */
        stackNames: string[];
    }
    interface ResourceCollectionTags {
        /**
         * An AWS tag key that is used to identify the AWS resources that DevOps Guru analyzes. All AWS resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The key must begin with the prefix `DevOps-Guru-`. Any casing can be used for the prefix, but the associated tags __must use the same casing__ in their tag key.
         */
        appBoundaryKey: string;
        /**
         * Array of tag values. These can be used to further filter for specific resources within the application boundary. To analyze all resources tagged with the `appBoundaryKey` regardless of the corresponding tag value, this array should be a single item containing a wildcard (`"*"`).
         */
        tagValues: string[];
    }
    interface ServiceIntegrationKmsServerSideEncryption {
        /**
         * KMS key ID. This value can be a key ID, key ARN, alias name, or alias ARN.
         */
        kmsKeyId: string;
        /**
         * Specifies whether KMS integration is enabled. Valid values are `DISABLED` and `ENABLED`.
         */
        optInStatus: string;
        /**
         * Type of KMS key used. Valid values are `CUSTOMER_MANAGED_KEY` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }
    interface ServiceIntegrationLogsAnomalyDetection {
        /**
         * Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups. Valid values are `DISABLED` and `ENABLED`.
         */
        optInStatus: string;
    }
    interface ServiceIntegrationOpsCenter {
        /**
         * Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight. Valid values are `DISABLED` and `ENABLED`.
         */
        optInStatus: string;
    }
}
export declare namespace directconnect {
    interface GetRouterConfigurationRouter {
        /**
         * Router platform
         */
        platform: string;
        /**
         * ID of the Router Type. For example: `CiscoSystemsInc-2900SeriesRouters-IOS124`
         *
         * There is currently no AWS API to retrieve the full list of `routerTypeIdentifier` values. Here is a list of known `RouterType` objects that can be used:
         *
         * ```json
         * {
         * "routerTypes": [
         * {"platform":"2900 Series Routers","routerTypeIdentifier":"CiscoSystemsInc-2900SeriesRouters-IOS124","software":"IOS 12.4+","vendor":"Cisco Systems, Inc.","xsltTemplateName":"customer-router-cisco-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"3700 Series Routers","routerTypeIdentifier":"CiscoSystemsInc-3700SeriesRouters-IOS124","software":"IOS 12.4+","vendor":"Cisco Systems, Inc.","xsltTemplateName":"customer-router-cisco-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"7200 Series Routers","routerTypeIdentifier":"CiscoSystemsInc-7200SeriesRouters-IOS124","software":"IOS 12.4+","vendor":"Cisco Systems, Inc.","xsltTemplateName":"customer-router-cisco-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"Nexus 7000 Series Switches","routerTypeIdentifier":"CiscoSystemsInc-Nexus7000SeriesSwitches-NXOS51","software":"NX-OS 5.1+","vendor":"Cisco Systems, Inc.","xsltTemplateName":"customer-switch-cisco-nexus-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"Nexus 9K+ Series Switches","routerTypeIdentifier":"CiscoSystemsInc-Nexus9KSeriesSwitches-NXOS93","software":"NX-OS 9.3+","vendor":"Cisco Systems, Inc.","xsltTemplateName":"customer-switch-cisco-nexus-generic.xslt","xsltTemplateNameForMacSec":"customer-switch-cisco-nexus-generic-macsec.xslt"},
         * {"platform":"M/MX Series Routers","routerTypeIdentifier":"JuniperNetworksInc-MMXSeriesRouters-JunOS95","software":"JunOS 9.5+","vendor":"Juniper Networks, Inc.","xsltTemplateName":"customer-router-juniper-generic.xslt","xsltTemplateNameForMacSec":"customer-router-juniper-generic-macsec.xslt"},
         * {"platform":"SRX Series Routers","routerTypeIdentifier":"JuniperNetworksInc-SRXSeriesRouters-JunOS95","software":"JunOS 9.5+","vendor":"Juniper Networks, Inc.","xsltTemplateName":"customer-router-juniper-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"T Series Routers","routerTypeIdentifier":"JuniperNetworksInc-TSeriesRouters-JunOS95","software":"JunOS 9.5+","vendor":"Juniper Networks, Inc.","xsltTemplateName":"customer-router-juniper-generic.xslt","xsltTemplateNameForMacSec":""},
         * {"platform":"PA-3000+ and 5000+ series","routerTypeIdentifier":"PaloAltoNetworks-PA3000and5000series-PANOS803","software":"PAN-OS 8.0.3+","vendor":"Palo Alto Networks","xsltTemplateName":"customer-router-palo-alto-generic.xslt","xsltTemplateNameForMacSec":""}]
         * }
         * ```
         */
        routerTypeIdentifier: string;
        /**
         * Router operating system
         */
        software: string;
        /**
         * Router vendor
         */
        vendor: string;
        /**
         * Router XSLT Template Name
         */
        xsltTemplateName: string;
        xsltTemplateNameForMacSec: string;
    }
}
export declare namespace directoryservice {
    interface DirectoryConnectSettings {
        availabilityZones: string[];
        /**
         * The IP addresses of the AD Connector servers.
         */
        connectIps: string[];
        /**
         * The DNS IP addresses of the domain to connect to.
         */
        customerDnsIps: string[];
        /**
         * The username corresponding to the password provided.
         */
        customerUsername: string;
        /**
         * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC that the directory is in.
         */
        vpcId: string;
    }
    interface DirectoryVpcSettings {
        availabilityZones: string[];
        /**
         * The identifiers of the subnets for the directory servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC that the directory is in.
         */
        vpcId: string;
    }
    interface GetDirectoryConnectSetting {
        availabilityZones: string[];
        /**
         * IP addresses of the AD Connector servers.
         */
        connectIps: string[];
        /**
         * DNS IP addresses of the domain to connect to.
         */
        customerDnsIps: string[];
        /**
         * Username corresponding to the password provided.
         */
        customerUsername: string;
        /**
         * Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * ID of the VPC that the connector is in.
         */
        vpcId: string;
    }
    interface GetDirectoryRadiusSetting {
        /**
         * The protocol specified for your RADIUS endpoints.
         */
        authenticationProtocol: string;
        /**
         * Display label.
         */
        displayLabel: string;
        /**
         * Port that your RADIUS server is using for communications.
         */
        radiusPort: number;
        /**
         * Maximum number of times that communication with the RADIUS server is attempted.
         */
        radiusRetries: number;
        /**
         * Set of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.
         */
        radiusServers: string[];
        /**
         * Amount of time, in seconds, to wait for the RADIUS server to respond.
         */
        radiusTimeout: number;
        /**
         * Not currently used.
         */
        useSameUsername: boolean;
    }
    interface GetDirectoryVpcSetting {
        availabilityZones: string[];
        /**
         * Identifiers of the subnets for the connector servers (2 subnets in 2 different AZs).
         */
        subnetIds: string[];
        /**
         * ID of the VPC that the connector is in.
         */
        vpcId: string;
    }
    interface ServiceRegionVpcSettings {
        /**
         * The identifiers of the subnets for the directory servers.
         */
        subnetIds: string[];
        /**
         * The identifier of the VPC in which to create the directory.
         */
        vpcId: string;
    }
    interface SharedDirectoryTarget {
        /**
         * Identifier of the directory consumer account.
         */
        id: string;
        /**
         * Type of identifier to be used in the `id` field. Valid value is `ACCOUNT`. Default is `ACCOUNT`.
         */
        type?: string;
    }
}
export declare namespace dlm {
    interface LifecyclePolicyPolicyDetails {
        action?: outputs.dlm.LifecyclePolicyPolicyDetailsAction;
        eventSource?: outputs.dlm.LifecyclePolicyPolicyDetailsEventSource;
        parameters?: outputs.dlm.LifecyclePolicyPolicyDetailsParameters;
        policyType?: string;
        resourceLocations: string;
        resourceTypes?: string[];
        schedules?: outputs.dlm.LifecyclePolicyPolicyDetailsSchedule[];
        targetTags?: {
            [key: string]: string;
        };
    }
    interface LifecyclePolicyPolicyDetailsAction {
        crossRegionCopies: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopy[];
        name: string;
    }
    interface LifecyclePolicyPolicyDetailsActionCrossRegionCopy {
        encryptionConfiguration: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration;
        retainRule?: outputs.dlm.LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule;
        target: string;
    }
    interface LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration {
        cmkArn?: string;
        encrypted?: boolean;
    }
    interface LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule {
        interval: number;
        intervalUnit: string;
    }
    interface LifecyclePolicyPolicyDetailsEventSource {
        parameters: outputs.dlm.LifecyclePolicyPolicyDetailsEventSourceParameters;
        type: string;
    }
    interface LifecyclePolicyPolicyDetailsEventSourceParameters {
        descriptionRegex: string;
        eventType: string;
        snapshotOwners: string[];
    }
    interface LifecyclePolicyPolicyDetailsParameters {
        excludeBootVolume?: boolean;
        noReboot?: boolean;
    }
    interface LifecyclePolicyPolicyDetailsSchedule {
        copyTags: boolean;
        createRule: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCreateRule;
        crossRegionCopyRules?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule[];
        deprecateRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleDeprecateRule;
        fastRestoreRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleFastRestoreRule;
        name: string;
        retainRule: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleRetainRule;
        shareRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleShareRule;
        tagsToAdd?: {
            [key: string]: string;
        };
        variableTags?: {
            [key: string]: string;
        };
    }
    interface LifecyclePolicyPolicyDetailsScheduleCreateRule {
        cronExpression?: string;
        interval?: number;
        intervalUnit: string;
        location: string;
        times: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule {
        cmkArn?: string;
        copyTags?: boolean;
        deprecateRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule;
        encrypted: boolean;
        retainRule?: outputs.dlm.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule;
        target: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule {
        interval: number;
        intervalUnit: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule {
        interval: number;
        intervalUnit: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleDeprecateRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleFastRestoreRule {
        availabilityZones: string[];
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleRetainRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }
    interface LifecyclePolicyPolicyDetailsScheduleShareRule {
        targetAccounts: string[];
        unshareInterval?: number;
        unshareIntervalUnit?: string;
    }
}
export declare namespace dms {
    interface EndpointElasticsearchSettings {
        /**
         * Endpoint for the OpenSearch cluster.
         */
        endpointUri: string;
        /**
         * Maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster. Default is `300`.
         */
        errorRetryDuration?: number;
        /**
         * Maximum percentage of records that can fail to be written before a full load operation stops. Default is `10`.
         */
        fullLoadErrorPercentage?: number;
        /**
         * ARN of the IAM Role with permissions to write to the OpenSearch cluster.
         */
        serviceAccessRoleArn: string;
        /**
         * Enable to migrate documentation using the documentation type `_doc`. OpenSearch and an Elasticsearch clusters only support the _doc documentation type in versions 7.x and later. The default value is `false`.
         */
        useNewMappingType?: boolean;
    }
    interface EndpointKafkaSettings {
        /**
         * Kafka broker location. Specify in the form broker-hostname-or-ip:port.
         */
        broker: string;
        /**
         * Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. Default is `false`.
         */
        includeControlDetails?: boolean;
        /**
         * Include NULL and empty columns for records migrated to the endpoint. Default is `false`.
         */
        includeNullAndEmpty?: boolean;
        /**
         * Shows the partition value within the Kafka message output unless the partition type is `schema-table-type`. Default is `false`.
         */
        includePartitionValue?: boolean;
        /**
         * Includes any data definition language (DDL) operations that change the table in the control data, such as `rename-table`, `drop-table`, `add-column`, `drop-column`, and `rename-column`. Default is `false`.
         */
        includeTableAlterOperations?: boolean;
        /**
         * Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for `transactionId`, previous `transactionId`, and `transactionRecordId` (the record offset within a transaction). Default is `false`.
         */
        includeTransactionDetails?: boolean;
        /**
         * Output format for the records created on the endpoint. Message format is `JSON` (default) or `JSON_UNFORMATTED` (a single line with no tab).
         */
        messageFormat?: string;
        /**
         * Maximum size in bytes for records created on the endpoint Default is `1,000,000`.
         */
        messageMaxBytes?: number;
        /**
         * Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, AWS DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the `noHexPrefix` endpoint setting to enable migration of RAW data type columns without adding the `'0x'` prefix.
         */
        noHexPrefix?: boolean;
        /**
         * Prefixes schema and table names to partition values, when the partition type is `primary-key-type`. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. Default is `false`.
         */
        partitionIncludeSchemaTable?: boolean;
        /**
         * Secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
         */
        saslPassword?: string;
        /**
         * Secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
         */
        saslUsername?: string;
        /**
         * Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include `ssl-encryption`, `ssl-authentication`, and `sasl-ssl`. `sasl-ssl` requires `saslUsername` and `saslPassword`.
         */
        securityProtocol?: string;
        /**
         * ARN for the private certificate authority (CA) cert that AWS DMS uses to securely connect to your Kafka target endpoint.
         */
        sslCaCertificateArn?: string;
        /**
         * ARN of the client certificate used to securely connect to a Kafka target endpoint.
         */
        sslClientCertificateArn?: string;
        /**
         * ARN for the client private key used to securely connect to a Kafka target endpoint.
         */
        sslClientKeyArn?: string;
        /**
         * Password for the client private key used to securely connect to a Kafka target endpoint.
         */
        sslClientKeyPassword?: string;
        /**
         * Kafka topic for migration. Default is `kafka-default-topic`.
         */
        topic?: string;
    }
    interface EndpointKinesisSettings {
        /**
         * Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. Default is `false`.
         */
        includeControlDetails?: boolean;
        /**
         * Include NULL and empty columns in the target. Default is `false`.
         */
        includeNullAndEmpty?: boolean;
        /**
         * Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. Default is `false`.
         */
        includePartitionValue?: boolean;
        /**
         * Includes any data definition language (DDL) operations that change the table in the control data. Default is `false`.
         */
        includeTableAlterOperations?: boolean;
        /**
         * Provides detailed transaction information from the source database. Default is `false`.
         */
        includeTransactionDetails?: boolean;
        /**
         * Output format for the records created. Default is `json`. Valid values are `json` and `json-unformatted` (a single line with no tab).
         */
        messageFormat?: string;
        /**
         * Prefixes schema and table names to partition values, when the partition type is primary-key-type. Default is `false`.
         */
        partitionIncludeSchemaTable?: boolean;
        /**
         * ARN of the IAM Role with permissions to write to the Kinesis data stream.
         */
        serviceAccessRoleArn?: string;
        /**
         * ARN of the Kinesis data stream.
         */
        streamArn?: string;
    }
    interface EndpointMongodbSettings {
        /**
         * Authentication mechanism to access the MongoDB source endpoint. Default is `default`.
         */
        authMechanism?: string;
        /**
         * Authentication database name. Not used when `authType` is `no`. Default is `admin`.
         */
        authSource?: string;
        /**
         * Authentication type to access the MongoDB source endpoint. Default is `password`.
         */
        authType?: string;
        /**
         * Number of documents to preview to determine the document organization. Use this setting when `nestingLevel` is set to `one`. Default is `1000`.
         */
        docsToInvestigate?: string;
        /**
         * Document ID. Use this setting when `nestingLevel` is set to `none`. Default is `false`.
         */
        extractDocId?: string;
        /**
         * Specifies either document or table mode. Default is `none`. Valid values are `one` (table mode) and `none` (document mode).
         */
        nestingLevel?: string;
    }
    interface EndpointPostgresSettings {
        /**
         * For use with change data capture (CDC) only, this attribute has AWS DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data.
         */
        afterConnectScript?: string;
        /**
         * The Babelfish for Aurora PostgreSQL database name for the endpoint.
         */
        babelfishDatabaseName?: string;
        /**
         * To capture DDL events, AWS DMS creates various artifacts in the PostgreSQL database when the task starts.
         */
        captureDdls?: boolean;
        /**
         * Specifies the default behavior of the replication's handling of PostgreSQL- compatible endpoints that require some additional configuration, such as Babelfish endpoints.
         */
        databaseMode?: string;
        /**
         * Sets the schema in which the operational DDL database artifacts are created. Default is `public`.
         */
        ddlArtifactsSchema?: string;
        /**
         * Sets the client statement timeout for the PostgreSQL instance, in seconds. Default value is `60`.
         */
        executeTimeout?: number;
        /**
         * When set to `true`, this value causes a task to fail if the actual size of a LOB column is greater than the specified `LobMaxSize`. Default is `false`.
         */
        failTasksOnLobTruncation?: boolean;
        /**
         * The write-ahead log (WAL) heartbeat feature mimics a dummy transaction. By doing this, it prevents idle logical replication slots from holding onto old WAL logs, which can result in storage full situations on the source.
         */
        heartbeatEnable?: boolean;
        /**
         * Sets the WAL heartbeat frequency (in minutes). Default value is `5`.
         */
        heartbeatFrequency?: number;
        /**
         * Sets the schema in which the heartbeat artifacts are created. Default value is `public`.
         */
        heartbeatSchema?: string;
        /**
         * You can use PostgreSQL endpoint settings to map a boolean as a boolean from your PostgreSQL source to a Amazon Redshift target. Default value is `false`.
         */
        mapBooleanAsBoolean?: boolean;
        /**
         * Optional When true, DMS migrates JSONB values as CLOB.
         */
        mapJsonbAsClob?: boolean;
        /**
         * Optional When true, DMS migrates LONG values as VARCHAR.
         */
        mapLongVarcharAs?: string;
        /**
         * Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. Default is `32,768 KB`.
         */
        maxFileSize?: number;
        /**
         * Specifies the plugin to use to create a replication slot. Valid values: `pglogical`, `testDecoding`.
         */
        pluginName?: string;
        /**
         * Sets the name of a previously created logical replication slot for a CDC load of the PostgreSQL source instance.
         */
        slotName?: string;
    }
    interface EndpointRedisSettings {
        /**
         * The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
         */
        authPassword?: string;
        /**
         * The type of authentication to perform when connecting to a Redis target. Options include `none`, `auth-token`, and `auth-role`. The `auth-token` option requires an `authPassword` value to be provided. The `auth-role` option requires `authUserName` and `authPassword` values to be provided.
         */
        authType: string;
        /**
         * The username provided with the `auth-role` option of the AuthType setting for a Redis target endpoint.
         */
        authUserName?: string;
        /**
         * Transmission Control Protocol (TCP) port for the endpoint.
         */
        port: number;
        /**
         * Fully qualified domain name of the endpoint.
         */
        serverName: string;
        /**
         * The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
         */
        sslCaCertificateArn?: string;
        /**
         * The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database. Options include `plaintext`, `ssl-encryption`. The default is `ssl-encryption`.
         */
        sslSecurityProtocol?: string;
    }
    interface EndpointRedshiftSettings {
        /**
         * Custom S3 Bucket Object prefix for intermediate storage.
         */
        bucketFolder?: string;
        /**
         * Custom S3 Bucket name for intermediate storage.
         */
        bucketName?: string;
        /**
         * The server-side encryption mode that you want to encrypt your intermediate .csv object files copied to S3. Defaults to `SSE_S3`. Valid values are `SSE_S3` and `SSE_KMS`.
         */
        encryptionMode?: string;
        /**
         * ARN or Id of KMS Key to use when `encryptionMode` is `SSE_KMS`.
         */
        serverSideEncryptionKmsKeyId?: string;
        /**
         * Amazon Resource Name (ARN) of the IAM Role with permissions to read from or write to the S3 Bucket for intermediate storage.
         */
        serviceAccessRoleArn?: string;
    }
    interface EndpointS3Settings {
        /**
         * Whether to add column name information to the .csv output file. Default is `false`.
         */
        addColumnName?: boolean;
        /**
         * S3 object prefix.
         */
        bucketFolder?: string;
        /**
         * S3 bucket name.
         */
        bucketName?: string;
        /**
         * Predefined (canned) access control list for objects created in an S3 bucket. Valid values include `none`, `private`, `public-read`, `public-read-write`, `authenticated-read`, `aws-exec-read`, `bucket-owner-read`, and `bucket-owner-full-control`. Default is `none`.
         */
        cannedAclForObjects?: string;
        /**
         * Whether to write insert and update operations to .csv or .parquet output files. Default is `false`.
         */
        cdcInsertsAndUpdates?: boolean;
        /**
         * Whether to write insert operations to .csv or .parquet output files. Default is `false`.
         */
        cdcInsertsOnly?: boolean;
        /**
         * Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. Default is `60`.
         */
        cdcMaxBatchInterval?: number;
        /**
         * Minimum file size condition as defined in kilobytes to output a file to Amazon S3. Default is `32000`. **NOTE:** Previously, this setting was measured in megabytes but now represents kilobytes. Update configurations accordingly.
         */
        cdcMinFileSize?: number;
        /**
         * Folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If `cdcPath` is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
         */
        cdcPath?: string;
        /**
         * Set to compress target files. Default is `NONE`. Valid values are `GZIP` and `NONE`.
         */
        compressionType?: string;
        /**
         * Delimiter used to separate columns in the source files. Default is `,`.
         */
        csvDelimiter?: string;
        /**
         * String to use for all columns not included in the supplemental log.
         */
        csvNoSupValue?: string;
        /**
         * String to as null when writing to the target.
         */
        csvNullValue?: string;
        /**
         * Delimiter used to separate rows in the source files. Default is `\n`.
         */
        csvRowDelimiter?: string;
        /**
         * Output format for the files that AWS DMS uses to create S3 objects. Valid values are `csv` and `parquet`. Default is `csv`.
         */
        dataFormat?: string;
        /**
         * Size of one data page in bytes. Default is `1048576` (1 MiB).
         */
        dataPageSize?: number;
        /**
         * Date separating delimiter to use during folder partitioning. Valid values are `SLASH`, `UNDERSCORE`, `DASH`, and `NONE`. Default is `SLASH`.
         */
        datePartitionDelimiter?: string;
        /**
         * Partition S3 bucket folders based on transaction commit dates. Default is `false`.
         */
        datePartitionEnabled?: boolean;
        /**
         * Date format to use during folder partitioning. Use this parameter when `datePartitionEnabled` is set to true. Valid values are `YYYYMMDD`, `YYYYMMDDHH`, `YYYYMM`, `MMYYYYDD`, and `DDMMYYYY`. Default is `YYYYMMDD`.
         */
        datePartitionSequence?: string;
        /**
         * Maximum size in bytes of an encoded dictionary page of a column. Default is `1048576` (1 MiB).
         */
        dictPageSizeLimit?: number;
        /**
         * Whether to enable statistics for Parquet pages and row groups. Default is `true`.
         */
        enableStatistics?: boolean;
        /**
         * Type of encoding to use. Value values are `rleDictionary`, `plain`, and `plainDictionary`. Default is `rleDictionary`.
         */
        encodingType?: string;
        /**
         * Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are `SSE_S3` and `SSE_KMS`. Default is `SSE_S3`.
         */
        encryptionMode?: string;
        /**
         * JSON document that describes how AWS DMS should interpret the data.
         */
        externalTableDefinition?: string;
        /**
         * Whether to integrate AWS Glue Data Catalog with an Amazon S3 target. See [Using AWS Glue Data Catalog with an Amazon S3 target for AWS DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.GlueCatalog) for more information. Default is `false`.
         */
        glueCatalogGeneration?: boolean;
        /**
         * When this value is set to `1`, DMS ignores the first row header in a .csv file. Default is `0`.
         */
        ignoreHeaderRows?: number;
        /**
         * Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is `false`.
         */
        includeOpForFullLoad?: boolean;
        /**
         * Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from `1` to `1048576`. Default is `1048576` (1 GB).
         */
        maxFileSize?: number;
        /**
         * Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is `false`.
         */
        parquetTimestampInMillisecond?: boolean;
        /**
         * Version of the .parquet file format. Default is `parquet-1-0`. Valid values are `parquet-1-0` and `parquet-2-0`.
         */
        parquetVersion?: string;
        /**
         * Whether DMS saves the transaction order for a CDC load on the S3 target specified by `cdcPath`. Default is `false`.
         */
        preserveTransactions?: boolean;
        /**
         * For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is `true`.
         */
        rfc4180?: boolean;
        /**
         * Number of rows in a row group. Default is `10000`.
         */
        rowGroupLength?: number;
        /**
         * ARN or Id of KMS Key to use when `encryptionMode` is `SSE_KMS`.
         */
        serverSideEncryptionKmsKeyId?: string;
        /**
         * ARN of the IAM Role with permissions to read from or write to the S3 Bucket.
         */
        serviceAccessRoleArn?: string;
        /**
         * Column to add with timestamp information to the endpoint data for an Amazon S3 target.
         */
        timestampColumnName?: string;
        /**
         * Whether to use `csvNoSupValue` for columns not included in the supplemental log.
         */
        useCsvNoSupValue?: boolean;
        /**
         * When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is `false`.
         */
        useTaskStartTimeForFullLoadTimestamp?: boolean;
    }
    interface GetEndpointElasticsearchSetting {
        endpointUri: string;
        errorRetryDuration: number;
        fullLoadErrorPercentage: number;
        serviceAccessRoleArn: string;
    }
    interface GetEndpointKafkaSetting {
        broker: string;
        includeControlDetails: boolean;
        includeNullAndEmpty: boolean;
        includePartitionValue: boolean;
        includeTableAlterOperations: boolean;
        includeTransactionDetails: boolean;
        messageFormat: string;
        messageMaxBytes: number;
        noHexPrefix: boolean;
        partitionIncludeSchemaTable: boolean;
        saslPassword: string;
        saslUsername: string;
        securityProtocol: string;
        sslCaCertificateArn: string;
        sslClientCertificateArn: string;
        sslClientKeyArn: string;
        sslClientKeyPassword: string;
        topic: string;
    }
    interface GetEndpointKinesisSetting {
        includeControlDetails: boolean;
        includeNullAndEmpty: boolean;
        includePartitionValue: boolean;
        includeTableAlterOperations: boolean;
        includeTransactionDetails: boolean;
        messageFormat: string;
        partitionIncludeSchemaTable: boolean;
        serviceAccessRoleArn: string;
        streamArn: string;
    }
    interface GetEndpointMongodbSetting {
        authMechanism: string;
        authSource: string;
        authType: string;
        docsToInvestigate: string;
        extractDocId: string;
        nestingLevel: string;
    }
    interface GetEndpointPostgresSetting {
        afterConnectScript: string;
        babelfishDatabaseName: string;
        captureDdls: boolean;
        databaseMode: string;
        ddlArtifactsSchema: string;
        executeTimeout: number;
        failTasksOnLobTruncation: boolean;
        heartbeatEnable: boolean;
        heartbeatFrequency: number;
        heartbeatSchema: string;
        mapBooleanAsBoolean: boolean;
        mapJsonbAsClob: boolean;
        mapLongVarcharAs: string;
        maxFileSize: number;
        pluginName: string;
        slotName: string;
    }
    interface GetEndpointRedisSetting {
        authPassword: string;
        authType: string;
        authUserName: string;
        port: number;
        serverName: string;
        sslCaCertificateArn: string;
        sslSecurityProtocol: string;
    }
    interface GetEndpointRedshiftSetting {
        bucketFolder: string;
        bucketName: string;
        encryptionMode: string;
        serverSideEncryptionKmsKeyId: string;
        serviceAccessRoleArn: string;
    }
    interface GetEndpointS3Setting {
        addColumnName: boolean;
        bucketFolder: string;
        bucketName: string;
        cannedAclForObjects: string;
        cdcInsertsAndUpdates: boolean;
        cdcInsertsOnly: boolean;
        cdcMaxBatchInterval: number;
        cdcMinFileSize: number;
        cdcPath: string;
        compressionType: string;
        csvDelimiter: string;
        csvNoSupValue: string;
        csvNullValue: string;
        csvRowDelimiter: string;
        dataFormat: string;
        dataPageSize: number;
        datePartitionDelimiter: string;
        datePartitionEnabled: boolean;
        datePartitionSequence: string;
        dictPageSizeLimit: number;
        enableStatistics: boolean;
        encodingType: string;
        encryptionMode: string;
        externalTableDefinition: string;
        glueCatalogGeneration: boolean;
        ignoreHeaderRows: number;
        ignoreHeadersRow: number;
        includeOpForFullLoad: boolean;
        maxFileSize: number;
        parquetTimestampInMillisecond: boolean;
        parquetVersion: string;
        preserveTransactions: boolean;
        rfc4180: boolean;
        rowGroupLength: number;
        serverSideEncryptionKmsKeyId: string;
        serviceAccessRoleArn: string;
        timestampColumnName: string;
        useCsvNoSupValue: boolean;
        useTaskStartTimeForFullLoadTimestamp: boolean;
    }
    interface ReplicationConfigComputeConfig {
        /**
         * The Availability Zone where the DMS Serverless replication using this configuration will run. The default value is a random.
         */
        availabilityZone: string;
        /**
         * A list of custom DNS name servers supported for the DMS Serverless replication to access your source or target database.
         */
        dnsNameServers?: string;
        /**
         * An Key Management Service (KMS) key Amazon Resource Name (ARN) that is used to encrypt the data during DMS Serverless replication. If you don't specify a value for the KmsKeyId parameter, DMS uses your default encryption key.
         */
        kmsKeyId: string;
        /**
         * Specifies the maximum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 2 DCUs as the minimum value allowed. The list of valid DCU values includes 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384.
         */
        maxCapacityUnits?: number;
        /**
         * Specifies the minimum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. The list of valid DCU values includes 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. If this value isn't set DMS scans the current activity of available source tables to identify an optimum setting for this parameter.
         */
        minCapacityUnits?: number;
        /**
         * Specifies if the replication instance is a multi-az deployment. You cannot set the `availabilityZone` parameter if the `multiAz` parameter is set to `true`.
         */
        multiAz: boolean;
        /**
         * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
         *
         * - Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week.
         * - Format: `ddd:hh24:mi-ddd:hh24:mi`
         * - Valid Days: `mon, tue, wed, thu, fri, sat, sun`
         * - Constraints: Minimum 30-minute window.
         */
        preferredMaintenanceWindow: string;
        /**
         * Specifies a subnet group identifier to associate with the DMS Serverless replication.
         */
        replicationSubnetGroupId: string;
        /**
         * Specifies the virtual private cloud (VPC) security group to use with the DMS Serverless replication. The VPC security group must work with the VPC containing the replication.
         */
        vpcSecurityGroupIds: string[];
    }
}
export declare namespace docdb {
    interface ClusterParameterGroupParameter {
        /**
         * Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the DocumentDB parameter.
         */
        name: string;
        /**
         * The value of the DocumentDB parameter.
         */
        value: string;
    }
    interface ElasticClusterTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster.
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster.
         */
        isWriter: boolean;
    }
}
export declare namespace dynamodb {
    interface GetTableAttribute {
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        type: string;
    }
    interface GetTableGlobalSecondaryIndex {
        hashKey: string;
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        nonKeyAttributes: string[];
        projectionType: string;
        rangeKey: string;
        readCapacity: number;
        writeCapacity: number;
    }
    interface GetTableLocalSecondaryIndex {
        /**
         * Name of the DynamoDB table.
         */
        name: string;
        nonKeyAttributes: string[];
        projectionType: string;
        rangeKey: string;
    }
    interface GetTablePointInTimeRecovery {
        enabled: boolean;
    }
    interface GetTableReplica {
        kmsKeyArn: string;
        regionName: string;
    }
    interface GetTableServerSideEncryption {
        enabled: boolean;
        kmsKeyArn: string;
    }
    interface GetTableTtl {
        attributeName: string;
        enabled: boolean;
    }
    interface GlobalTableReplica {
        /**
         * AWS region name of replica DynamoDB TableE.g., `us-east-1`
         */
        regionName: string;
    }
    interface TableAttribute {
        /**
         * Name of the attribute
         */
        name: string;
        /**
         * Attribute type. Valid values are `S` (string), `N` (number), `B` (binary).
         */
        type: string;
    }
    interface TableGlobalSecondaryIndex {
        /**
         * Name of the hash key in the index; must be defined as an attribute in the resource.
         */
        hashKey: string;
        /**
         * Name of the index.
         */
        name: string;
        /**
         * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
         */
        nonKeyAttributes?: string[];
        /**
         * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
         */
        projectionType: string;
        /**
         * Name of the range key; must be defined
         */
        rangeKey?: string;
        /**
         * Number of read units for this index. Must be set if billingMode is set to PROVISIONED.
         */
        readCapacity?: number;
        /**
         * Number of write units for this index. Must be set if billingMode is set to PROVISIONED.
         */
        writeCapacity?: number;
    }
    interface TableImportTable {
        /**
         * Type of compression to be used on the input coming from the imported table.
         * Valid values are `GZIP`, `ZSTD` and `NONE`.
         */
        inputCompressionType?: string;
        /**
         * The format of the source data.
         * Valid values are `CSV`, `DYNAMODB_JSON`, and `ION`.
         */
        inputFormat: string;
        /**
         * Describe the format options for the data that was imported into the target table.
         * There is one value, `csv`.
         * See below.
         */
        inputFormatOptions?: outputs.dynamodb.TableImportTableInputFormatOptions;
        /**
         * Values for the S3 bucket the source file is imported from.
         * See below.
         */
        s3BucketSource: outputs.dynamodb.TableImportTableS3BucketSource;
    }
    interface TableImportTableInputFormatOptions {
        /**
         * This block contains the processing options for the CSV file being imported:
         */
        csv?: outputs.dynamodb.TableImportTableInputFormatOptionsCsv;
    }
    interface TableImportTableInputFormatOptionsCsv {
        /**
         * The delimiter used for separating items in the CSV file being imported.
         */
        delimiter?: string;
        /**
         * List of the headers used to specify a common header for all source CSV files being imported.
         */
        headerLists?: string[];
    }
    interface TableImportTableS3BucketSource {
        /**
         * The S3 bucket that is being imported from.
         */
        bucket: string;
        /**
         * The account number of the S3 bucket that is being imported from.
         */
        bucketOwner?: string;
        /**
         * The key prefix shared by all S3 Objects that are being imported.
         */
        keyPrefix?: string;
    }
    interface TableLocalSecondaryIndex {
        /**
         * Name of the index
         */
        name: string;
        /**
         * Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
         */
        nonKeyAttributes?: string[];
        /**
         * One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects  into the index only the table and index hashKey and sortKey attributes ,  `INCLUDE` projects into the index all of the attributes that are defined in `nonKeyAttributes` in addition to the attributes that that`KEYS_ONLY` project.
         */
        projectionType: string;
        /**
         * Name of the range key.
         */
        rangeKey: string;
    }
    interface TablePointInTimeRecovery {
        /**
         * Whether to enable point-in-time recovery. It can take 10 minutes to enable for new tables. If the `pointInTimeRecovery` block is not provided, this defaults to `false`.
         */
        enabled: boolean;
    }
    interface TableReplica {
        /**
         * ARN of the table
         */
        arn: string;
        /**
         * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
         */
        kmsKeyArn: string;
        /**
         * Whether to enable Point In Time Recovery for the replica. Default is `false`.
         */
        pointInTimeRecovery?: boolean;
        /**
         * Whether to propagate the global table's tags to a replica. Default is `false`. Changes to tags only move in one direction: from global (source) to replica. In other words, tag drift on a replica will not trigger an update. Tag or replica changes on the global table, whether from drift or configuration changes, are propagated to replicas. Changing from `true` to `false` on a subsequent `apply` means replica tags are left as they were, unmanaged, not deleted.
         */
        propagateTags?: boolean;
        /**
         * Region name of the replica.
         */
        regionName: string;
        /**
         * ARN of the Table Stream. Only available when `streamEnabled = true`
         */
        streamArn: string;
        /**
         * Timestamp, in ISO 8601 format, for this stream. Note that this timestamp is not a unique identifier for the stream on its own. However, the combination of AWS customer ID, table name and this field is guaranteed to be unique. It can be used for creating CloudWatch Alarms. Only available when `streamEnabled = true`.
         */
        streamLabel: string;
    }
    interface TableServerSideEncryption {
        /**
         * Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK). If `enabled` is `false` then server-side encryption is set to AWS-_owned_ key (shown as `DEFAULT` in the AWS console). Potentially confusingly, if `enabled` is `true` and no `kmsKeyArn` is specified then server-side encryption is set to the _default_ KMS-_managed_ key (shown as `KMS` in the AWS console). The [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html) explains the difference between AWS-_owned_ and KMS-_managed_ keys.
         */
        enabled: boolean;
        /**
         * ARN of the CMK that should be used for the AWS KMS encryption. This argument should only be used if the key is different from the default KMS-managed DynamoDB key, `alias/aws/dynamodb`. **Note:** This attribute will _not_ be populated with the ARN of _default_ keys.
         */
        kmsKeyArn: string;
    }
    interface TableTtl {
        /**
         * Name of the table attribute to store the TTL timestamp in.
         */
        attributeName: string;
        /**
         * Whether TTL is enabled.
         */
        enabled?: boolean;
    }
}
export declare namespace ebs {
    interface FastSnapshotRestoreTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface GetEbsVolumesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html).
         * For example, if matching against the `size` filter, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const tenOrTwentyGbVolumes = aws.ebs.getEbsVolumes({
         *     filters: [{
         *         name: "size",
         *         values: [
         *             "10",
         *             "20",
         *         ],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * EBS Volume IDs will be selected if any one of the given values match.
         */
        values: string[];
    }
    interface GetSnapshotFilter {
        name: string;
        values: string[];
    }
    interface GetSnapshotIdsFilter {
        name: string;
        values: string[];
    }
    interface GetVolumeFilter {
        name: string;
        values: string[];
    }
    interface SnapshotImportClientData {
        /**
         * A user-defined comment about the disk upload.
         */
        comment?: string;
        /**
         * The time that the disk upload ends.
         */
        uploadEnd: string;
        /**
         * The size of the uploaded disk image, in GiB.
         */
        uploadSize: number;
        /**
         * The time that the disk upload starts.
         */
        uploadStart: string;
    }
    interface SnapshotImportDiskContainer {
        /**
         * The description of the disk image being imported.
         */
        description?: string;
        /**
         * The format of the disk image being imported. One of `VHD` or `VMDK`.
         */
        format: string;
        /**
         * The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..). One of `url` or `userBucket` must be set.
         */
        url?: string;
        /**
         * The Amazon S3 bucket for the disk image. One of `url` or `userBucket` must be set. Detailed below.
         */
        userBucket?: outputs.ebs.SnapshotImportDiskContainerUserBucket;
    }
    interface SnapshotImportDiskContainerUserBucket {
        /**
         * The name of the Amazon S3 bucket where the disk image is located.
         */
        s3Bucket: string;
        /**
         * The file name of the disk image.
         */
        s3Key: string;
    }
}
export declare namespace ec2 {
    interface AmiCopyEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType: string;
    }
    interface AmiCopyEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }
    interface AmiEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination?: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted?: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops?: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn?: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId?: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType?: string;
    }
    interface AmiEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }
    interface AmiFromInstanceEbsBlockDevice {
        /**
         * Boolean controlling whether the EBS volumes created to
         * support each created instance will be deleted once that instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Boolean controlling whether the created EBS volumes will be encrypted. Can't be used with `snapshotId`.
         */
        encrypted: boolean;
        /**
         * Number of I/O operations per second the
         * created volumes will support.
         */
        iops: number;
        /**
         * ARN of the Outpost on which the snapshot is stored.
         *
         * > **Note:** You can specify `encrypted` or `snapshotId` but not both.
         */
        outpostArn: string;
        /**
         * ID of an EBS snapshot that will be used to initialize the created
         * EBS volumes. If set, the `volumeSize` attribute must be at least as large as the referenced
         * snapshot.
         */
        snapshotId: string;
        /**
         * Throughput that the EBS volume supports, in MiB/s. Only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * Size of created volumes in GiB.
         * If `snapshotId` is set and `volumeSize` is omitted then the volume will have the same size
         * as the selected snapshot.
         */
        volumeSize: number;
        /**
         * Type of EBS volume to create. Can be `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1` (Default: `standard`).
         */
        volumeType: string;
    }
    interface AmiFromInstanceEphemeralBlockDevice {
        /**
         * Path at which the device is exposed to created instances.
         */
        deviceName: string;
        /**
         * Name for the ephemeral device, of the form "ephemeralN" where
         * *N* is a volume number starting from zero.
         */
        virtualName: string;
    }
    interface DefaultNetworkAclEgress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         *
         * > For more information on ICMP types and codes, see [Internet Control Message Protocol (ICMP) Parameters](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml).
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all' protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         *
         * The following arguments are optional:
         */
        toPort: number;
    }
    interface DefaultNetworkAclIngress {
        action: string;
        cidrBlock?: string;
        fromPort: number;
        icmpCode?: number;
        icmpType?: number;
        ipv6CidrBlock?: string;
        protocol: string;
        ruleNo: number;
        toPort: number;
    }
    interface DefaultRouteTableRoute {
        /**
         * The CIDR block of the route.
         */
        cidrBlock?: string;
        /**
         * The Amazon Resource Name (ARN) of a core network.
         */
        coreNetworkArn?: string;
        /**
         * The ID of a managed prefix list destination of the route.
         *
         * One of the following target arguments must be supplied:
         */
        destinationPrefixListId?: string;
        /**
         * Identifier of a VPC Egress Only Internet Gateway.
         */
        egressOnlyGatewayId?: string;
        /**
         * Identifier of a VPC internet gateway or a virtual private gateway.
         */
        gatewayId?: string;
        /**
         * Identifier of an EC2 instance.
         */
        instanceId?: string;
        /**
         * The Ipv6 CIDR block of the route
         */
        ipv6CidrBlock?: string;
        /**
         * Identifier of a VPC NAT gateway.
         */
        natGatewayId?: string;
        /**
         * Identifier of an EC2 network interface.
         */
        networkInterfaceId?: string;
        /**
         * Identifier of an EC2 Transit Gateway.
         */
        transitGatewayId?: string;
        /**
         * Identifier of a VPC Endpoint. This route must be removed prior to VPC Endpoint deletion.
         */
        vpcEndpointId?: string;
        /**
         * Identifier of a VPC peering connection.
         *
         * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
         */
        vpcPeeringConnectionId?: string;
    }
    interface DefaultSecurityGroupEgress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp`)
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of prefix list IDs (for allowing access to VPC endpoints)
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of "-1" (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to `0`. If not `icmp`, `tcp`, `udp`, or `-1` use the [protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this egress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         */
        toPort: number;
    }
    interface DefaultSecurityGroupIngress {
        cidrBlocks?: string[];
        /**
         * Description of the security group.
         */
        description?: string;
        fromPort: number;
        ipv6CidrBlocks?: string[];
        prefixListIds?: string[];
        protocol: string;
        securityGroups?: string[];
        self?: boolean;
        toPort: number;
    }
    interface EipDomainNameTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface FleetFleetInstanceSet {
        /**
         * The IDs of the instances.
         */
        instanceIds: string[];
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.
         */
        lifecycle: string;
        /**
         * The value is `Windows` for Windows instances. Otherwise, the value is blank.
         */
        platform: string;
    }
    interface FleetLaunchTemplateConfig {
        /**
         * Nested argument containing EC2 Launch Template to use. Defined below.
         */
        launchTemplateSpecification?: outputs.ec2.FleetLaunchTemplateConfigLaunchTemplateSpecification;
        /**
         * Nested argument(s) containing parameters to override the same parameters in the Launch Template. Defined below.
         */
        overrides?: outputs.ec2.FleetLaunchTemplateConfigOverride[];
    }
    interface FleetLaunchTemplateConfigLaunchTemplateSpecification {
        /**
         * The ID of the launch template.
         */
        launchTemplateId?: string;
        /**
         * The name of the launch template.
         */
        launchTemplateName?: string;
        /**
         * The launch template version number, `$Latest`, or `$Default.`
         */
        version: string;
    }
    interface FleetLaunchTemplateConfigOverride {
        /**
         * Availability Zone in which to launch the instances.
         */
        availabilityZone?: string;
        /**
         * Override the instance type in the Launch Template with instance types that satisfy the requirements.
         */
        instanceRequirements?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirements;
        /**
         * Instance type.
         */
        instanceType?: string;
        /**
         * Maximum price per unit hour that you are willing to pay for a Spot Instance.
         */
        maxPrice?: string;
        /**
         * Priority for the launch template override. If `onDemandOptions` `allocationStrategy` is set to `prioritized`, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. Valid values are whole numbers starting at 0.
         */
        priority?: number;
        /**
         * ID of the subnet in which to launch the instances.
         */
        subnetId?: string;
        /**
         * Number of units provided by the specified instance type.
         */
        weightedCapacity?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum limits.
         */
        acceleratorCount?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * The accelerator types that must be on the instance type. Default is any accelerator type.
         */
        acceleratorTypes?: string[];
        /**
         * The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards,represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types. Default is any instance type.
         *
         * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicates whether burstable performance T instance types are `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * The CPU manufacturers to include. Default is any manufacturer.
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         */
        cpuManufacturers?: string[];
        /**
         * The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*). The following are examples: `c5*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * If you specify `AllowedInstanceTypes`, you can't specify `ExcludedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Valid values are `current` and `previous`. Default is `current` and `previous` generation instance types.
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Valid values are `hdd` and `ssd`. Default any storage type.
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
        /**
         * The minimum and maximum amount of memory per vCPU, in GiB. Default is no minimum or maximum limits.
         */
        memoryMib: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
        /**
         * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is No minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set `targetCapacityUnitType` to `vcpu` or `memory-mib`, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount: outputs.ec2.FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter..
         */
        max?: number;
        /**
         * The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter..
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
        /**
         * The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
        /**
         * The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum amount of memory, in MiB. To specify no minimum limit, specify `0`.
         */
        min: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
        /**
         * The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
        /**
         * The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
        /**
         * The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
         */
        min?: number;
    }
    interface FleetLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
        /**
         * The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
         */
        max?: number;
        /**
         * The minimum number of vCPUs. To specify no minimum limit, specify `0`.
         */
        min: number;
    }
    interface FleetOnDemandOptions {
        /**
         * The order of the launch template overrides to use in fulfilling On-Demand capacity. Valid values: `lowestPrice`, `prioritized`. Default: `lowestPrice`.
         */
        allocationStrategy?: string;
        /**
         * The maximum amount per hour for On-Demand Instances that you're willing to pay.
         */
        maxTotalPrice?: string;
        /**
         * The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type `instant`.
         * If you specify `minTargetCapacity`, at least one of the following must be specified: `singleAvailabilityZone` or `singleInstanceType`.
         */
        minTargetCapacity?: number;
        /**
         * Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type `instant`.
         */
        singleAvailabilityZone?: boolean;
        /**
         * Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type `instant`.
         */
        singleInstanceType?: boolean;
    }
    interface FleetSpotOptions {
        /**
         * How to allocate the target capacity across the Spot pools. Valid values: `diversified`, `lowestPrice`, `capacity-optimized`, `capacity-optimized-prioritized` and `price-capacity-optimized`. Default: `lowestPrice`.
         */
        allocationStrategy?: string;
        /**
         * Behavior when a Spot Instance is interrupted. Valid values: `hibernate`, `stop`, `terminate`. Default: `terminate`.
         */
        instanceInterruptionBehavior?: string;
        /**
         * Number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot `allocationStrategy` is set to `lowestPrice`. Default: `1`.
         */
        instancePoolsToUseCount?: number;
        /**
         * Nested argument containing maintenance strategies for managing your Spot Instances that are at an elevated risk of being interrupted. Defined below.
         */
        maintenanceStrategies?: outputs.ec2.FleetSpotOptionsMaintenanceStrategies;
    }
    interface FleetSpotOptionsMaintenanceStrategies {
        /**
         * Nested argument containing the capacity rebalance for your fleet request. Defined below.
         */
        capacityRebalance?: outputs.ec2.FleetSpotOptionsMaintenanceStrategiesCapacityRebalance;
    }
    interface FleetSpotOptionsMaintenanceStrategiesCapacityRebalance {
        /**
         * The replacement strategy to use. Only available for fleets of `type` set to `maintain`. Valid values: `launch`.
         */
        replacementStrategy?: string;
        terminationDelay?: number;
    }
    interface FleetTargetCapacitySpecification {
        /**
         * Default target capacity type. Valid values: `on-demand`, `spot`.
         */
        defaultTargetCapacityType: string;
        /**
         * The number of On-Demand units to request.
         */
        onDemandTargetCapacity?: number;
        /**
         * The number of Spot units to request.
         */
        spotTargetCapacity?: number;
        /**
         * The unit for the target capacity.
         * If you specify `targetCapacityUnitType`, `instanceRequirements` must be specified.
         */
        targetCapacityUnitType?: string;
        /**
         * The number of units to request, filled using `defaultTargetCapacityType`.
         */
        totalTargetCapacity: number;
    }
    interface FlowLogDestinationOptions {
        /**
         * The format for the flow log. Default value: `plain-text`. Valid values: `plain-text`, `parquet`.
         */
        fileFormat?: string;
        /**
         * Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. Default value: `false`.
         */
        hiveCompatiblePartitions?: boolean;
        /**
         * Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. Default value: `false`.
         */
        perHourPartition?: boolean;
    }
    interface GetAmiBlockDeviceMapping {
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * Map containing EBS information, if the device is EBS based. Unlike most object attributes, these are accessed directly (e.g., `ebs.volume_size` or `ebs["volumeSize"]`) rather than accessed through the first element of a list (e.g., `ebs[0].volume_size`).
         */
        ebs: {
            [key: string]: string;
        };
        /**
         * Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice: string;
        /**
         * Virtual device name (for instance stores).
         */
        virtualName: string;
    }
    interface GetAmiFilter {
        /**
         * Name of the AMI that was provided during image creation.
         */
        name: string;
        values: string[];
    }
    interface GetAmiIdsFilter {
        name: string;
        values: string[];
    }
    interface GetAmiProductCode {
        productCodeId: string;
        productCodeType: string;
    }
    interface GetCoipPoolFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A COIP Pool will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetCoipPoolsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCoipPools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A COIP Pool will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetCustomerGatewayFilter {
        name: string;
        values: string[];
    }
    interface GetDedicatedHostFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeHosts.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A host will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetEipsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAddresses.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An Elastic IP will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetElasticIpFilter {
        name: string;
        values: string[];
    }
    interface GetInstanceCreditSpecification {
        cpuCredits: string;
    }
    interface GetInstanceEbsBlockDevice {
        /**
         * If the root block device will be deleted on termination.
         */
        deleteOnTermination: boolean;
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * If the EBS volume is encrypted.
         */
        encrypted: boolean;
        /**
         * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
         */
        iops: number;
        kmsKeyId: string;
        /**
         * ID of the snapshot.
         */
        snapshotId: string;
        /**
         * Map of tags assigned to the Instance.
         */
        tags: {
            [key: string]: string;
        };
        /**
         * Throughput of the volume, in MiB/s.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }
    interface GetInstanceEnclaveOption {
        /**
         * Whether Nitro Enclaves are enabled.
         */
        enabled: boolean;
    }
    interface GetInstanceEphemeralBlockDevice {
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * Whether the specified device included in the device mapping was suppressed or not (Boolean).
         */
        noDevice?: boolean;
        /**
         * Virtual device name.
         */
        virtualName?: string;
    }
    interface GetInstanceFilter {
        name: string;
        values: string[];
    }
    interface GetInstanceMaintenanceOption {
        /**
         * Automatic recovery behavior of the instance.
         */
        autoRecovery: string;
    }
    interface GetInstanceMetadataOption {
        /**
         * State of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * Whether the IPv6 endpoint for the instance metadata service is `enabled` or `disabled`
         */
        httpProtocolIpv6: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
        /**
         * If access to instance tags is allowed from the metadata service: `enabled`, `disabled`.
         */
        instanceMetadataTags: string;
    }
    interface GetInstancePrivateDnsNameOption {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for EC2 instances.
         */
        hostnameType: string;
    }
    interface GetInstanceRootBlockDevice {
        /**
         * If the root block device will be deleted on termination.
         */
        deleteOnTermination: boolean;
        /**
         * Physical name of the device.
         */
        deviceName: string;
        /**
         * If the EBS volume is encrypted.
         */
        encrypted: boolean;
        /**
         * `0` If the volume is not a provisioned IOPS image, otherwise the supported IOPS count.
         */
        iops: number;
        kmsKeyId: string;
        /**
         * Map of tags assigned to the Instance.
         */
        tags: {
            [key: string]: string;
        };
        /**
         * Throughput of the volume, in MiB/s.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }
    interface GetInstanceTypeFpga {
        count: number;
        manufacturer: string;
        /**
         * Size of the instance memory, in MiB.
         */
        memorySize: number;
        name: string;
    }
    interface GetInstanceTypeGpus {
        count: number;
        manufacturer: string;
        /**
         * Size of the instance memory, in MiB.
         */
        memorySize: number;
        name: string;
    }
    interface GetInstanceTypeInferenceAccelerator {
        count: number;
        manufacturer: string;
        name: string;
    }
    interface GetInstanceTypeInstanceDisk {
        count: number;
        size: number;
        type: string;
    }
    interface GetInstanceTypeOfferingFilter {
        /**
         * Name of the filter. The `location` filter depends on the top-level `locationType` argument and if not specified, defaults to the current region.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetInstanceTypeOfferingsFilter {
        /**
         * Name of the filter. The `location` filter depends on the top-level `locationType` argument and if not specified, defaults to the current region.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetInstanceTypesFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetInstancesFilter {
        name: string;
        values: string[];
    }
    interface GetInternetGatewayAttachment {
        /**
         * Current state of the attachment between the gateway and the VPC. Present only if a VPC is attached
         */
        state: string;
        /**
         * ID of an attached VPC.
         */
        vpcId: string;
    }
    interface GetInternetGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An Internet Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetKeyPairFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeKeyPairs API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeKeyPairs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetLaunchConfigurationEbsBlockDevice {
        /**
         * Whether the EBS Volume will be deleted on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Name of the device.
         */
        deviceName: string;
        /**
         * Whether the volume is Encrypted.
         */
        encrypted: boolean;
        /**
         * Provisioned IOPs of the volume.
         */
        iops: number;
        /**
         * Whether the device in the block device mapping of the AMI is suppressed.
         */
        noDevice: boolean;
        /**
         * Snapshot ID of the mount.
         */
        snapshotId: string;
        /**
         * Throughput of the volume.
         */
        throughput: number;
        /**
         * Size of the volume.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }
    interface GetLaunchConfigurationEphemeralBlockDevice {
        /**
         * Name of the device.
         */
        deviceName: string;
        /**
         * Virtual Name of the device.
         */
        virtualName: string;
    }
    interface GetLaunchConfigurationMetadataOption {
        /**
         * State of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
    }
    interface GetLaunchConfigurationRootBlockDevice {
        /**
         * Whether the EBS Volume will be deleted on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Whether the volume is Encrypted.
         */
        encrypted: boolean;
        /**
         * Provisioned IOPs of the volume.
         */
        iops: number;
        /**
         * Throughput of the volume.
         */
        throughput: number;
        /**
         * Size of the volume.
         */
        volumeSize: number;
        /**
         * Type of the volume.
         */
        volumeType: string;
    }
    interface GetLaunchTemplateBlockDeviceMapping {
        deviceName: string;
        ebs: outputs.ec2.GetLaunchTemplateBlockDeviceMappingEb[];
        noDevice: string;
        virtualName: string;
    }
    interface GetLaunchTemplateBlockDeviceMappingEb {
        deleteOnTermination: string;
        encrypted: string;
        iops: number;
        kmsKeyId: string;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }
    interface GetLaunchTemplateCapacityReservationSpecification {
        capacityReservationPreference: string;
        capacityReservationTargets: outputs.ec2.GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget[];
    }
    interface GetLaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
        capacityReservationId: string;
        capacityReservationResourceGroupArn: string;
    }
    interface GetLaunchTemplateCpuOption {
        amdSevSnp: string;
        coreCount: number;
        threadsPerCore: number;
    }
    interface GetLaunchTemplateCreditSpecification {
        cpuCredits: string;
    }
    interface GetLaunchTemplateElasticGpuSpecification {
        type: string;
    }
    interface GetLaunchTemplateElasticInferenceAccelerator {
        type: string;
    }
    interface GetLaunchTemplateEnclaveOption {
        enabled: boolean;
    }
    interface GetLaunchTemplateFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeLaunchTemplates API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetLaunchTemplateHibernationOption {
        configured: boolean;
    }
    interface GetLaunchTemplateIamInstanceProfile {
        arn: string;
        /**
         * Name of the launch template.
         */
        name: string;
    }
    interface GetLaunchTemplateInstanceMarketOption {
        marketType: string;
        spotOptions: outputs.ec2.GetLaunchTemplateInstanceMarketOptionSpotOption[];
    }
    interface GetLaunchTemplateInstanceMarketOptionSpotOption {
        blockDurationMinutes: number;
        instanceInterruptionBehavior: string;
        maxPrice: string;
        spotInstanceType: string;
        validUntil: string;
    }
    interface GetLaunchTemplateInstanceRequirement {
        acceleratorCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementAcceleratorCount[];
        acceleratorManufacturers: string[];
        acceleratorNames: string[];
        acceleratorTotalMemoryMibs: outputs.ec2.GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib[];
        acceleratorTypes: string[];
        allowedInstanceTypes: string[];
        bareMetal: string;
        baselineEbsBandwidthMbps: outputs.ec2.GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp[];
        burstablePerformance: string;
        cpuManufacturers: string[];
        excludedInstanceTypes: string[];
        instanceGenerations: string[];
        localStorage: string;
        localStorageTypes: string[];
        memoryGibPerVcpus: outputs.ec2.GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus[];
        memoryMibs: outputs.ec2.GetLaunchTemplateInstanceRequirementMemoryMib[];
        networkBandwidthGbps: outputs.ec2.GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp[];
        networkInterfaceCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementNetworkInterfaceCount[];
        onDemandMaxPricePercentageOverLowestPrice: number;
        requireHibernateSupport: boolean;
        spotMaxPricePercentageOverLowestPrice: number;
        totalLocalStorageGbs: outputs.ec2.GetLaunchTemplateInstanceRequirementTotalLocalStorageGb[];
        vcpuCounts: outputs.ec2.GetLaunchTemplateInstanceRequirementVcpuCount[];
    }
    interface GetLaunchTemplateInstanceRequirementAcceleratorCount {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementAcceleratorTotalMemoryMib {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementBaselineEbsBandwidthMbp {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementMemoryGibPerVcpus {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementMemoryMib {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementNetworkBandwidthGbp {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementNetworkInterfaceCount {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementTotalLocalStorageGb {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateInstanceRequirementVcpuCount {
        max: number;
        min: number;
    }
    interface GetLaunchTemplateLicenseSpecification {
        licenseConfigurationArn: string;
    }
    interface GetLaunchTemplateMaintenanceOption {
        autoRecovery: string;
    }
    interface GetLaunchTemplateMetadataOption {
        httpEndpoint: string;
        httpProtocolIpv6: string;
        httpPutResponseHopLimit: number;
        httpTokens: string;
        instanceMetadataTags: string;
    }
    interface GetLaunchTemplateMonitoring {
        enabled: boolean;
    }
    interface GetLaunchTemplateNetworkInterface {
        associateCarrierIpAddress: string;
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description: string;
        deviceIndex: number;
        interfaceType: string;
        ipv4AddressCount: number;
        ipv4Addresses: string[];
        ipv4PrefixCount: number;
        ipv4Prefixes: string[];
        ipv6AddressCount: number;
        ipv6Addresses: string[];
        ipv6PrefixCount: number;
        ipv6Prefixes: string[];
        networkCardIndex: number;
        networkInterfaceId: string;
        privateIpAddress: string;
        securityGroups: string[];
        subnetId: string;
    }
    interface GetLaunchTemplatePlacement {
        affinity: string;
        availabilityZone: string;
        groupName: string;
        hostId: string;
        hostResourceGroupArn: string;
        partitionNumber: number;
        spreadDomain: string;
        tenancy: string;
    }
    interface GetLaunchTemplatePrivateDnsNameOption {
        enableResourceNameDnsARecord: boolean;
        enableResourceNameDnsAaaaRecord: boolean;
        hostnameType: string;
    }
    interface GetLaunchTemplateTagSpecification {
        resourceType: string;
        /**
         * Map of tags, each pair of which must exactly match a pair on the desired Launch Template.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetLocalGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetLocalGatewayRouteTableFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A local gateway route table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetLocalGatewayRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetLocalGatewayVirtualInterfaceFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetLocalGatewayVirtualInterfaceGroupFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetLocalGatewayVirtualInterfaceGroupsFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetLocalGatewaysFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLocalGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Local Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetManagedPrefixListEntry {
        cidr: string;
        description: string;
    }
    interface GetManagedPrefixListFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [DescribeManagedPrefixLists](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetManagedPrefixListsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeManagedPrefixLists.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A managed prefix list will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetNatGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An Nat Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetNatGatewaysFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Nat Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetNetworkAclsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkAcls.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetNetworkInsightsAnalysisAlternatePathHint {
        componentArn: string;
        componentId: string;
    }
    interface GetNetworkInsightsAnalysisExplanation {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisExplanationAclRule[];
        acls: outputs.ec2.GetNetworkInsightsAnalysisExplanationAcl[];
        address: string;
        addresses: string[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisExplanationAttachedTo[];
        availabilityZones: string[];
        cidrs: string[];
        classicLoadBalancerListeners: outputs.ec2.GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
        components: outputs.ec2.GetNetworkInsightsAnalysisExplanationComponent[];
        customerGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationCustomerGateway[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationDestinationVpc[];
        destinations: outputs.ec2.GetNetworkInsightsAnalysisExplanationDestination[];
        direction: string;
        elasticLoadBalancerListeners: outputs.ec2.GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
        explanationCode: string;
        ingressRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationIngressRouteTable[];
        internetGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationInternetGateway[];
        loadBalancerArn: string;
        loadBalancerListenerPort: number;
        loadBalancerTargetGroup: outputs.ec2.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetGroups: outputs.ec2.GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetPort: number;
        missingComponent: string;
        natGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationNatGateway[];
        networkInterfaces: outputs.ec2.GetNetworkInsightsAnalysisExplanationNetworkInterface[];
        packetField: string;
        port: number;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationPortRange[];
        prefixLists: outputs.ec2.GetNetworkInsightsAnalysisExplanationPrefixList[];
        protocols: string[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisExplanationRouteTableRoute[];
        routeTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationRouteTable[];
        securityGroup: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroupRule[];
        securityGroups: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroup[];
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationSourceVpc[];
        state: string;
        subnetRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationSubnetRouteTable[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisExplanationSubnet[];
        transitGatewayAttachments: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
        transitGatewayRouteTables: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationTransitGateway[];
        vpcEndpoints: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpcEndpoint[];
        vpcPeeringConnections: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpcPeeringConnection[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpc[];
        vpnConnections: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpnConnection[];
        vpnGateways: outputs.ec2.GetNetworkInsightsAnalysisExplanationVpnGateway[];
    }
    interface GetNetworkInsightsAnalysisExplanationAcl {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface GetNetworkInsightsAnalysisExplanationAclRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisExplanationAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
        instancePort: number;
        loadBalancerPort: number;
    }
    interface GetNetworkInsightsAnalysisExplanationComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationCustomerGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationDestination {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationIngressRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationInternetGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationNatGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationNetworkInterface {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationPortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisExplanationPrefixList {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface GetNetworkInsightsAnalysisExplanationSecurityGroup {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface GetNetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisExplanationSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationSubnetRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationTransitGatewayAttachment {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface GetNetworkInsightsAnalysisExplanationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationVpcEndpoint {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationVpcPeeringConnection {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationVpnConnection {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisExplanationVpnGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsAnalyses`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsAnalyses.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetNetworkInsightsAnalysisForwardPathComponent {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAclRule[];
        additionalDetails: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAttachedTo[];
        components: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentComponent[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSourceVpc[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentTransitGateway[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentVpc[];
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface GetNetworkInsightsAnalysisForwardPathComponentVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponent {
        aclRules: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAclRule[];
        additionalDetails: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAttachedTo[];
        components: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentComponent[];
        destinationVpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSourceVpc[];
        subnets: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentTransitGateway[];
        vpcs: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentVpc[];
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentAttachedTo {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentComponent {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentDestinationVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentSourceVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentSubnet {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentTransitGateway {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface GetNetworkInsightsAnalysisReturnPathComponentVpc {
        /**
         * ARN of the selected Network Insights Analysis.
         */
        arn: string;
        id: string;
        name: string;
    }
    interface GetNetworkInsightsPathFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeNetworkInsightsPaths`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInsightsPaths.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetNetworkInterfaceAssociation {
        /**
         * Allocation ID.
         */
        allocationId: string;
        /**
         * Association ID.
         */
        associationId: string;
        /**
         * Carrier IP address associated with the network interface. This attribute is only set when the network interface is in a subnet which is associated with a Wavelength Zone.
         */
        carrierIp: string;
        /**
         * Customer-owned IP address.
         */
        customerOwnedIp: string;
        /**
         * ID of the Elastic IP address owner.
         */
        ipOwnerId: string;
        /**
         * Public DNS name.
         */
        publicDnsName: string;
        /**
         * Address of the Elastic IP address bound to the network interface.
         */
        publicIp: string;
    }
    interface GetNetworkInterfaceAttachment {
        attachmentId: string;
        deviceIndex: number;
        instanceId: string;
        instanceOwnerId: string;
    }
    interface GetNetworkInterfaceFilter {
        name: string;
        values: string[];
    }
    interface GetNetworkInterfacesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }
    interface GetPrefixListFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribePrefixLists API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePrefixLists.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetPublicIpv4PoolPoolAddressRange {
        /**
         * Number of addresses in the range.
         */
        addressCount: number;
        /**
         * Number of available addresses in the range.
         */
        availableAddressCount: number;
        /**
         * First address in the range.
         */
        firstAddress: string;
        /**
         * Last address in the range.
         */
        lastAddress: string;
    }
    interface GetPublicIpv4PoolsFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribePublicIpv4Pools.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. Pool IDs will be selected if any one of the given values match.
         */
        values: string[];
    }
    interface GetRouteTableAssociation {
        /**
         * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
         */
        gatewayId: string;
        /**
         * Whether the association is due to the main route table.
         */
        main: boolean;
        /**
         * Association ID.
         */
        routeTableAssociationId: string;
        /**
         * ID of the specific Route Table to retrieve.
         */
        routeTableId: string;
        /**
         * ID of a Subnet which is connected to the Route Table (not exported if not passed as a parameter).
         */
        subnetId: string;
    }
    interface GetRouteTableFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetRouteTableRoute {
        /**
         * ID of the Carrier Gateway.
         */
        carrierGatewayId: string;
        /**
         * CIDR block of the route.
         */
        cidrBlock: string;
        /**
         * ARN of the core network.
         */
        coreNetworkArn: string;
        /**
         * The ID of a managed prefix list destination of the route.
         */
        destinationPrefixListId: string;
        /**
         * ID of the Egress Only Internet Gateway.
         */
        egressOnlyGatewayId: string;
        /**
         * ID of an Internet Gateway or Virtual Private Gateway which is connected to the Route Table (not exported if not passed as a parameter).
         */
        gatewayId: string;
        /**
         * EC2 instance ID.
         */
        instanceId: string;
        /**
         * IPv6 CIDR block of the route.
         */
        ipv6CidrBlock: string;
        /**
         * Local Gateway ID.
         */
        localGatewayId: string;
        /**
         * NAT Gateway ID.
         */
        natGatewayId: string;
        /**
         * ID of the elastic network interface (eni) to use.
         */
        networkInterfaceId: string;
        /**
         * EC2 Transit Gateway ID.
         */
        transitGatewayId: string;
        /**
         * VPC Endpoint ID.
         */
        vpcEndpointId: string;
        /**
         * VPC Peering ID.
         */
        vpcPeeringConnectionId: string;
    }
    interface GetRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetSecurityGroupFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Security Group will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetSecurityGroupsFilter {
        name: string;
        values: string[];
    }
    interface GetSpotPriceFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetSubnetFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A subnet will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetSubnetsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html).
         * For example, if matching against tag `Name`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.ec2.getSubnets({
         *     filters: [{
         *         name: "tag:Name",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * Subnet IDs will be selected if any one of the given values match.
         */
        values: string[];
    }
    interface GetTransitGatewayRouteTablesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayRouteTables.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpcCidrBlockAssociation {
        /**
         * Association ID for the IPv4 CIDR block.
         */
        associationId: string;
        /**
         * Cidr block of the desired VPC.
         */
        cidrBlock: string;
        /**
         * Current state of the desired VPC.
         * Can be either `"pending"` or `"available"`.
         */
        state: string;
    }
    interface GetVpcDhcpOptionsFilter {
        /**
         * Name of the field to filter.
         */
        name: string;
        /**
         * Set of values for filtering.
         */
        values: string[];
    }
    interface GetVpcEndpointDnsEntry {
        /**
         * DNS name.
         */
        dnsName: string;
        /**
         * ID of the private hosted zone.
         */
        hostedZoneId: string;
    }
    interface GetVpcEndpointDnsOption {
        /**
         * The DNS records created for the endpoint.
         */
        dnsRecordIpType: string;
        /**
         * Indicates whether to enable private DNS only for inbound endpoints.
         */
        privateDnsOnlyForInboundResolverEndpoint: boolean;
    }
    interface GetVpcEndpointFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Endpoint will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpcEndpointServiceFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeVpcEndpointServices API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetVpcFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpcIamPoolCidrsFilter {
        name: string;
        values: string[];
    }
    interface GetVpcIamPoolCidrsIpamPoolCidr {
        /**
         * A network CIDR.
         */
        cidr: string;
        /**
         * The provisioning state of that CIDR.
         */
        state: string;
    }
    interface GetVpcIamPoolFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }
    interface GetVpcIamPoolsFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }
    interface GetVpcIamPoolsIpamPool {
        /**
         * IP protocol assigned to this pool.
         */
        addressFamily: string;
        /**
         * A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
         */
        allocationDefaultNetmaskLength: number;
        /**
         * The maximum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMaxNetmaskLength: number;
        /**
         * The minimum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMinNetmaskLength: number;
        /**
         * Tags that are required to create resources in using this pool.
         */
        allocationResourceTags: {
            [key: string]: string;
        };
        /**
         * ARN of the pool
         */
        arn: string;
        /**
         * If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
         */
        autoImport: boolean;
        /**
         * Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
         */
        awsService: string;
        /**
         * Description for the IPAM pool.
         */
        description: string;
        /**
         * ID of the IPAM pool.
         */
        id: string;
        /**
         * ID of the scope the pool belongs to.
         */
        ipamScopeId: string;
        ipamScopeType: string;
        /**
         * Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
         */
        locale: string;
        poolDepth: number;
        /**
         * Defines whether or not IPv6 pool space is publicly advertisable over the internet.
         */
        publiclyAdvertisable: boolean;
        /**
         * ID of the source IPAM pool.
         */
        sourceIpamPoolId: string;
        state: string;
        /**
         * Map of tags to assigned to the resource.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetVpcIpamPoolCidrsFilter {
        name: string;
        values: string[];
    }
    interface GetVpcIpamPoolCidrsIpamPoolCidr {
        /**
         * A network CIDR.
         */
        cidr: string;
        /**
         * The provisioning state of that CIDR.
         */
        state: string;
    }
    interface GetVpcIpamPoolFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }
    interface GetVpcIpamPoolsFilter {
        /**
         * The name of the filter. Filter names are case-sensitive.
         */
        name: string;
        /**
         * The filter values. Filter values are case-sensitive.
         */
        values: string[];
    }
    interface GetVpcIpamPoolsIpamPool {
        /**
         * IP protocol assigned to this pool.
         */
        addressFamily: string;
        /**
         * A default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is `10.0.0.0/8` and you enter 16 here, new allocations will default to `10.0.0.0/16`.
         */
        allocationDefaultNetmaskLength: number;
        /**
         * The maximum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMaxNetmaskLength: number;
        /**
         * The minimum netmask length that will be required for CIDR allocations in this pool.
         */
        allocationMinNetmaskLength: number;
        /**
         * Tags that are required to create resources in using this pool.
         */
        allocationResourceTags: {
            [key: string]: string;
        };
        /**
         * ARN of the pool
         */
        arn: string;
        /**
         * If enabled, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.
         */
        autoImport: boolean;
        /**
         * Limits which service in AWS that the pool can be used in. `ec2` for example, allows users to use space for Elastic IP addresses and VPCs.
         */
        awsService: string;
        /**
         * Description for the IPAM pool.
         */
        description: string;
        /**
         * ID of the IPAM pool.
         */
        id: string;
        /**
         * ID of the scope the pool belongs to.
         */
        ipamScopeId: string;
        ipamScopeType: string;
        /**
         * Locale is the Region where your pool is available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region.
         */
        locale: string;
        poolDepth: number;
        /**
         * Defines whether or not IPv6 pool space is publicly advertisable over the internet.
         */
        publiclyAdvertisable: boolean;
        /**
         * ID of the source IPAM pool.
         */
        sourceIpamPoolId: string;
        state: string;
        /**
         * Map of tags to assigned to the resource.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetVpcPeeringConnectionCidrBlockSet {
        /**
         * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
         */
        cidrBlock: string;
    }
    interface GetVpcPeeringConnectionFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Peering Connection will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpcPeeringConnectionIpv6CidrBlockSet {
        ipv6CidrBlock: string;
    }
    interface GetVpcPeeringConnectionPeerCidrBlockSet {
        /**
         * Primary CIDR block of the requester VPC of the specific VPC Peering Connection to retrieve.
         */
        cidrBlock: string;
    }
    interface GetVpcPeeringConnectionPeerIpv6CidrBlockSet {
        ipv6CidrBlock: string;
    }
    interface GetVpcPeeringConnectionsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC Peering Connection will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpcsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPC will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetVpnGatewayFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnGateways.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A VPN Gateway will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface InstanceCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
         */
        capacityReservationPreference?: string;
        /**
         * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
         *
         * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
         */
        capacityReservationTarget?: outputs.ec2.InstanceCapacityReservationSpecificationCapacityReservationTarget;
    }
    interface InstanceCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }
    interface InstanceCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp: string;
        /**
         * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
         */
        coreCount: number;
        /**
         * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
         *
         * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
         */
        threadsPerCore: number;
    }
    interface InstanceCreditSpecification {
        /**
         * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
         */
        cpuCredits?: string;
    }
    interface InstanceEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Snapshot ID to mount.
         */
        snapshotId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
         */
        tagsAll: {
            [key: string]: string;
        };
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
         */
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
         */
        volumeType: string;
    }
    interface InstanceEnclaveOptions {
        /**
         * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled: boolean;
    }
    interface InstanceEphemeralBlockDevice {
        /**
         * Name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: boolean;
        /**
         * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
         *
         * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
         */
        virtualName?: string;
    }
    interface InstanceInstanceMarketOptions {
        /**
         * Type of market for the instance. Valid value is `spot`. Defaults to `spot`. Required if `spotOptions` is specified.
         */
        marketType: string;
        /**
         * Block to configure the options for Spot Instances. See Spot Options below for details on attributes.
         */
        spotOptions: outputs.ec2.InstanceInstanceMarketOptionsSpotOptions;
    }
    interface InstanceInstanceMarketOptionsSpotOptions {
        /**
         * The behavior when a Spot Instance is interrupted. Valid values include `hibernate`, `stop`, `terminate` . The default is `terminate`.
         */
        instanceInterruptionBehavior: string;
        /**
         * The maximum hourly price that you're willing to pay for a Spot Instance.
         */
        maxPrice: string;
        /**
         * The Spot Instance request type. Valid values include `one-time`, `persistent`. Persistent Spot Instance requests are only supported when the instance interruption behavior is either hibernate or stop. The default is `one-time`.
         */
        spotInstanceType: string;
        /**
         * The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
         */
        validUntil: string;
    }
    interface InstanceLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
         */
        version?: string;
    }
    interface InstanceMaintenanceOptions {
        /**
         * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery: string;
    }
    interface InstanceMetadataOptions {
        /**
         * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
         */
        httpEndpoint?: string;
        /**
         * Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
         */
        httpProtocolIpv6?: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }
    interface InstanceNetworkInterface {
        /**
         * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
         */
        deleteOnTermination?: boolean;
        /**
         * Integer index of the network interface attachment. Limited by instance type.
         */
        deviceIndex: number;
        /**
         * Integer index of the network card. Limited by instance type. The default index is `0`.
         */
        networkCardIndex?: number;
        /**
         * ID of the network interface to attach.
         */
        networkInterfaceId: string;
    }
    interface InstancePrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType: string;
    }
    interface InstanceRootBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Device name, e.g., `/dev/sdh` or `xvdh`.
         */
        deviceName: string;
        /**
         * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
         */
        tagsAll: {
            [key: string]: string;
        };
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        /**
         * ID of the volume. For example, the ID can be accessed like this, `aws_instance.web.root_block_device.0.volume_id`.
         */
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
         *
         * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
         */
        volumeType: string;
    }
    interface LaunchConfigurationEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        encrypted: boolean;
        iops: number;
        noDevice?: boolean;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }
    interface LaunchConfigurationEphemeralBlockDevice {
        deviceName: string;
        noDevice?: boolean;
        virtualName?: string;
    }
    interface LaunchConfigurationMetadataOptions {
        /**
         * The state of the metadata service: `enabled`, `disabled`.
         */
        httpEndpoint: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit: number;
        /**
         * If session tokens are required: `optional`, `required`.
         */
        httpTokens: string;
    }
    interface LaunchConfigurationRootBlockDevice {
        deleteOnTermination?: boolean;
        encrypted: boolean;
        iops: number;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }
    interface LaunchTemplateBlockDeviceMapping {
        /**
         * The name of the device to mount.
         */
        deviceName?: string;
        /**
         * Configure EBS volume properties.
         */
        ebs?: outputs.ec2.LaunchTemplateBlockDeviceMappingEbs;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: string;
        /**
         * The [Instance Store Device
         * Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
         * (e.g., `"ephemeral0"`).
         */
        virtualName?: string;
    }
    interface LaunchTemplateBlockDeviceMappingEbs {
        /**
         * Whether the volume should be destroyed on instance termination.
         * See [Preserving Amazon EBS Volumes on Instance Termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/preserving-volumes-on-termination.html) for more information.
         */
        deleteOnTermination?: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         * Cannot be used with `snapshotId`.
         */
        encrypted?: string;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
         * This must be set with a `volumeType` of `"io1/io2/gp3"`.
         */
        iops: number;
        /**
         * The ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume.
         * `encrypted` must be set to `true` when this is set.
         */
        kmsKeyId?: string;
        /**
         * The Snapshot ID to mount.
         */
        snapshotId?: string;
        /**
         * The throughput to provision for a `gp3` volume in MiB/s (specified as an integer, e.g., 500), with a maximum of 1,000 MiB/s.
         */
        throughput: number;
        /**
         * The size of the volume in gigabytes.
         */
        volumeSize: number;
        /**
         * The volume type.
         * Can be one of `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1` or `st1`.
         */
        volumeType: string;
    }
    interface LaunchTemplateCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `open` or `none`. (Default `none`).
         */
        capacityReservationPreference?: string;
        /**
         * Used to target a specific Capacity Reservation:
         */
        capacityReservationTarget?: outputs.ec2.LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget;
    }
    interface LaunchTemplateCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * The ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * The ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }
    interface LaunchTemplateCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp?: string;
        /**
         * The number of CPU cores for the instance.
         */
        coreCount?: number;
        /**
         * The number of threads per CPU core.
         * To disable Intel Hyper-Threading Technology for the instance, specify a value of 1.
         * Otherwise, specify the default value of 2.
         *
         * Both number of CPU cores and threads per core must be specified. Valid number of CPU cores and threads per core for the instance type can be found in the [CPU Options Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html?shortFooter=true#cpu-options-supported-instances-values)
         */
        threadsPerCore?: number;
    }
    interface LaunchTemplateCreditSpecification {
        /**
         * The credit option for CPU usage.
         * Can be `standard` or `unlimited`.
         * T3 instances are launched as `unlimited` by default.
         * T2 instances are launched as `standard` by default.
         */
        cpuCredits?: string;
    }
    interface LaunchTemplateElasticGpuSpecification {
        /**
         * The [Elastic GPU Type](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-gpus.html#elastic-gpus-basics)
         */
        type: string;
    }
    interface LaunchTemplateElasticInferenceAccelerator {
        /**
         * Accelerator type.
         */
        type: string;
    }
    interface LaunchTemplateEnclaveOptions {
        /**
         * If set to `true`, Nitro Enclaves will be enabled on the instance.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled?: boolean;
    }
    interface LaunchTemplateHibernationOptions {
        /**
         * If set to `true`, the launched EC2 instance will hibernation enabled.
         */
        configured: boolean;
    }
    interface LaunchTemplateIamInstanceProfile {
        /**
         * The Amazon Resource Name (ARN) of the instance profile. Conflicts with `name`.
         */
        arn?: string;
        /**
         * The name of the instance profile.
         */
        name?: string;
    }
    interface LaunchTemplateInstanceMarketOptions {
        /**
         * The market type. Can be `spot`.
         */
        marketType?: string;
        /**
         * The options for [Spot Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html)
         */
        spotOptions?: outputs.ec2.LaunchTemplateInstanceMarketOptionsSpotOptions;
    }
    interface LaunchTemplateInstanceMarketOptionsSpotOptions {
        /**
         * The required duration in minutes. This value must be a multiple of 60.
         */
        blockDurationMinutes?: number;
        /**
         * The behavior when a Spot Instance is interrupted. Can be `hibernate`,
         * `stop`, or `terminate`. (Default: `terminate`).
         */
        instanceInterruptionBehavior?: string;
        /**
         * The maximum hourly price you're willing to pay for the Spot Instances.
         */
        maxPrice?: string;
        /**
         * The Spot Instance request type. Can be `one-time`, or `persistent`.
         */
        spotInstanceType?: string;
        /**
         * The end date of the request.
         */
        validUntil: string;
    }
    interface LaunchTemplateInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
         */
        acceleratorCount?: outputs.ec2.LaunchTemplateInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         *
         * ```
         * Valid names:
         * * amazon-web-services
         * * amd
         * * nvidia
         * * xilinx
         * ```
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         *
         * ```
         * Valid names:
         * * a100            - NVIDIA A100 GPUs
         * * v100            - NVIDIA V100 GPUs
         * * k80             - NVIDIA K80 GPUs
         * * t4              - NVIDIA T4 GPUs
         * * m60             - NVIDIA M60 GPUs
         * * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
         * * vu9p            - Xilinx VU9P FPGAs
         * ```
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * List of accelerator types. Default is any accelerator type.
         *
         * ```
         * Valid types:
         * * fpga
         * * gpu
         * * inference
         * ```
         */
        acceleratorTypes?: string[];
        /**
         * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
         *
         * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * List of CPU manufacturer names. Default is any manufacturer.
         *
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         *
         * ```
         * Valid names:
         * * amazon-web-services
         * * amd
         * * intel
         * ```
         */
        cpuManufacturers?: string[];
        /**
         * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * List of instance generation names. Default is any generation.
         *
         * ```
         * Valid names:
         * * current  - Recommended for best performance.
         * * previous - For existing applications optimized for older instance types.
         * ```
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Default any storage type.
         *
         * ```
         * Value names:
         * * hdd - hard disk drive
         * * ssd - solid state drive
         * ```
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.LaunchTemplateInstanceRequirementsMemoryGibPerVcpu;
        /**
         * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
         */
        memoryMib: outputs.ec2.LaunchTemplateInstanceRequirementsMemoryMib;
        /**
         * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.LaunchTemplateInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.LaunchTemplateInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.LaunchTemplateInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount: outputs.ec2.LaunchTemplateInstanceRequirementsVcpuCount;
    }
    interface LaunchTemplateInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. May be a decimal number, e.g. `0.5`.
         */
        max?: number;
        /**
         * Minimum. May be a decimal number, e.g. `0.5`.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsMemoryMib {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface LaunchTemplateInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. May be a decimal number, e.g. `0.5`.
         */
        max?: number;
        /**
         * Minimum. May be a decimal number, e.g. `0.5`.
         */
        min?: number;
    }
    interface LaunchTemplateInstanceRequirementsVcpuCount {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min: number;
    }
    interface LaunchTemplateLicenseSpecification {
        /**
         * ARN of the license configuration.
         */
        licenseConfigurationArn: string;
    }
    interface LaunchTemplateMaintenanceOptions {
        /**
         * Disables the automatic recovery behavior of your instance or sets it to default. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery?: string;
    }
    interface LaunchTemplateMetadataOptions {
        /**
         * Whether the metadata service is available. Can be `"enabled"` or `"disabled"`. (Default: `"enabled"`).
         */
        httpEndpoint: string;
        /**
         * Enables or disables the IPv6 endpoint for the instance metadata service. Can be `"enabled"` or `"disabled"`.
         */
        httpProtocolIpv6: string;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Can be an integer from `1` to `64`. (Default: `1`).
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Can be `"optional"` or `"required"`. (Default: `"optional"`).
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Can be `"enabled"` or `"disabled"`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }
    interface LaunchTemplateMonitoring {
        /**
         * If `true`, the launched EC2 instance will have detailed monitoring enabled.
         */
        enabled?: boolean;
    }
    interface LaunchTemplateNetworkInterface {
        /**
         * Associate a Carrier IP address with `eth0` for a new network interface.
         * Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface.
         * Boolean value, can be left unset.
         */
        associateCarrierIpAddress?: string;
        /**
         * Associate a public ip address with the network interface.
         * Boolean value, can be left unset.
         */
        associatePublicIpAddress?: string;
        /**
         * Whether the network interface should be destroyed on instance termination.
         */
        deleteOnTermination?: string;
        /**
         * Description of the network interface.
         */
        description?: string;
        /**
         * The integer index of the network interface attachment.
         */
        deviceIndex?: number;
        /**
         * The type of network interface. To create an Elastic Fabric Adapter (EFA), specify `efa`.
         */
        interfaceType?: string;
        /**
         * The number of secondary private IPv4 addresses to assign to a network interface. Conflicts with `ipv4Addresses`
         */
        ipv4AddressCount?: number;
        /**
         * One or more private IPv4 addresses to associate. Conflicts with `ipv4AddressCount`
         */
        ipv4Addresses?: string[];
        /**
         * The number of IPv4 prefixes to be automatically assigned to the network interface. Conflicts with `ipv4Prefixes`
         */
        ipv4PrefixCount?: number;
        /**
         * One or more IPv4 prefixes to be assigned to the network interface. Conflicts with `ipv4PrefixCount`
         */
        ipv4Prefixes?: string[];
        /**
         * The number of IPv6 addresses to assign to a network interface. Conflicts with `ipv6Addresses`
         */
        ipv6AddressCount?: number;
        /**
         * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. Conflicts with `ipv6AddressCount`
         */
        ipv6Addresses?: string[];
        /**
         * The number of IPv6 prefixes to be automatically assigned to the network interface. Conflicts with `ipv6Prefixes`
         */
        ipv6PrefixCount?: number;
        /**
         * One or more IPv6 prefixes to be assigned to the network interface. Conflicts with `ipv6PrefixCount`
         */
        ipv6Prefixes?: string[];
        /**
         * The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
         */
        networkCardIndex?: number;
        /**
         * The ID of the network interface to attach.
         */
        networkInterfaceId?: string;
        /**
         * The primary private IPv4 address.
         */
        privateIpAddress?: string;
        /**
         * A list of security group IDs to associate.
         */
        securityGroups?: string[];
        /**
         * The VPC Subnet ID to associate.
         */
        subnetId?: string;
    }
    interface LaunchTemplatePlacement {
        /**
         * The affinity setting for an instance on a Dedicated Host.
         */
        affinity?: string;
        /**
         * The Availability Zone for the instance.
         */
        availabilityZone?: string;
        /**
         * The name of the placement group for the instance.
         */
        groupName?: string;
        /**
         * The ID of the Dedicated Host for the instance.
         */
        hostId?: string;
        /**
         * The ARN of the Host Resource Group in which to launch instances.
         */
        hostResourceGroupArn?: string;
        /**
         * The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
         */
        partitionNumber?: number;
        /**
         * Reserved for future use.
         */
        spreadDomain?: string;
        /**
         * The tenancy of the instance (if the instance is running in a VPC). Can be `default`, `dedicated`, or `host`.
         */
        tenancy?: string;
    }
    interface LaunchTemplatePrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord?: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord?: boolean;
        /**
         * The type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType?: string;
    }
    interface LaunchTemplateTagSpecification {
        /**
         * The type of resource to tag.
         */
        resourceType?: string;
        /**
         * A map of tags to assign to the resource.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface ManagedPrefixListEntry {
        /**
         * CIDR block of this entry.
         */
        cidr: string;
        /**
         * Description of this entry. Due to API limitations, updating only the description of an existing entry requires temporarily removing and re-adding the entry.
         */
        description?: string;
    }
    interface NetworkAclEgress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a
         * valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         *
         * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all'
         * protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         */
        toPort: number;
    }
    interface NetworkAclIngress {
        /**
         * The action to take.
         */
        action: string;
        /**
         * The CIDR block to match. This must be a
         * valid network mask.
         */
        cidrBlock?: string;
        /**
         * The from port to match.
         */
        fromPort: number;
        /**
         * The ICMP type code to be used. Default 0.
         *
         * > Note: For more information on ICMP types and codes, see here: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
         */
        icmpCode?: number;
        /**
         * The ICMP type to be used. Default 0.
         */
        icmpType?: number;
        /**
         * The IPv6 CIDR block.
         */
        ipv6CidrBlock?: string;
        /**
         * The protocol to match. If using the -1 'all'
         * protocol, you must specify a from and to port of 0.
         */
        protocol: string;
        /**
         * The rule number. Used for ordering.
         */
        ruleNo: number;
        /**
         * The to port to match.
         */
        toPort: number;
    }
    interface NetworkInsightsAnalysisAlternatePathHint {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn: string;
        /**
         * The ID of the component.
         */
        componentId: string;
    }
    interface NetworkInsightsAnalysisExplanation {
        aclRules: outputs.ec2.NetworkInsightsAnalysisExplanationAclRule[];
        acls: outputs.ec2.NetworkInsightsAnalysisExplanationAcl[];
        address: string;
        addresses: string[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisExplanationAttachedTo[];
        availabilityZones: string[];
        cidrs: string[];
        classicLoadBalancerListeners: outputs.ec2.NetworkInsightsAnalysisExplanationClassicLoadBalancerListener[];
        components: outputs.ec2.NetworkInsightsAnalysisExplanationComponent[];
        customerGateways: outputs.ec2.NetworkInsightsAnalysisExplanationCustomerGateway[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisExplanationDestinationVpc[];
        destinations: outputs.ec2.NetworkInsightsAnalysisExplanationDestination[];
        direction: string;
        elasticLoadBalancerListeners: outputs.ec2.NetworkInsightsAnalysisExplanationElasticLoadBalancerListener[];
        explanationCode: string;
        ingressRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationIngressRouteTable[];
        internetGateways: outputs.ec2.NetworkInsightsAnalysisExplanationInternetGateway[];
        loadBalancerArn: string;
        loadBalancerListenerPort: number;
        loadBalancerTargetGroup: outputs.ec2.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetGroups: outputs.ec2.NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup[];
        loadBalancerTargetPort: number;
        missingComponent: string;
        natGateways: outputs.ec2.NetworkInsightsAnalysisExplanationNatGateway[];
        networkInterfaces: outputs.ec2.NetworkInsightsAnalysisExplanationNetworkInterface[];
        packetField: string;
        port: number;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationPortRange[];
        prefixLists: outputs.ec2.NetworkInsightsAnalysisExplanationPrefixList[];
        protocols: string[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisExplanationRouteTableRoute[];
        routeTables: outputs.ec2.NetworkInsightsAnalysisExplanationRouteTable[];
        securityGroup: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroup[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroupRule[];
        securityGroups: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroup[];
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisExplanationSourceVpc[];
        state: string;
        subnetRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationSubnetRouteTable[];
        subnets: outputs.ec2.NetworkInsightsAnalysisExplanationSubnet[];
        transitGatewayAttachments: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayAttachment[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute[];
        transitGatewayRouteTables: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGatewayRouteTable[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisExplanationTransitGateway[];
        vpcEndpoints: outputs.ec2.NetworkInsightsAnalysisExplanationVpcEndpoint[];
        vpcPeeringConnections: outputs.ec2.NetworkInsightsAnalysisExplanationVpcPeeringConnection[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisExplanationVpc[];
        vpnConnections: outputs.ec2.NetworkInsightsAnalysisExplanationVpnConnection[];
        vpnGateways: outputs.ec2.NetworkInsightsAnalysisExplanationVpnGateway[];
    }
    interface NetworkInsightsAnalysisExplanationAcl {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface NetworkInsightsAnalysisExplanationAclRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisExplanationAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationClassicLoadBalancerListener {
        instancePort: number;
        loadBalancerPort: number;
    }
    interface NetworkInsightsAnalysisExplanationComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationCustomerGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationDestination {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationElasticLoadBalancerListener {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationIngressRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationInternetGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationLoadBalancerTargetGroup {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationNatGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationNetworkInterface {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationPortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisExplanationPrefixList {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface NetworkInsightsAnalysisExplanationSecurityGroup {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface NetworkInsightsAnalysisExplanationSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisExplanationSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationSubnetRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationTransitGatewayAttachment {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTable {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface NetworkInsightsAnalysisExplanationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationVpcEndpoint {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationVpcPeeringConnection {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationVpnConnection {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisExplanationVpnGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponent {
        aclRules: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAclRule[];
        additionalDetails: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAttachedTo[];
        components: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentComponent[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSourceVpc[];
        subnets: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentTransitGateway[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentVpc[];
    }
    interface NetworkInsightsAnalysisForwardPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentAclRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent[];
    }
    interface NetworkInsightsAnalysisForwardPathComponentAdditionalDetailComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange[];
    }
    interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange[];
    }
    interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisForwardPathComponentSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface NetworkInsightsAnalysisForwardPathComponentVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponent {
        aclRules: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAclRule[];
        additionalDetails: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAdditionalDetail[];
        attachedTos: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAttachedTo[];
        components: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentComponent[];
        destinationVpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentDestinationVpc[];
        inboundHeaders: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeader[];
        outboundHeaders: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeader[];
        routeTableRoutes: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentRouteTableRoute[];
        securityGroupRules: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule[];
        sequenceNumber: number;
        sourceVpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSourceVpc[];
        subnets: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSubnet[];
        transitGatewayRouteTableRoutes: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute[];
        transitGateways: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentTransitGateway[];
        vpcs: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentVpc[];
    }
    interface NetworkInsightsAnalysisReturnPathComponentAclRule {
        cidr: string;
        egress: boolean;
        portRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAclRulePortRange[];
        protocol: string;
        ruleAction: string;
        ruleNumber: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentAclRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetail {
        additionalDetailType: string;
        components: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent[];
    }
    interface NetworkInsightsAnalysisReturnPathComponentAdditionalDetailComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentAttachedTo {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentComponent {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentDestinationVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentInboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange[];
    }
    interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentInboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentOutboundHeader {
        destinationAddresses: string[];
        destinationPortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange[];
        protocol: string;
        sourceAddresses: string[];
        sourcePortRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange[];
    }
    interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderDestinationPortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentOutboundHeaderSourcePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentRouteTableRoute {
        destinationCidr: string;
        destinationPrefixListId: string;
        egressOnlyInternetGatewayId: string;
        gatewayId: string;
        instanceId: string;
        natGatewayId: string;
        networkInterfaceId: string;
        origin: string;
        transitGatewayId: string;
        vpcPeeringConnectionId: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRule {
        cidr: string;
        direction: string;
        portRanges: outputs.ec2.NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange[];
        prefixListId: string;
        protocol: string;
        securityGroupId: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentSecurityGroupRulePortRange {
        from: number;
        to: number;
    }
    interface NetworkInsightsAnalysisReturnPathComponentSourceVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentSubnet {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentTransitGateway {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentTransitGatewayRouteTableRoute {
        attachmentId: string;
        destinationCidr: string;
        prefixListId: string;
        resourceId: string;
        resourceType: string;
        routeOrigin: string;
        state: string;
    }
    interface NetworkInsightsAnalysisReturnPathComponentVpc {
        /**
         * ARN of the Network Insights Analysis.
         */
        arn: string;
        /**
         * ID of the Network Insights Analysis.
         */
        id: string;
        name: string;
    }
    interface NetworkInterfaceAttachment {
        attachmentId: string;
        /**
         * Integer to define the devices index.
         */
        deviceIndex: number;
        /**
         * ID of the instance to attach to.
         */
        instance: string;
    }
    interface PeeringConnectionOptionsAccepter {
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface PeeringConnectionOptionsRequester {
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface RouteTableRoute {
        /**
         * Identifier of a carrier gateway. This attribute can only be used when the VPC contains a subnet which is associated with a Wavelength Zone.
         */
        carrierGatewayId?: string;
        /**
         * The CIDR block of the route.
         */
        cidrBlock?: string;
        /**
         * The Amazon Resource Name (ARN) of a core network.
         */
        coreNetworkArn?: string;
        /**
         * The ID of a managed prefix list destination of the route.
         *
         * One of the following target arguments must be supplied:
         */
        destinationPrefixListId?: string;
        /**
         * Identifier of a VPC Egress Only Internet Gateway.
         */
        egressOnlyGatewayId?: string;
        /**
         * Identifier of a VPC internet gateway, virtual private gateway, or `local`. `local` routes cannot be created but can be adopted or imported. See the example above.
         */
        gatewayId?: string;
        /**
         * The Ipv6 CIDR block of the route.
         */
        ipv6CidrBlock?: string;
        /**
         * Identifier of a Outpost local gateway.
         */
        localGatewayId?: string;
        /**
         * Identifier of a VPC NAT gateway.
         */
        natGatewayId?: string;
        /**
         * Identifier of an EC2 network interface.
         */
        networkInterfaceId?: string;
        /**
         * Identifier of an EC2 Transit Gateway.
         */
        transitGatewayId?: string;
        /**
         * Identifier of a VPC Endpoint.
         */
        vpcEndpointId?: string;
        /**
         * Identifier of a VPC peering connection.
         *
         * Note that the default route, mapping the VPC's CIDR block to "local", is created implicitly and cannot be specified.
         */
        vpcPeeringConnectionId?: string;
    }
    interface SecurityGroupEgress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this egress rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp`)
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of Prefix List IDs.
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0. The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this egress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         *
         * The following arguments are optional:
         *
         * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the destination of the traffic.
         */
        toPort: number;
    }
    interface SecurityGroupIngress {
        /**
         * List of CIDR blocks.
         */
        cidrBlocks?: string[];
        /**
         * Description of this ingress rule.
         */
        description?: string;
        /**
         * Start port (or ICMP type number if protocol is `icmp` or `icmpv6`).
         */
        fromPort: number;
        /**
         * List of IPv6 CIDR blocks.
         */
        ipv6CidrBlocks?: string[];
        /**
         * List of Prefix List IDs.
         */
        prefixListIds?: string[];
        /**
         * Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `fromPort` and `toPort` equal to 0. The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference.
         *
         * The following arguments are optional:
         *
         * > **Note** Although `cidrBlocks`, `ipv6CidrBlocks`, `prefixListIds`, and `securityGroups` are all marked as optional, you _must_ provide one of them in order to configure the source of the traffic.
         */
        protocol: string;
        /**
         * List of security groups. A group name can be used relative to the default VPC. Otherwise, group ID.
         */
        securityGroups?: string[];
        /**
         * Whether the security group itself will be added as a source to this ingress rule.
         */
        self?: boolean;
        /**
         * End range port (or ICMP code if protocol is `icmp`).
         */
        toPort: number;
    }
    interface SpotFleetRequestLaunchSpecification {
        ami: string;
        associatePublicIpAddress?: boolean;
        availabilityZone: string;
        ebsBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationEbsBlockDevice[];
        ebsOptimized?: boolean;
        ephemeralBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationEphemeralBlockDevice[];
        iamInstanceProfile?: string;
        iamInstanceProfileArn?: string;
        instanceType: string;
        keyName: string;
        monitoring?: boolean;
        placementGroup: string;
        placementTenancy?: string;
        rootBlockDevices: outputs.ec2.SpotFleetRequestLaunchSpecificationRootBlockDevice[];
        /**
         * The maximum bid price per unit hour.
         */
        spotPrice?: string;
        subnetId: string;
        /**
         * A map of tags to assign to the resource. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {
            [key: string]: string;
        };
        userData?: string;
        vpcSecurityGroupIds: string[];
        weightedCapacity?: string;
    }
    interface SpotFleetRequestLaunchSpecificationEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        encrypted: boolean;
        iops: number;
        kmsKeyId: string;
        snapshotId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }
    interface SpotFleetRequestLaunchSpecificationEphemeralBlockDevice {
        deviceName: string;
        virtualName: string;
    }
    interface SpotFleetRequestLaunchSpecificationRootBlockDevice {
        deleteOnTermination?: boolean;
        encrypted: boolean;
        iops: number;
        kmsKeyId: string;
        throughput: number;
        volumeSize: number;
        volumeType: string;
    }
    interface SpotFleetRequestLaunchTemplateConfig {
        /**
         * Launch template specification. See Launch Template Specification below for more details.
         */
        launchTemplateSpecification: outputs.ec2.SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification;
        /**
         * One or more override configurations. See Overrides below for more details.
         */
        overrides?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverride[];
    }
    interface SpotFleetRequestLaunchTemplateConfigLaunchTemplateSpecification {
        /**
         * The ID of the launch template. Conflicts with `name`.
         */
        id?: string;
        /**
         * The name of the launch template. Conflicts with `id`.
         */
        name?: string;
        /**
         * Template version. Unlike the autoscaling equivalent, does not support `$Latest` or `$Default`, so use the launchTemplate resource's attribute, e.g., `"${aws_launch_template.foo.latest_version}"`. It will use the default version if omitted.
         *
         * **Note:** The specified launch template can specify only a subset of the
         * inputs of `aws.ec2.LaunchTemplate`.  There are limitations on
         * what you can specify as spot fleet does not support all the attributes that are supported by autoscaling groups. [AWS documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#launch-templates-spot-fleet) is currently sparse, but at least `instanceInitiatedShutdownBehavior` is confirmed unsupported.
         */
        version?: string;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverride {
        /**
         * The availability zone in which to place the request.
         */
        availabilityZone?: string;
        /**
         * The instance requirements. See below.
         */
        instanceRequirements?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements;
        /**
         * The type of instance to request.
         */
        instanceType?: string;
        /**
         * The priority for the launch template override. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.
         */
        priority: number;
        /**
         * The maximum spot bid for this override request.
         */
        spotPrice: string;
        /**
         * The subnet in which to launch the requested instance.
         */
        subnetId: string;
        /**
         * The capacity added to the fleet by a fulfilled request.
         */
        weightedCapacity: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirements {
        /**
         * Block describing the minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips). Default is no minimum or maximum.
         */
        acceleratorCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount;
        /**
         * List of accelerator manufacturer names. Default is any manufacturer.
         *
         * ```
         * Valid names:
         * * amazon-web-services
         * * amd
         * * nvidia
         * * xilinx
         * ```
         */
        acceleratorManufacturers?: string[];
        /**
         * List of accelerator names. Default is any acclerator.
         *
         * ```
         * Valid names:
         * * a100            - NVIDIA A100 GPUs
         * * v100            - NVIDIA V100 GPUs
         * * k80             - NVIDIA K80 GPUs
         * * t4              - NVIDIA T4 GPUs
         * * m60             - NVIDIA M60 GPUs
         * * radeon-pro-v520 - AMD Radeon Pro V520 GPUs
         * * vu9p            - Xilinx VU9P FPGAs
         * ```
         */
        acceleratorNames?: string[];
        /**
         * Block describing the minimum and maximum total memory of the accelerators. Default is no minimum or maximum.
         */
        acceleratorTotalMemoryMib?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib;
        /**
         * List of accelerator types. Default is any accelerator type.
         *
         * ```
         * Valid types:
         * * fpga
         * * gpu
         * * inference
         * ```
         */
        acceleratorTypes?: string[];
        /**
         * List of instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (\*), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are allowing the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are allowing all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is all instance types.
         *
         * > **NOTE:** If you specify `allowedInstanceTypes`, you can't specify `excludedInstanceTypes`.
         */
        allowedInstanceTypes?: string[];
        /**
         * Indicate whether bare metal instace types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        bareMetal?: string;
        /**
         * Block describing the minimum and maximum baseline EBS bandwidth, in Mbps. Default is no minimum or maximum.
         */
        baselineEbsBandwidthMbps?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps;
        /**
         * Indicate whether burstable performance instance types should be `included`, `excluded`, or `required`. Default is `excluded`.
         */
        burstablePerformance?: string;
        /**
         * List of CPU manufacturer names. Default is any manufacturer.
         *
         * > **NOTE:** Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
         *
         * ```
         * Valid names:
         * * amazon-web-services
         * * amd
         * * intel
         * ```
         */
        cpuManufacturers?: string[];
        /**
         * List of instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (\*), to exclude an instance type, size, or generation. The following are examples: `m5.8xlarge`, `c5*.*`, `m5a.*`, `r*`, `*3*`. For example, if you specify `c5*`, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*`, you are excluding all the M5a instance types, but not the M5n instance types. Maximum of 400 entries in the list; each entry is limited to 30 characters. Default is no excluded instance types.
         *
         * > **NOTE:** If you specify `excludedInstanceTypes`, you can't specify `allowedInstanceTypes`.
         */
        excludedInstanceTypes?: string[];
        /**
         * List of instance generation names. Default is any generation.
         *
         * ```
         * Valid names:
         * * current  - Recommended for best performance.
         * * previous - For existing applications optimized for older instance types.
         * ```
         */
        instanceGenerations?: string[];
        /**
         * Indicate whether instance types with local storage volumes are `included`, `excluded`, or `required`. Default is `included`.
         */
        localStorage?: string;
        /**
         * List of local storage type names. Default any storage type.
         *
         * ```
         * Value names:
         * * hdd - hard disk drive
         * * ssd - solid state drive
         * ```
         */
        localStorageTypes?: string[];
        /**
         * Block describing the minimum and maximum amount of memory (GiB) per vCPU. Default is no minimum or maximum.
         */
        memoryGibPerVcpu?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu;
        /**
         * Block describing the minimum and maximum amount of memory (MiB). Default is no maximum.
         */
        memoryMib?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib;
        /**
         * Block describing the minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default is no minimum or maximum.
         */
        networkBandwidthGbps?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps;
        /**
         * Block describing the minimum and maximum number of network interfaces. Default is no minimum or maximum.
         */
        networkInterfaceCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount;
        /**
         * The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 20.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        onDemandMaxPricePercentageOverLowestPrice?: number;
        /**
         * Indicate whether instance types must support On-Demand Instance Hibernation, either `true` or `false`. Default is `false`.
         */
        requireHibernateSupport?: boolean;
        /**
         * The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage higher than the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price is higher than your threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as 999999. Default is 100.
         *
         * If you set DesiredCapacityType to vcpu or memory-mib, the price protection threshold is applied based on the per vCPU or per memory price instead of the per instance price.
         */
        spotMaxPricePercentageOverLowestPrice?: number;
        /**
         * Block describing the minimum and maximum total local storage (GB). Default is no minimum or maximum.
         */
        totalLocalStorageGb?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb;
        /**
         * Block describing the minimum and maximum number of vCPUs. Default is no maximum.
         */
        vcpuCount?: outputs.ec2.SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorCount {
        /**
         * Maximum. Set to `0` to exclude instance types with accelerators.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsAcceleratorTotalMemoryMib {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsBaselineEbsBandwidthMbps {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryGibPerVcpu {
        /**
         * Maximum. May be a decimal number, e.g. `0.5`.
         */
        max?: number;
        /**
         * Minimum. May be a decimal number, e.g. `0.5`.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsMemoryMib {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkBandwidthGbps {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsNetworkInterfaceCount {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsTotalLocalStorageGb {
        /**
         * Maximum. May be a decimal number, e.g. `0.5`.
         */
        max?: number;
        /**
         * Minimum. May be a decimal number, e.g. `0.5`.
         */
        min?: number;
    }
    interface SpotFleetRequestLaunchTemplateConfigOverrideInstanceRequirementsVcpuCount {
        /**
         * Maximum.
         */
        max?: number;
        /**
         * Minimum.
         */
        min?: number;
    }
    interface SpotFleetRequestSpotMaintenanceStrategies {
        /**
         * Nested argument containing the capacity rebalance for your fleet request. Defined below.
         */
        capacityRebalance?: outputs.ec2.SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance;
    }
    interface SpotFleetRequestSpotMaintenanceStrategiesCapacityRebalance {
        /**
         * The replacement strategy to use. Only available for spot fleets with `fleetType` set to `maintain`. Valid values: `launch`.
         */
        replacementStrategy?: string;
    }
    interface SpotInstanceRequestCapacityReservationSpecification {
        /**
         * Indicates the instance's Capacity Reservation preferences. Can be `"open"` or `"none"`. (Default: `"open"`).
         */
        capacityReservationPreference?: string;
        /**
         * Information about the target Capacity Reservation. See Capacity Reservation Target below for more details.
         *
         * For more information, see the documentation on [Capacity Reservations](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/capacity-reservations-using.html).
         */
        capacityReservationTarget?: outputs.ec2.SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget;
    }
    interface SpotInstanceRequestCapacityReservationSpecificationCapacityReservationTarget {
        /**
         * ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: string;
        /**
         * ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: string;
    }
    interface SpotInstanceRequestCpuOptions {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. Valid values are `enabled` and `disabled`.
         */
        amdSevSnp: string;
        /**
         * Sets the number of CPU cores for an instance. This option is only supported on creation of instance type that support CPU Options [CPU Cores and Threads Per CPU Core Per Instance Type](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html#cpu-options-supported-instances-values) - specifying this option for unsupported instance types will return an error from the EC2 API.
         */
        coreCount: number;
        /**
         * If set to 1, hyperthreading is disabled on the launched instance. Defaults to 2 if not set. See [Optimizing CPU Options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) for more information.
         *
         * For more information, see the documentation on [Optimizing CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html).
         */
        threadsPerCore: number;
    }
    interface SpotInstanceRequestCreditSpecification {
        /**
         * Credit option for CPU usage. Valid values include `standard` or `unlimited`. T3 instances are launched as unlimited by default. T2 instances are launched as standard by default.
         */
        cpuCredits?: string;
    }
    interface SpotInstanceRequestEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        /**
         * Name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume. Defaults to `false`. Cannot be used with `snapshotId`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Snapshot ID to mount.
         */
        snapshotId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
         */
        tagsAll: {
            [key: string]: string;
        };
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to `gp2`.
         *
         * > **NOTE:** Currently, changes to the `ebsBlockDevice` configuration of _existing_ resources cannot be automatically detected by this provider. To manage changes and attachments of an EBS block to an instance, use the `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources instead. If you use `ebsBlockDevice` on an `aws.ec2.Instance`, this provider will assume management over the full set of non-root EBS block devices for the instance, treating additional block devices as drift. For this reason, `ebsBlockDevice` cannot be mixed with external `aws.ebs.Volume` and `aws.ec2.VolumeAttachment` resources for a given instance.
         */
        volumeType: string;
    }
    interface SpotInstanceRequestEnclaveOptions {
        /**
         * Whether Nitro Enclaves will be enabled on the instance. Defaults to `false`.
         *
         * For more information, see the documentation on [Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).
         */
        enabled: boolean;
    }
    interface SpotInstanceRequestEphemeralBlockDevice {
        /**
         * Name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * Suppresses the specified device included in the AMI's block device mapping.
         */
        noDevice?: boolean;
        /**
         * [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames) (e.g., `ephemeral0`).
         *
         * Each AWS Instance type has a different set of Instance Store block devices available for attachment. AWS [publishes a list](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes) of which ephemeral devices are available on each type. The devices are always identified by the `virtualName` in the format `ephemeral{0..N}`.
         */
        virtualName?: string;
    }
    interface SpotInstanceRequestLaunchTemplate {
        /**
         * ID of the launch template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the launch template. Conflicts with `id`.
         */
        name: string;
        /**
         * Template version. Can be a specific version number, `$Latest` or `$Default`. The default value is `$Default`.
         */
        version?: string;
    }
    interface SpotInstanceRequestMaintenanceOptions {
        /**
         * Automatic recovery behavior of the Instance. Can be `"default"` or `"disabled"`. See [Recover your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-recover.html) for more details.
         */
        autoRecovery: string;
    }
    interface SpotInstanceRequestMetadataOptions {
        /**
         * Whether the metadata service is available. Valid values include `enabled` or `disabled`. Defaults to `enabled`.
         */
        httpEndpoint?: string;
        /**
         * Whether the IPv6 endpoint for the instance metadata service is enabled. Defaults to `disabled`.
         */
        httpProtocolIpv6?: string;
        /**
         * Desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values are integer from `1` to `64`. Defaults to `1`.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether or not the metadata service requires session tokens, also referred to as _Instance Metadata Service Version 2 (IMDSv2)_. Valid values include `optional` or `required`. Defaults to `optional`.
         */
        httpTokens: string;
        /**
         * Enables or disables access to instance tags from the instance metadata service. Valid values include `enabled` or `disabled`. Defaults to `disabled`.
         *
         * For more information, see the documentation on the [Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
         */
        instanceMetadataTags: string;
    }
    interface SpotInstanceRequestNetworkInterface {
        /**
         * Whether or not to delete the network interface on instance termination. Defaults to `false`. Currently, the only valid value is `false`, as this is only supported when creating new network interfaces when launching an instance.
         */
        deleteOnTermination?: boolean;
        /**
         * Integer index of the network interface attachment. Limited by instance type.
         */
        deviceIndex: number;
        /**
         * Integer index of the network card. Limited by instance type. The default index is `0`.
         */
        networkCardIndex?: number;
        /**
         * ID of the network interface to attach.
         */
        networkInterfaceId: string;
    }
    interface SpotInstanceRequestPrivateDnsNameOptions {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord: boolean;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord: boolean;
        /**
         * Type of hostname for Amazon EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 native subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. Valid values: `ip-name` and `resource-name`.
         */
        hostnameType: string;
    }
    interface SpotInstanceRequestRootBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination. Defaults to `true`.
         */
        deleteOnTermination?: boolean;
        deviceName: string;
        /**
         * Whether to enable volume encryption. Defaults to `false`. Must be configured to perform drift detection.
         */
        encrypted: boolean;
        /**
         * Amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). Only valid for volumeType of `io1`, `io2` or `gp3`.
         */
        iops: number;
        /**
         * Amazon Resource Name (ARN) of the KMS Key to use when encrypting the volume. Must be configured to perform drift detection.
         */
        kmsKeyId: string;
        /**
         * Map of tags to assign to the device.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
         */
        tagsAll: {
            [key: string]: string;
        };
        /**
         * Throughput to provision for a volume in mebibytes per second (MiB/s). This is only valid for `volumeType` of `gp3`.
         */
        throughput: number;
        volumeId: string;
        /**
         * Size of the volume in gibibytes (GiB).
         */
        volumeSize: number;
        /**
         * Type of volume. Valid values include `standard`, `gp2`, `gp3`, `io1`, `io2`, `sc1`, or `st1`. Defaults to the volume type that the AMI uses.
         *
         * Modifying the `encrypted` or `kmsKeyId` settings of the `rootBlockDevice` requires resource replacement.
         */
        volumeType: string;
    }
    interface TrafficMirrorFilterRuleDestinationPortRange {
        /**
         * Starting port of the range
         */
        fromPort?: number;
        /**
         * Ending port of the range
         */
        toPort?: number;
    }
    interface TrafficMirrorFilterRuleSourcePortRange {
        /**
         * Starting port of the range
         */
        fromPort?: number;
        /**
         * Ending port of the range
         */
        toPort?: number;
    }
    interface VpcEndpointDnsEntry {
        /**
         * The DNS name.
         */
        dnsName: string;
        /**
         * The ID of the private hosted zone.
         */
        hostedZoneId: string;
    }
    interface VpcEndpointDnsOptions {
        /**
         * The DNS records created for the endpoint. Valid values are `ipv4`, `dualstack`, `service-defined`, and `ipv6`.
         */
        dnsRecordIpType: string;
        /**
         * Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint. Default is `false`. Can only be specified if privateDnsEnabled is `true`.
         */
        privateDnsOnlyForInboundResolverEndpoint?: boolean;
    }
    interface VpcEndpointServicePrivateDnsNameConfiguration {
        /**
         * Name of the record subdomain the service provider needs to create.
         */
        name: string;
        /**
         * Verification state of the VPC endpoint service. Consumers of the endpoint service can use the private name only when the state is `verified`.
         */
        state: string;
        /**
         * Endpoint service verification type, for example `TXT`.
         */
        type: string;
        /**
         * Value the service provider adds to the private DNS name domain record before verification.
         */
        value: string;
    }
    interface VpcIpamOperatingRegion {
        /**
         * The name of the Region you want to add to the IPAM.
         */
        regionName: string;
    }
    interface VpcIpamPoolCidrCidrAuthorizationContext {
        /**
         * The plain-text authorization message for the prefix and account.
         */
        message?: string;
        /**
         * The signed authorization message for the prefix and account.
         */
        signature?: string;
    }
    interface VpcIpamResourceDiscoveryOperatingRegion {
        /**
         * The name of the Region you want to add to the IPAM.
         */
        regionName: string;
    }
    interface VpcPeeringConnectionAccepter {
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface VpcPeeringConnectionAccepterAccepter {
        /**
         * Indicates whether a local VPC can resolve public DNS hostnames to
         * private IP addresses when queried from instances in a peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface VpcPeeringConnectionAccepterRequester {
        /**
         * Indicates whether a local VPC can resolve public DNS hostnames to
         * private IP addresses when queried from instances in a peer VPC.
         */
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface VpcPeeringConnectionRequester {
        allowRemoteVpcDnsResolution?: boolean;
    }
    interface VpnConnectionRoute {
        /**
         * The CIDR block associated with the local subnet of the customer data center.
         */
        destinationCidrBlock: string;
        /**
         * Indicates how the routes were provided.
         */
        source: string;
        /**
         * The current state of the static route.
         */
        state: string;
    }
    interface VpnConnectionTunnel1LogOptions {
        /**
         * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
         */
        cloudwatchLogOptions: outputs.ec2.VpnConnectionTunnel1LogOptionsCloudwatchLogOptions;
    }
    interface VpnConnectionTunnel1LogOptionsCloudwatchLogOptions {
        /**
         * Enable or disable VPN tunnel logging feature. The default is `false`.
         */
        logEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
         */
        logGroupArn?: string;
        /**
         * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
         */
        logOutputFormat?: string;
    }
    interface VpnConnectionTunnel2LogOptions {
        /**
         * Options for sending VPN tunnel logs to CloudWatch. See CloudWatch Log Options below for more details.
         */
        cloudwatchLogOptions: outputs.ec2.VpnConnectionTunnel2LogOptionsCloudwatchLogOptions;
    }
    interface VpnConnectionTunnel2LogOptionsCloudwatchLogOptions {
        /**
         * Enable or disable VPN tunnel logging feature. The default is `false`.
         */
        logEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
         */
        logGroupArn?: string;
        /**
         * Set log format. Default format is json. Possible values are: `json` and `text`. The default is `json`.
         */
        logOutputFormat?: string;
    }
    interface VpnConnectionVgwTelemetry {
        /**
         * The number of accepted routes.
         */
        acceptedRouteCount: number;
        /**
         * The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.
         */
        certificateArn: string;
        /**
         * The date and time of the last change in status.
         */
        lastStatusChange: string;
        /**
         * The Internet-routable IP address of the virtual private gateway's outside interface.
         */
        outsideIpAddress: string;
        /**
         * The status of the VPN tunnel.
         */
        status: string;
        /**
         * If an error occurs, a description of the error.
         */
        statusMessage: string;
    }
}
export declare namespace ec2clientvpn {
    interface EndpointAuthenticationOption {
        /**
         * The ID of the Active Directory to be used for authentication if type is `directory-service-authentication`.
         */
        activeDirectoryId?: string;
        /**
         * The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Only necessary when type is set to `certificate-authentication`.
         */
        rootCertificateChainArn?: string;
        /**
         * The ARN of the IAM SAML identity provider if type is `federated-authentication`.
         */
        samlProviderArn?: string;
        /**
         * The ARN of the IAM SAML identity provider for the self service portal if type is `federated-authentication`.
         */
        selfServiceSamlProviderArn?: string;
        /**
         * The type of client authentication to be used. Specify `certificate-authentication` to use certificate-based authentication, `directory-service-authentication` to use Active Directory authentication, or `federated-authentication` to use Federated Authentication via SAML 2.0.
         */
        type: string;
    }
    interface EndpointClientConnectOptions {
        /**
         * Indicates whether client connect options are enabled. The default is `false` (not enabled).
         */
        enabled: boolean;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function used for connection authorization.
         */
        lambdaFunctionArn: string;
    }
    interface EndpointClientLoginBannerOptions {
        /**
         * Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters.
         */
        bannerText: string;
        /**
         * Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established. The default is `false` (not enabled).
         */
        enabled: boolean;
    }
    interface EndpointConnectionLogOptions {
        /**
         * The name of the CloudWatch Logs log group.
         */
        cloudwatchLogGroup?: string;
        /**
         * The name of the CloudWatch Logs log stream to which the connection data is published.
         */
        cloudwatchLogStream: string;
        /**
         * Indicates whether connection logging is enabled.
         */
        enabled: boolean;
    }
    interface GetEndpointAuthenticationOption {
        activeDirectoryId: string;
        rootCertificateChainArn: string;
        samlProviderArn: string;
        selfServiceSamlProviderArn: string;
        type: string;
    }
    interface GetEndpointClientConnectOption {
        enabled: boolean;
        lambdaFunctionArn: string;
    }
    interface GetEndpointClientLoginBannerOption {
        bannerText: string;
        enabled: boolean;
    }
    interface GetEndpointConnectionLogOption {
        cloudwatchLogGroup: string;
        cloudwatchLogStream: string;
        enabled: boolean;
    }
    interface GetEndpointFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeClientVpnEndpoints.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An endpoint will be selected if any one of the given values matches.
         */
        values: string[];
    }
}
export declare namespace ec2transitgateway {
    interface GetAttachmentFilter {
        /**
         * Name of the field to filter by, as defined by the [underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetAttachmentsFilter {
        /**
         * Name of the filter check available value on [official documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html)
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetConnectFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetConnectPeerFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetDirectConnectGatewayAttachmentFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeTransitGatewayAttachments API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetMulticastDomainAssociation {
        /**
         * The ID of the subnet associated with the transit gateway multicast domain.
         */
        subnetId: string;
        /**
         * The ID of the transit gateway attachment.
         */
        transitGatewayAttachmentId: string;
    }
    interface GetMulticastDomainFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayMulticastDomains.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. A multicast domain will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetMulticastDomainMember {
        /**
         * The IP address assigned to the transit gateway multicast group.
         */
        groupIpAddress: string;
        /**
         * The group members' network interface ID.
         */
        networkInterfaceId: string;
    }
    interface GetMulticastDomainSource {
        /**
         * The IP address assigned to the transit gateway multicast group.
         */
        groupIpAddress: string;
        /**
         * The group members' network interface ID.
         */
        networkInterfaceId: string;
    }
    interface GetPeeringAttachmentFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayPeeringAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * An EC2 Transit Gateway Peering Attachment be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetRouteTableAssociationsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetTransitGatewayRouteTableAssociations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetRouteTableFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetRouteTablePropagationsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetTransitGatewayRouteTablePropagations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * A Transit Gateway Route Table will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetRouteTableRoutesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SearchTransitGatewayRoutes.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }
    interface GetRouteTableRoutesRoute {
        /**
         * The CIDR used for route destination matches.
         */
        destinationCidrBlock: string;
        /**
         * The ID of the prefix list used for destination matches.
         */
        prefixListId: string;
        /**
         * The current state of the route, can be `active`, `deleted`, `pending`, `blackhole`, `deleting`.
         */
        state: string;
        /**
         * The id of the transit gateway route table announcement, most of the time it is an empty string.
         */
        transitGatewayRouteTableAnnouncementId: string;
        /**
         * The type of the route, can be `propagated` or `static`.
         */
        type: string;
    }
    interface GetTransitGatewayFilter {
        /**
         * Name of the field to filter by, as defined by the [underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGateways.html).
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetVpcAttachmentFilter {
        /**
         * Name of the filter.
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetVpcAttachmentsFilter {
        /**
         * Name of the filter check available value on [official documentation](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayVpcAttachments.html)
         */
        name: string;
        /**
         * List of one or more values for the filter.
         */
        values: string[];
    }
    interface GetVpnAttachmentFilter {
        /**
         * Name of the filter field. Valid values can be found in the [EC2 DescribeTransitGatewayAttachments API Reference](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGatewayAttachments.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface InstanceConnectEndpointTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
}
export declare namespace ecr {
    interface GetLifecyclePolicyDocumentRule {
        /**
         * Specifies the action type.
         */
        action?: outputs.ecr.GetLifecyclePolicyDocumentRuleAction;
        /**
         * Describes the purpose of a rule within a lifecycle policy.
         */
        description?: string;
        /**
         * Sets the order in which rules are evaluated, lowest to highest. When you add rules to a lifecycle policy, you must give them each a unique value for `priority`. Values do not need to be sequential across rules in a policy. A rule with a `tagStatus` value of any must have the highest value for `priority` and be evaluated last.
         */
        priority: number;
        /**
         * Collects parameters describing the selection criteria for the ECR lifecycle policy:
         */
        selection?: outputs.ecr.GetLifecyclePolicyDocumentRuleSelection;
    }
    interface GetLifecyclePolicyDocumentRuleAction {
        /**
         * The supported value is `expire`.
         */
        type: string;
    }
    interface GetLifecyclePolicyDocumentRuleSelection {
        /**
         * Specify a count number. If the `countType` used is imageCountMoreThan, then the value is the maximum number of images that you want to retain in your repository. If the `countType` used is sinceImagePushed, then the value is the maximum age limit for your images.
         */
        countNumber: number;
        /**
         * Specify a count type to apply to the images. If `countType` is set to imageCountMoreThan, you also specify `countNumber` to create a rule that sets a limit on the number of images that exist in your repository. If `countType` is set to sinceImagePushed, you also specify `countUnit` and `countNumber` to specify a time limit on the images that exist in your repository.
         */
        countType: string;
        /**
         * Specify a count unit of days to indicate that as the unit of time, in addition to `countNumber`, which is the number of days.
         */
        countUnit?: string;
        /**
         * You must specify a comma-separated list of image tag patterns that may contain wildcards (*) on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag pattern list prod* to specify all of them. If you specify multiple tags, only the images with all specified tags are selected. There is a maximum limit of four wildcards (*) per string. For example, ["*test*1*2*3", "test*1*2*3*"] is valid but ["test*1*2*3*4*5*6"] is invalid.
         */
        tagPatternLists?: string[];
        /**
         * You must specify a comma-separated list of image tag prefixes on which to take action with your lifecycle policy. For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag prefix prod to specify all of them. If you specify multiple tags, only images with all specified tags are selected.
         */
        tagPrefixLists?: string[];
        /**
         * Determines whether the lifecycle policy rule that you are adding specifies a tag for an image. Acceptable options are tagged, untagged, or any. If you specify any, then all images have the rule applied to them. If you specify tagged, then you must also specify a `tagPrefixList` value. If you specify untagged, then you must omit `tagPrefixList`.
         */
        tagStatus: string;
    }
    interface GetRepositoryEncryptionConfiguration {
        /**
         * Encryption type to use for the repository, either `AES256` or `KMS`.
         */
        encryptionType: string;
        /**
         * If `encryptionType` is `KMS`, the ARN of the KMS key used.
         */
        kmsKey: string;
    }
    interface GetRepositoryImageScanningConfiguration {
        /**
         * Whether images are scanned after being pushed to the repository.
         */
        scanOnPush: boolean;
    }
    interface RegistryScanningConfigurationRule {
        /**
         * One or more repository filter blocks, containing a `filter` (required string filtering repositories, see pattern regex [here](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_ScanningRepositoryFilter.html)) and a `filterType` (required string, currently only `WILDCARD` is supported).
         */
        repositoryFilters: outputs.ecr.RegistryScanningConfigurationRuleRepositoryFilter[];
        /**
         * The frequency that scans are performed at for a private registry. Can be `SCAN_ON_PUSH`, `CONTINUOUS_SCAN`, or `MANUAL`.
         */
        scanFrequency: string;
    }
    interface RegistryScanningConfigurationRuleRepositoryFilter {
        filter: string;
        filterType: string;
    }
    interface ReplicationConfigurationReplicationConfiguration {
        /**
         * The replication rules for a replication configuration. A maximum of 10 are allowed per `replicationConfiguration`. See Rule
         */
        rules: outputs.ecr.ReplicationConfigurationReplicationConfigurationRule[];
    }
    interface ReplicationConfigurationReplicationConfigurationRule {
        /**
         * the details of a replication destination. A maximum of 25 are allowed per `rule`. See Destination.
         */
        destinations: outputs.ecr.ReplicationConfigurationReplicationConfigurationRuleDestination[];
        /**
         * filters for a replication rule. See Repository Filter.
         */
        repositoryFilters?: outputs.ecr.ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter[];
    }
    interface ReplicationConfigurationReplicationConfigurationRuleDestination {
        /**
         * A Region to replicate to.
         */
        region: string;
        /**
         * The account ID of the destination registry to replicate to.
         */
        registryId: string;
    }
    interface ReplicationConfigurationReplicationConfigurationRuleRepositoryFilter {
        /**
         * The repository filter details.
         */
        filter: string;
        /**
         * The repository filter type. The only supported value is `PREFIX_MATCH`, which is a repository name prefix specified with the filter parameter.
         */
        filterType: string;
    }
    interface RepositoryEncryptionConfiguration {
        /**
         * The encryption type to use for the repository. Valid values are `AES256` or `KMS`. Defaults to `AES256`.
         */
        encryptionType?: string;
        /**
         * The ARN of the KMS key to use when `encryptionType` is `KMS`. If not specified, uses the default AWS managed key for ECR.
         */
        kmsKey: string;
    }
    interface RepositoryImageScanningConfiguration {
        /**
         * Indicates whether images are scanned after being pushed to the repository (true) or not scanned (false).
         */
        scanOnPush: boolean;
    }
}
export declare namespace ecrpublic {
    interface RepositoryCatalogData {
        /**
         * A detailed description of the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The text must be in markdown format.
         */
        aboutText?: string;
        /**
         * The system architecture that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported architectures will appear as badges on the repository and are used as search filters: `ARM`, `ARM 64`, `x86`, `x86-64`
         */
        architectures?: string[];
        /**
         * A short description of the contents of the repository. This text appears in both the image details and also when searching for repositories on the Amazon ECR Public Gallery.
         */
        description?: string;
        /**
         * The base64-encoded repository logo payload. (Only visible for verified accounts) Note that drift detection is disabled for this attribute.
         */
        logoImageBlob: string;
        /**
         * The operating systems that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported operating systems will appear as badges on the repository and are used as search filters: `Linux`, `Windows`
         */
        operatingSystems?: string[];
        /**
         * Detailed information on how to use the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The usage text provides context, support information, and additional usage details for users of the repository. The text must be in markdown format.
         */
        usageText?: string;
    }
}
export declare namespace ecs {
    interface CapacityProviderAutoScalingGroupProvider {
        /**
         * ARN of the associated auto scaling group.
         */
        autoScalingGroupArn: string;
        /**
         * Enables or disables a graceful shutdown of instances without disturbing workloads. Valid values are `ENABLED` and `DISABLED`. The default value is `ENABLED` when a capacity provider is created.
         */
        managedDraining: string;
        /**
         * Configuration block defining the parameters of the auto scaling. Detailed below.
         */
        managedScaling: outputs.ecs.CapacityProviderAutoScalingGroupProviderManagedScaling;
        /**
         * Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are `ENABLED` and `DISABLED`.
         */
        managedTerminationProtection: string;
    }
    interface CapacityProviderAutoScalingGroupProviderManagedScaling {
        /**
         * Period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of 300 seconds is used.
         */
        instanceWarmupPeriod: number;
        /**
         * Maximum step adjustment size. A number between 1 and 10,000.
         */
        maximumScalingStepSize: number;
        /**
         * Minimum step adjustment size. A number between 1 and 10,000.
         */
        minimumScalingStepSize: number;
        /**
         * Whether auto scaling is managed by ECS. Valid values are `ENABLED` and `DISABLED`.
         */
        status: string;
        /**
         * Target utilization for the capacity provider. A number between 1 and 100.
         */
        targetCapacity: number;
    }
    interface ClusterCapacityProvidersDefaultCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The `weight` value is taken into consideration after the `base` count of tasks has been satisfied. Defaults to `0`.
         */
        weight?: number;
    }
    interface ClusterConfiguration {
        /**
         * The details of the execute command configuration. Detailed below.
         */
        executeCommandConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfiguration;
    }
    interface ClusterConfigurationExecuteCommandConfiguration {
        /**
         * The AWS Key Management Service key ID to encrypt the data between the local client and the container.
         */
        kmsKeyId?: string;
        /**
         * The log configuration for the results of the execute command actions Required when `logging` is `OVERRIDE`. Detailed below.
         */
        logConfiguration?: outputs.ecs.ClusterConfigurationExecuteCommandConfigurationLogConfiguration;
        /**
         * The log setting to use for redirecting logs for your execute command results. Valid values are `NONE`, `DEFAULT`, and `OVERRIDE`.
         */
        logging?: string;
    }
    interface ClusterConfigurationExecuteCommandConfigurationLogConfiguration {
        /**
         * Whether or not to enable encryption on the CloudWatch logs. If not specified, encryption will be disabled.
         */
        cloudWatchEncryptionEnabled?: boolean;
        /**
         * The name of the CloudWatch log group to send logs to.
         */
        cloudWatchLogGroupName?: string;
        /**
         * Whether or not to enable encryption on the logs sent to S3. If not specified, encryption will be disabled.
         */
        s3BucketEncryptionEnabled?: boolean;
        /**
         * The name of the S3 bucket to send logs to.
         */
        s3BucketName?: string;
        /**
         * An optional folder in the S3 bucket to place logs in.
         */
        s3KeyPrefix?: string;
    }
    interface ClusterServiceConnectDefaults {
        /**
         * The ARN of the `aws.servicediscovery.HttpNamespace` that's used when you create a service and don't specify a Service Connect configuration.
         */
        namespace: string;
    }
    interface ClusterSetting {
        /**
         * Name of the setting to manage. Valid values: `containerInsights`.
         */
        name: string;
        /**
         * The value to assign to the setting. Valid values are `enabled` and `disabled`.
         */
        value: string;
    }
    interface GetClusterServiceConnectDefault {
        namespace: string;
    }
    interface GetClusterSetting {
        name: string;
        value: string;
    }
    interface GetTaskExecutionCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
         */
        base?: number;
        /**
         * Name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The `weight` value is taken into consideration after the `base` count of tasks has been satisfied. Defaults to `0`.
         */
        weight?: number;
    }
    interface GetTaskExecutionNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see the [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) documentation.
         */
        assignPublicIp?: boolean;
        /**
         * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * Subnets associated with the task or service.
         */
        subnets: string[];
    }
    interface GetTaskExecutionOverrides {
        /**
         * One or more container overrides that are sent to a task. See below.
         */
        containerOverrides?: outputs.ecs.GetTaskExecutionOverridesContainerOverride[];
        /**
         * The CPU override for the task.
         */
        cpu?: string;
        /**
         * Amazon Resource Name (ARN) of the task execution role override for the task.
         */
        executionRoleArn?: string;
        /**
         * Elastic Inference accelerator override for the task. See below.
         */
        inferenceAcceleratorOverrides?: outputs.ecs.GetTaskExecutionOverridesInferenceAcceleratorOverride[];
        /**
         * The memory override for the task.
         */
        memory?: string;
        /**
         * Amazon Resource Name (ARN) of the role that containers in this task can assume.
         */
        taskRoleArn?: string;
    }
    interface GetTaskExecutionOverridesContainerOverride {
        /**
         * The command to send to the container that overrides the default command from the Docker image or the task definition.
         */
        commands?: string[];
        /**
         * The number of cpu units reserved for the container, instead of the default value from the task definition.
         */
        cpu?: number;
        /**
         * The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. See below.
         */
        environments?: outputs.ecs.GetTaskExecutionOverridesContainerOverrideEnvironment[];
        /**
         * The hard limit (in MiB) of memory to present to the container, instead of the default value from the task definition. If your container attempts to exceed the memory specified here, the container is killed.
         */
        memory?: number;
        /**
         * The soft limit (in MiB) of memory to reserve for the container, instead of the default value from the task definition.
         */
        memoryReservation?: number;
        /**
         * The name of the container that receives the override. This parameter is required if any override is specified.
         */
        name: string;
        /**
         * The type and amount of a resource to assign to a container, instead of the default value from the task definition. The only supported resource is a GPU. See below.
         */
        resourceRequirements?: outputs.ecs.GetTaskExecutionOverridesContainerOverrideResourceRequirement[];
    }
    interface GetTaskExecutionOverridesContainerOverrideEnvironment {
        /**
         * The name of the key-value pair. For environment variables, this is the name of the environment variable.
         */
        key: string;
        /**
         * The value of the key-value pair. For environment variables, this is the value of the environment variable.
         */
        value: string;
    }
    interface GetTaskExecutionOverridesContainerOverrideResourceRequirement {
        /**
         * The type of resource to assign to a container. Valid values are `GPU` or `InferenceAccelerator`.
         */
        type: string;
        /**
         * The value for the specified resource type. If the `GPU` type is used, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. The number of GPUs that's reserved for all containers in a task can't exceed the number of available GPUs on the container instance that the task is launched on. If the `InferenceAccelerator` type is used, the value matches the `deviceName` for an InferenceAccelerator specified in a task definition.
         */
        value: string;
    }
    interface GetTaskExecutionOverridesInferenceAcceleratorOverride {
        /**
         * The Elastic Inference accelerator device name to override for the task. This parameter must match a deviceName specified in the task definition.
         */
        deviceName?: string;
        /**
         * The Elastic Inference accelerator type to use.
         */
        deviceType?: string;
    }
    interface GetTaskExecutionPlacementConstraint {
        /**
         * A cluster query language expression to apply to the constraint. The expression can have a maximum length of 2000 characters. You can't specify an expression if the constraint type is `distinctInstance`.
         */
        expression?: string;
        /**
         * The type of constraint. Valid values are `distinctInstance` or `memberOf`. Use `distinctInstance` to ensure that each task in a particular group is running on a different container instance. Use `memberOf` to restrict the selection to a group of valid candidates.
         */
        type: string;
    }
    interface GetTaskExecutionPlacementStrategy {
        /**
         * The field to apply the placement strategy against.
         */
        field?: string;
        /**
         * The type of placement strategy. Valid values are `random`, `spread`, and `binpack`.
         *
         * For more information, see the [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html) documentation.
         */
        type: string;
    }
    interface ServiceAlarms {
        /**
         * One or more CloudWatch alarm names.
         */
        alarmNames: string[];
        /**
         * Determines whether to use the CloudWatch alarm option in the service deployment process.
         */
        enable: boolean;
        /**
         * Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
         */
        rollback: boolean;
    }
    interface ServiceCapacityProviderStrategy {
        /**
         * Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * Relative percentage of the total number of launched tasks that should use the specified capacity provider.
         */
        weight?: number;
    }
    interface ServiceDeploymentCircuitBreaker {
        /**
         * Whether to enable the deployment circuit breaker logic for the service.
         */
        enable: boolean;
        /**
         * Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
         */
        rollback: boolean;
    }
    interface ServiceDeploymentController {
        /**
         * Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`, `EXTERNAL`. Default: `ECS`.
         */
        type?: string;
    }
    interface ServiceLoadBalancer {
        /**
         * Name of the container to associate with the load balancer (as it appears in a container definition).
         */
        containerName: string;
        /**
         * Port on the container to associate with the load balancer.
         *
         * > **Version note:** Multiple `loadBalancer` configuration block support was added in version 2.22.0 of the provider. This allows configuration of [ECS service support for multiple target groups](https://aws.amazon.com/about-aws/whats-new/2019/07/amazon-ecs-services-now-support-multiple-load-balancer-target-groups/).
         */
        containerPort: number;
        /**
         * Name of the ELB (Classic) to associate with the service.
         */
        elbName?: string;
        /**
         * ARN of the Load Balancer target group to associate with the service.
         */
        targetGroupArn?: string;
    }
    interface ServiceNetworkConfiguration {
        /**
         * Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
         */
        assignPublicIp?: boolean;
        /**
         * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: string[];
        /**
         * Subnets associated with the task or service.
         */
        subnets: string[];
    }
    interface ServiceOrderedPlacementStrategy {
        /**
         * For the `spread` placement strategy, valid values are `instanceId` (or `host`,
         * which has the same effect), or any platform or custom attribute that is applied to a container instance.
         * For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
         * needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
         *
         * > **Note:** for `spread`, `host` and `instanceId` will be normalized, by AWS, to be `instanceId`. This means the statefile will show `instanceId` but your config will differ if you use `host`.
         */
        field?: string;
        /**
         * Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
         */
        type: string;
    }
    interface ServicePlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
         */
        type: string;
    }
    interface ServiceServiceConnectConfiguration {
        /**
         * Specifies whether to use Service Connect with this service.
         */
        enabled: boolean;
        /**
         * The log configuration for the container. See below.
         */
        logConfiguration?: outputs.ecs.ServiceServiceConnectConfigurationLogConfiguration;
        /**
         * The namespace name or ARN of the `aws.servicediscovery.HttpNamespace` for use with Service Connect.
         */
        namespace?: string;
        /**
         * The list of Service Connect service objects. See below.
         */
        services?: outputs.ecs.ServiceServiceConnectConfigurationService[];
    }
    interface ServiceServiceConnectConfigurationLogConfiguration {
        /**
         * The log driver to use for the container.
         */
        logDriver: string;
        /**
         * The configuration options to send to the log driver.
         */
        options: {
            [key: string]: string;
        };
        /**
         * The secrets to pass to the log configuration. See below.
         */
        secretOptions?: outputs.ecs.ServiceServiceConnectConfigurationLogConfigurationSecretOption[];
    }
    interface ServiceServiceConnectConfigurationLogConfigurationSecretOption {
        /**
         * The name of the secret.
         */
        name: string;
        /**
         * The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
         */
        valueFrom: string;
    }
    interface ServiceServiceConnectConfigurationService {
        /**
         * The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
         */
        clientAlias?: outputs.ecs.ServiceServiceConnectConfigurationServiceClientAlias[];
        /**
         * The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
         */
        discoveryName?: string;
        /**
         * The port number for the Service Connect proxy to listen on.
         */
        ingressPortOverride?: number;
        /**
         * The name of one of the `portMappings` from all the containers in the task definition of this Amazon ECS service.
         */
        portName: string;
        /**
         * Configuration timeouts for Service Connect
         */
        timeout?: outputs.ecs.ServiceServiceConnectConfigurationServiceTimeout;
        /**
         * The configuration for enabling Transport Layer Security (TLS)
         */
        tls?: outputs.ecs.ServiceServiceConnectConfigurationServiceTls;
    }
    interface ServiceServiceConnectConfigurationServiceClientAlias {
        /**
         * The name that you use in the applications of client tasks to connect to this service.
         */
        dnsName?: string;
        /**
         * The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
         */
        port: number;
    }
    interface ServiceServiceConnectConfigurationServiceTimeout {
        /**
         * The amount of time in seconds a connection will stay active while idle. A value of 0 can be set to disable idleTimeout.
         */
        idleTimeoutSeconds?: number;
        /**
         * The amount of time in seconds for the upstream to respond with a complete response per request. A value of 0 can be set to disable perRequestTimeout. Can only be set when appProtocol isn't TCP.
         */
        perRequestTimeoutSeconds?: number;
    }
    interface ServiceServiceConnectConfigurationServiceTls {
        /**
         * The details of the certificate authority which will issue the certificate.
         */
        issuerCertAuthority: outputs.ecs.ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthority;
        /**
         * The KMS key used to encrypt the private key in Secrets Manager.
         */
        kmsKey?: string;
        /**
         * The ARN of the IAM Role that's associated with the Service Connect TLS.
         */
        roleArn?: string;
    }
    interface ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthority {
        /**
         * The ARN of the `aws.acmpca.CertificateAuthority` used to create the TLS Certificates.
         */
        awsPcaAuthorityArn: string;
    }
    interface ServiceServiceRegistries {
        /**
         * Container name value, already specified in the task definition, to be used for your service discovery service.
         */
        containerName?: string;
        /**
         * Port value, already specified in the task definition, to be used for your service discovery service.
         */
        containerPort?: number;
        /**
         * Port value used if your Service Discovery service specified an SRV record.
         */
        port?: number;
        /**
         * ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
         */
        registryArn: string;
    }
    interface TaskDefinitionEphemeralStorage {
        /**
         * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is `21` GiB and the maximum supported value is `200` GiB.
         */
        sizeInGib: number;
    }
    interface TaskDefinitionInferenceAccelerator {
        /**
         * Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
         */
        deviceName: string;
        /**
         * Elastic Inference accelerator type to use.
         */
        deviceType: string;
    }
    interface TaskDefinitionPlacementConstraint {
        /**
         * Cluster Query Language expression to apply to the constraint. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
         */
        expression?: string;
        /**
         * Type of constraint. Use `memberOf` to restrict selection to a group of valid candidates. Note that `distinctInstance` is not supported in task definitions.
         */
        type: string;
    }
    interface TaskDefinitionProxyConfiguration {
        /**
         * Name of the container that will serve as the App Mesh proxy.
         */
        containerName: string;
        /**
         * Set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
         */
        properties?: {
            [key: string]: string;
        };
        /**
         * Proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
         */
        type?: string;
    }
    interface TaskDefinitionRuntimePlatform {
        /**
         * Must be set to either `X86_64` or `ARM64`; see [cpu architecture](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform)
         */
        cpuArchitecture?: string;
        /**
         * If the `requiresCompatibilities` is `FARGATE` this field is required; must be set to a valid option from the [operating system family in the runtime platform](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform) setting
         */
        operatingSystemFamily?: string;
    }
    interface TaskDefinitionVolume {
        /**
         * Configuration block to configure a docker volume. Detailed below.
         */
        dockerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeDockerVolumeConfiguration;
        /**
         * Configuration block for an EFS volume. Detailed below.
         */
        efsVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfiguration;
        /**
         * Configuration block for an FSX Windows File Server volume. Detailed below.
         */
        fsxWindowsFileServerVolumeConfiguration?: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration;
        /**
         * Path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
         */
        hostPath?: string;
        /**
         * Name of the volume. This name is referenced in the `sourceVolume`
         * parameter of container definition in the `mountPoints` section.
         */
        name: string;
    }
    interface TaskDefinitionVolumeDockerVolumeConfiguration {
        /**
         * If this value is `true`, the Docker volume is created if it does not already exist. *Note*: This field is only used if the scope is `shared`.
         */
        autoprovision?: boolean;
        /**
         * Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
         */
        driver?: string;
        /**
         * Map of Docker driver specific options.
         */
        driverOpts?: {
            [key: string]: string;
        };
        /**
         * Map of custom metadata to add to your Docker volume.
         */
        labels?: {
            [key: string]: string;
        };
        /**
         * Scope for the Docker volume, which determines its lifecycle, either `task` or `shared`.  Docker volumes that are scoped to a `task` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as `shared` persist after the task stops.
         */
        scope: string;
    }
    interface TaskDefinitionVolumeEfsVolumeConfiguration {
        /**
         * Configuration block for authorization for the Amazon EFS file system. Detailed below.
         */
        authorizationConfig?: outputs.ecs.TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig;
        /**
         * ID of the EFS File System.
         */
        fileSystemId: string;
        /**
         * Directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using `authorizationConfig`.
         */
        rootDirectory?: string;
        /**
         * Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
         */
        transitEncryption?: string;
        /**
         * Port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
         */
        transitEncryptionPort?: number;
    }
    interface TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig {
        /**
         * Access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
         */
        accessPointId?: string;
        /**
         * Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
         */
        iam?: string;
    }
    interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfiguration {
        /**
         * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
         */
        authorizationConfig: outputs.ecs.TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig;
        /**
         * The Amazon FSx for Windows File Server file system ID to use.
         */
        fileSystemId: string;
        /**
         * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
         */
        rootDirectory: string;
    }
    interface TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
        /**
         * The authorization credential option to use. The authorization credential options can be provided using either the Amazon Resource Name (ARN) of an AWS Secrets Manager secret or AWS Systems Manager Parameter Store parameter. The ARNs refer to the stored credentials.
         */
        credentialsParameter: string;
        /**
         * A fully qualified domain name hosted by an AWS Directory Service Managed Microsoft AD (Active Directory) or self-hosted AD on Amazon EC2.
         */
        domain: string;
    }
    interface TaskSetCapacityProviderStrategy {
        /**
         * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
         */
        base?: number;
        /**
         * The short name or full Amazon Resource Name (ARN) of the capacity provider.
         */
        capacityProvider: string;
        /**
         * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
         */
        weight: number;
    }
    interface TaskSetLoadBalancer {
        /**
         * The name of the container to associate with the load balancer (as it appears in a container definition).
         */
        containerName: string;
        /**
         * The port on the container to associate with the load balancer. Defaults to `0` if not specified.
         *
         * > **Note:** Specifying multiple `loadBalancer` configurations is still not supported by AWS for ECS task set.
         */
        containerPort?: number;
        /**
         * The name of the ELB (Classic) to associate with the service.
         */
        loadBalancerName?: string;
        /**
         * The ARN of the Load Balancer target group to associate with the service.
         */
        targetGroupArn?: string;
    }
    interface TaskSetNetworkConfiguration {
        /**
         * Whether to assign a public IP address to the ENI (`FARGATE` launch type only). Valid values are `true` or `false`. Default `false`.
         *
         * For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html).
         */
        assignPublicIp?: boolean;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. Maximum of 5.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service. Maximum of 16.
         */
        subnets: string[];
    }
    interface TaskSetScale {
        /**
         * The unit of measure for the scale value. Default: `PERCENT`.
         */
        unit?: string;
        /**
         * The value, specified as a percent total of a service's `desiredCount`, to scale the task set. Defaults to `0` if not specified. Accepted values are numbers between 0.0 and 100.0.
         */
        value?: number;
    }
    interface TaskSetServiceRegistries {
        /**
         * The container name value, already specified in the task definition, to be used for your service discovery service.
         */
        containerName?: string;
        /**
         * The port value, already specified in the task definition, to be used for your service discovery service.
         */
        containerPort?: number;
        /**
         * The port value used if your Service Discovery service specified an SRV record.
         */
        port?: number;
        /**
         * The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service` resource). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html).
         */
        registryArn: string;
    }
}
export declare namespace efs {
    interface AccessPointPosixUser {
        /**
         * POSIX group ID used for all file system operations using this access point.
         */
        gid: number;
        /**
         * Secondary POSIX group IDs used for all file system operations using this access point.
         */
        secondaryGids?: number[];
        /**
         * POSIX user ID used for all file system operations using this access point.
         */
        uid: number;
    }
    interface AccessPointRootDirectory {
        /**
         * POSIX IDs and permissions to apply to the access point's Root Directory. See Creation Info below.
         */
        creationInfo: outputs.efs.AccessPointRootDirectoryCreationInfo;
        /**
         * Path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide `creationInfo`.
         */
        path: string;
    }
    interface AccessPointRootDirectoryCreationInfo {
        /**
         * POSIX group ID to apply to the `rootDirectory`.
         */
        ownerGid: number;
        /**
         * POSIX user ID to apply to the `rootDirectory`.
         */
        ownerUid: number;
        /**
         * POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
         */
        permissions: string;
    }
    interface BackupPolicyBackupPolicy {
        /**
         * A status of the backup policy. Valid values: `ENABLED`, `DISABLED`.
         */
        status: string;
    }
    interface FileSystemLifecyclePolicy {
        /**
         * Indicates how long it takes to transition files to the archive storage class. Requires transition_to_ia, Elastic Throughput and General Purpose performance mode. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, `AFTER_90_DAYS`, `AFTER_180_DAYS`, `AFTER_270_DAYS`, or `AFTER_365_DAYS`.
         */
        transitionToArchive?: string;
        /**
         * Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, `AFTER_90_DAYS`, `AFTER_180_DAYS`, `AFTER_270_DAYS`, or `AFTER_365_DAYS`.
         */
        transitionToIa?: string;
        /**
         * Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`.
         */
        transitionToPrimaryStorageClass?: string;
    }
    interface FileSystemProtection {
        /**
         * Indicates whether replication overwrite protection is enabled. Valid values: `ENABLED` or `DISABLED`.
         */
        replicationOverwrite: string;
    }
    interface FileSystemSizeInByte {
        /**
         * The latest known metered size (in bytes) of data stored in the file system.
         */
        value: number;
        /**
         * The latest known metered size (in bytes) of data stored in the Infrequent Access storage class.
         */
        valueInIa: number;
        /**
         * The latest known metered size (in bytes) of data stored in the Standard storage class.
         */
        valueInStandard: number;
    }
    interface GetAccessPointPosixUser {
        /**
         * Group ID
         */
        gid: number;
        /**
         * Secondary group IDs
         */
        secondaryGids: number[];
        /**
         * User Id
         */
        uid: number;
    }
    interface GetAccessPointRootDirectory {
        /**
         * Single element list containing information on the creation permissions of the directory
         */
        creationInfos: outputs.efs.GetAccessPointRootDirectoryCreationInfo[];
        /**
         * Path exposed as the root directory
         */
        path: string;
    }
    interface GetAccessPointRootDirectoryCreationInfo {
        /**
         * POSIX owner group ID
         */
        ownerGid: number;
        /**
         * POSIX owner user ID
         */
        ownerUid: number;
        /**
         * POSIX permissions mode
         */
        permissions: string;
    }
    interface GetFileSystemLifecyclePolicy {
        transitionToArchive: string;
        transitionToIa: string;
        transitionToPrimaryStorageClass: string;
    }
    interface GetFileSystemProtection {
        replicationOverwrite: string;
    }
    interface ReplicationConfigurationDestination {
        /**
         * The availability zone in which the replica should be created. If specified, the replica will be created with One Zone storage. If omitted, regional storage will be used.
         */
        availabilityZoneName?: string;
        /**
         * The ID of the destination file system for the replication. If no ID is provided, then EFS creates a new file system with the default settings.
         */
        fileSystemId: string;
        /**
         * The Key ID, ARN, alias, or alias ARN of the KMS key that should be used to encrypt the replica file system. If omitted, the default KMS key for EFS `/aws/elasticfilesystem` will be used.
         */
        kmsKeyId?: string;
        /**
         * The region in which the replica should be created.
         */
        region: string;
        status: string;
    }
}
export declare namespace eks {
    interface AccessPolicyAssociationAccessScope {
        /**
         * The namespaces to which the access scope applies when type is namespace.
         */
        namespaces?: string[];
        /**
         * Valid values are `namespace` or `cluster`.
         */
        type: string;
    }
    interface ClusterAccessConfig {
        /**
         * The authentication mode for the cluster. Valid values are `CONFIG_MAP`, `API` or `API_AND_CONFIG_MAP`
         */
        authenticationMode: string;
        /**
         * Whether or not to bootstrap the access config values to the cluster. Default is `true`.
         */
        bootstrapClusterCreatorAdminPermissions?: boolean;
    }
    interface ClusterCertificateAuthority {
        /**
         * Base64 encoded certificate data required to communicate with your cluster. Add this to the `certificate-authority-data` section of the `kubeconfig` file for your cluster.
         */
        data: string;
    }
    interface ClusterEncryptionConfig {
        /**
         * Configuration block with provider for encryption. Detailed below.
         */
        provider: outputs.eks.ClusterEncryptionConfigProvider;
        /**
         * List of strings with resources to be encrypted. Valid values: `secrets`.
         */
        resources: string[];
    }
    interface ClusterEncryptionConfigProvider {
        /**
         * ARN of the Key Management Service (KMS) customer master key (CMK). The CMK must be symmetric, created in the same region as the cluster, and if the CMK was created in a different account, the user must have access to the CMK. For more information, see [Allowing Users in Other Accounts to Use a CMK in the AWS Key Management Service Developer Guide](https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html).
         */
        keyArn: string;
    }
    interface ClusterIdentity {
        /**
         * Nested block containing [OpenID Connect](https://openid.net/connect/) identity provider information for the cluster. Detailed below.
         */
        oidcs: outputs.eks.ClusterIdentityOidc[];
    }
    interface ClusterIdentityOidc {
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuer: string;
    }
    interface ClusterKubernetesNetworkConfig {
        /**
         * The IP family used to assign Kubernetes pod and service addresses. Valid values are `ipv4` (default) and `ipv6`. You can only specify an IP family when you create a cluster, changing this value will force a new cluster to be created.
         */
        ipFamily: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. You can only specify a custom CIDR block when you create a cluster, changing this value will force a new cluster to be created. The block must meet the following requirements:
         *
         * * Within one of the following private IP address blocks: 10.0.0.0/8, 172.16.0.0/12, or 192.168.0.0/16.
         *
         * * Doesn't overlap with any CIDR block assigned to the VPC that you selected for VPC.
         *
         * * Between /24 and /12.
         */
        serviceIpv4Cidr: string;
        /**
         * The CIDR block that Kubernetes pod and service IP addresses are assigned from if you specified `ipv6` for ipFamily when you created the cluster. Kubernetes assigns service addresses from the unique local address range (fc00::/7) because you can't specify a custom IPv6 CIDR block when you create the cluster.
         */
        serviceIpv6Cidr: string;
    }
    interface ClusterOutpostConfig {
        /**
         * The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. Choose an instance type based on the number of nodes that your cluster will have. If your cluster will have:
         *
         * * 1–20 nodes, then we recommend specifying a large instance type.
         *
         * * 21–100 nodes, then we recommend specifying an xlarge instance type.
         *
         * * 101–250 nodes, then we recommend specifying a 2xlarge instance type.
         *
         * For a list of the available Amazon EC2 instance types, see Compute and storage in AWS Outposts rack features  The control plane is not automatically scaled by Amazon EKS.
         */
        controlPlaneInstanceType: string;
        /**
         * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost.
         * The `controlPlanePlacement` configuration block supports the following arguments:
         */
        controlPlanePlacement?: outputs.eks.ClusterOutpostConfigControlPlanePlacement;
        /**
         * The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. This argument is a list of arns, but only a single Outpost ARN is supported currently.
         */
        outpostArns: string[];
    }
    interface ClusterOutpostConfigControlPlanePlacement {
        /**
         * The name of the placement group for the Kubernetes control plane instances. This setting can't be changed after cluster creation.
         */
        groupName: string;
    }
    interface ClusterVpcConfig {
        /**
         * Cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.
         */
        clusterSecurityGroupId: string;
        /**
         * Whether the Amazon EKS private API server endpoint is enabled. Default is `false`.
         */
        endpointPrivateAccess?: boolean;
        /**
         * Whether the Amazon EKS public API server endpoint is enabled. Default is `true`.
         */
        endpointPublicAccess?: boolean;
        /**
         * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with `0.0.0.0/0`. The provider will only perform drift detection of its value when present in a configuration.
         */
        publicAccessCidrs: string[];
        /**
         * List of security group IDs for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane.
         */
        securityGroupIds?: string[];
        /**
         * List of subnet IDs. Must be in at least two different availability zones. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your worker nodes and the Kubernetes control plane.
         */
        subnetIds: string[];
        /**
         * ID of the VPC associated with your cluster.
         */
        vpcId: string;
    }
    interface FargateProfileSelector {
        /**
         * Key-value map of Kubernetes labels for selection.
         */
        labels?: {
            [key: string]: string;
        };
        /**
         * Kubernetes namespace for selection.
         *
         * The following arguments are optional:
         */
        namespace: string;
    }
    interface GetClusterAccessConfig {
        /**
         * Values returned are `CONFIG_MAP`, `API` or `API_AND_CONFIG_MAP`
         */
        authenticationMode: string;
    }
    interface GetClusterCertificateAuthority {
        /**
         * The base64 encoded certificate data required to communicate with your cluster. Add this to the `certificate-authority-data` section of the `kubeconfig` file for your cluster.
         */
        data: string;
    }
    interface GetClusterIdentity {
        /**
         * Nested attribute containing [OpenID Connect](https://openid.net/connect/) identity provider information for the cluster.
         */
        oidcs: outputs.eks.GetClusterIdentityOidc[];
    }
    interface GetClusterIdentityOidc {
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuer: string;
    }
    interface GetClusterKubernetesNetworkConfig {
        /**
         * `ipv4` or `ipv6`.
         */
        ipFamily: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from if `ipv4` was specified when the cluster was created.
         */
        serviceIpv4Cidr: string;
        /**
         * The CIDR block to assign Kubernetes pod and service IP addresses from if `ipv6` was specified when the cluster was created. Kubernetes assigns service addresses from the unique local address range (fc00::/7) because you can't specify a custom IPv6 CIDR block when you create the cluster.
         */
        serviceIpv6Cidr: string;
    }
    interface GetClusterOutpostConfig {
        /**
         * The Amazon EC2 instance type for all Kubernetes control plane instances.
         */
        controlPlaneInstanceType: string;
        /**
         * An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on AWS Outpost.
         */
        controlPlanePlacements: outputs.eks.GetClusterOutpostConfigControlPlanePlacement[];
        /**
         * List of ARNs of the Outposts hosting the EKS cluster. Only a single ARN is supported currently.
         */
        outpostArns: string[];
    }
    interface GetClusterOutpostConfigControlPlanePlacement {
        /**
         * The name of the placement group for the Kubernetes control plane instances.
         */
        groupName: string;
    }
    interface GetClusterVpcConfig {
        /**
         * The cluster security group that was created by Amazon EKS for the cluster.
         */
        clusterSecurityGroupId: string;
        /**
         * Indicates whether or not the Amazon EKS private API server endpoint is enabled.
         */
        endpointPrivateAccess: boolean;
        /**
         * Indicates whether or not the Amazon EKS public API server endpoint is enabled.
         */
        endpointPublicAccess: boolean;
        /**
         * List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint.
         */
        publicAccessCidrs: string[];
        /**
         * List of security group IDs
         */
        securityGroupIds: string[];
        /**
         * List of subnet IDs
         */
        subnetIds: string[];
        /**
         * The VPC associated with your cluster.
         */
        vpcId: string;
    }
    interface GetNodeGroupLaunchTemplate {
        /**
         * The ID of the launch template.
         */
        id: string;
        /**
         * Name of the AutoScaling Group.
         */
        name: string;
        /**
         * Kubernetes version.
         */
        version: string;
    }
    interface GetNodeGroupRemoteAccess {
        /**
         * EC2 Key Pair name that provides access for SSH communication with the worker nodes in the EKS Node Group.
         */
        ec2SshKey: string;
        /**
         * Set of EC2 Security Group IDs to allow SSH access (port 22) from on the worker nodes.
         */
        sourceSecurityGroupIds: string[];
    }
    interface GetNodeGroupResource {
        /**
         * List of objects containing information about AutoScaling Groups.
         */
        autoscalingGroups: outputs.eks.GetNodeGroupResourceAutoscalingGroup[];
        /**
         * Identifier of the remote access EC2 Security Group.
         */
        remoteAccessSecurityGroupId: string;
    }
    interface GetNodeGroupResourceAutoscalingGroup {
        /**
         * Name of the AutoScaling Group.
         */
        name: string;
    }
    interface GetNodeGroupScalingConfig {
        /**
         * Desired number of worker nodes.
         */
        desiredSize: number;
        /**
         * Maximum number of worker nodes.
         */
        maxSize: number;
        /**
         * Minimum number of worker nodes.
         */
        minSize: number;
    }
    interface GetNodeGroupTaint {
        /**
         * The effect of the taint.
         */
        effect: string;
        /**
         * The key of the taint.
         */
        key: string;
        /**
         * The value of the taint.
         */
        value: string;
    }
    interface IdentityProviderConfigOidc {
        /**
         * Client ID for the OpenID Connect identity provider.
         */
        clientId: string;
        /**
         * The JWT claim that the provider will use to return groups.
         */
        groupsClaim?: string;
        /**
         * A prefix that is prepended to group claims e.g., `oidc:`.
         */
        groupsPrefix?: string;
        /**
         * The name of the identity provider config.
         */
        identityProviderConfigName: string;
        /**
         * Issuer URL for the OpenID Connect identity provider.
         */
        issuerUrl: string;
        /**
         * The key value pairs that describe required claims in the identity token.
         */
        requiredClaims?: {
            [key: string]: string;
        };
        /**
         * The JWT claim that the provider will use as the username.
         */
        usernameClaim?: string;
        /**
         * A prefix that is prepended to username claims.
         */
        usernamePrefix?: string;
    }
    interface NodeGroupLaunchTemplate {
        /**
         * Identifier of the EC2 Launch Template. Conflicts with `name`.
         */
        id: string;
        /**
         * Name of the EC2 Launch Template. Conflicts with `id`.
         */
        name: string;
        /**
         * EC2 Launch Template version number. While the API accepts values like `$Default` and `$Latest`, the API will convert the value to the associated version number (e.g., `1`) on read and the provider will show a difference on next plan. Using the `defaultVersion` or `latestVersion` attribute of the `aws.ec2.LaunchTemplate` resource or data source is recommended for this argument.
         */
        version: string;
    }
    interface NodeGroupRemoteAccess {
        /**
         * EC2 Key Pair name that provides access for remote communication with the worker nodes in the EKS Node Group. If you specify this configuration, but do not specify `sourceSecurityGroupIds` when you create an EKS Node Group, either port 3389 for Windows, or port 22 for all other operating systems is opened on the worker nodes to the Internet (0.0.0.0/0). For Windows nodes, this will allow you to use RDP, for all others this allows you to SSH into the worker nodes.
         */
        ec2SshKey?: string;
        /**
         * Set of EC2 Security Group IDs to allow SSH access (port 22) from on the worker nodes. If you specify `ec2SshKey`, but do not specify this configuration when you create an EKS Node Group, port 22 on the worker nodes is opened to the Internet (0.0.0.0/0).
         */
        sourceSecurityGroupIds?: string[];
    }
    interface NodeGroupResource {
        /**
         * List of objects containing information about AutoScaling Groups.
         */
        autoscalingGroups: outputs.eks.NodeGroupResourceAutoscalingGroup[];
        /**
         * Identifier of the remote access EC2 Security Group.
         */
        remoteAccessSecurityGroupId: string;
    }
    interface NodeGroupResourceAutoscalingGroup {
        /**
         * Name of the AutoScaling Group.
         */
        name: string;
    }
    interface NodeGroupScalingConfig {
        /**
         * Desired number of worker nodes.
         */
        desiredSize: number;
        /**
         * Maximum number of worker nodes.
         */
        maxSize: number;
        /**
         * Minimum number of worker nodes.
         */
        minSize: number;
    }
    interface NodeGroupTaint {
        /**
         * The effect of the taint. Valid values: `NO_SCHEDULE`, `NO_EXECUTE`, `PREFER_NO_SCHEDULE`.
         */
        effect: string;
        /**
         * The key of the taint. Maximum length of 63.
         */
        key: string;
        /**
         * The value of the taint. Maximum length of 63.
         */
        value?: string;
    }
    interface NodeGroupUpdateConfig {
        /**
         * Desired max number of unavailable worker nodes during node group update.
         */
        maxUnavailable?: number;
        /**
         * Desired max percentage of unavailable worker nodes during node group update.
         */
        maxUnavailablePercentage?: number;
    }
}
export declare namespace elasticache {
    interface ClusterCacheNode {
        address: string;
        /**
         * Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use `preferredAvailabilityZones` instead. Default: System chosen Availability Zone. Changing this value will re-create the resource.
         */
        availabilityZone: string;
        id: string;
        outpostArn: string;
        /**
         * The port number on which each of the cache nodes will accept connections. For Memcached the default is 11211, and for Redis the default port is 6379. Cannot be provided with `replicationGroupId`. Changing this value will re-create the resource.
         */
        port: number;
    }
    interface ClusterLogDeliveryConfiguration {
        /**
         * Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
         */
        destination: string;
        /**
         * For CloudWatch Logs use `cloudwatch-logs` or for Kinesis Data Firehose use `kinesis-firehose`.
         */
        destinationType: string;
        /**
         * Valid values are `json` or `text`
         */
        logFormat: string;
        /**
         * Valid values are  `slow-log` or `engine-log`. Max 1 of each.
         */
        logType: string;
    }
    interface GetClusterCacheNode {
        address: string;
        /**
         * Availability Zone for the cache cluster.
         */
        availabilityZone: string;
        id: string;
        outpostArn: string;
        /**
         * The port number on which each of the cache nodes will
         * accept connections.
         */
        port: number;
    }
    interface GetClusterLogDeliveryConfiguration {
        destination: string;
        destinationType: string;
        logFormat: string;
        logType: string;
    }
    interface GetReplicationGroupLogDeliveryConfiguration {
        destination: string;
        destinationType: string;
        logFormat: string;
        logType: string;
    }
    interface GetUserAuthenticationMode {
        passwordCount?: number;
        type?: string;
    }
    interface GlobalReplicationGroupGlobalNodeGroup {
        /**
         * The ID of the global node group.
         */
        globalNodeGroupId: string;
        /**
         * The keyspace for this node group.
         */
        slots: string;
    }
    interface ParameterGroupParameter {
        /**
         * The name of the ElastiCache parameter.
         */
        name: string;
        /**
         * The value of the ElastiCache parameter.
         */
        value: string;
    }
    interface ReplicationGroupLogDeliveryConfiguration {
        /**
         * Name of either the CloudWatch Logs LogGroup or Kinesis Data Firehose resource.
         */
        destination: string;
        /**
         * For CloudWatch Logs use `cloudwatch-logs` or for Kinesis Data Firehose use `kinesis-firehose`.
         */
        destinationType: string;
        /**
         * Valid values are `json` or `text`
         */
        logFormat: string;
        /**
         * Valid values are  `slow-log` or `engine-log`. Max 1 of each.
         */
        logType: string;
    }
    interface ServerlessCacheCacheUsageLimits {
        dataStorage?: outputs.elasticache.ServerlessCacheCacheUsageLimitsDataStorage;
        ecpuPerSeconds?: outputs.elasticache.ServerlessCacheCacheUsageLimitsEcpuPerSecond[];
    }
    interface ServerlessCacheCacheUsageLimitsDataStorage {
        maximum?: number;
        minimum?: number;
        unit: string;
    }
    interface ServerlessCacheCacheUsageLimitsEcpuPerSecond {
        maximum?: number;
        minimum?: number;
    }
    interface ServerlessCacheEndpoint {
        /**
         * The DNS hostname of the cache node.
         */
        address: string;
        /**
         * The port number that the cache engine is listening on. Set as integer.
         */
        port: number;
    }
    interface ServerlessCacheReaderEndpoint {
        /**
         * The DNS hostname of the cache node.
         */
        address: string;
        /**
         * The port number that the cache engine is listening on. Set as integer.
         */
        port: number;
    }
    interface ServerlessCacheTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface UserAuthenticationMode {
        passwordCount: number;
        /**
         * Specifies the passwords to use for authentication if `type` is set to `password`.
         */
        passwords?: string[];
        /**
         * Specifies the authentication type. Possible options are: `password`, `no-password-required` or `iam`.
         */
        type: string;
    }
}
export declare namespace elasticbeanstalk {
    interface ApplicationAppversionLifecycle {
        /**
         * Set to `true` to delete a version's source bundle from S3 when the application version is deleted.
         */
        deleteSourceFromS3?: boolean;
        /**
         * The number of days to retain an application version ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
         */
        maxAgeInDays?: number;
        /**
         * The maximum number of application versions to retain ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
         */
        maxCount?: number;
        /**
         * The ARN of an IAM service role under which the application version is deleted.  Elastic Beanstalk must have permission to assume this role.
         */
        serviceRole: string;
    }
    interface ConfigurationTemplateSetting {
        /**
         * A unique name for this Template.
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }
    interface EnvironmentAllSetting {
        /**
         * A unique name for this Environment. This name is used
         * in the application URL
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }
    interface EnvironmentSetting {
        /**
         * A unique name for this Environment. This name is used
         * in the application URL
         */
        name: string;
        namespace: string;
        resource?: string;
        value: string;
    }
    interface GetApplicationAppversionLifecycle {
        /**
         * Specifies whether delete a version's source bundle from S3 when the application version is deleted.
         */
        deleteSourceFromS3: boolean;
        /**
         * Number of days to retain an application version.
         */
        maxAgeInDays: number;
        /**
         * Maximum number of application versions to retain.
         */
        maxCount: number;
        /**
         * ARN of an IAM service role under which the application version is deleted.  Elastic Beanstalk must have permission to assume this role.
         */
        serviceRole: string;
    }
}
export declare namespace elasticsearch {
    interface DomainAdvancedSecurityOptions {
        /**
         * Whether advanced security is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled. If not set, defaults to `false` by the AWS API.
         */
        internalUserDatabaseEnabled?: boolean;
        /**
         * Configuration block for the main user. Detailed below.
         */
        masterUserOptions?: outputs.elasticsearch.DomainAdvancedSecurityOptionsMasterUserOptions;
    }
    interface DomainAdvancedSecurityOptionsMasterUserOptions {
        /**
         * ARN for the main user. Only specify if `internalUserDatabaseEnabled` is not set or set to `false`.
         */
        masterUserArn?: string;
        /**
         * Main user's username, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserName?: string;
        /**
         * Main user's password, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserPassword?: string;
    }
    interface DomainAutoTuneOptions {
        /**
         * The Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
         */
        desiredState: string;
        /**
         * Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
         */
        maintenanceSchedules: outputs.elasticsearch.DomainAutoTuneOptionsMaintenanceSchedule[];
        /**
         * Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
         */
        rollbackOnDisable: string;
    }
    interface DomainAutoTuneOptionsMaintenanceSchedule {
        /**
         * A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
         */
        duration: outputs.elasticsearch.DomainAutoTuneOptionsMaintenanceScheduleDuration;
        /**
         * Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }
    interface DomainAutoTuneOptionsMaintenanceScheduleDuration {
        /**
         * The unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
         */
        unit: string;
        /**
         * An integer specifying the value of the duration of an Auto-Tune maintenance window.
         */
        value: number;
    }
    interface DomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration. Detailed below.
         */
        coldStorageOptions: outputs.elasticsearch.DomainClusterConfigColdStorageOptions;
        /**
         * Number of dedicated main nodes in the cluster.
         */
        dedicatedMasterCount?: number;
        /**
         * Whether dedicated main nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled?: boolean;
        /**
         * Instance type of the dedicated main nodes in the cluster.
         */
        dedicatedMasterType?: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount?: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType?: string;
        /**
         * Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warmCount` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmCount?: number;
        /**
         * Whether to enable warm storage.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the Elasticsearch cluster's warm nodes. Valid values are `ultrawarm1.medium.elasticsearch`, `ultrawarm1.large.elasticsearch` and `ultrawarm1.xlarge.elasticsearch`. `warmType` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmType?: string;
        /**
         * Configuration block containing zone awareness settings. Detailed below.
         */
        zoneAwarenessConfig?: outputs.elasticsearch.DomainClusterConfigZoneAwarenessConfig;
        /**
         * Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availabilityZoneCount` within the `zoneAwarenessConfig` must be set to `3`.
         */
        zoneAwarenessEnabled?: boolean;
    }
    interface DomainClusterConfigColdStorageOptions {
        /**
         * Boolean to enable cold storage for an Elasticsearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
         */
        enabled: boolean;
    }
    interface DomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of Availability Zones for the domain to use with `zoneAwarenessEnabled`. Defaults to `2`. Valid values: `2` or `3`.
         */
        availabilityZoneCount?: number;
    }
    interface DomainCognitoOptions {
        /**
         * Whether Amazon Cognito authentication with Kibana is enabled or not.
         */
        enabled?: boolean;
        /**
         * ID of the Cognito Identity Pool to use.
         */
        identityPoolId: string;
        /**
         * ARN of the IAM role that has the AmazonESCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * ID of the Cognito User Pool to use.
         */
        userPoolId: string;
    }
    interface DomainDomainEndpointOptions {
        /**
         * Fully qualified domain for your custom endpoint.
         */
        customEndpoint?: string;
        /**
         * ACM certificate ARN for your custom endpoint.
         */
        customEndpointCertificateArn?: string;
        /**
         * Whether to enable custom endpoint for the Elasticsearch domain.
         */
        customEndpointEnabled?: boolean;
        /**
         * Whether or not to require HTTPS. Defaults to `true`.
         */
        enforceHttps?: boolean;
        /**
         * Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided.
         */
        tlsSecurityPolicy: string;
    }
    interface DomainEbsOptions {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
         */
        iops: number;
        /**
         * Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GiB).
         */
        volumeSize?: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }
    interface DomainEncryptAtRest {
        /**
         * Whether to enable encryption at rest. If the `encryptAtRest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires `elasticsearchVersion` 5.1 or greater.
         */
        enabled: boolean;
        /**
         * KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
         */
        kmsKeyId: string;
    }
    interface DomainLogPublishingOption {
        /**
         * ARN of the Cloudwatch log group to which log needs to be published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether given log publishing option is enabled or not.
         */
        enabled?: boolean;
        /**
         * Type of Elasticsearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
         */
        logType: string;
    }
    interface DomainNodeToNodeEncryption {
        /**
         * Whether to enable node-to-node encryption. If the `nodeToNodeEncryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `elasticsearchVersion` of `6.0` or greater.
         */
        enabled: boolean;
    }
    interface DomainSamlOptionsSamlOptions {
        /**
         * Whether SAML authentication is enabled.
         */
        enabled?: boolean;
        /**
         * Information from your identity provider.
         */
        idp?: outputs.elasticsearch.DomainSamlOptionsSamlOptionsIdp;
        /**
         * This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterBackendRole?: string;
        /**
         * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterUserName?: string;
        /**
         * Element of the SAML assertion to use for backend roles. Default is roles.
         */
        rolesKey?: string;
        /**
         * Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
         */
        sessionTimeoutMinutes?: number;
        /**
         * Custom SAML attribute to use for user names. Default is an empty string - `""`. This will cause Elasticsearch to use the `NameID` element of the `Subject`, which is the default location for name identifiers in the SAML specification.
         */
        subjectKey?: string;
    }
    interface DomainSamlOptionsSamlOptionsIdp {
        /**
         * The unique Entity ID of the application in SAML Identity Provider.
         */
        entityId: string;
        /**
         * The Metadata of the SAML application in xml format.
         */
        metadataContent: string;
    }
    interface DomainSnapshotOptions {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }
    interface DomainVpcOptions {
        /**
         * If the domain was created inside a VPC, the names of the availability zones the configured `subnetIds` were created inside.
         */
        availabilityZones: string[];
        /**
         * List of VPC Security Group IDs to be applied to the Elasticsearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
         */
        securityGroupIds?: string[];
        /**
         * List of VPC Subnet IDs for the Elasticsearch domain endpoints to be created in.
         */
        subnetIds?: string[];
        /**
         * If the domain was created inside a VPC, the ID of the VPC.
         */
        vpcId: string;
    }
    interface GetDomainAdvancedSecurityOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled.
         */
        internalUserDatabaseEnabled: boolean;
    }
    interface GetDomainAutoTuneOption {
        /**
         * The Auto-Tune desired state for the domain.
         */
        desiredState: string;
        /**
         * A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
         */
        maintenanceSchedules: outputs.elasticsearch.GetDomainAutoTuneOptionMaintenanceSchedule[];
        /**
         * Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
         */
        rollbackOnDisable: string;
    }
    interface GetDomainAutoTuneOptionMaintenanceSchedule {
        /**
         * Cron expression for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window.
         */
        durations: outputs.elasticsearch.GetDomainAutoTuneOptionMaintenanceScheduleDuration[];
        /**
         * Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }
    interface GetDomainAutoTuneOptionMaintenanceScheduleDuration {
        /**
         * Unit of time.
         */
        unit: string;
        /**
         * Duration of an Auto-Tune maintenance window.
         */
        value: number;
    }
    interface GetDomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration.
         */
        coldStorageOptions: outputs.elasticsearch.GetDomainClusterConfigColdStorageOption[];
        /**
         * Number of dedicated master nodes in the cluster.
         */
        dedicatedMasterCount: number;
        /**
         * Indicates whether dedicated master nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled: boolean;
        /**
         * Instance type of the dedicated master nodes in the cluster.
         */
        dedicatedMasterType: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType: string;
        /**
         * The number of warm nodes in the cluster.
         */
        warmCount: number;
        /**
         * Warm storage is enabled.
         */
        warmEnabled: boolean;
        /**
         * The instance type for the Elasticsearch cluster's warm nodes.
         */
        warmType: string;
        /**
         * Configuration block containing zone awareness settings.
         */
        zoneAwarenessConfigs: outputs.elasticsearch.GetDomainClusterConfigZoneAwarenessConfig[];
        /**
         * Indicates whether zone awareness is enabled.
         */
        zoneAwarenessEnabled: boolean;
    }
    interface GetDomainClusterConfigColdStorageOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
    }
    interface GetDomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of availability zones used.
         */
        availabilityZoneCount: number;
    }
    interface GetDomainCognitoOption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The Cognito Identity pool used by the domain.
         */
        identityPoolId: string;
        /**
         * The IAM Role with the AmazonESCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * The Cognito User pool used by the domain.
         */
        userPoolId: string;
    }
    interface GetDomainEbsOption {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * The baseline input/output (I/O) performance of EBS volumes attached to data nodes.
         */
        iops: number;
        /**
         * The throughput (in MiB/s) of the EBS volumes attached to data nodes.
         */
        throughput: number;
        /**
         * The size of EBS volumes attached to data nodes (in GB).
         */
        volumeSize: number;
        /**
         * The type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }
    interface GetDomainEncryptionAtRest {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The KMS key id used to encrypt data at rest.
         */
        kmsKeyId: string;
    }
    interface GetDomainLogPublishingOption {
        /**
         * The CloudWatch Log Group where the logs are published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
        /**
         * The type of Elasticsearch log being published.
         */
        logType: string;
    }
    interface GetDomainNodeToNodeEncryption {
        /**
         * Whether node to node encryption is enabled.
         */
        enabled: boolean;
    }
    interface GetDomainSnapshotOption {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }
    interface GetDomainVpcOption {
        /**
         * The availability zones used by the domain.
         */
        availabilityZones: string[];
        /**
         * The security groups used by the domain.
         */
        securityGroupIds: string[];
        /**
         * The subnets used by the domain.
         */
        subnetIds: string[];
        /**
         * The VPC used by the domain.
         */
        vpcId: string;
    }
    interface VpcEndpointVpcOptions {
        availabilityZones: string[];
        /**
         * The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, elasticsearch Service uses the default security group for the VPC.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
         */
        subnetIds: string[];
        vpcId: string;
    }
}
export declare namespace elastictranscoder {
    interface PipelineContentConfig {
        /**
         * The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files and playlists.
         */
        bucket: string;
        /**
         * The Amazon S3 storage class, `Standard` or `ReducedRedundancy`, that you want Elastic Transcoder to assign to the files and playlists that it stores in your Amazon S3 bucket.
         */
        storageClass?: string;
    }
    interface PipelineContentConfigPermission {
        /**
         * The permission that you want to give to the AWS user that you specified in `content_config_permissions.grantee`. Valid values are `Read`, `ReadAcp`, `WriteAcp` or `FullControl`.
         */
        accesses?: string[];
        /**
         * The AWS user or group that you want to have access to transcoded files and playlists.
         */
        grantee?: string;
        /**
         * Specify the type of value that appears in the `content_config_permissions.grantee` object. Valid values are `Canonical`, `Email` or `Group`.
         */
        granteeType?: string;
    }
    interface PipelineNotifications {
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder has finished processing a job in this pipeline.
         */
        completed?: string;
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters an error condition while processing a job in this pipeline.
         */
        error?: string;
        /**
         * The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify when Elastic Transcoder has started to process a job in this pipeline.
         */
        progressing?: string;
        /**
         * The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder encounters a warning condition while processing a job in this pipeline.
         *
         * The `thumbnailConfig` object specifies information about the Amazon S3 bucket in
         * which you want Elastic Transcoder to save thumbnail files: which bucket to use,
         * which users you want to have access to the files, the type of access you want
         * users to have, and the storage class that you want to assign to the files. If
         * you specify values for `contentConfig`, you must also specify values for
         * `thumbnailConfig` even if you don't want to create thumbnails. (You control
         * whether to create thumbnails when you create a job. For more information, see
         * ThumbnailPattern in the topic Create Job.) If you specify values for
         * `contentConfig` and `thumbnailConfig`, omit the OutputBucket object.
         */
        warning?: string;
    }
    interface PipelineThumbnailConfig {
        /**
         * The Amazon S3 bucket in which you want Elastic Transcoder to save thumbnail files.
         */
        bucket: string;
        /**
         * The Amazon S3 storage class, Standard or ReducedRedundancy, that you want Elastic Transcoder to assign to the thumbnails that it stores in your Amazon S3 bucket.
         */
        storageClass?: string;
    }
    interface PipelineThumbnailConfigPermission {
        /**
         * The permission that you want to give to the AWS user that you specified in `thumbnail_config_permissions.grantee`. Valid values are `Read`, `ReadAcp`, `WriteAcp` or `FullControl`.
         */
        accesses?: string[];
        /**
         * The AWS user or group that you want to have access to thumbnail files.
         */
        grantee?: string;
        /**
         * Specify the type of value that appears in the `thumbnail_config_permissions.grantee` object. Valid values are `Canonical`, `Email` or `Group`.
         */
        granteeType?: string;
    }
    interface PresetAudio {
        /**
         * The method of organizing audio channels and tracks. Use Audio:Channels to specify the number of channels in your output, and Audio:AudioPackingMode to specify the number of tracks and their relation to the channels. If you do not specify an Audio:AudioPackingMode, Elastic Transcoder uses SingleTrack.
         */
        audioPackingMode?: string;
        /**
         * The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer between 64 and 320, inclusive.
         */
        bitRate: string;
        /**
         * The number of audio channels in the output file
         */
        channels?: string;
        /**
         * The audio codec for the output file. Valid values are `AAC`, `flac`, `mp2`, `mp3`, `pcm`, and `vorbis`.
         */
        codec?: string;
        /**
         * The sample rate of the audio stream in the output file, in hertz. Valid values are: `auto`, `22050`, `32000`, `44100`, `48000`, `96000`
         */
        sampleRate?: string;
    }
    interface PresetAudioCodecOptions {
        /**
         * The bit depth of a sample is how many bits of information are included in the audio samples. Valid values are `16` and `24`. (FLAC/PCM Only)
         */
        bitDepth: string;
        /**
         * The order the bits of a PCM sample are stored in. The supported value is LittleEndian. (PCM Only)
         */
        bitOrder: string;
        /**
         * If you specified AAC for Audio:Codec, choose the AAC profile for the output file.
         */
        profile: string;
        /**
         * Whether audio samples are represented with negative and positive numbers (signed) or only positive numbers (unsigned). The supported value is Signed. (PCM Only)
         */
        signed: string;
    }
    interface PresetThumbnails {
        /**
         * The aspect ratio of thumbnails. The following values are valid: auto, 1:1, 4:3, 3:2, 16:9
         */
        aspectRatio?: string;
        /**
         * The format of thumbnails, if any. Valid formats are jpg and png.
         */
        format?: string;
        /**
         * The approximate number of seconds between thumbnails. The value must be an integer. The actual interval can vary by several seconds from one thumbnail to the next.
         */
        interval?: string;
        /**
         * The maximum height of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 3072, inclusive.
         */
        maxHeight?: string;
        /**
         * The maximum width of thumbnails, in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 32 and 4096, inclusive.
         */
        maxWidth?: string;
        /**
         * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of thumbnails to make the total size of the thumbnails match the values that you specified for thumbnail MaxWidth and MaxHeight settings.
         */
        paddingPolicy?: string;
        /**
         * The width and height of thumbnail files in pixels, in the format WidthxHeight, where both values are even integers. The values cannot exceed the width and height that you specified in the Video:Resolution object. (To better control resolution and aspect ratio of thumbnails, we recommend that you use the thumbnail values `maxWidth`, `maxHeight`, `sizingPolicy`, and `paddingPolicy` instead of `resolution` and `aspectRatio`. The two groups of settings are mutually exclusive. Do not use them together)
         */
        resolution?: string;
        /**
         * A value that controls scaling of thumbnails. Valid values are: `Fit`, `Fill`, `Stretch`, `Keep`, `ShrinkToFit`, and `ShrinkToFill`.
         */
        sizingPolicy?: string;
    }
    interface PresetVideo {
        /**
         * The display aspect ratio of the video in the output file. Valid values are: `auto`, `1:1`, `4:3`, `3:2`, `16:9`. (Note; to better control resolution and aspect ratio of output videos, we recommend that you use the values `maxWidth`, `maxHeight`, `sizingPolicy`, `paddingPolicy`, and `displayAspectRatio` instead of `resolution` and `aspectRatio`.)
         */
        aspectRatio?: string;
        /**
         * The bit rate of the video stream in the output file, in kilobits/second. You can configure variable bit rate or constant bit rate encoding.
         */
        bitRate: string;
        /**
         * The video codec for the output file. Valid values are `gif`, `H.264`, `mpeg2`, `vp8`, and `vp9`.
         */
        codec?: string;
        /**
         * The value that Elastic Transcoder adds to the metadata in the output file. If you set DisplayAspectRatio to auto, Elastic Transcoder chooses an aspect ratio that ensures square pixels. If you specify another option, Elastic Transcoder sets that value in the output file.
         */
        displayAspectRatio?: string;
        /**
         * Whether to use a fixed value for Video:FixedGOP. Not applicable for containers of type gif. Valid values are true and false. Also known as, Fixed Number of Frames Between Keyframes.
         */
        fixedGop?: string;
        /**
         * The frames per second for the video stream in the output file. The following values are valid: `auto`, `10`, `15`, `23.97`, `24`, `25`, `29.97`, `30`, `50`, `60`.
         */
        frameRate?: string;
        /**
         * The maximum number of frames between key frames. Not applicable for containers of type gif.
         */
        keyframesMaxDist?: string;
        /**
         * If you specify auto for FrameRate, Elastic Transcoder uses the frame rate of the input video for the frame rate of the output video, up to the maximum frame rate. If you do not specify a MaxFrameRate, Elastic Transcoder will use a default of 30.
         */
        maxFrameRate: string;
        /**
         * The maximum height of the output video in pixels. If you specify auto, Elastic Transcoder uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 96 and 3072, inclusive.
         */
        maxHeight?: string;
        /**
         * The maximum width of the output video in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even integer between 128 and 4096, inclusive.
         */
        maxWidth?: string;
        /**
         * When you set PaddingPolicy to Pad, Elastic Transcoder might add black bars to the top and bottom and/or left and right sides of the output video to make the total size of the output video match the values that you specified for `maxWidth` and `maxHeight`.
         */
        paddingPolicy?: string;
        /**
         * The width and height of the video in the output file, in pixels. Valid values are `auto` and `widthxheight`. (see note for `aspectRatio`)
         */
        resolution?: string;
        /**
         * A value that controls scaling of the output video. Valid values are: `Fit`, `Fill`, `Stretch`, `Keep`, `ShrinkToFit`, `ShrinkToFill`.
         */
        sizingPolicy?: string;
    }
    interface PresetVideoWatermark {
        /**
         * The horizontal position of the watermark unless you specify a nonzero value for `horzontalOffset`.
         */
        horizontalAlign?: string;
        /**
         * The amount by which you want the horizontal position of the watermark to be offset from the position specified by `horizontalAlign`.
         */
        horizontalOffset?: string;
        /**
         * A unique identifier for the settings for one watermark. The value of Id can be up to 40 characters long. You can specify settings for up to four watermarks.
         */
        id?: string;
        /**
         * The maximum height of the watermark.
         */
        maxHeight?: string;
        /**
         * The maximum width of the watermark.
         */
        maxWidth?: string;
        /**
         * A percentage that indicates how much you want a watermark to obscure the video in the location where it appears.
         */
        opacity?: string;
        /**
         * A value that controls scaling of the watermark. Valid values are: `Fit`, `Stretch`, `ShrinkToFit`
         */
        sizingPolicy?: string;
        /**
         * A value that determines how Elastic Transcoder interprets values that you specified for `video_watermarks.horizontal_offset`, `video_watermarks.vertical_offset`, `video_watermarks.max_width`, and `video_watermarks.max_height`. Valid values are `Content` and `Frame`.
         */
        target?: string;
        /**
         * The vertical position of the watermark unless you specify a nonzero value for `verticalAlign`. Valid values are `Top`, `Bottom`, `Center`.
         */
        verticalAlign?: string;
        /**
         * The amount by which you want the vertical position of the watermark to be offset from the position specified by `verticalAlign`
         */
        verticalOffset?: string;
    }
}
export declare namespace elb {
    interface GetLoadBalancerAccessLogs {
        bucket: string;
        bucketPrefix: string;
        enabled: boolean;
        interval: number;
    }
    interface GetLoadBalancerHealthCheck {
        healthyThreshold: number;
        interval: number;
        target: string;
        timeout: number;
        unhealthyThreshold: number;
    }
    interface GetLoadBalancerListener {
        instancePort: number;
        instanceProtocol: string;
        lbPort: number;
        lbProtocol: string;
        sslCertificateId: string;
    }
    interface LoadBalancerAccessLogs {
        /**
         * The S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * The S3 bucket prefix. Logs are stored in the root if not configured.
         */
        bucketPrefix?: string;
        /**
         * Boolean to enable / disable `accessLogs`. Default is `true`
         */
        enabled?: boolean;
        /**
         * The publishing interval in minutes. Valid values: `5` and `60`. Default: `60`
         */
        interval?: number;
    }
    interface LoadBalancerHealthCheck {
        /**
         * The number of checks before the instance is declared healthy.
         */
        healthyThreshold: number;
        /**
         * The interval between checks.
         */
        interval: number;
        /**
         * The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL
         * values are:
         * * `HTTP`, `HTTPS` - PORT and PATH are required
         * * `TCP`, `SSL` - PORT is required, PATH is not supported
         */
        target: string;
        /**
         * The length of time before the check times out.
         */
        timeout: number;
        /**
         * The number of checks before the instance is declared unhealthy.
         */
        unhealthyThreshold: number;
    }
    interface LoadBalancerListener {
        /**
         * The port on the instance to route to
         */
        instancePort: number;
        /**
         * The protocol to use to the instance. Valid
         * values are `HTTP`, `HTTPS`, `TCP`, or `SSL`
         */
        instanceProtocol: string;
        /**
         * The port to listen on for the load balancer
         */
        lbPort: number;
        /**
         * The protocol to listen on. Valid values are `HTTP`,
         * `HTTPS`, `TCP`, or `SSL`
         */
        lbProtocol: string;
        /**
         * The ARN of an SSL certificate you have
         * uploaded to AWS IAM. **Note ECDSA-specific restrictions below.  Only valid when `lbProtocol` is either HTTPS or SSL**
         */
        sslCertificateId?: string;
    }
    interface LoadBalancerPolicyPolicyAttribute {
        name?: string;
        value?: string;
    }
    interface SslNegotiationPolicyAttribute {
        /**
         * The name of the attribute
         */
        name: string;
        /**
         * The value of the attribute
         */
        value: string;
    }
}
export declare namespace emr {
    interface BlockPublicAccessConfigurationPermittedPublicSecurityGroupRuleRange {
        /**
         * The final port in the range of TCP ports.
         */
        maxRange: number;
        /**
         * The first port in the range of TCP ports.
         */
        minRange: number;
    }
    interface ClusterAutoTerminationPolicy {
        /**
         * Specifies the amount of idle time in seconds after which the cluster automatically terminates. You can specify a minimum of `60` seconds and a maximum of `604800` seconds (seven days).
         */
        idleTimeout?: number;
    }
    interface ClusterBootstrapAction {
        /**
         * List of command line arguments to pass to the bootstrap action script.
         */
        args?: string[];
        /**
         * Name of the bootstrap action.
         */
        name: string;
        /**
         * Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system.
         */
        path: string;
    }
    interface ClusterCoreInstanceFleet {
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Configuration block for instance fleet.
         */
        instanceTypeConfigs?: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfig[];
        /**
         * Configuration block for launch specification.
         */
        launchSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecifications;
        /**
         * Friendly name given to the instance fleet.
         */
        name?: string;
        provisionedOnDemandCapacity: number;
        provisionedSpotCapacity: number;
        /**
         * The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
         */
        targetOnDemandCapacity?: number;
        /**
         * Target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
         */
        targetSpotCapacity?: number;
    }
    interface ClusterCoreInstanceFleetInstanceTypeConfig {
        /**
         * Bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * Bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * Number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }
    interface ClusterCoreInstanceFleetInstanceTypeConfigConfiguration {
        /**
         * Classification within a configuration.
         */
        classification?: string;
        /**
         * Map of properties specified within a configuration classification.
         */
        properties?: {
            [key: string]: string;
        };
    }
    interface ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }
    interface ClusterCoreInstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications.
         */
        onDemandSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications.
         */
        spotSpecifications?: outputs.emr.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification[];
    }
    interface ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies the strategy to use in launching On-Demand instance fleets. Currently, the only option is `lowest-price` (the default), which launches the lowest price first.
         */
        allocationStrategy: string;
    }
    interface ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Valid values include `capacity-optimized`, `diversified`, `lowest-price`, `price-capacity-optimized`. See the [AWS documentation](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html#emr-instance-fleet-allocation-strategy) for details on each strategy type.
         */
        allocationStrategy: string;
        /**
         * Defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * Action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * Spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }
    interface ClusterCoreInstanceGroup {
        /**
         * String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
         */
        autoscalingPolicy?: string;
        /**
         * Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
         */
        bidPrice?: string;
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterCoreInstanceGroupEbsConfig[];
        /**
         * Core node type Instance Group ID, if using Instance Group for this node type.
         */
        id: string;
        /**
         * Target number of instances for the instance group. Must be at least 1. Defaults to 1.
         */
        instanceCount?: number;
        /**
         * EC2 instance type for all instances in the instance group.
         */
        instanceType: string;
        /**
         * Friendly name given to the instance group.
         */
        name?: string;
    }
    interface ClusterCoreInstanceGroupEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The throughput, in mebibyte per second (MiB/s).
         */
        throughput?: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }
    interface ClusterEc2Attributes {
        /**
         * String containing a comma separated list of additional Amazon EC2 security group IDs for the master node.
         */
        additionalMasterSecurityGroups?: string;
        /**
         * String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string.
         */
        additionalSlaveSecurityGroups?: string;
        /**
         * Identifier of the Amazon EC2 EMR-Managed security group for the master node.
         */
        emrManagedMasterSecurityGroup: string;
        /**
         * Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes.
         */
        emrManagedSlaveSecurityGroup: string;
        /**
         * Instance Profile for EC2 instances of the cluster assume this role.
         */
        instanceProfile: string;
        /**
         * Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`.
         */
        keyName?: string;
        /**
         * Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet.
         */
        serviceAccessSecurityGroup: string;
        /**
         * VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in an Amazon VPC.
         */
        subnetId: string;
        /**
         * List of VPC subnet id-s where you want the job flow to launch.  Amazon EMR identifies the best Availability Zone to launch instances according to your fleet specifications.
         *
         * > **NOTE on EMR-Managed security groups:** These security groups will have any missing inbound or outbound access rules added and maintained by AWS, to ensure proper communication between instances in a cluster. The EMR service will maintain these rules for groups provided in `emrManagedMasterSecurityGroup` and `emrManagedSlaveSecurityGroup`; attempts to remove the required rules may succeed, only for the EMR service to re-add them in a matter of minutes. This may cause this provider to fail to destroy an environment that contains an EMR cluster, because the EMR service does not revoke rules added on deletion, leaving a cyclic dependency between the security groups that prevents their deletion. To avoid this, use the `revokeRulesOnDelete` optional attribute for any Security Group used in `emrManagedMasterSecurityGroup` and `emrManagedSlaveSecurityGroup`. See [Amazon EMR-Managed Security Groups](http://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-man-sec-groups.html) for more information about the EMR-managed security group rules.
         */
        subnetIds: string[];
    }
    interface ClusterKerberosAttributes {
        /**
         * Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
         */
        adDomainJoinPassword?: string;
        /**
         * Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
         */
        adDomainJoinUser?: string;
        /**
         * Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
         */
        crossRealmTrustPrincipalPassword?: string;
        /**
         * Password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
         */
        kdcAdminPassword: string;
        /**
         * Name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
         */
        realm: string;
    }
    interface ClusterMasterInstanceFleet {
        /**
         * ID of the cluster.
         */
        id: string;
        /**
         * Configuration block for instance fleet.
         */
        instanceTypeConfigs?: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfig[];
        /**
         * Configuration block for launch specification.
         */
        launchSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecifications;
        /**
         * Friendly name given to the instance fleet.
         */
        name?: string;
        provisionedOnDemandCapacity: number;
        provisionedSpotCapacity: number;
        /**
         * Target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
         */
        targetOnDemandCapacity?: number;
        /**
         * Target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
         */
        targetSpotCapacity?: number;
    }
    interface ClusterMasterInstanceFleetInstanceTypeConfig {
        /**
         * Bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * Bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * Number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }
    interface ClusterMasterInstanceFleetInstanceTypeConfigConfiguration {
        /**
         * Classification within a configuration.
         */
        classification?: string;
        /**
         * Map of properties specified within a configuration classification.
         */
        properties?: {
            [key: string]: string;
        };
    }
    interface ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }
    interface ClusterMasterInstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications.
         */
        onDemandSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications.
         */
        spotSpecifications?: outputs.emr.ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification[];
    }
    interface ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies the strategy to use in launching On-Demand instance fleets. Currently, the only option is `lowest-price` (the default), which launches the lowest price first.
         */
        allocationStrategy: string;
    }
    interface ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies the strategy to use in launching Spot instance fleets. Valid values include `capacity-optimized`, `diversified`, `lowest-price`, `price-capacity-optimized`. See the [AWS documentation](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html#emr-instance-fleet-allocation-strategy) for details on each strategy type.
         */
        allocationStrategy: string;
        /**
         * Defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * Action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * Spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }
    interface ClusterMasterInstanceGroup {
        /**
         * Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
         */
        bidPrice?: string;
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.ClusterMasterInstanceGroupEbsConfig[];
        /**
         * Master node type Instance Group ID, if using Instance Group for this node type.
         */
        id: string;
        /**
         * Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have map public IP on launch enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
         */
        instanceCount?: number;
        /**
         * EC2 instance type for all instances in the instance group.
         */
        instanceType: string;
        /**
         * Friendly name given to the instance group.
         */
        name?: string;
    }
    interface ClusterMasterInstanceGroupEbsConfig {
        /**
         * Number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * Volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The throughput, in mebibyte per second (MiB/s).
         */
        throughput?: number;
        /**
         * Volume type. Valid options are `gp3`, `gp2`, `io1`, `standard`, `st1` and `sc1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * Number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1).
         */
        volumesPerInstance?: number;
    }
    interface ClusterPlacementGroupConfig {
        /**
         * Role of the instance in the cluster. Valid Values: `MASTER`, `CORE`, `TASK`.
         */
        instanceRole: string;
        /**
         * EC2 Placement Group strategy associated with instance role. Valid Values: `SPREAD`, `PARTITION`, `CLUSTER`, `NONE`.
         */
        placementStrategy: string;
    }
    interface ClusterStep {
        /**
         * Action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
         */
        actionOnFailure: string;
        /**
         * JAR file used for the step. See below.
         */
        hadoopJarStep: outputs.emr.ClusterStepHadoopJarStep;
        /**
         * Name of the step.
         */
        name: string;
    }
    interface ClusterStepHadoopJarStep {
        /**
         * List of command line arguments passed to the JAR file's main function when executed.
         */
        args?: string[];
        /**
         * Path to a JAR file run during the step.
         */
        jar: string;
        /**
         * Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
         */
        mainClass?: string;
        /**
         * Key-Value map of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function.
         */
        properties?: {
            [key: string]: string;
        };
    }
    interface GetReleaseLabelsFilters {
        /**
         * Optional release label application filter. For example, `Spark@2.1.0` or `Spark`.
         */
        application?: string;
        /**
         * Optional release label version prefix filter. For example, `emr-5`.
         */
        prefix?: string;
    }
    interface GetSupportedInstanceTypesSupportedInstanceType {
        /**
         * CPU architecture.
         */
        architecture: string;
        /**
         * Indicates whether the instance type supports Amazon EBS optimization.
         */
        ebsOptimizedAvailable: boolean;
        /**
         * Indicates whether the instance type uses Amazon EBS optimization by default.
         */
        ebsOptimizedByDefault: boolean;
        /**
         * Indicates whether the instance type only supports Amazon EBS.
         */
        ebsStorageOnly: boolean;
        /**
         * The Amazon EC2 family and generation for the instance type.
         */
        instanceFamilyId: string;
        /**
         * Indicates whether the instance type only supports 64-bit architecture.
         */
        is64BitsOnly: boolean;
        /**
         * Memory that is available to Amazon EMR from the instance type.
         */
        memoryGb: number;
        /**
         * Number of disks for the instance type.
         */
        numberOfDisks: number;
        /**
         * Storage capacity of the instance type.
         */
        storageGb: number;
        /**
         * Amazon EC2 instance type. For example, `m5.xlarge`.
         */
        type: string;
        /**
         * The number of vCPUs available for the instance type.
         */
        vcpu: number;
    }
    interface InstanceFleetInstanceTypeConfig {
        /**
         * The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPrice?: string;
        /**
         * The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
         */
        bidPriceAsPercentageOfOnDemandPrice?: number;
        /**
         * A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
         */
        configurations?: outputs.emr.InstanceFleetInstanceTypeConfigConfiguration[];
        /**
         * Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
         */
        ebsConfigs: outputs.emr.InstanceFleetInstanceTypeConfigEbsConfig[];
        /**
         * An EC2 instance type, such as m4.xlarge.
         */
        instanceType: string;
        /**
         * The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `aws.emr.InstanceFleet`.
         */
        weightedCapacity?: number;
    }
    interface InstanceFleetInstanceTypeConfigConfiguration {
        /**
         * The classification within a configuration.
         */
        classification?: string;
        /**
         * A map of properties specified within a configuration classification
         */
        properties?: {
            [key: string]: string;
        };
    }
    interface InstanceFleetInstanceTypeConfigEbsConfig {
        /**
         * The number of I/O operations per second (IOPS) that the volume supports
         */
        iops?: number;
        /**
         * The volume size, in gibibytes (GiB).
         */
        size: number;
        /**
         * The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
         */
        type: string;
        /**
         * The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
         */
        volumesPerInstance?: number;
    }
    interface InstanceFleetLaunchSpecifications {
        /**
         * Configuration block for on demand instances launch specifications
         */
        onDemandSpecifications?: outputs.emr.InstanceFleetLaunchSpecificationsOnDemandSpecification[];
        /**
         * Configuration block for spot instances launch specifications
         */
        spotSpecifications?: outputs.emr.InstanceFleetLaunchSpecificationsSpotSpecification[];
    }
    interface InstanceFleetLaunchSpecificationsOnDemandSpecification {
        /**
         * Specifies one of the following strategies to launch Spot Instance fleets: `price-capacity-optimized`, `capacity-optimized`, `lowest-price`, or `diversified`. For more information on the provisioning strategies, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-allocation-strategy.html).
         */
        allocationStrategy: string;
    }
    interface InstanceFleetLaunchSpecificationsSpotSpecification {
        /**
         * Specifies one of the following strategies to launch Spot Instance fleets: `price-capacity-optimized`, `capacity-optimized`, `lowest-price`, or `diversified`. For more information on the provisioning strategies, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-allocation-strategy.html).
         */
        allocationStrategy: string;
        /**
         * The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
         */
        blockDurationMinutes?: number;
        /**
         * The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
         */
        timeoutAction: string;
        /**
         * The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
         */
        timeoutDurationMinutes: number;
    }
    interface InstanceGroupEbsConfig {
        /**
         * The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
         */
        size: number;
        /**
         * The volume type. Valid options are 'gp2', 'io1' and 'standard'.
         */
        type: string;
        /**
         * The number of EBS Volumes to attach per instance.
         */
        volumesPerInstance?: number;
    }
    interface ManagedScalingPolicyComputeLimit {
        /**
         * The upper boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
         */
        maximumCapacityUnits: number;
        /**
         * The upper boundary of EC2 units for core node type in a cluster. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The core units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between core and task nodes.
         */
        maximumCoreCapacityUnits?: number;
        /**
         * The upper boundary of On-Demand EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The On-Demand units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between On-Demand and Spot instances.
         */
        maximumOndemandCapacityUnits?: number;
        /**
         * The lower boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
         */
        minimumCapacityUnits: number;
        /**
         * The unit type used for specifying a managed scaling policy. Valid Values: `InstanceFleetUnits` | `Instances` | `VCPU`
         */
        unitType: string;
    }
}
export declare namespace emrcontainers {
    interface GetVirtualClusterContainerProvider {
        /**
         * The name of the container provider that is running your EMR Containers cluster
         */
        id: string;
        /**
         * Nested list containing information about the configuration of the container provider
         */
        infos: outputs.emrcontainers.GetVirtualClusterContainerProviderInfo[];
        /**
         * The type of the container provider
         */
        type: string;
    }
    interface GetVirtualClusterContainerProviderInfo {
        /**
         * Nested list containing EKS-specific information about the cluster where the EMR Containers cluster is running
         */
        eksInfos: outputs.emrcontainers.GetVirtualClusterContainerProviderInfoEksInfo[];
    }
    interface GetVirtualClusterContainerProviderInfoEksInfo {
        /**
         * The namespace where the EMR Containers cluster is running
         */
        namespace: string;
    }
    interface JobTemplateJobTemplateData {
        /**
         * The configuration settings that are used to override defaults configuration.
         */
        configurationOverrides?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverrides;
        /**
         * The execution role ARN of the job run.
         */
        executionRoleArn: string;
        /**
         * Specify the driver that the job runs on. Exactly one of the two available job drivers is required, either sparkSqlJobDriver or sparkSubmitJobDriver.
         */
        jobDriver: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriver;
        /**
         * The tags assigned to jobs started using the job template.
         */
        jobTags?: {
            [key: string]: string;
        };
        /**
         * The release version of Amazon EMR.
         */
        releaseLabel: string;
    }
    interface JobTemplateJobTemplateDataConfigurationOverrides {
        /**
         * The configurations for the application running by the job run.
         */
        applicationConfigurations?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesApplicationConfiguration[];
        /**
         * The configurations for monitoring.
         */
        monitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfiguration;
    }
    interface JobTemplateJobTemplateDataConfigurationOverridesApplicationConfiguration {
        /**
         * The classification within a configuration.
         */
        classification: string;
        /**
         * A list of additional configurations to apply within a configuration object.
         */
        configurations?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesApplicationConfigurationConfiguration[];
        /**
         * A set of properties specified within a configuration classification.
         */
        properties?: {
            [key: string]: string;
        };
    }
    interface JobTemplateJobTemplateDataConfigurationOverridesApplicationConfigurationConfiguration {
        classification?: string;
        properties?: {
            [key: string]: string;
        };
    }
    interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfiguration {
        /**
         * Monitoring configurations for CloudWatch.
         */
        cloudWatchMonitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationCloudWatchMonitoringConfiguration;
        /**
         * Monitoring configurations for the persistent application UI.
         */
        persistentAppUi?: string;
        /**
         * Amazon S3 configuration for monitoring log publishing.
         */
        s3MonitoringConfiguration?: outputs.emrcontainers.JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationS3MonitoringConfiguration;
    }
    interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationCloudWatchMonitoringConfiguration {
        /**
         * The name of the log group for log publishing.
         */
        logGroupName: string;
        /**
         * The specified name prefix for log streams.
         */
        logStreamNamePrefix?: string;
    }
    interface JobTemplateJobTemplateDataConfigurationOverridesMonitoringConfigurationS3MonitoringConfiguration {
        /**
         * Amazon S3 destination URI for log publishing.
         */
        logUri: string;
    }
    interface JobTemplateJobTemplateDataJobDriver {
        /**
         * The job driver for job type.
         */
        sparkSqlJobDriver?: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriverSparkSqlJobDriver;
        /**
         * The job driver parameters specified for spark submit.
         */
        sparkSubmitJobDriver?: outputs.emrcontainers.JobTemplateJobTemplateDataJobDriverSparkSubmitJobDriver;
    }
    interface JobTemplateJobTemplateDataJobDriverSparkSqlJobDriver {
        /**
         * The SQL file to be executed.
         */
        entryPoint?: string;
        /**
         * The Spark parameters to be included in the Spark SQL command.
         */
        sparkSqlParameters?: string;
    }
    interface JobTemplateJobTemplateDataJobDriverSparkSubmitJobDriver {
        /**
         * The entry point of job application.
         */
        entryPoint: string;
        /**
         * The arguments for job application.
         */
        entryPointArguments?: string[];
        /**
         * The Spark submit parameters that are used for job runs.
         */
        sparkSubmitParameters?: string;
    }
    interface VirtualClusterContainerProvider {
        /**
         * The name of the container provider that is running your EMR Containers cluster
         */
        id: string;
        /**
         * Nested list containing information about the configuration of the container provider
         */
        info: outputs.emrcontainers.VirtualClusterContainerProviderInfo;
        /**
         * The type of the container provider
         */
        type: string;
    }
    interface VirtualClusterContainerProviderInfo {
        /**
         * Nested list containing EKS-specific information about the cluster where the EMR Containers cluster is running
         */
        eksInfo: outputs.emrcontainers.VirtualClusterContainerProviderInfoEksInfo;
    }
    interface VirtualClusterContainerProviderInfoEksInfo {
        /**
         * The namespace where the EMR Containers cluster is running
         */
        namespace?: string;
    }
}
export declare namespace emrserverless {
    interface ApplicationAutoStartConfiguration {
        /**
         * Enables the application to automatically start on job submission. Defaults to `true`.
         */
        enabled?: boolean;
    }
    interface ApplicationAutoStopConfiguration {
        /**
         * Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
         */
        idleTimeoutMinutes?: number;
    }
    interface ApplicationImageConfiguration {
        /**
         * The image URI.
         */
        imageUri: string;
    }
    interface ApplicationInitialCapacity {
        /**
         * The initial capacity configuration per worker.
         */
        initialCapacityConfig?: outputs.emrserverless.ApplicationInitialCapacityInitialCapacityConfig;
        /**
         * The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
         */
        initialCapacityType: string;
    }
    interface ApplicationInitialCapacityInitialCapacityConfig {
        /**
         * The resource configuration of the initial capacity configuration.
         */
        workerConfiguration?: outputs.emrserverless.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration;
        /**
         * The number of workers in the initial capacity configuration.
         */
        workerCount: number;
    }
    interface ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration {
        /**
         * The CPU requirements for every worker instance of the worker type.
         */
        cpu: string;
        /**
         * The disk requirements for every worker instance of the worker type.
         */
        disk: string;
        /**
         * The memory requirements for every worker instance of the worker type.
         */
        memory: string;
    }
    interface ApplicationMaximumCapacity {
        /**
         * The maximum allowed CPU for an application.
         */
        cpu: string;
        /**
         * The maximum allowed disk for an application.
         */
        disk: string;
        /**
         * The maximum allowed resources for an application.
         */
        memory: string;
    }
    interface ApplicationNetworkConfiguration {
        /**
         * The array of security group Ids for customer VPC connectivity.
         */
        securityGroupIds?: string[];
        /**
         * The array of subnet Ids for customer VPC connectivity.
         */
        subnetIds?: string[];
    }
}
export declare namespace evidently {
    interface FeatureEvaluationRule {
        /**
         * The name for the new feature. Minimum length of `1`. Maximum length of `127`.
         */
        name: string;
        /**
         * This value is `aws.evidently.splits` if this is an evaluation rule for a launch, and it is `aws.evidently.onlineab` if this is an evaluation rule for an experiment.
         */
        type: string;
    }
    interface FeatureVariation {
        /**
         * The name of the variation. Minimum length of `1`. Maximum length of `127`.
         */
        name: string;
        /**
         * A block that specifies the value assigned to this variation. Detailed below
         */
        value: outputs.evidently.FeatureVariationValue;
    }
    interface FeatureVariationValue {
        /**
         * If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
         */
        boolValue?: string;
        /**
         * If this feature uses the double integer variation type, this field contains the double integer value of this variation.
         */
        doubleValue?: string;
        /**
         * If this feature uses the long variation type, this field contains the long value of this variation. Minimum value of `-9007199254740991`. Maximum value of `9007199254740991`.
         */
        longValue?: string;
        /**
         * If this feature uses the string variation type, this field contains the string value of this variation. Minimum length of `0`. Maximum length of `512`.
         */
        stringValue?: string;
    }
    interface LaunchExecution {
        /**
         * The date and time that the launch ended.
         */
        endedTime: string;
        /**
         * The date and time that the launch started.
         */
        startedTime: string;
    }
    interface LaunchGroup {
        /**
         * Specifies the description of the launch group.
         */
        description?: string;
        /**
         * Specifies the name of the feature that the launch is using.
         */
        feature: string;
        /**
         * Specifies the name of the lahnch group.
         */
        name: string;
        /**
         * Specifies the feature variation to use for this launch group.
         */
        variation: string;
    }
    interface LaunchMetricMonitor {
        /**
         * A block that defines the metric. Detailed below.
         */
        metricDefinition: outputs.evidently.LaunchMetricMonitorMetricDefinition;
    }
    interface LaunchMetricMonitorMetricDefinition {
        /**
         * Specifies the entity, such as a user or session, that does an action that causes a metric value to be recorded. An example is `userDetails.userID`.
         */
        entityIdKey: string;
        /**
         * Specifies The EventBridge event pattern that defines how the metric is recorded.
         */
        eventPattern?: string;
        /**
         * Specifies the name for the metric.
         */
        name: string;
        /**
         * Specifies a label for the units that the metric is measuring.
         */
        unitLabel?: string;
        /**
         * Specifies the value that is tracked to produce the metric.
         */
        valueKey: string;
    }
    interface LaunchScheduledSplitsConfig {
        /**
         * One or up to six blocks that define the traffic allocation percentages among the feature variations during each step of the launch. This also defines the start time of each step. Detailed below.
         */
        steps: outputs.evidently.LaunchScheduledSplitsConfigStep[];
    }
    interface LaunchScheduledSplitsConfigStep {
        /**
         * The traffic allocation percentages among the feature variations during one step of a launch. This is a set of key-value pairs. The keys are variation names. The values represent the percentage of traffic to allocate to that variation during this step. For more information, refer to the [AWS documentation for ScheduledSplitConfig groupWeights](https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_ScheduledSplitConfig.html).
         */
        groupWeights: {
            [key: string]: number;
        };
        /**
         * One or up to six blocks that specify different traffic splits for one or more audience segments. A segment is a portion of your audience that share one or more characteristics. Examples could be Chrome browser users, users in Europe, or Firefox browser users in Europe who also fit other criteria that your application collects, such as age. Detailed below.
         */
        segmentOverrides?: outputs.evidently.LaunchScheduledSplitsConfigStepSegmentOverride[];
        /**
         * Specifies the date and time that this step of the launch starts.
         */
        startTime: string;
    }
    interface LaunchScheduledSplitsConfigStepSegmentOverride {
        /**
         * Specifies a number indicating the order to use to evaluate segment overrides, if there are more than one. Segment overrides with lower numbers are evaluated first.
         */
        evaluationOrder: number;
        /**
         * The name or ARN of the segment to use.
         */
        segment: string;
        /**
         * The traffic allocation percentages among the feature variations to assign to this segment. This is a set of key-value pairs. The keys are variation names. The values represent the amount of traffic to allocate to that variation for this segment. This is expressed in thousandths of a percent, so a weight of 50000 represents 50% of traffic.
         */
        weights: {
            [key: string]: number;
        };
    }
    interface ProjectDataDelivery {
        /**
         * A block that defines the CloudWatch Log Group that stores the evaluation events. See below.
         */
        cloudwatchLogs?: outputs.evidently.ProjectDataDeliveryCloudwatchLogs;
        /**
         * A block that defines the S3 bucket and prefix that stores the evaluation events. See below.
         */
        s3Destination?: outputs.evidently.ProjectDataDeliveryS3Destination;
    }
    interface ProjectDataDeliveryCloudwatchLogs {
        /**
         * The name of the log group where the project stores evaluation events.
         */
        logGroup?: string;
    }
    interface ProjectDataDeliveryS3Destination {
        /**
         * The name of the bucket in which Evidently stores evaluation events.
         */
        bucket?: string;
        /**
         * The bucket prefix in which Evidently stores evaluation events.
         */
        prefix?: string;
    }
}
export declare namespace finspace {
    interface KxClusterAutoScalingConfiguration {
        /**
         * Metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all nodes in a cluster.
         */
        autoScalingMetric: string;
        /**
         * Highest number of nodes to scale. Cannot be greater than 5
         */
        maxNodeCount: number;
        /**
         * Desired value of chosen `autoScalingMetric`. When metric drops below this value, cluster will scale in. When metric goes above this value, cluster will scale out. Can be set between 0 and 100 percent.
         */
        metricTarget: number;
        /**
         * Lowest number of nodes to scale. Must be at least 1 and less than the `maxNodeCount`. If nodes in cluster belong to multiple availability zones, then `minNodeCount` must be at least 3.
         */
        minNodeCount: number;
        /**
         * Duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.
         */
        scaleInCooldownSeconds: number;
        /**
         * Duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.
         */
        scaleOutCooldownSeconds: number;
    }
    interface KxClusterCacheStorageConfiguration {
        size: number;
        /**
         * Type of KDB database. The following types are available:
         * * HDB - Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed KX databases mounted to the cluster.
         * * RDB - Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the `savedownStorageConfiguration` parameter.
         * * GATEWAY - A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a  writable local storage.
         * * GP - A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only `SINGLE` AZ mode.
         * * Tickerplant – A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.
         */
        type: string;
    }
    interface KxClusterCapacityConfiguration {
        /**
         * Number of instances running in a cluster. Must be at least 1 and at most 5.
         */
        nodeCount: number;
        /**
         * Determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance.
         *
         * You can only specify one of the following values:
         * * kx.s.large – The node type with a configuration of 12 GiB memory and 2 vCPUs.
         * * kx.s.xlarge – The node type with a configuration of 27 GiB memory and 4 vCPUs.
         * * kx.s.2xlarge – The node type with a configuration of 54 GiB memory and 8 vCPUs.
         * * kx.s.4xlarge – The node type with a configuration of 108 GiB memory and 16 vCPUs.
         * * kx.s.8xlarge – The node type with a configuration of 216 GiB memory and 32 vCPUs.
         * * kx.s.16xlarge – The node type with a configuration of 432 GiB memory and 64 vCPUs.
         * * kx.s.32xlarge – The node type with a configuration of 864 GiB memory and 128 vCPUs.
         */
        nodeType: string;
    }
    interface KxClusterCode {
        /**
         * Unique name for the S3 bucket.
         */
        s3Bucket: string;
        /**
         * Full S3 path (excluding bucket) to the .zip file that contains the code to be loaded onto the cluster when it’s started.
         */
        s3Key: string;
        /**
         * Version of an S3 Object.
         */
        s3ObjectVersion?: string;
    }
    interface KxClusterDatabase {
        /**
         * Configuration details for the disk cache to increase performance reading from a KX database mounted to the cluster. See cache_configurations.
         */
        cacheConfigurations?: outputs.finspace.KxClusterDatabaseCacheConfiguration[];
        /**
         * A unique identifier of the changeset that is associated with the cluster.
         */
        changesetId?: string;
        /**
         * Name of the KX database.
         */
        databaseName: string;
        /**
         * The name of the dataview to be used for caching historical data on disk. You cannot update to a different dataview name once a cluster is created. Use `lifecycle` `ignoreChanges` for database to prevent any undesirable behaviors.
         */
        dataviewName?: string;
    }
    interface KxClusterDatabaseCacheConfiguration {
        /**
         * Type of disk cache.
         */
        cacheType: string;
        /**
         * Paths within the database to cache.
         */
        dbPaths?: string[];
    }
    interface KxClusterSavedownStorageConfiguration {
        /**
         * Size of temporary storage in gigabytes. Must be between 10 and 16000.
         */
        size?: number;
        /**
         * Type of writeable storage space for temporarily storing your savedown data. The valid values are:
         * * SDS01 - This type represents 3000 IOPS and io2 ebs volume type.
         */
        type?: string;
        /**
         * The name of the kdb volume that you want to use as writeable save-down storage for clusters.
         */
        volumeName?: string;
    }
    interface KxClusterScalingGroupConfiguration {
        /**
         * The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.
         */
        cpu?: number;
        /**
         * An optional hard limit on the amount of memory a kdb cluster can use.
         */
        memoryLimit?: number;
        /**
         * A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.
         */
        memoryReservation: number;
        /**
         * The number of kdb cluster nodes.
         */
        nodeCount: number;
        /**
         * A unique identifier for the kdb scaling group.
         */
        scalingGroupName: string;
    }
    interface KxClusterTickerplantLogConfiguration {
        tickerplantLogVolumes: string[];
    }
    interface KxClusterVpcConfiguration {
        /**
         * IP address type for cluster network configuration parameters. The following type is available: IP_V4 - IP address version 4.
         */
        ipAddressType: string;
        /**
         * Unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.
         * * `subnetIds `- (Required) Identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.
         */
        securityGroupIds: string[];
        subnetIds: string[];
        /**
         * Identifier of the VPC endpoint
         */
        vpcId: string;
    }
    interface KxDataviewSegmentConfiguration {
        /**
         * The database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume.
         */
        dbPaths: string[];
        /**
         * Enables on-demand caching on the selected database path when a particular file or a column of the database is accessed. When on demand caching is **True**, dataviews perform minimal loading of files on the filesystem as needed. When it is set to **False**, everything is cached. The default value is **False**.
         */
        onDemand?: boolean;
        /**
         * The name of the volume that you want to attach to a dataview. This volume must be in the same availability zone as the dataview that you are attaching to.
         */
        volumeName: string;
    }
    interface KxEnvironmentCustomDnsConfiguration {
        /**
         * IP address of the DNS server.
         */
        customDnsServerIp: string;
        /**
         * Name of the DNS server.
         */
        customDnsServerName: string;
    }
    interface KxEnvironmentTransitGatewayConfiguration {
        /**
         * Rules that define how you manage outbound traffic from kdb network to your internal network. Defined below.
         */
        attachmentNetworkAclConfigurations?: outputs.finspace.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration[];
        /**
         * Routing CIDR on behalf of KX environment. It could be any “/26 range in the 100.64.0.0 CIDR space. After providing, it will be added to the customer’s transit gateway routing table so that the traffics could be routed to KX network.
         */
        routableCidrSpace: string;
        /**
         * Identifier of the transit gateway created by the customer to connect outbound traffics from KX network to your internal network.
         */
        transitGatewayId: string;
    }
    interface KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration {
        /**
         * The IPv4 network range to allow or deny, in CIDR notation. The specified CIDR block is modified to its canonical form. For example, `100.68.0.18/18` will be converted to `100.68.0.0/18`.
         */
        cidrBlock: string;
        /**
         * Defines the ICMP protocol that consists of the ICMP type and code. Defined below.
         */
        icmpTypeCode?: outputs.finspace.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode;
        /**
         * Range of ports the rule applies to. Defined below.
         */
        portRange?: outputs.finspace.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange;
        /**
         * Protocol number. A value of `1` means all the protocols.
         */
        protocol: string;
        /**
         * Indicates whether to `allow` or `deny` the traffic that matches the rule.
         */
        ruleAction: string;
        /**
         * Rule number for the entry. All the network ACL entries are processed in ascending order by rule number.
         */
        ruleNumber: number;
    }
    interface KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode {
        /**
         * ICMP code. A value of `-1` means all codes for the specified ICMP type.
         */
        code: number;
        /**
         * ICMP type. A value of `-1` means all types.
         */
        type: number;
    }
    interface KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange {
        /**
         * First port in the range.
         */
        from: number;
        /**
         * Last port in the range.
         */
        to: number;
    }
    interface KxVolumeAttachedCluster {
        clusterName: string;
        clusterStatus: string;
        clusterType: string;
    }
    interface KxVolumeNas1Configuration {
        /**
         * The size of the network attached storage.
         */
        size: number;
        /**
         * The type of the network attached storage.
         */
        type: string;
    }
}
export declare namespace fis {
    interface ExperimentTemplateAction {
        /**
         * ID of the action. To find out what actions are supported see [AWS FIS actions reference](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html).
         */
        actionId: string;
        /**
         * Description of the action.
         */
        description?: string;
        /**
         * Friendly name of the action.
         */
        name: string;
        /**
         * Parameter(s) for the action, if applicable. See below.
         */
        parameters?: outputs.fis.ExperimentTemplateActionParameter[];
        /**
         * Set of action names that must complete before this action can be executed.
         */
        startAfters?: string[];
        /**
         * Action's target, if applicable. See below.
         */
        target?: outputs.fis.ExperimentTemplateActionTarget;
    }
    interface ExperimentTemplateActionParameter {
        /**
         * Parameter name.
         */
        key: string;
        /**
         * Parameter value.
         *
         * For a list of parameters supported by each action, see [AWS FIS actions reference](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html).
         */
        value: string;
    }
    interface ExperimentTemplateActionTarget {
        /**
         * Target type. Valid values are `AutoScalingGroups` (EC2 Auto Scaling groups), `Buckets` (S3 Buckets), `Cluster` (EKS Cluster), `Clusters` (ECS Clusters), `DBInstances` (RDS DB Instances), `Instances` (EC2 Instances), `Nodegroups` (EKS Node groups), `Pods` (EKS Pods), `ReplicationGroups`(ElastiCache Redis Replication Groups), `Roles` (IAM Roles), `SpotInstances` (EC2 Spot Instances), `Subnets` (VPC Subnets), `Tables` (DynamoDB encrypted global tables), `Tasks` (ECS Tasks), `TransitGateways` (Transit gateways), `Volumes` (EBS Volumes). See the [documentation](https://docs.aws.amazon.com/fis/latest/userguide/actions.html#action-targets) for more details.
         */
        key: string;
        /**
         * Target name, referencing a corresponding target.
         */
        value: string;
    }
    interface ExperimentTemplateLogConfiguration {
        /**
         * The configuration for experiment logging to Amazon CloudWatch Logs. See below.
         */
        cloudwatchLogsConfiguration?: outputs.fis.ExperimentTemplateLogConfigurationCloudwatchLogsConfiguration;
        /**
         * The schema version. See [documentation](https://docs.aws.amazon.com/fis/latest/userguide/monitoring-logging.html#experiment-log-schema) for the list of schema versions.
         */
        logSchemaVersion: number;
        /**
         * The configuration for experiment logging to Amazon S3. See below.
         */
        s3Configuration?: outputs.fis.ExperimentTemplateLogConfigurationS3Configuration;
    }
    interface ExperimentTemplateLogConfigurationCloudwatchLogsConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
         */
        logGroupArn: string;
    }
    interface ExperimentTemplateLogConfigurationS3Configuration {
        /**
         * The name of the destination bucket.
         */
        bucketName: string;
        /**
         * The bucket prefix.
         */
        prefix?: string;
    }
    interface ExperimentTemplateStopCondition {
        /**
         * Source of the condition. One of `none`, `aws:cloudwatch:alarm`.
         */
        source: string;
        /**
         * ARN of the CloudWatch alarm. Required if the source is a CloudWatch alarm.
         */
        value?: string;
    }
    interface ExperimentTemplateTarget {
        /**
         * Filter(s) for the target. Filters can be used to select resources based on specific attributes returned by the respective describe action of the resource type. For more information, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters). See below.
         */
        filters?: outputs.fis.ExperimentTemplateTargetFilter[];
        /**
         * Friendly name given to the target.
         */
        name: string;
        /**
         * The resource type parameters.
         *
         * > **NOTE:** The `target` configuration block requires either `resourceArns` or `resourceTag`.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Set of ARNs of the resources to target with an action. Conflicts with `resourceTag`.
         */
        resourceArns?: string[];
        /**
         * Tag(s) the resources need to have to be considered a valid target for an action. Conflicts with `resourceArns`. See below.
         */
        resourceTags?: outputs.fis.ExperimentTemplateTargetResourceTag[];
        /**
         * AWS resource type. The resource type must be supported for the specified action. To find out what resource types are supported, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#resource-types).
         */
        resourceType: string;
        /**
         * Scopes the identified resources. Valid values are `ALL` (all identified resources), `COUNT(n)` (randomly select `n` of the identified resources), `PERCENT(n)` (randomly select `n` percent of the identified resources).
         */
        selectionMode: string;
    }
    interface ExperimentTemplateTargetFilter {
        /**
         * Attribute path for the filter.
         */
        path: string;
        /**
         * Set of attribute values for the filter.
         *
         * > **NOTE:** Values specified in a `filter` are joined with an `OR` clause, while values across multiple `filter` blocks are joined with an `AND` clause. For more information, see [Targets for AWS FIS](https://docs.aws.amazon.com/fis/latest/userguide/targets.html#target-filters).
         */
        values: string[];
    }
    interface ExperimentTemplateTargetResourceTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }
}
export declare namespace fms {
    interface PolicyExcludeMap {
        /**
         * A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
         */
        accounts?: string[];
        /**
         * A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
         *
         * You can specify inclusions or exclusions, but not both. If you specify an `includeMap`, AWS Firewall Manager applies the policy to all accounts specified by the `includeMap`, and does not evaluate any `excludeMap` specifications. If you do not specify an `includeMap`, then Firewall Manager applies the policy to all accounts except for those specified by the `excludeMap`.
         */
        orgunits?: string[];
    }
    interface PolicyIncludeMap {
        /**
         * A list of AWS Organization member Accounts that you want to include for this AWS FMS Policy.
         */
        accounts?: string[];
        /**
         * A list of IDs of the AWS Organizational Units that you want to include for this AWS FMS Policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.
         *
         * You can specify inclusions or exclusions, but not both. If you specify an `includeMap`, AWS Firewall Manager applies the policy to all accounts specified by the `includeMap`, and does not evaluate any `excludeMap` specifications. If you do not specify an `includeMap`, then Firewall Manager applies the policy to all accounts except for those specified by the `excludeMap`.
         */
        orgunits?: string[];
    }
    interface PolicySecurityServicePolicyData {
        /**
         * Details about the service that are specific to the service type, in JSON format. For service type `SHIELD_ADVANCED`, this is an empty string. Examples depending on `type` can be found in the [AWS Firewall Manager SecurityServicePolicyData API Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html).
         */
        managedServiceData?: string;
        /**
         * Contains the Network Firewall firewall policy options to configure a centralized deployment model. Documented below.
         */
        policyOption?: outputs.fms.PolicySecurityServicePolicyDataPolicyOption;
        /**
         * The service that the policy is using to protect the resources. For the current list of supported types, please refer to the [AWS Firewall Manager SecurityServicePolicyData API Type Reference](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html#fms-Type-SecurityServicePolicyData-Type).
         */
        type: string;
    }
    interface PolicySecurityServicePolicyDataPolicyOption {
        /**
         * Defines the deployment model to use for the firewall policy. Documented below.
         */
        networkFirewallPolicy?: outputs.fms.PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicy;
        thirdPartyFirewallPolicy?: outputs.fms.PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicy;
    }
    interface PolicySecurityServicePolicyDataPolicyOptionNetworkFirewallPolicy {
        /**
         * Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
         */
        firewallDeploymentModel?: string;
    }
    interface PolicySecurityServicePolicyDataPolicyOptionThirdPartyFirewallPolicy {
        /**
         * Defines the deployment model to use for the third-party firewall policy. Valid values are `CENTRALIZED` and `DISTRIBUTED`.
         */
        firewallDeploymentModel?: string;
    }
}
export declare namespace fsx {
    interface DataRepositoryAssociationS3 {
        autoExportPolicy: outputs.fsx.DataRepositoryAssociationS3AutoExportPolicy;
        autoImportPolicy: outputs.fsx.DataRepositoryAssociationS3AutoImportPolicy;
    }
    interface DataRepositoryAssociationS3AutoExportPolicy {
        events: string[];
    }
    interface DataRepositoryAssociationS3AutoImportPolicy {
        events: string[];
    }
    interface FileCacheDataRepositoryAssociation {
        associationId: string;
        /**
         * The path to the S3 or NFS data repository that links to the cache.
         */
        dataRepositoryPath: string;
        /**
         * A list of NFS Exports that will be linked with this data repository association. The Export paths are in the format /exportpath1. To use this parameter, you must configure DataRepositoryPath as the domain name of the NFS file system. The NFS file system domain name in effect is the root of the subdirectories. Note that DataRepositorySubdirectories is not supported for S3 data repositories. Max of 500.
         */
        dataRepositorySubdirectories?: string[];
        /**
         * The system-generated, unique ID of the cache.
         */
        fileCacheId: string;
        /**
         * A path on the cache that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with DataRepositoryPath. The leading forward slash in the name is required. Two data repository associations cannot have overlapping cache paths. For example, if a data repository is associated with cache path /ns1/, then you cannot link another data repository with cache path /ns1/ns2. This path specifies where in your cache files will be exported from. This cache directory can be linked to only one data repository, and no data repository other can be linked to the directory. Note: The cache path can only be set to root (/) on an NFS DRA when DataRepositorySubdirectories is specified. If you specify root (/) as the cache path, you can create only one DRA on the cache. The cache path cannot be set to root (/) for an S3 DRA.
         */
        fileCachePath: string;
        fileSystemId: string;
        fileSystemPath: string;
        importedFileChunkSize: number;
        /**
         * (Optional) See the `nfs` configuration block.
         */
        nfs?: outputs.fsx.FileCacheDataRepositoryAssociationNf[];
        resourceArn: string;
        /**
         * A map of tags to assign to the file cache. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface FileCacheDataRepositoryAssociationNf {
        /**
         * A list of up to 2 IP addresses of DNS servers used to resolve the NFS file system domain name. The provided IP addresses can either be the IP addresses of a DNS forwarder or resolver that the customer manages and runs inside the customer VPC, or the IP addresses of the on-premises DNS servers.
         */
        dnsIps?: string[];
        /**
         * The version of the NFS (Network File System) protocol of the NFS data repository. The only supported value is NFS3, which indicates that the data repository must support the NFSv3 protocol. The only supported value is `NFS3`.
         */
        version: string;
    }
    interface FileCacheLustreConfiguration {
        /**
         * Specifies the cache deployment type. The only supported value is `CACHE_1`.
         */
        deploymentType: string;
        logConfigurations: outputs.fsx.FileCacheLustreConfigurationLogConfiguration[];
        /**
         * The configuration for a Lustre MDT (Metadata Target) storage volume. See the `metadataConfiguration` block.
         */
        metadataConfigurations: outputs.fsx.FileCacheLustreConfigurationMetadataConfiguration[];
        mountName: string;
        /**
         * Provisions the amount of read and write throughput for each 1 tebibyte (TiB) of cache storage capacity, in MB/s/TiB. The only supported value is `1000`.
         */
        perUnitStorageThroughput: number;
        /**
         * A recurring weekly time, in the format `D:HH:MM`. `D` is the day of the week, for which `1` represents Monday and `7` represents Sunday. `HH` is the zero-padded hour of the day (0-23), and `MM` is the zero-padded minute of the hour. For example, 1:05:00 specifies maintenance at 5 AM Monday. See the [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date) for more information.
         */
        weeklyMaintenanceStartTime?: string;
    }
    interface FileCacheLustreConfigurationLogConfiguration {
        destination: string;
        level: string;
    }
    interface FileCacheLustreConfigurationMetadataConfiguration {
        /**
         * The storage capacity of the Lustre MDT (Metadata Target) storage volume in gibibytes (GiB). The only supported value is `2400` GiB.
         */
        storageCapacity: number;
    }
    interface GetOntapFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the file system is using the `AUTOMATIC` setting of SSD IOPS of 3 IOPS per GB of storage capacity, or if it using a `USER_PROVISIONED` value.
         */
        mode: string;
    }
    interface GetOntapFileSystemEndpoint {
        /**
         * A FileSystemEndpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See FileSystemEndpoint below.
         */
        interclusters: outputs.fsx.GetOntapFileSystemEndpointIntercluster[];
        /**
         * A FileSystemEndpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See FileSystemEndpoint below.
         */
        managements: outputs.fsx.GetOntapFileSystemEndpointManagement[];
    }
    interface GetOntapFileSystemEndpointIntercluster {
        /**
         * DNS name for the file system (e.g. `fs-12345678.corp.example.com`).
         */
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapFileSystemEndpointManagement {
        /**
         * DNS name for the file system (e.g. `fs-12345678.corp.example.com`).
         */
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapStorageVirtualMachineActiveDirectoryConfiguration {
        /**
         * The NetBIOS name of the AD computer object to which the SVM is joined.
         */
        netbiosName: string;
        selfManagedActiveDirectoryConfigurations: outputs.fsx.GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration[];
    }
    interface GetOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration {
        /**
         * A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
         */
        dnsIps: string[];
        /**
         * The fully qualified domain name of the self-managed AD directory.
         */
        domainName: string;
        /**
         * The name of the domain group whose members have administrative privileges for the FSx file system.
         */
        fileSystemAdministratorsGroup: string;
        /**
         * The fully qualified distinguished name of the organizational unit within the self-managed AD directory to which the Windows File Server or ONTAP storage virtual machine (SVM) instance is joined.
         */
        organizationalUnitDistinguishedName: string;
        /**
         * The user name for the service account on your self-managed AD domain that FSx uses to join to your AD domain.
         */
        username: string;
    }
    interface GetOntapStorageVirtualMachineEndpoint {
        iscsis: outputs.fsx.GetOntapStorageVirtualMachineEndpointIscsi[];
        /**
         * An endpoint for managing SVMs using the NetApp ONTAP CLI, NetApp ONTAP API, or NetApp CloudManager. See SVM Endpoint below.
         */
        managements: outputs.fsx.GetOntapStorageVirtualMachineEndpointManagement[];
        /**
         * An endpoint for connecting using the Network File System (NFS) protocol. See SVM Endpoint below.
         */
        nfs: outputs.fsx.GetOntapStorageVirtualMachineEndpointNf[];
        /**
         * An endpoint for connecting using the Server Message Block (SMB) protocol. See SVM Endpoint below.
         */
        smbs: outputs.fsx.GetOntapStorageVirtualMachineEndpointSmb[];
    }
    interface GetOntapStorageVirtualMachineEndpointIscsi {
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapStorageVirtualMachineEndpointManagement {
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapStorageVirtualMachineEndpointNf {
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapStorageVirtualMachineEndpointSmb {
        dnsName: string;
        ipAddresses: string[];
    }
    interface GetOntapStorageVirtualMachineFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/fsx/latest/APIReference/API_StorageVirtualMachineFilter.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An SVM will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetOntapStorageVirtualMachineLifecycleTransitionReason {
        /**
         * A detailed message.
         */
        message: string;
    }
    interface GetOntapStorageVirtualMachinesFilter {
        /**
         * Name of the field to filter by, as defined by [the underlying AWS API](https://docs.aws.amazon.com/fsx/latest/APIReference/API_StorageVirtualMachineFilter.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field. An SVM will be selected if any one of the given values matches.
         */
        values: string[];
    }
    interface GetOpenZfsSnapshotFilter {
        /**
         * Name of the snapshot.
         */
        name: string;
        values: string[];
    }
    interface GetWindowsFileSystemAuditLogConfiguration {
        auditLogDestination: string;
        fileAccessAuditLogLevel: string;
        fileShareAccessAuditLogLevel: string;
    }
    interface GetWindowsFileSystemDiskIopsConfiguration {
        iops: number;
        mode: string;
    }
    interface LustreFileSystemLogConfiguration {
        /**
         * The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs `/aws/fsx/lustre` log group.
         */
        destination: string;
        /**
         * Sets which data repository events are logged by Amazon FSx. Valid values are `WARN_ONLY`, `FAILURE_ONLY`, `ERROR_ONLY`, `WARN_ERROR` and `DISABLED`. Default value is `DISABLED`.
         */
        level?: string;
    }
    interface LustreFileSystemRootSquashConfiguration {
        /**
         * When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the client’s IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
         */
        noSquashNids?: string[];
        /**
         * You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
         */
        rootSquash?: string;
    }
    interface OntapFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
         */
        mode?: string;
    }
    interface OntapFileSystemEndpoint {
        /**
         * An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
         */
        interclusters: outputs.fsx.OntapFileSystemEndpointIntercluster[];
        /**
         * An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
         */
        managements: outputs.fsx.OntapFileSystemEndpointManagement[];
    }
    interface OntapFileSystemEndpointIntercluster {
        /**
         * The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the file system endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapFileSystemEndpointManagement {
        /**
         * The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the file system endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapStorageVirtualMachineActiveDirectoryConfiguration {
        /**
         * The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
         */
        netbiosName?: string;
        selfManagedActiveDirectoryConfiguration?: outputs.fsx.OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration;
    }
    interface OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration {
        dnsIps: string[];
        domainName: string;
        fileSystemAdministratorsGroup?: string;
        organizationalUnitDistinguishedName?: string;
        password: string;
        username: string;
    }
    interface OntapStorageVirtualMachineEndpoint {
        /**
         * An endpoint for accessing data on your storage virtual machine via iSCSI protocol. See Endpoint.
         */
        iscsis: outputs.fsx.OntapStorageVirtualMachineEndpointIscsi[];
        /**
         * An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
         */
        managements: outputs.fsx.OntapStorageVirtualMachineEndpointManagement[];
        /**
         * An endpoint for accessing data on your storage virtual machine via NFS protocol. See Endpoint.
         */
        nfs: outputs.fsx.OntapStorageVirtualMachineEndpointNf[];
        /**
         * An endpoint for accessing data on your storage virtual machine via SMB protocol. This is only set if an activeDirectoryConfiguration has been set. See Endpoint.
         */
        smbs: outputs.fsx.OntapStorageVirtualMachineEndpointSmb[];
    }
    interface OntapStorageVirtualMachineEndpointIscsi {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapStorageVirtualMachineEndpointManagement {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapStorageVirtualMachineEndpointNf {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapStorageVirtualMachineEndpointSmb {
        /**
         * The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
         */
        dnsName: string;
        /**
         * IP addresses of the storage virtual machine endpoint.
         */
        ipAddresses: string[];
    }
    interface OntapVolumeAggregateConfiguration {
        /**
         * Used to specify the names of the aggregates on which the volume will be created. Each aggregate needs to be in the format aggrX where X is the number of the aggregate.
         */
        aggregates: string[];
        /**
         * Used to explicitly set the number of constituents within the FlexGroup per storage aggregate. the default value is `8`.
         */
        constituentsPerAggregate: number;
        /**
         * The total amount of constituents for a `FLEXGROUP` volume. This would equal constituentsPerAggregate x aggregates.
         */
        totalConstituents: number;
    }
    interface OntapVolumeSnaplockConfiguration {
        /**
         * Enables or disables the audit log volume for an FSx for ONTAP SnapLock volume. The default value is `false`.
         */
        auditLogVolume?: boolean;
        /**
         * The configuration object for setting the autocommit period of files in an FSx for ONTAP SnapLock volume. See Autocommit Period below.
         */
        autocommitPeriod: outputs.fsx.OntapVolumeSnaplockConfigurationAutocommitPeriod;
        /**
         * Enables, disables, or permanently disables privileged delete on an FSx for ONTAP SnapLock Enterprise volume. Valid values: `DISABLED`, `ENABLED`, `PERMANENTLY_DISABLED`. The default value is `DISABLED`.
         */
        privilegedDelete?: string;
        /**
         * The retention period of an FSx for ONTAP SnapLock volume. See SnapLock Retention Period below.
         */
        retentionPeriod: outputs.fsx.OntapVolumeSnaplockConfigurationRetentionPeriod;
        /**
         * Specifies the retention mode of an FSx for ONTAP SnapLock volume. After it is set, it can't be changed. Valid values: `COMPLIANCE`, `ENTERPRISE`.
         */
        snaplockType: string;
        /**
         * Enables or disables volume-append mode on an FSx for ONTAP SnapLock volume. The default value is `false`.
         */
        volumeAppendModeEnabled?: boolean;
    }
    interface OntapVolumeSnaplockConfigurationAutocommitPeriod {
        /**
         * The type of time for the autocommit period of a file in an FSx for ONTAP SnapLock volume. Setting this value to `NONE` disables autocommit. Valid values: `MINUTES`, `HOURS`, `DAYS`, `MONTHS`, `YEARS`, `NONE`.
         */
        type: string;
        /**
         * The amount of time for the autocommit period of a file in an FSx for ONTAP SnapLock volume.
         */
        value?: number;
    }
    interface OntapVolumeSnaplockConfigurationRetentionPeriod {
        defaultRetention: outputs.fsx.OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention;
        maximumRetention: outputs.fsx.OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention;
        minimumRetention: outputs.fsx.OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention;
    }
    interface OntapVolumeSnaplockConfigurationRetentionPeriodDefaultRetention {
        type: string;
        value?: number;
    }
    interface OntapVolumeSnaplockConfigurationRetentionPeriodMaximumRetention {
        type: string;
        value?: number;
    }
    interface OntapVolumeSnaplockConfigurationRetentionPeriodMinimumRetention {
        type: string;
        value?: number;
    }
    interface OntapVolumeTieringPolicy {
        /**
         * Specifies the number of days that user data in a volume must remain inactive before it is considered "cold" and moved to the capacity pool. Used with `AUTO` and `SNAPSHOT_ONLY` tiering policies only. Valid values are whole numbers between 2 and 183. Default values are 31 days for `AUTO` and 2 days for `SNAPSHOT_ONLY`.
         */
        coolingPeriod: number;
        /**
         * Specifies the tiering policy for the ONTAP volume for moving data to the capacity pool storage. Valid values are `SNAPSHOT_ONLY`, `AUTO`, `ALL`, `NONE`. Default value is `SNAPSHOT_ONLY`.
         */
        name: string;
    }
    interface OpenZfsFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
         */
        mode?: string;
    }
    interface OpenZfsFileSystemRootVolumeConfiguration {
        /**
         * A boolean flag indicating whether tags for the file system should be copied to snapshots. The default value is false.
         */
        copyTagsToSnapshots?: boolean;
        /**
         * Method used to compress the data on the volume. Valid values are `LZ4`, `NONE` or `ZSTD`. Child volumes that don't specify compression option will inherit from parent volume. This option on file system applies to the root volume.
         */
        dataCompressionType?: string;
        /**
         * NFS export configuration for the root volume. Exactly 1 item. See NFS Exports Below.
         */
        nfsExports?: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationNfsExports;
        /**
         * specifies whether the volume is read-only. Default is false.
         */
        readOnly: boolean;
        /**
         * Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are `4`, `8`, `16`, `32`, `64`, `128`, `256`, `512`, or `1024` KiB. The default is `128` KiB.
         */
        recordSizeKib?: number;
        /**
         * Specify how much storage users or groups can use on the volume. Maximum of 100 items. See User and Group Quotas Below.
         */
        userAndGroupQuotas: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota[];
    }
    interface OpenZfsFileSystemRootVolumeConfigurationNfsExports {
        /**
         * A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
         */
        clientConfigurations: outputs.fsx.OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration[];
    }
    interface OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration {
        /**
         * A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
         */
        clients: string;
        /**
         * The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
         */
        options: string[];
    }
    interface OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota {
        /**
         * The ID of the user or group. Valid values between `0` and `2147483647`
         */
        id: number;
        /**
         * The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
         */
        storageCapacityQuotaGib: number;
        /**
         * A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
         */
        type: string;
    }
    interface OpenZfsVolumeNfsExports {
        /**
         * A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See `clientConfigurations` Block below for details.
         */
        clientConfigurations: outputs.fsx.OpenZfsVolumeNfsExportsClientConfiguration[];
    }
    interface OpenZfsVolumeNfsExportsClientConfiguration {
        /**
         * A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
         */
        clients: string;
        /**
         * The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
         */
        options: string[];
    }
    interface OpenZfsVolumeOriginSnapshot {
        /**
         * Specifies the strategy used when copying data from the snapshot to the new volume. Valid values are `CLONE`, `FULL_COPY`, `INCREMENTAL_COPY`.
         */
        copyStrategy: string;
        /**
         * The Amazon Resource Name (ARN) of the origin snapshot.
         */
        snapshotArn: string;
    }
    interface OpenZfsVolumeUserAndGroupQuota {
        /**
         * The ID of the user or group. Valid values between `0` and `2147483647`
         */
        id: number;
        /**
         * The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
         * * `Type` - (Required) - A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
         */
        storageCapacityQuotaGib: number;
        type: string;
    }
    interface WindowsFileSystemAuditLogConfiguration {
        /**
         * The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when `fileAccessAuditLogLevel` and `fileShareAccessAuditLogLevel` are not set to `DISABLED`. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the `aws-fsx` prefix. If you do not provide a destination in `auditLogDestionation`, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
         */
        auditLogDestination: string;
        /**
         * Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
         */
        fileAccessAuditLogLevel?: string;
        /**
         * Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
         */
        fileShareAccessAuditLogLevel?: string;
    }
    interface WindowsFileSystemDiskIopsConfiguration {
        /**
         * The total number of SSD IOPS provisioned for the file system.
         */
        iops: number;
        /**
         * Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
         */
        mode?: string;
    }
    interface WindowsFileSystemSelfManagedActiveDirectory {
        /**
         * A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in [RFC 1918](https://tools.ietf.org/html/rfc1918).
         */
        dnsIps: string[];
        /**
         * The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
         */
        domainName: string;
        /**
         * The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
         */
        fileSystemAdministratorsGroup?: string;
        /**
         * The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
         */
        organizationalUnitDistinguishedName?: string;
        /**
         * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        password: string;
        /**
         * The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
         */
        username: string;
    }
}
export declare namespace gamelift {
    interface AliasRoutingStrategy {
        /**
         * ID of the GameLift Fleet to point the alias to.
         */
        fleetId?: string;
        /**
         * Message text to be used with the `TERMINAL` routing strategy.
         */
        message?: string;
        /**
         * Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
         */
        type: string;
    }
    interface BuildStorageLocation {
        /**
         * Name of your S3 bucket.
         */
        bucket: string;
        /**
         * Name of the zip file containing your build files.
         */
        key: string;
        /**
         * A specific version of the file. If not set, the latest version of the file is retrieved.
         */
        objectVersion?: string;
        /**
         * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
         */
        roleArn: string;
    }
    interface FleetCertificateConfiguration {
        /**
         * Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
         */
        certificateType?: string;
    }
    interface FleetEc2InboundPermission {
        /**
         * Starting value for a range of allowed port numbers.
         */
        fromPort: number;
        /**
         * Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
         */
        ipRange: string;
        /**
         * Network communication protocol used by the fleetE.g., `TCP` or `UDP`
         */
        protocol: string;
        /**
         * Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
         */
        toPort: number;
    }
    interface FleetResourceCreationLimitPolicy {
        /**
         * Maximum number of game sessions that an individual can create during the policy period.
         */
        newGameSessionsPerCreator?: number;
        /**
         * Time span used in evaluating the resource creation limit policy.
         */
        policyPeriodInMinutes?: number;
    }
    interface FleetRuntimeConfiguration {
        /**
         * Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
         */
        gameSessionActivationTimeoutSeconds?: number;
        /**
         * Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
         */
        maxConcurrentGameSessionActivations?: number;
        /**
         * Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
         */
        serverProcesses?: outputs.gamelift.FleetRuntimeConfigurationServerProcess[];
    }
    interface FleetRuntimeConfigurationServerProcess {
        /**
         * Number of server processes using this configuration to run concurrently on an instance.
         */
        concurrentExecutions: number;
        /**
         * Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
         */
        launchPath: string;
        /**
         * Optional list of parameters to pass to the server executable on launch.
         */
        parameters?: string;
    }
    interface GameServerGroupAutoScalingPolicy {
        /**
         * Length of time, in seconds, it takes for a new instance to start
         * new game server processes and register with GameLift FleetIQ.
         * Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
         * because it avoids prematurely starting new instances. Defaults to `60`.
         */
        estimatedInstanceWarmup: number;
        targetTrackingConfiguration: outputs.gamelift.GameServerGroupAutoScalingPolicyTargetTrackingConfiguration;
    }
    interface GameServerGroupAutoScalingPolicyTargetTrackingConfiguration {
        /**
         * Desired value to use with a game server group target-based scaling policy.
         */
        targetValue: number;
    }
    interface GameServerGroupInstanceDefinition {
        /**
         * An EC2 instance type.
         */
        instanceType: string;
        /**
         * Instance weighting that indicates how much this instance type contributes
         * to the total capacity of a game server group.
         * Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
         * the most cost-effective options.
         */
        weightedCapacity?: string;
    }
    interface GameServerGroupLaunchTemplate {
        /**
         * A unique identifier for an existing EC2 launch template.
         */
        id: string;
        /**
         * A readable identifier for an existing EC2 launch template.
         */
        name: string;
        /**
         * The version of the EC2 launch template to use. If none is set, the default is the first version created.
         */
        version?: string;
    }
    interface GameSessionQueuePlayerLatencyPolicy {
        /**
         * Maximum latency value that is allowed for any player.
         */
        maximumIndividualPlayerLatencyMilliseconds: number;
        /**
         * Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
         */
        policyDurationSeconds?: number;
    }
    interface MatchmakingConfigurationGameProperty {
        /**
         * A game property key
         */
        key: string;
        /**
         * A game property value.
         */
        value: string;
    }
    interface ScriptStorageLocation {
        /**
         * Name of your S3 bucket.
         */
        bucket: string;
        /**
         * Name of the zip file containing your script files.
         */
        key: string;
        /**
         * A specific version of the file. If not set, the latest version of the file is retrieved.
         */
        objectVersion?: string;
        /**
         * ARN of the access role that allows Amazon GameLift to access your S3 bucket.
         */
        roleArn: string;
    }
}
export declare namespace glacier {
    interface VaultNotification {
        /**
         * You can configure a vault to publish a notification for `ArchiveRetrievalCompleted` and `InventoryRetrievalCompleted` events.
         */
        events: string[];
        /**
         * The SNS Topic ARN.
         */
        snsTopic: string;
    }
}
export declare namespace globalaccelerator {
    interface AcceleratorAttributes {
        /**
         * Indicates whether flow logs are enabled. Defaults to `false`. Valid values: `true`, `false`.
         */
        flowLogsEnabled?: boolean;
        /**
         * The name of the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Bucket?: string;
        /**
         * The prefix for the location in the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Prefix?: string;
    }
    interface AcceleratorIpSet {
        /**
         * The IP addresses to use for BYOIP accelerators. If not specified, the service assigns IP addresses. Valid values: 1 or 2 IPv4 addresses.
         */
        ipAddresses: string[];
        /**
         * The type of IP addresses included in this IP set.
         */
        ipFamily: string;
    }
    interface CrossAccountAttachmentResource {
        /**
         * The endpoint ID for the endpoint that is specified as a AWS resource.
         */
        endpointId?: string;
        /**
         * The AWS Region where a shared endpoint resource is located.
         */
        region?: string;
    }
    interface CustomRoutingAcceleratorAttributes {
        /**
         * Indicates whether flow logs are enabled. Defaults to `false`. Valid values: `true`, `false`.
         */
        flowLogsEnabled?: boolean;
        /**
         * The name of the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Bucket?: string;
        /**
         * The prefix for the location in the Amazon S3 bucket for the flow logs. Required if `flowLogsEnabled` is `true`.
         */
        flowLogsS3Prefix?: string;
    }
    interface CustomRoutingAcceleratorIpSet {
        /**
         * The IP addresses to use for BYOIP accelerators. If not specified, the service assigns IP addresses. Valid values: 1 or 2 IPv4 addresses.
         */
        ipAddresses: string[];
        /**
         * The type of IP addresses included in this IP set.
         */
        ipFamily: string;
    }
    interface CustomRoutingEndpointGroupDestinationConfiguration {
        /**
         * The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
         */
        fromPort: number;
        /**
         * The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either `"TCP"` or `"UDP"`.
         */
        protocols: string[];
        /**
         * The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
         */
        toPort: number;
    }
    interface CustomRoutingEndpointGroupEndpointConfiguration {
        /**
         * An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
         */
        endpointId?: string;
    }
    interface CustomRoutingListenerPortRange {
        /**
         * The first port in the range of ports, inclusive.
         */
        fromPort?: number;
        /**
         * The last port in the range of ports, inclusive.
         */
        toPort?: number;
    }
    interface EndpointGroupEndpointConfiguration {
        /**
         * Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint. See the [AWS documentation](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) for more details. The default value is `false`.
         * **Note:** When client IP address preservation is enabled, the Global Accelerator service creates an EC2 Security Group in the VPC named `GlobalAccelerator` that must be deleted (potentially outside of the provider) before the VPC will successfully delete. If this EC2 Security Group is not deleted, the provider will retry the VPC deletion for a few minutes before reporting a `DependencyViolation` error. This cannot be resolved by re-running the provider.
         */
        clientIpPreservationEnabled: boolean;
        /**
         * An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID.
         */
        endpointId?: string;
        /**
         * The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic based on proportions that you specify.
         */
        weight?: number;
    }
    interface EndpointGroupPortOverride {
        /**
         * The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
         */
        endpointPort: number;
        /**
         * The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
         */
        listenerPort: number;
    }
    interface GetAcceleratorAttribute {
        flowLogsEnabled: boolean;
        flowLogsS3Bucket: string;
        flowLogsS3Prefix: string;
    }
    interface GetAcceleratorIpSet {
        ipAddresses: string[];
        ipFamily: string;
    }
    interface GetCustomRoutingAcceleratorAttribute {
        flowLogsEnabled: boolean;
        flowLogsS3Bucket: string;
        flowLogsS3Prefix: string;
    }
    interface GetCustomRoutingAcceleratorIpSet {
        ipAddresses: string[];
        ipFamily: string;
    }
    interface ListenerPortRange {
        /**
         * The first port in the range of ports, inclusive.
         */
        fromPort?: number;
        /**
         * The last port in the range of ports, inclusive.
         */
        toPort?: number;
    }
}
export declare namespace glue {
    interface CatalogDatabaseCreateTableDefaultPermission {
        /**
         * The permissions that are granted to the principal.
         */
        permissions?: string[];
        /**
         * The principal who is granted permissions.. See `principal` below.
         */
        principal?: outputs.glue.CatalogDatabaseCreateTableDefaultPermissionPrincipal;
    }
    interface CatalogDatabaseCreateTableDefaultPermissionPrincipal {
        /**
         * An identifier for the Lake Formation principal.
         */
        dataLakePrincipalIdentifier?: string;
    }
    interface CatalogDatabaseFederatedDatabase {
        /**
         * Name of the connection to the external metastore.
         */
        connectionName?: string;
        /**
         * Unique identifier for the federated database.
         */
        identifier?: string;
    }
    interface CatalogDatabaseTargetDatabase {
        /**
         * ID of the Data Catalog in which the database resides.
         */
        catalogId: string;
        /**
         * Name of the catalog database.
         */
        databaseName: string;
        /**
         * Region of the target database.
         */
        region?: string;
    }
    interface CatalogTableOpenTableFormatInput {
        /**
         * Configuration block for iceberg table config. See `icebergInput` below.
         */
        icebergInput: outputs.glue.CatalogTableOpenTableFormatInputIcebergInput;
    }
    interface CatalogTableOpenTableFormatInputIcebergInput {
        /**
         * A required metadata operation. Can only be set to CREATE.
         */
        metadataOperation: string;
        /**
         * The table version for the Iceberg table. Defaults to 2.
         */
        version?: string;
    }
    interface CatalogTablePartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys: string[];
    }
    interface CatalogTablePartitionKey {
        /**
         * Free-form text comment.
         */
        comment?: string;
        /**
         * Name of the Partition Key.
         */
        name: string;
        /**
         * Datatype of data in the Partition Key.
         */
        type?: string;
    }
    interface CatalogTableStorageDescriptor {
        /**
         * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns?: string[];
        /**
         * Configuration block for columns in the table. See `columns` below.
         */
        columns: outputs.glue.CatalogTableStorageDescriptorColumn[];
        /**
         * Whether the data in the table is compressed.
         */
        compressed?: boolean;
        /**
         * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat?: string;
        /**
         * Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location?: string;
        /**
         * Must be specified if the table contains any dimension columns.
         */
        numberOfBuckets?: number;
        /**
         * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat?: string;
        /**
         * User-supplied properties in key-value form.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
         */
        schemaReference?: outputs.glue.CatalogTableStorageDescriptorSchemaReference;
        /**
         * Configuration block for serialization and deserialization ("SerDe") information. See `serDeInfo` below.
         */
        serDeInfo?: outputs.glue.CatalogTableStorageDescriptorSerDeInfo;
        /**
         * Configuration block with information about values that appear very frequently in a column (skewed values). See `skewedInfo` below.
         */
        skewedInfo?: outputs.glue.CatalogTableStorageDescriptorSkewedInfo;
        /**
         * Configuration block for the sort order of each bucket in the table. See `sortColumns` below.
         */
        sortColumns?: outputs.glue.CatalogTableStorageDescriptorSortColumn[];
        /**
         * Whether the table data is stored in subdirectories.
         */
        storedAsSubDirectories?: boolean;
    }
    interface CatalogTableStorageDescriptorColumn {
        /**
         * Free-form text comment.
         */
        comment?: string;
        /**
         * Name of the Column.
         */
        name: string;
        /**
         * Key-value pairs defining properties associated with the column.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Datatype of data in the Column.
         */
        type?: string;
    }
    interface CatalogTableStorageDescriptorSchemaReference {
        /**
         * Configuration block that contains schema identity fields. Either this or the `schemaVersionId` has to be provided. See `schemaId` below.
         */
        schemaId?: outputs.glue.CatalogTableStorageDescriptorSchemaReferenceSchemaId;
        /**
         * Unique ID assigned to a version of the schema. Either this or the `schemaId` has to be provided.
         */
        schemaVersionId?: string;
        /**
         * Version number of the schema.
         */
        schemaVersionNumber: number;
    }
    interface CatalogTableStorageDescriptorSchemaReferenceSchemaId {
        /**
         * Name of the schema registry that contains the schema. Must be provided when `schemaName` is specified and conflicts with `schemaArn`.
         */
        registryName?: string;
        /**
         * ARN of the schema. One of `schemaArn` or `schemaName` has to be provided.
         */
        schemaArn?: string;
        /**
         * Name of the schema. One of `schemaArn` or `schemaName` has to be provided.
         */
        schemaName?: string;
    }
    interface CatalogTableStorageDescriptorSerDeInfo {
        /**
         * Name of the SerDe.
         */
        name?: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
         */
        serializationLibrary?: string;
    }
    interface CatalogTableStorageDescriptorSkewedInfo {
        /**
         * List of names of columns that contain skewed values.
         */
        skewedColumnNames?: string[];
        /**
         * List of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps?: {
            [key: string]: string;
        };
        /**
         * Map of skewed values to the columns that contain them.
         */
        skewedColumnValues?: string[];
    }
    interface CatalogTableStorageDescriptorSortColumn {
        /**
         * Name of the column.
         */
        column: string;
        /**
         * Whether the column is sorted in ascending (`1`) or descending order (`0`).
         */
        sortOrder: number;
    }
    interface CatalogTableTargetTable {
        /**
         * ID of the Data Catalog in which the table resides.
         */
        catalogId: string;
        /**
         * Name of the catalog database that contains the target table.
         */
        databaseName: string;
        /**
         * Name of the target table.
         */
        name: string;
        /**
         * Region of the target table.
         */
        region?: string;
    }
    interface ClassifierCsvClassifier {
        /**
         * Enables the processing of files that contain only one column.
         */
        allowSingleColumn?: boolean;
        /**
         * Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
         */
        containsHeader?: string;
        /**
         * Enables the custom datatype to be configured.
         */
        customDatatypeConfigured?: boolean;
        /**
         * A list of supported custom datatypes. Valid values are `BINARY`, `BOOLEAN`, `DATE`, `DECIMAL`, `DOUBLE`, `FLOAT`, `INT`, `LONG`, `SHORT`, `STRING`, `TIMESTAMP`.
         */
        customDatatypes?: string[];
        /**
         * The delimiter used in the Csv to separate columns.
         */
        delimiter?: string;
        /**
         * Specifies whether to trim column values.
         */
        disableValueTrimming?: boolean;
        /**
         * A list of strings representing column names.
         */
        headers?: string[];
        /**
         * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
         */
        quoteSymbol?: string;
        serde: string;
    }
    interface ClassifierGrokClassifier {
        /**
         * An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
         */
        classification: string;
        /**
         * Custom grok patterns used by this classifier.
         */
        customPatterns?: string;
        /**
         * The grok pattern used by this classifier.
         */
        grokPattern: string;
    }
    interface ClassifierJsonClassifier {
        /**
         * A `JsonPath` string defining the JSON data for the classifier to classify. AWS Glue supports a subset of `JsonPath`, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
         */
        jsonPath: string;
    }
    interface ClassifierXmlClassifier {
        /**
         * An identifier of the data format that the classifier matches.
         */
        classification: string;
        /**
         * The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by `/>`). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, `<row item_a="A" item_b="B"></row>` is okay, but `<row item_a="A" item_b="B" />` is not).
         */
        rowTag: string;
    }
    interface ConnectionPhysicalConnectionRequirements {
        /**
         * The availability zone of the connection. This field is redundant and implied by `subnetId`, but is currently an api requirement.
         */
        availabilityZone?: string;
        /**
         * The security group ID list used by the connection.
         */
        securityGroupIdLists?: string[];
        /**
         * The subnet ID used by the connection.
         */
        subnetId?: string;
    }
    interface CrawlerCatalogTarget {
        /**
         * The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a `NETWORK` Connection type.
         */
        connectionName?: string;
        /**
         * The name of the Glue database to be synchronized.
         */
        databaseName: string;
        /**
         * A valid Amazon SQS ARN.
         *
         * > **Note:** `deletionBehavior` of catalog target doesn't support `DEPRECATE_IN_DATABASE`.
         *
         * > **Note:** `configuration` for catalog target crawlers will have `{ ... "Grouping": { "TableGroupingPolicy": "CombineCompatibleSchemas"} }` by default.
         */
        dlqEventQueueArn?: string;
        /**
         * A valid Amazon SQS ARN.
         */
        eventQueueArn?: string;
        /**
         * A list of catalog tables to be synchronized.
         */
        tables: string[];
    }
    interface CrawlerDeltaTarget {
        /**
         * The name of the connection to use to connect to the Delta table target.
         */
        connectionName?: string;
        /**
         * Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
         */
        createNativeDeltaTable?: boolean;
        /**
         * A list of the Amazon S3 paths to the Delta tables.
         */
        deltaTables: string[];
        /**
         * Specifies whether to write the manifest files to the Delta table path.
         */
        writeManifest: boolean;
    }
    interface CrawlerDynamodbTarget {
        /**
         * The name of the DynamoDB table to crawl.
         */
        path: string;
        /**
         * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to `true`.
         */
        scanAll?: boolean;
        /**
         * The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
         */
        scanRate?: number;
    }
    interface CrawlerHudiTarget {
        /**
         * The name of the connection to use to connect to the Hudi target.
         */
        connectionName?: string;
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
         */
        maximumTraversalDepth: number;
        /**
         * One or more Amazon S3 paths that contains Hudi metadata folders as s3://bucket/prefix.
         */
        paths: string[];
    }
    interface CrawlerIcebergTarget {
        /**
         * The name of the connection to use to connect to the Iceberg target.
         */
        connectionName?: string;
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time. Valid values are between `1` and `20`.
         */
        maximumTraversalDepth: number;
        /**
         * One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
         */
        paths: string[];
    }
    interface CrawlerJdbcTarget {
        /**
         * The name of the connection to use to connect to the JDBC target.
         */
        connectionName: string;
        /**
         * Specify a value of `RAWTYPES` or `COMMENTS` to enable additional metadata intable responses. `RAWTYPES` provides the native-level datatype. `COMMENTS` provides comments associated with a column or table in the database.
         */
        enableAdditionalMetadatas?: string[];
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The path of the JDBC target.
         */
        path: string;
    }
    interface CrawlerLakeFormationConfiguration {
        /**
         * Required for cross account crawls. For same account crawls as the target data, this can omitted.
         */
        accountId: string;
        /**
         * Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
         */
        useLakeFormationCredentials?: boolean;
    }
    interface CrawlerLineageConfiguration {
        /**
         * Specifies whether data lineage is enabled for the crawler. Valid values are: `ENABLE` and `DISABLE`. Default value is `DISABLE`.
         */
        crawlerLineageSettings?: string;
    }
    interface CrawlerMongodbTarget {
        /**
         * The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
         */
        connectionName: string;
        /**
         * The path of the Amazon DocumentDB or MongoDB target (database/collection).
         */
        path: string;
        /**
         * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. Default value is `true`.
         */
        scanAll?: boolean;
    }
    interface CrawlerRecrawlPolicy {
        /**
         * Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: `CRAWL_EVENT_MODE`, `CRAWL_EVERYTHING` and `CRAWL_NEW_FOLDERS_ONLY`. Default value is `CRAWL_EVERYTHING`.
         */
        recrawlBehavior?: string;
    }
    interface CrawlerS3Target {
        /**
         * The name of a connection which allows crawler to access data in S3 within a VPC.
         */
        connectionName?: string;
        /**
         * The ARN of the dead-letter SQS queue.
         */
        dlqEventQueueArn?: string;
        /**
         * The ARN of the SQS queue to receive S3 notifications from.
         */
        eventQueueArn?: string;
        /**
         * A list of glob patterns used to exclude from the crawl.
         */
        exclusions?: string[];
        /**
         * The path to the Amazon S3 target.
         */
        path: string;
        /**
         * Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
         */
        sampleSize?: number;
    }
    interface CrawlerSchemaChangePolicy {
        /**
         * The deletion behavior when the crawler finds a deleted object. Valid values: `LOG`, `DELETE_FROM_DATABASE`, or `DEPRECATE_IN_DATABASE`. Defaults to `DEPRECATE_IN_DATABASE`.
         */
        deleteBehavior?: string;
        /**
         * The update behavior when the crawler finds a changed schema. Valid values: `LOG` or `UPDATE_IN_DATABASE`. Defaults to `UPDATE_IN_DATABASE`.
         */
        updateBehavior?: string;
    }
    interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettings {
        /**
         * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
         */
        connectionPasswordEncryption: outputs.glue.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption;
        /**
         * Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
         */
        encryptionAtRest: outputs.glue.DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest;
    }
    interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsConnectionPasswordEncryption {
        /**
         * A KMS key ARN that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least `kms:Encrypt` permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.
         */
        awsKmsKeyId?: string;
        /**
         * When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
         */
        returnConnectionPasswordEncrypted: boolean;
    }
    interface DataCatalogEncryptionSettingsDataCatalogEncryptionSettingsEncryptionAtRest {
        /**
         * The encryption-at-rest mode for encrypting Data Catalog data. Valid values: `DISABLED`, `SSE-KMS`, `SSE-KMS-WITH-SERVICE-ROLE`.
         */
        catalogEncryptionMode: string;
        /**
         * The ARN of the AWS IAM role used for accessing encrypted Data Catalog data.
         */
        catalogEncryptionServiceRole?: string;
        /**
         * The ARN of the AWS KMS key to use for encryption at rest.
         */
        sseAwsKmsKeyId?: string;
    }
    interface DataQualityRulesetTargetTable {
        /**
         * The catalog id where the AWS Glue table exists.
         */
        catalogId?: string;
        /**
         * Name of the database where the AWS Glue table exists.
         */
        databaseName: string;
        /**
         * Name of the AWS Glue table.
         */
        tableName: string;
    }
    interface GetCatalogTablePartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys: string[];
    }
    interface GetCatalogTablePartitionKey {
        /**
         * Free-form text comment.
         */
        comment: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Datatype of data in the Column.
         */
        type: string;
    }
    interface GetCatalogTableStorageDescriptor {
        /**
         * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns: string[];
        /**
         * Configuration block for columns in the table. See `columns` below.
         */
        columns: outputs.glue.GetCatalogTableStorageDescriptorColumn[];
        /**
         * Whether the data in the table is compressed.
         */
        compressed: boolean;
        /**
         * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat: string;
        /**
         * Physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location: string;
        /**
         * Is if the table contains any dimension columns.
         */
        numberOfBuckets: number;
        /**
         * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {
            [key: string]: string;
        };
        /**
         * Object that references a schema stored in the AWS Glue Schema Registry. See `schemaReference` below.
         */
        schemaReferences: outputs.glue.GetCatalogTableStorageDescriptorSchemaReference[];
        /**
         * Configuration block for serialization and deserialization ("SerDe") information. See `serDeInfo` below.
         */
        serDeInfos: outputs.glue.GetCatalogTableStorageDescriptorSerDeInfo[];
        /**
         * Configuration block with information about values that appear very frequently in a column (skewed values). See `skewedInfo` below.
         */
        skewedInfos: outputs.glue.GetCatalogTableStorageDescriptorSkewedInfo[];
        /**
         * Configuration block for the sort order of each bucket in the table. See `sortColumns` below.
         */
        sortColumns: outputs.glue.GetCatalogTableStorageDescriptorSortColumn[];
        /**
         * Whether the table data is stored in subdirectories.
         */
        storedAsSubDirectories: boolean;
    }
    interface GetCatalogTableStorageDescriptorColumn {
        /**
         * Free-form text comment.
         */
        comment: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {
            [key: string]: string;
        };
        /**
         * Datatype of data in the Column.
         */
        type: string;
    }
    interface GetCatalogTableStorageDescriptorSchemaReference {
        /**
         * Configuration block that contains schema identity fields. See `schemaId` below.
         */
        schemaIds: outputs.glue.GetCatalogTableStorageDescriptorSchemaReferenceSchemaId[];
        /**
         * Unique ID assigned to a version of the schema.
         */
        schemaVersionId: string;
        /**
         * Version number of the schema.
         */
        schemaVersionNumber: number;
    }
    interface GetCatalogTableStorageDescriptorSchemaReferenceSchemaId {
        /**
         * Name of the schema registry that contains the schema.
         */
        registryName: string;
        /**
         * ARN of the schema.
         */
        schemaArn: string;
        /**
         * Name of the schema.
         */
        schemaName: string;
    }
    interface GetCatalogTableStorageDescriptorSerDeInfo {
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Map of initialization parameters for the SerDe, in key-value form.
         */
        parameters: {
            [key: string]: string;
        };
        /**
         * Usually the class that implements the SerDe. An example is `org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`.
         */
        serializationLibrary: string;
    }
    interface GetCatalogTableStorageDescriptorSkewedInfo {
        /**
         * List of names of columns that contain skewed values.
         */
        skewedColumnNames: string[];
        /**
         * List of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps: {
            [key: string]: string;
        };
        /**
         * Map of skewed values to the columns that contain them.
         */
        skewedColumnValues: string[];
    }
    interface GetCatalogTableStorageDescriptorSortColumn {
        /**
         * Name of the column.
         */
        column: string;
        /**
         * Whether the column is sorted in ascending (`1`) or descending order (`0`).
         */
        sortOrder: number;
    }
    interface GetCatalogTableTargetTable {
        /**
         * ID of the Glue Catalog and database where the table metadata resides. If omitted, this defaults to the current AWS Account ID.
         */
        catalogId: string;
        /**
         * Name of the metadata database where the table metadata resides.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Region of the target table.
         */
        region: string;
    }
    interface GetConnectionPhysicalConnectionRequirement {
        availabilityZone: string;
        securityGroupIdLists: string[];
        subnetId: string;
    }
    interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSetting {
        /**
         * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
         */
        connectionPasswordEncryptions: outputs.glue.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryption[];
        /**
         * Encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
         */
        encryptionAtRests: outputs.glue.GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRest[];
    }
    interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingConnectionPasswordEncryption {
        /**
         * KMS key ARN that is used to encrypt the connection password.
         */
        awsKmsKeyId: string;
        /**
         * When set to `true`, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
         */
        returnConnectionPasswordEncrypted: boolean;
    }
    interface GetDataCatalogEncryptionSettingsDataCatalogEncryptionSettingEncryptionAtRest {
        /**
         * The encryption-at-rest mode for encrypting Data Catalog data.
         */
        catalogEncryptionMode: string;
        /**
         * The ARN of the AWS IAM role used for accessing encrypted Data Catalog data.
         */
        catalogEncryptionServiceRole: string;
        /**
         * ARN of the AWS KMS key to use for encryption at rest.
         */
        sseAwsKmsKeyId: string;
    }
    interface GetScriptDagEdge {
        /**
         * ID of the node at which the edge starts.
         */
        source: string;
        /**
         * ID of the node at which the edge ends.
         */
        target: string;
        /**
         * Target of the edge.
         */
        targetParameter?: string;
    }
    interface GetScriptDagNode {
        /**
         * Nested configuration an argument or property of a node. Defined below.
         */
        args: outputs.glue.GetScriptDagNodeArg[];
        /**
         * Node identifier that is unique within the node's graph.
         */
        id: string;
        /**
         * Line number of the node.
         */
        lineNumber?: number;
        /**
         * Type of node this is.
         */
        nodeType: string;
    }
    interface GetScriptDagNodeArg {
        /**
         * Name of the argument or property.
         */
        name: string;
        /**
         * Boolean if the value is used as a parameter. Defaults to `false`.
         */
        param?: boolean;
        /**
         * Value of the argument or property.
         */
        value: string;
    }
    interface JobCommand {
        /**
         * The name of the job command. Defaults to `glueetl`. Use `pythonshell` for Python Shell Job Type, `glueray` for Ray Job Type, or `gluestreaming` for Streaming Job Type. `maxCapacity` needs to be set if `pythonshell` is chosen.
         */
        name?: string;
        /**
         * The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
         */
        pythonVersion: string;
        /**
         * In Ray jobs, runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see [Working with Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/ray-jobs-section.html#author-job-ray-runtimes) in the Glue Developer Guide.
         */
        runtime: string;
        /**
         * Specifies the S3 path to a script that executes a job.
         */
        scriptLocation: string;
    }
    interface JobExecutionProperty {
        /**
         * The maximum number of concurrent runs allowed for a job. The default is 1.
         */
        maxConcurrentRuns?: number;
    }
    interface JobNotificationProperty {
        /**
         * After a job run starts, the number of minutes to wait before sending a job run delay notification.
         */
        notifyDelayAfter?: number;
    }
    interface MLTransformInputRecordTable {
        /**
         * A unique identifier for the AWS Glue Data Catalog.
         */
        catalogId?: string;
        /**
         * The name of the connection to the AWS Glue Data Catalog.
         */
        connectionName?: string;
        /**
         * A database name in the AWS Glue Data Catalog.
         */
        databaseName: string;
        /**
         * A table name in the AWS Glue Data Catalog.
         */
        tableName: string;
    }
    interface MLTransformParameters {
        /**
         * The parameters for the find matches algorithm. see Find Matches Parameters.
         */
        findMatchesParameters: outputs.glue.MLTransformParametersFindMatchesParameters;
        /**
         * The type of machine learning transform. For information about the types of machine learning transforms, see [Creating Machine Learning Transforms](http://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html).
         */
        transformType: string;
    }
    interface MLTransformParametersFindMatchesParameters {
        /**
         * The value that is selected when tuning your transform for a balance between accuracy and cost.
         */
        accuracyCostTradeOff?: number;
        /**
         * The value to switch on or off to force the output to match the provided labels from users.
         */
        enforceProvidedLabels?: boolean;
        /**
         * The value selected when tuning your transform for a balance between precision and recall.
         */
        precisionRecallTradeOff?: number;
        /**
         * The name of a column that uniquely identifies rows in the source table.
         */
        primaryKeyColumnName?: string;
    }
    interface MLTransformSchema {
        /**
         * The type of data in the column.
         */
        dataType: string;
        /**
         * The name you assign to this ML Transform. It must be unique in your account.
         */
        name: string;
    }
    interface PartitionIndexPartitionIndex {
        /**
         * Name of the partition index.
         */
        indexName?: string;
        indexStatus: string;
        /**
         * Keys for the partition index.
         */
        keys?: string[];
    }
    interface PartitionStorageDescriptor {
        /**
         * A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
         */
        bucketColumns?: string[];
        /**
         * A list of the Columns in the table.
         */
        columns?: outputs.glue.PartitionStorageDescriptorColumn[];
        /**
         * True if the data in the table is compressed, or False if not.
         */
        compressed?: boolean;
        /**
         * The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
         */
        inputFormat?: string;
        /**
         * The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
         */
        location?: string;
        /**
         * Must be specified if the table contains any dimension columns.
         */
        numberOfBuckets?: number;
        /**
         * The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
         */
        outputFormat?: string;
        /**
         * User-supplied properties in key-value form.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Serialization/deserialization (SerDe) information.
         */
        serDeInfo?: outputs.glue.PartitionStorageDescriptorSerDeInfo;
        /**
         * Information about values that appear very frequently in a column (skewed values).
         */
        skewedInfo?: outputs.glue.PartitionStorageDescriptorSkewedInfo;
        /**
         * A list of Order objects specifying the sort order of each bucket in the table.
         */
        sortColumns?: outputs.glue.PartitionStorageDescriptorSortColumn[];
        /**
         * True if the table data is stored in subdirectories, or False if not.
         */
        storedAsSubDirectories?: boolean;
    }
    interface PartitionStorageDescriptorColumn {
        comment?: string;
        name: string;
        type?: string;
    }
    interface PartitionStorageDescriptorSerDeInfo {
        /**
         * Name of the SerDe.
         */
        name?: string;
        /**
         * A map of initialization parameters for the SerDe, in key-value form.
         */
        parameters?: {
            [key: string]: string;
        };
        /**
         * Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
         */
        serializationLibrary?: string;
    }
    interface PartitionStorageDescriptorSkewedInfo {
        /**
         * A list of names of columns that contain skewed values.
         */
        skewedColumnNames?: string[];
        /**
         * A list of values that appear so frequently as to be considered skewed.
         */
        skewedColumnValueLocationMaps?: {
            [key: string]: string;
        };
        /**
         * A map of skewed values to the columns that contain them.
         */
        skewedColumnValues?: string[];
    }
    interface PartitionStorageDescriptorSortColumn {
        /**
         * The name of the column.
         */
        column: string;
        /**
         * Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
         */
        sortOrder: number;
    }
    interface SecurityConfigurationEncryptionConfiguration {
        cloudwatchEncryption: outputs.glue.SecurityConfigurationEncryptionConfigurationCloudwatchEncryption;
        jobBookmarksEncryption: outputs.glue.SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption;
        /**
         * A `s3Encryption ` block as described below, which contains encryption configuration for S3 data.
         */
        s3Encryption: outputs.glue.SecurityConfigurationEncryptionConfigurationS3Encryption;
    }
    interface SecurityConfigurationEncryptionConfigurationCloudwatchEncryption {
        /**
         * Encryption mode to use for CloudWatch data. Valid values: `DISABLED`, `SSE-KMS`. Default value: `DISABLED`.
         */
        cloudwatchEncryptionMode?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
    }
    interface SecurityConfigurationEncryptionConfigurationJobBookmarksEncryption {
        /**
         * Encryption mode to use for job bookmarks data. Valid values: `CSE-KMS`, `DISABLED`. Default value: `DISABLED`.
         */
        jobBookmarksEncryptionMode?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
    }
    interface SecurityConfigurationEncryptionConfigurationS3Encryption {
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         */
        kmsKeyArn?: string;
        /**
         * Encryption mode to use for S3 data. Valid values: `DISABLED`, `SSE-KMS`, `SSE-S3`. Default value: `DISABLED`.
         */
        s3EncryptionMode?: string;
    }
    interface TriggerAction {
        /**
         * Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
         */
        arguments?: {
            [key: string]: string;
        };
        /**
         * The name of the crawler to be executed. Conflicts with `jobName`.
         */
        crawlerName?: string;
        /**
         * The name of a job to be executed. Conflicts with `crawlerName`.
         */
        jobName?: string;
        /**
         * Specifies configuration properties of a job run notification. See Notification Property details below.
         */
        notificationProperty?: outputs.glue.TriggerActionNotificationProperty;
        /**
         * The name of the Security Configuration structure to be used with this action.
         */
        securityConfiguration?: string;
        /**
         * The job run timeout in minutes. It overrides the timeout value of the job.
         */
        timeout?: number;
    }
    interface TriggerActionNotificationProperty {
        /**
         * After a job run starts, the number of minutes to wait before sending a job run delay notification.
         */
        notifyDelayAfter?: number;
    }
    interface TriggerEventBatchingCondition {
        /**
         * Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
         */
        batchSize: number;
        /**
         * Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is `900`.
         */
        batchWindow?: number;
    }
    interface TriggerPredicate {
        /**
         * A list of the conditions that determine when the trigger will fire. See Conditions.
         */
        conditions: outputs.glue.TriggerPredicateCondition[];
        /**
         * How to handle multiple conditions. Defaults to `AND`. Valid values are `AND` or `ANY`.
         */
        logical?: string;
    }
    interface TriggerPredicateCondition {
        /**
         * The condition crawl state. Currently, the values supported are `RUNNING`, `SUCCEEDED`, `CANCELLED`, and `FAILED`. If this is specified, `crawlerName` must also be specified. Conflicts with `state`.
         */
        crawlState?: string;
        /**
         * The name of the crawler to watch. If this is specified, `crawlState` must also be specified. Conflicts with `jobName`.
         */
        crawlerName?: string;
        /**
         * The name of the job to watch. If this is specified, `state` must also be specified. Conflicts with `crawlerName`.
         */
        jobName?: string;
        /**
         * A logical operator. Defaults to `EQUALS`.
         */
        logicalOperator?: string;
        /**
         * The condition job state. Currently, the values supported are `SUCCEEDED`, `STOPPED`, `TIMEOUT` and `FAILED`. If this is specified, `jobName` must also be specified. Conflicts with `crawlerState`.
         */
        state?: string;
    }
    interface UserDefinedFunctionResourceUri {
        /**
         * The type of the resource. can be one of `JAR`, `FILE`, and `ARCHIVE`.
         */
        resourceType: string;
        /**
         * The URI for accessing the resource.
         */
        uri: string;
    }
}
export declare namespace grafana {
    interface WorkspaceNetworkAccessControl {
        /**
         * An array of prefix list IDs.
         */
        prefixListIds: string[];
        /**
         * An array of Amazon VPC endpoint IDs for the workspace. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints will be ignored.
         */
        vpceIds: string[];
    }
    interface WorkspaceVpcConfiguration {
        /**
         * The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect.
         */
        securityGroupIds: string[];
        /**
         * The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect.
         */
        subnetIds: string[];
    }
}
export declare namespace guardduty {
    interface DetectorDatasources {
        /**
         * Configures [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes and Kubernetes Audit Logs below for more details.
         */
        kubernetes: outputs.guardduty.DetectorDatasourcesKubernetes;
        /**
         * Configures [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html).
         * See Malware Protection, Scan EC2 instance with findings and EBS volumes below for more details.
         */
        malwareProtection: outputs.guardduty.DetectorDatasourcesMalwareProtection;
        /**
         * Configures [S3 protection](https://docs.aws.amazon.com/guardduty/latest/ug/s3-protection.html).
         * See S3 Logs below for more details.
         */
        s3Logs: outputs.guardduty.DetectorDatasourcesS3Logs;
    }
    interface DetectorDatasourcesKubernetes {
        /**
         * Configures Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes Audit Logs below for more details.
         */
        auditLogs: outputs.guardduty.DetectorDatasourcesKubernetesAuditLogs;
    }
    interface DetectorDatasourcesKubernetesAuditLogs {
        /**
         * If true, enables Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * Defaults to `true`.
         */
        enable: boolean;
    }
    interface DetectorDatasourcesMalwareProtection {
        /**
         * Configure whether [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) is enabled as data source for EC2 instances with findings for the detector.
         * See Scan EC2 instance with findings below for more details.
         */
        scanEc2InstanceWithFindings: outputs.guardduty.DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindings;
    }
    interface DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindings {
        /**
         * Configure whether scanning EBS volumes is enabled as data source for the detector for instances with findings.
         * See EBS volumes below for more details.
         */
        ebsVolumes: outputs.guardduty.DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes;
    }
    interface DetectorDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes {
        /**
         * If true, enables [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) as data source for the detector.
         * Defaults to `true`.
         */
        enable: boolean;
    }
    interface DetectorDatasourcesS3Logs {
        /**
         * If true, enables [S3 protection](https://docs.aws.amazon.com/guardduty/latest/ug/s3-protection.html).
         * Defaults to `true`.
         */
        enable: boolean;
    }
    interface DetectorFeatureAdditionalConfiguration {
        /**
         * The name of the additional configuration. Refer to the [AWS Documentation](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_DetectorAdditionalConfiguration.html) for the current list of supported values.
         */
        name: string;
        /**
         * The status of the additional configuration. Valid values: `ENABLED`, `DISABLED`.
         */
        status: string;
    }
    interface FilterFindingCriteria {
        criterions: outputs.guardduty.FilterFindingCriteriaCriterion[];
    }
    interface FilterFindingCriteriaCriterion {
        /**
         * List of string values to be evaluated.
         */
        equals?: string[];
        /**
         * The name of the field to be evaluated. The full list of field names can be found in [AWS documentation](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_filter-findings.html#filter_criteria).
         */
        field: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        greaterThan?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        greaterThanOrEqual?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        lessThan?: string;
        /**
         * A value to be evaluated. Accepts either an integer or a date in [RFC 3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        lessThanOrEqual?: string;
        /**
         * List of string values to be evaluated.
         */
        notEquals?: string[];
    }
    interface GetDetectorFeature {
        /**
         * Additional feature configuration.
         */
        additionalConfigurations: outputs.guardduty.GetDetectorFeatureAdditionalConfiguration[];
        /**
         * The name of the detector feature.
         */
        name: string;
        /**
         * Current status of the detector.
         */
        status: string;
    }
    interface GetDetectorFeatureAdditionalConfiguration {
        /**
         * The name of the detector feature.
         */
        name: string;
        /**
         * Current status of the detector.
         */
        status: string;
    }
    interface OrganizationConfigurationDatasources {
        /**
         * Enable Kubernetes Audit Logs Monitoring automatically for new member accounts.
         */
        kubernetes: outputs.guardduty.OrganizationConfigurationDatasourcesKubernetes;
        /**
         * Enable Malware Protection automatically for new member accounts.
         */
        malwareProtection: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtection;
        /**
         * Enable S3 Protection automatically for new member accounts.
         */
        s3Logs: outputs.guardduty.OrganizationConfigurationDatasourcesS3Logs;
    }
    interface OrganizationConfigurationDatasourcesKubernetes {
        /**
         * Enable Kubernetes Audit Logs Monitoring automatically for new member accounts. [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * See Kubernetes Audit Logs below for more details.
         */
        auditLogs: outputs.guardduty.OrganizationConfigurationDatasourcesKubernetesAuditLogs;
    }
    interface OrganizationConfigurationDatasourcesKubernetesAuditLogs {
        /**
         * If true, enables Kubernetes audit logs as a data source for [Kubernetes protection](https://docs.aws.amazon.com/guardduty/latest/ug/kubernetes-protection.html).
         * Defaults to `true`.
         */
        enable: boolean;
    }
    interface OrganizationConfigurationDatasourcesMalwareProtection {
        /**
         * Configure whether [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) for EC2 instances with findings should be auto-enabled for new members joining the organization.
         * See Scan EC2 instance with findings below for more details.
         */
        scanEc2InstanceWithFindings: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindings;
    }
    interface OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindings {
        /**
         * Configure whether scanning EBS volumes should be auto-enabled for new members joining the organization
         * See EBS volumes below for more details.
         */
        ebsVolumes: outputs.guardduty.OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes;
    }
    interface OrganizationConfigurationDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes {
        /**
         * If true, enables [Malware Protection](https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection.html) for all new accounts joining the organization.
         * Defaults to `true`.
         */
        autoEnable: boolean;
    }
    interface OrganizationConfigurationDatasourcesS3Logs {
        /**
         * Set to `true` if you want S3 data event logs to be automatically enabled for new members of the organization. Default: `false`
         */
        autoEnable: boolean;
    }
    interface OrganizationConfigurationFeatureAdditionalConfiguration {
        /**
         * The status of the additional configuration that will be configured for the organization. Valid values: `NEW`, `ALL`, `NONE`.
         */
        autoEnable: string;
        /**
         * The name of the additional configuration that will be configured for the organization. Valid values: `EKS_ADDON_MANAGEMENT`, `ECS_FARGATE_AGENT_MANAGEMENT`, `EC2_AGENT_MANAGEMENT`.
         */
        name: string;
    }
}
export declare namespace iam {
    interface GetAccessKeysAccessKey {
        /**
         * Access key ID.
         */
        accessKeyId: string;
        /**
         * Date and time in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) that the access key was created.
         */
        createDate: string;
        /**
         * Access key status. Possible values are `Active` and `Inactive`.
         */
        status: string;
    }
    interface GetGroupUser {
        /**
         * User ARN.
         */
        arn: string;
        /**
         * Path to the IAM user.
         */
        path: string;
        /**
         * Stable and unique string identifying the IAM user.
         */
        userId: string;
        /**
         * Name of the IAM user.
         */
        userName: string;
    }
    interface GetPolicyDocumentStatement {
        /**
         * List of actions that this statement either allows or denies. For example, `["ec2:RunInstances", "s3:*"]`.
         */
        actions?: string[];
        /**
         * Configuration block for a condition. Detailed below.
         */
        conditions?: outputs.iam.GetPolicyDocumentStatementCondition[];
        /**
         * Whether this statement allows or denies the given actions. Valid values are `Allow` and `Deny`. Defaults to `Allow`.
         */
        effect?: string;
        /**
         * List of actions that this statement does *not* apply to. Use to apply a policy statement to all actions *except* those listed.
         */
        notActions?: string[];
        /**
         * Like `principals` except these are principals that the statement does *not* apply to.
         */
        notPrincipals?: outputs.iam.GetPolicyDocumentStatementNotPrincipal[];
        /**
         * List of resource ARNs that this statement does *not* apply to. Use to apply a policy statement to all resources *except* those listed. Conflicts with `resources`.
         */
        notResources?: string[];
        /**
         * Configuration block for principals. Detailed below.
         */
        principals?: outputs.iam.GetPolicyDocumentStatementPrincipal[];
        /**
         * List of resource ARNs that this statement applies to. This is required by AWS if used for an IAM policy. Conflicts with `notResources`.
         */
        resources?: string[];
        /**
         * Sid (statement ID) is an identifier for a policy statement.
         */
        sid?: string;
    }
    interface GetPolicyDocumentStatementCondition {
        /**
         * Name of the [IAM condition operator](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html) to evaluate.
         */
        test: string;
        /**
         * Values to evaluate the condition against. If multiple values are provided, the condition matches if at least one of them applies. That is, AWS evaluates multiple values as though using an "OR" boolean operation.
         */
        values: string[];
        /**
         * Name of a [Context Variable](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#AvailableKeys) to apply the condition to. Context variables may either be standard AWS variables starting with `aws:` or service-specific variables prefixed with the service name.
         */
        variable: string;
    }
    interface GetPolicyDocumentStatementNotPrincipal {
        identifiers: string[];
        type: string;
    }
    interface GetPolicyDocumentStatementPrincipal {
        /**
         * List of identifiers for principals. When `type` is `AWS`, these are IAM principal ARNs, e.g., `arn:aws:iam::12345678901:role/yak-role`.  When `type` is `Service`, these are AWS Service roles, e.g., `lambda.amazonaws.com`. When `type` is `Federated`, these are web identity users or SAML provider ARNs, e.g., `accounts.google.com` or `arn:aws:iam::12345678901:saml-provider/yak-saml-provider`. When `type` is `CanonicalUser`, these are [canonical user IDs](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId), e.g., `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`.
         */
        identifiers: string[];
        /**
         * Type of principal. Valid values include `AWS`, `Service`, `Federated`, `CanonicalUser` and `*`.
         */
        type: string;
    }
    interface GetPrincipalPolicySimulationContext {
        /**
         * The context _condition key_ to set.
         *
         * If you have policies containing `Condition` elements or using dynamic interpolations then you will need to provide suitable values for each condition key your policies use. See [Actions, resources, and condition keys for AWS services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) to find the various condition keys that are normally provided for real requests to each action of each AWS service.
         */
        key: string;
        /**
         * An IAM value type that determines how the policy simulator will interpret the strings given in `values`.
         *
         * For more information, see the `ContextKeyType` field of [`iam.ContextEntry`](https://docs.aws.amazon.com/IAM/latest/APIReference/API_ContextEntry.html) in the underlying API.
         */
        type: string;
        /**
         * A set of one or more values for this context entry.
         */
        values: string[];
    }
    interface GetPrincipalPolicySimulationResult {
        /**
         * The name of the single IAM action used for this particular request.
         */
        actionName: string;
        /**
         * `true` if `decision` is "allowed", and `false` otherwise.
         */
        allowed: boolean;
        /**
         * The raw decision determined from all of the policies in scope; either "allowed", "explicitDeny", or "implicitDeny".
         */
        decision: string;
        /**
         * A map of arbitrary metadata entries returned by the policy simulator for this request.
         */
        decisionDetails: {
            [key: string]: string;
        };
        /**
         * A nested set of objects describing which policies contained statements that were relevant to this simulation request. Each object has attributes `sourcePolicyId` and `sourcePolicyType` to identify one of the policies.
         */
        matchedStatements: outputs.iam.GetPrincipalPolicySimulationResultMatchedStatement[];
        /**
         * A set of context keys (or condition keys) that were needed by some of the policies contributing to this result but not specified using a `context` block in the configuration. Missing or incorrect context keys will typically cause a simulated request to be disallowed.
         */
        missingContextKeys: string[];
        /**
         * ARN of the resource that was used for this particular request. When you specify multiple actions and multiple resource ARNs, that causes a separate policy request for each combination of unique action and resource.
         */
        resourceArn: string;
    }
    interface GetPrincipalPolicySimulationResultMatchedStatement {
        /**
         * Identifier of one of the policies used as input to the simulation.
         */
        sourcePolicyId: string;
        /**
         * The type of the policy identified in source_policy_id.
         */
        sourcePolicyType: string;
    }
    interface GetRoleRoleLastUsed {
        /**
         * The date and time, in RFC 3339 format, that the role was last used.
         */
        lastUsedDate: string;
        /**
         * The name of the AWS Region in which the role was last used.
         */
        region: string;
    }
    interface RoleInlinePolicy {
        /**
         * Name of the role policy.
         */
        name: string;
        /**
         * Policy document as a JSON formatted string.
         */
        policy?: string;
    }
}
export declare namespace identitystore {
    interface GetGroupAlternateIdentifier {
        /**
         * Configuration block for filtering by the identifier issued by an external identity provider. Detailed below.
         */
        externalId?: outputs.identitystore.GetGroupAlternateIdentifierExternalId;
        /**
         * An entity attribute that's unique to a specific entity. Detailed below.
         *
         * > Exactly one of the above arguments must be provided.
         */
        uniqueAttribute?: outputs.identitystore.GetGroupAlternateIdentifierUniqueAttribute;
    }
    interface GetGroupAlternateIdentifierExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface GetGroupAlternateIdentifierUniqueAttribute {
        /**
         * Attribute path that is used to specify which attribute name to search. For example: `DisplayName`. Refer to the [Group data type](https://docs.aws.amazon.com/singlesignon/latest/IdentityStoreAPIReference/API_Group.html).
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }
    interface GetGroupExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface GetGroupFilter {
        /**
         * Attribute path that is used to specify which attribute name to search. Currently, `DisplayName` is the only valid attribute path.
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }
    interface GetGroupsGroup {
        /**
         * Description of the specified group.
         */
        description: string;
        /**
         * Group's display name.
         */
        displayName: string;
        /**
         * List of identifiers issued to this resource by an external identity provider.
         */
        externalIds: any[];
        /**
         * Identifier of the group in the Identity Store.
         */
        groupId: string;
        /**
         * Identity Store ID associated with the Single Sign-On (SSO) Instance.
         */
        identityStoreId: string;
    }
    interface GetUserAddress {
        /**
         * The country that this address is in.
         */
        country: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted: string;
        /**
         * The address locality.
         */
        locality: string;
        /**
         * The postal code of the address.
         */
        postalCode: string;
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The region of the address.
         */
        region: string;
        /**
         * The street of the address.
         */
        streetAddress: string;
        /**
         * The type of phone number.
         */
        type: string;
    }
    interface GetUserAlternateIdentifier {
        /**
         * Configuration block for filtering by the identifier issued by an external identity provider. Detailed below.
         */
        externalId?: outputs.identitystore.GetUserAlternateIdentifierExternalId;
        /**
         * An entity attribute that's unique to a specific entity. Detailed below.
         *
         * > Exactly one of the above arguments must be provided.
         */
        uniqueAttribute?: outputs.identitystore.GetUserAlternateIdentifierUniqueAttribute;
    }
    interface GetUserAlternateIdentifierExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface GetUserAlternateIdentifierUniqueAttribute {
        /**
         * Attribute path that is used to specify which attribute name to search. For example: `UserName`. Refer to the [User data type](https://docs.aws.amazon.com/singlesignon/latest/IdentityStoreAPIReference/API_User.html).
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }
    interface GetUserEmail {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The type of phone number.
         */
        type: string;
        /**
         * The user's phone number.
         */
        value: string;
    }
    interface GetUserExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface GetUserFilter {
        /**
         * Attribute path that is used to specify which attribute name to search. Currently, `UserName` is the only valid attribute path.
         */
        attributePath: string;
        /**
         * Value for an attribute.
         */
        attributeValue: string;
    }
    interface GetUserName {
        /**
         * The family name of the user.
         */
        familyName: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted: string;
        /**
         * The given name of the user.
         */
        givenName: string;
        /**
         * The honorific prefix of the user.
         */
        honorificPrefix: string;
        /**
         * The honorific suffix of the user.
         */
        honorificSuffix: string;
        /**
         * The middle name of the user.
         */
        middleName: string;
    }
    interface GetUserPhoneNumber {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary: boolean;
        /**
         * The type of phone number.
         */
        type: string;
        /**
         * The user's phone number.
         */
        value: string;
    }
    interface GroupExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface UserAddresses {
        /**
         * The country that this address is in.
         */
        country?: string;
        /**
         * The name that is typically displayed when the address is shown for display.
         */
        formatted?: string;
        /**
         * The address locality.
         */
        locality?: string;
        /**
         * The postal code of the address.
         */
        postalCode?: string;
        /**
         * When `true`, this is the primary address associated with the user.
         */
        primary?: boolean;
        /**
         * The region of the address.
         */
        region?: string;
        /**
         * The street of the address.
         */
        streetAddress?: string;
        /**
         * The type of address.
         */
        type?: string;
    }
    interface UserEmails {
        /**
         * When `true`, this is the primary email associated with the user.
         */
        primary?: boolean;
        /**
         * The type of email.
         */
        type?: string;
        /**
         * The email address. This value must be unique across the identity store.
         */
        value?: string;
    }
    interface UserExternalId {
        /**
         * The identifier issued to this resource by an external identity provider.
         */
        id: string;
        /**
         * The issuer for an external identifier.
         */
        issuer: string;
    }
    interface UserName {
        /**
         * The family name of the user.
         */
        familyName: string;
        /**
         * The name that is typically displayed when the name is shown for display.
         */
        formatted?: string;
        /**
         * The given name of the user.
         *
         * The following arguments are optional:
         */
        givenName: string;
        /**
         * The honorific prefix of the user.
         */
        honorificPrefix?: string;
        /**
         * The honorific suffix of the user.
         */
        honorificSuffix?: string;
        /**
         * The middle name of the user.
         */
        middleName?: string;
    }
    interface UserPhoneNumbers {
        /**
         * When `true`, this is the primary phone number associated with the user.
         */
        primary?: boolean;
        /**
         * The type of phone number.
         */
        type?: string;
        /**
         * The user's phone number.
         */
        value?: string;
    }
}
export declare namespace imagebuilder {
    interface ContainerRecipeComponent {
        /**
         * Amazon Resource Name (ARN) of the Image Builder Component to associate.
         */
        componentArn: string;
        /**
         * Configuration block(s) for parameters to configure the component. Detailed below.
         */
        parameters?: outputs.imagebuilder.ContainerRecipeComponentParameter[];
    }
    interface ContainerRecipeComponentParameter {
        /**
         * The name of the component parameter.
         */
        name: string;
        /**
         * The value for the named component parameter.
         */
        value: string;
    }
    interface ContainerRecipeInstanceConfiguration {
        /**
         * Configuration block(s) with block device mappings for the container recipe. Detailed below.
         */
        blockDeviceMappings?: outputs.imagebuilder.ContainerRecipeInstanceConfigurationBlockDeviceMapping[];
        /**
         * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
         */
        image?: string;
    }
    interface ContainerRecipeInstanceConfigurationBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName?: string;
        /**
         * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
         */
        ebs?: outputs.imagebuilder.ContainerRecipeInstanceConfigurationBlockDeviceMappingEbs;
        /**
         * Set to `true` to remove a mapping from the parent image.
         */
        noDevice?: boolean;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName?: string;
    }
    interface ContainerRecipeInstanceConfigurationBlockDeviceMappingEbs {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination?: string;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted?: string;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops?: number;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId?: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize?: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType?: string;
    }
    interface ContainerRecipeTargetRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * The service in which this image is registered. Valid values: `ECR`.
         */
        service: string;
    }
    interface DistributionConfigurationDistribution {
        /**
         * Configuration block with Amazon Machine Image (AMI) distribution settings. Detailed below.
         */
        amiDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfiguration;
        /**
         * Configuration block with container distribution settings. Detailed below.
         */
        containerDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionContainerDistributionConfiguration;
        /**
         * Set of Windows faster-launching configurations to use for AMI distribution. Detailed below.
         */
        fastLaunchConfigurations?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfiguration[];
        /**
         * Set of launch template configuration settings that apply to image distribution. Detailed below.
         */
        launchTemplateConfigurations?: outputs.imagebuilder.DistributionConfigurationDistributionLaunchTemplateConfiguration[];
        /**
         * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
         */
        licenseConfigurationArns?: string[];
        /**
         * AWS Region for the distribution.
         *
         * The following arguments are optional:
         */
        region: string;
    }
    interface DistributionConfigurationDistributionAmiDistributionConfiguration {
        /**
         * Key-value map of tags to apply to the distributed AMI.
         */
        amiTags?: {
            [key: string]: string;
        };
        /**
         * Description to apply to the distributed AMI.
         */
        description?: string;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key to encrypt the distributed AMI.
         */
        kmsKeyId?: string;
        /**
         * Configuration block of EC2 launch permissions to apply to the distributed AMI. Detailed below.
         */
        launchPermission?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission;
        /**
         * Name to apply to the distributed AMI.
         */
        name?: string;
        /**
         * Set of AWS Account identifiers to distribute the AMI.
         */
        targetAccountIds?: string[];
    }
    interface DistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission {
        /**
         * Set of AWS Organization ARNs to assign.
         */
        organizationArns?: string[];
        /**
         * Set of AWS Organizational Unit ARNs to assign.
         */
        organizationalUnitArns?: string[];
        /**
         * Set of EC2 launch permission user groups to assign. Use `all` to distribute a public AMI.
         */
        userGroups?: string[];
        /**
         * Set of AWS Account identifiers to assign.
         */
        userIds?: string[];
    }
    interface DistributionConfigurationDistributionContainerDistributionConfiguration {
        /**
         * Set of tags that are attached to the container distribution configuration.
         */
        containerTags?: string[];
        /**
         * Description of the container distribution configuration.
         */
        description?: string;
        /**
         * Configuration block with the destination repository for the container distribution configuration.
         */
        targetRepository: outputs.imagebuilder.DistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository;
    }
    interface DistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * The service in which this image is registered. Valid values: `ECR`.
         */
        service: string;
    }
    interface DistributionConfigurationDistributionFastLaunchConfiguration {
        /**
         * The owner account ID for the fast-launch enabled Windows AMI.
         */
        accountId: string;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI. Set to `true` to start using Windows faster launching, or `false` to stop using it.
         */
        enabled: boolean;
        /**
         * Configuration block for the launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots. Detailed below.
         */
        launchTemplate?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate;
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches?: number;
        /**
         * Configuration block for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled. Detailed below.
         */
        snapshotConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration;
    }
    interface DistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate {
        /**
         * The ID of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateId?: string;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName?: string;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion?: string;
    }
    interface DistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount?: number;
    }
    interface DistributionConfigurationDistributionLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId?: string;
        /**
         * Indicates whether to set the specified Amazon EC2 launch template as the default launch template. Defaults to `true`.
         */
        default?: boolean;
        /**
         * The ID of the Amazon EC2 launch template to use.
         */
        launchTemplateId: string;
    }
    interface GetComponentsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListComponents API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListComponents.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetContainerRecipeComponent {
        /**
         * ARN of the Image Builder Component.
         */
        componentArn: string;
        /**
         * Set of parameters that are used to configure the component.
         */
        parameters: outputs.imagebuilder.GetContainerRecipeComponentParameter[];
    }
    interface GetContainerRecipeComponentParameter {
        /**
         * Name of the container recipe.
         */
        name: string;
        /**
         * Value of the component parameter.
         */
        value: string;
    }
    interface GetContainerRecipeInstanceConfiguration {
        /**
         * Set of objects with block device mappings for the instance configuration.
         */
        blockDeviceMappings: outputs.imagebuilder.GetContainerRecipeInstanceConfigurationBlockDeviceMapping[];
        /**
         * AMI ID of the base image for container build and test instance.
         */
        image: string;
    }
    interface GetContainerRecipeInstanceConfigurationBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName: string;
        /**
         * Single list of object with Elastic Block Storage (EBS) block device mapping settings.
         */
        ebs: outputs.imagebuilder.GetContainerRecipeInstanceConfigurationBlockDeviceMappingEb[];
        /**
         * Whether to remove a mapping from the parent image.
         */
        noDevice: string;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName: string;
    }
    interface GetContainerRecipeInstanceConfigurationBlockDeviceMappingEb {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination: boolean;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted: boolean;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops: number;
        /**
         * KMS key used to encrypt the container image.
         */
        kmsKeyId: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType: string;
    }
    interface GetContainerRecipeTargetRepository {
        /**
         * Name of the container repository where the output container image is stored. The name is prefixed by the repository location.
         */
        repositoryName: string;
        /**
         * Service in which this image is registered.
         */
        service: string;
    }
    interface GetContainerRecipesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListContainerRecipes API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListContainerRecipes.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetDistributionConfigurationDistribution {
        /**
         * Nested list of AMI distribution configuration.
         */
        amiDistributionConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionAmiDistributionConfiguration[];
        /**
         * Nested list of container distribution configurations.
         */
        containerDistributionConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionContainerDistributionConfiguration[];
        /**
         * Nested list of Windows faster-launching configurations to use for AMI distribution.
         */
        fastLaunchConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfiguration[];
        /**
         * Nested list of launch template configurations.
         */
        launchTemplateConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionLaunchTemplateConfiguration[];
        /**
         * Set of Amazon Resource Names (ARNs) of License Manager License Configurations.
         */
        licenseConfigurationArns: string[];
        /**
         * AWS Region of distribution.
         */
        region: string;
    }
    interface GetDistributionConfigurationDistributionAmiDistributionConfiguration {
        /**
         * Key-value map of tags to apply to distributed AMI.
         */
        amiTags: {
            [key: string]: string;
        };
        /**
         * Description of the container distribution configuration.
         */
        description: string;
        /**
         * ARN of Key Management Service (KMS) Key to encrypt AMI.
         */
        kmsKeyId: string;
        /**
         * Nested list of EC2 launch permissions.
         */
        launchPermissions: outputs.imagebuilder.GetDistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission[];
        /**
         * Name of the distribution configuration.
         */
        name: string;
        /**
         * Set of target AWS Account identifiers.
         */
        targetAccountIds: string[];
    }
    interface GetDistributionConfigurationDistributionAmiDistributionConfigurationLaunchPermission {
        /**
         * Set of AWS Organization ARNs.
         */
        organizationArns: string[];
        /**
         * Set of AWS Organizational Unit ARNs.
         */
        organizationalUnitArns: string[];
        /**
         * Set of EC2 launch permission user groups.
         */
        userGroups: string[];
        /**
         * Set of AWS Account identifiers.
         */
        userIds: string[];
    }
    interface GetDistributionConfigurationDistributionContainerDistributionConfiguration {
        /**
         * Set of tags that are attached to the container distribution configuration.
         */
        containerTags: string[];
        /**
         * Description of the container distribution configuration.
         */
        description: string;
        /**
         * Set of destination repositories for the container distribution configuration.
         */
        targetRepositories: outputs.imagebuilder.GetDistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository[];
    }
    interface GetDistributionConfigurationDistributionContainerDistributionConfigurationTargetRepository {
        /**
         * Name of the container repository where the output container image is stored.
         */
        repositoryName: string;
        /**
         * Service in which the image is registered.
         */
        service: string;
    }
    interface GetDistributionConfigurationDistributionFastLaunchConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId: string;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI.
         */
        enabled: boolean;
        /**
         * Nested list of launch templates that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
         */
        launchTemplates: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate[];
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches: number;
        /**
         * Nested list of configurations for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
         */
        snapshotConfigurations: outputs.imagebuilder.GetDistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration[];
    }
    interface GetDistributionConfigurationDistributionFastLaunchConfigurationLaunchTemplate {
        /**
         * ID of the Amazon EC2 launch template.
         */
        launchTemplateId: string;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName: string;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion: string;
    }
    interface GetDistributionConfigurationDistributionFastLaunchConfigurationSnapshotConfiguration {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount: number;
    }
    interface GetDistributionConfigurationDistributionLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId: string;
        /**
         * Whether the specified Amazon EC2 launch template is set as the default launch template.
         */
        default: boolean;
        /**
         * ID of the Amazon EC2 launch template.
         */
        launchTemplateId: string;
    }
    interface GetDistributionConfigurationsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListDistributionConfigurations API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListDistributionConfigurations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetImageImageScanningConfiguration {
        /**
         * Configuration block with ECR configuration.
         */
        ecrConfigurations: outputs.imagebuilder.GetImageImageScanningConfigurationEcrConfiguration[];
        /**
         * Indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
         */
        imageScanningEnabled: boolean;
    }
    interface GetImageImageScanningConfigurationEcrConfiguration {
        /**
         * Set of tags for Image Builder to apply to the output container image that that Amazon Inspector scans.
         */
        containerTags: string[];
        /**
         * The name of the container repository that Amazon Inspector scans to identify findings for your container images.
         */
        repositoryName: string;
    }
    interface GetImageImageTestsConfiguration {
        /**
         * Whether image tests are enabled.
         */
        imageTestsEnabled: boolean;
        /**
         * Number of minutes before image tests time out.
         */
        timeoutMinutes: number;
    }
    interface GetImageOutputResource {
        /**
         * Set of objects with each Amazon Machine Image (AMI) created.
         */
        amis: outputs.imagebuilder.GetImageOutputResourceAmi[];
        /**
         * Set of objects with each container image created and stored in the output repository.
         */
        containers: outputs.imagebuilder.GetImageOutputResourceContainer[];
    }
    interface GetImageOutputResourceAmi {
        /**
         * Account identifier of the AMI.
         */
        accountId: string;
        /**
         * Description of the AMI.
         */
        description: string;
        /**
         * Identifier of the AMI.
         */
        image: string;
        /**
         * Name of the AMI.
         */
        name: string;
        /**
         * Region of the container image.
         */
        region: string;
    }
    interface GetImageOutputResourceContainer {
        /**
         * Set of URIs for created containers.
         */
        imageUris: string[];
        /**
         * Region of the container image.
         */
        region: string;
    }
    interface GetImagePipelineImageScanningConfiguration {
        /**
         * List if an object with ecr configuration for image scanning
         */
        ecrConfigurations: outputs.imagebuilder.GetImagePipelineImageScanningConfigurationEcrConfiguration[];
        /**
         * Whether image scanning is enabled.
         */
        imageScanningEnabled: boolean;
    }
    interface GetImagePipelineImageScanningConfigurationEcrConfiguration {
        /**
         * Tags that are added to the output containers that are scanned
         */
        containerTags: string[];
        /**
         * The name of the container repository that Amazon Inspector scans
         */
        repositoryName: string;
    }
    interface GetImagePipelineImageTestsConfiguration {
        /**
         * Whether image tests are enabled.
         */
        imageTestsEnabled: boolean;
        /**
         * Number of minutes before image tests time out.
         */
        timeoutMinutes: number;
    }
    interface GetImagePipelineSchedule {
        /**
         * Condition when the pipeline should trigger a new image build.
         */
        pipelineExecutionStartCondition: string;
        /**
         * Cron expression of how often the pipeline start condition is evaluated.
         */
        scheduleExpression: string;
    }
    interface GetImagePipelinesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListImagePipelines API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListImagePipelines.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetImageRecipeBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName: string;
        /**
         * Single list of object with Elastic Block Storage (EBS) block device mapping settings.
         */
        ebs: outputs.imagebuilder.GetImageRecipeBlockDeviceMappingEb[];
        /**
         * Whether to remove a mapping from the parent image.
         */
        noDevice: string;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName: string;
    }
    interface GetImageRecipeBlockDeviceMappingEb {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination: boolean;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted: boolean;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops: number;
        /**
         * ARN of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType: string;
    }
    interface GetImageRecipeComponent {
        /**
         * ARN of the Image Builder Component.
         */
        componentArn: string;
        /**
         * Set of parameters that are used to configure the component.
         */
        parameters: outputs.imagebuilder.GetImageRecipeComponentParameter[];
    }
    interface GetImageRecipeComponentParameter {
        /**
         * Name of the image recipe.
         */
        name: string;
        /**
         * Value of the component parameter.
         */
        value: string;
    }
    interface GetImageRecipesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListImageRecipes API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListImageRecipes.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetInfrastructureConfigurationInstanceMetadataOption {
        /**
         * Number of hops that an instance can traverse to reach its destonation.
         */
        httpPutResponseHopLimit: number;
        /**
         * Whether a signed token is required for instance metadata retrieval requests.
         */
        httpTokens: string;
    }
    interface GetInfrastructureConfigurationLogging {
        /**
         * Nested list of S3 logs settings.
         */
        s3Logs: outputs.imagebuilder.GetInfrastructureConfigurationLoggingS3Log[];
    }
    interface GetInfrastructureConfigurationLoggingS3Log {
        /**
         * Name of the S3 Bucket for logging.
         */
        s3BucketName: string;
        /**
         * Key prefix for S3 Bucket logging.
         */
        s3KeyPrefix: string;
    }
    interface GetInfrastructureConfigurationsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Image Builder ListInfrastructureConfigurations API Reference](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_ListInfrastructureConfigurations.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface ImageImageScanningConfiguration {
        /**
         * Configuration block with ECR configuration. Detailed below.
         */
        ecrConfiguration: outputs.imagebuilder.ImageImageScanningConfigurationEcrConfiguration;
        /**
         * Indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image. Defaults to `false`.
         */
        imageScanningEnabled?: boolean;
    }
    interface ImageImageScanningConfigurationEcrConfiguration {
        /**
         * Set of tags for Image Builder to apply to the output container image that that Amazon Inspector scans.
         */
        containerTags?: string[];
        /**
         * The name of the container repository that Amazon Inspector scans to identify findings for your container images.
         */
        repositoryName?: string;
    }
    interface ImageImageTestsConfiguration {
        /**
         * Whether image tests are enabled. Defaults to `true`.
         */
        imageTestsEnabled?: boolean;
        /**
         * Number of minutes before image tests time out. Valid values are between `60` and `1440`. Defaults to `720`.
         */
        timeoutMinutes?: number;
    }
    interface ImageOutputResource {
        /**
         * Set of objects with each Amazon Machine Image (AMI) created.
         */
        amis: outputs.imagebuilder.ImageOutputResourceAmi[];
        /**
         * Set of objects with each container image created and stored in the output repository.
         */
        containers: outputs.imagebuilder.ImageOutputResourceContainer[];
    }
    interface ImageOutputResourceAmi {
        /**
         * Account identifier of the AMI.
         */
        accountId: string;
        /**
         * Description of the AMI.
         */
        description: string;
        /**
         * Identifier of the AMI.
         */
        image: string;
        /**
         * Name of the AMI.
         */
        name: string;
        /**
         * Region of the container image.
         */
        region: string;
    }
    interface ImageOutputResourceContainer {
        /**
         * Set of URIs for created containers.
         */
        imageUris: string[];
        /**
         * Region of the container image.
         */
        region: string;
    }
    interface ImagePipelineImageScanningConfiguration {
        /**
         * Configuration block with ECR configuration for image scanning. Detailed below.
         */
        ecrConfiguration: outputs.imagebuilder.ImagePipelineImageScanningConfigurationEcrConfiguration;
        /**
         * Whether image scans are enabled. Defaults to `false`.
         */
        imageScanningEnabled?: boolean;
    }
    interface ImagePipelineImageScanningConfigurationEcrConfiguration {
        containerTags?: string[];
        /**
         * The name of the repository to scan
         */
        repositoryName?: string;
    }
    interface ImagePipelineImageTestsConfiguration {
        /**
         * Whether image tests are enabled. Defaults to `true`.
         */
        imageTestsEnabled?: boolean;
        /**
         * Number of minutes before image tests time out. Valid values are between `60` and `1440`. Defaults to `720`.
         */
        timeoutMinutes?: number;
    }
    interface ImagePipelineSchedule {
        /**
         * Condition when the pipeline should trigger a new image build. Valid values are `EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE` and `EXPRESSION_MATCH_ONLY`. Defaults to `EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE`.
         */
        pipelineExecutionStartCondition?: string;
        /**
         * Cron expression of how often the pipeline start condition is evaluated. For example, `cron(0 0 * * ? *)` is evaluated every day at midnight UTC. Configurations using the five field syntax that was previously accepted by the API, such as `cron(0 0 * * *)`, must be updated to the six field syntax. For more information, see the [Image Builder User Guide](https://docs.aws.amazon.com/imagebuilder/latest/userguide/cron-expressions.html).
         *
         * The following arguments are optional:
         */
        scheduleExpression: string;
        /**
         * The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the [IANA timezone format](https://www.joda.org/joda-time/timezones.html). If not specified this defaults to UTC.
         */
        timezone: string;
    }
    interface ImageRecipeBlockDeviceMapping {
        /**
         * Name of the device. For example, `/dev/sda` or `/dev/xvdb`.
         */
        deviceName?: string;
        /**
         * Configuration block with Elastic Block Storage (EBS) block device mapping settings. Detailed below.
         */
        ebs?: outputs.imagebuilder.ImageRecipeBlockDeviceMappingEbs;
        /**
         * Set to `true` to remove a mapping from the parent image.
         */
        noDevice?: boolean;
        /**
         * Virtual device name. For example, `ephemeral0`. Instance store volumes are numbered starting from 0.
         */
        virtualName?: string;
    }
    interface ImageRecipeBlockDeviceMappingEbs {
        /**
         * Whether to delete the volume on termination. Defaults to unset, which is the value inherited from the parent image.
         */
        deleteOnTermination?: string;
        /**
         * Whether to encrypt the volume. Defaults to unset, which is the value inherited from the parent image.
         */
        encrypted?: string;
        /**
         * Number of Input/Output (I/O) operations per second to provision for an `io1` or `io2` volume.
         */
        iops?: number;
        /**
         * Amazon Resource Name (ARN) of the Key Management Service (KMS) Key for encryption.
         */
        kmsKeyId?: string;
        /**
         * Identifier of the EC2 Volume Snapshot.
         */
        snapshotId?: string;
        /**
         * For GP3 volumes only. The throughput in MiB/s that the volume supports.
         */
        throughput?: number;
        /**
         * Size of the volume, in GiB.
         */
        volumeSize?: number;
        /**
         * Type of the volume. For example, `gp2` or `io2`.
         */
        volumeType?: string;
    }
    interface ImageRecipeComponent {
        /**
         * Amazon Resource Name (ARN) of the Image Builder Component to associate.
         */
        componentArn: string;
        /**
         * Configuration block(s) for parameters to configure the component. Detailed below.
         */
        parameters?: outputs.imagebuilder.ImageRecipeComponentParameter[];
    }
    interface ImageRecipeComponentParameter {
        /**
         * The name of the component parameter.
         */
        name: string;
        /**
         * The value for the named component parameter.
         */
        value: string;
    }
    interface ImageRecipeSystemsManagerAgent {
        /**
         * Whether to remove the Systems Manager Agent after the image has been built. Defaults to `false`.
         */
        uninstallAfterBuild: boolean;
    }
    interface ImageWorkflow {
        /**
         * The action to take if the workflow fails. Must be one of `CONTINUE` or `ABORT`.
         */
        onFailure?: string;
        /**
         * The parallel group in which to run a test Workflow.
         */
        parallelGroup?: string;
        /**
         * Configuration block for the workflow parameters. Detailed below.
         */
        parameters?: outputs.imagebuilder.ImageWorkflowParameter[];
        /**
         * Amazon Resource Name (ARN) of the Image Builder Workflow.
         *
         * The following arguments are optional:
         */
        workflowArn: string;
    }
    interface ImageWorkflowParameter {
        /**
         * The name of the Workflow parameter.
         */
        name: string;
        /**
         * The value of the Workflow parameter.
         */
        value: string;
    }
    interface InfrastructureConfigurationInstanceMetadataOptions {
        /**
         * The number of hops that an instance can traverse to reach its destonation.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Whether a signed token is required for instance metadata retrieval requests. Valid values: `required`, `optional`.
         */
        httpTokens?: string;
    }
    interface InfrastructureConfigurationLogging {
        /**
         * Configuration block with S3 logging settings. Detailed below.
         */
        s3Logs: outputs.imagebuilder.InfrastructureConfigurationLoggingS3Logs;
    }
    interface InfrastructureConfigurationLoggingS3Logs {
        /**
         * Name of the S3 Bucket.
         *
         * The following arguments are optional:
         */
        s3BucketName: string;
        /**
         * Prefix to use for S3 logs. Defaults to `/`.
         */
        s3KeyPrefix?: string;
    }
}
export declare namespace inspector {
    interface AssessmentTemplateEventSubscription {
        event: string;
        topicArn: string;
    }
}
export declare namespace inspector2 {
    interface OrganizationConfigurationAutoEnable {
        /**
         * Whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        ec2: boolean;
        /**
         * Whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        ecr: boolean;
        /**
         * Whether Lambda Function scans are automatically enabled for new members of your Amazon Inspector organization.
         */
        lambda?: boolean;
        /**
         * Whether AWS Lambda code scans are automatically enabled for new members of your Amazon Inspector organization. **Note:** Lambda code scanning requires Lambda standard scanning to be activated. Consequently, if you are setting this argument to `true`, you must also set the `lambda` argument to `true`. See [Scanning AWS Lambda functions with Amazon Inspector](https://docs.aws.amazon.com/inspector/latest/user/scanning-lambda.html#lambda-code-scans) for more information.
         */
        lambdaCode?: boolean;
    }
}
export declare namespace iot {
    interface BillingGroupMetadata {
        creationDate: string;
    }
    interface BillingGroupProperties {
        /**
         * A description of the Billing Group.
         */
        description?: string;
    }
    interface CaCertificateRegistrationConfig {
        /**
         * The ARN of the role.
         */
        roleArn?: string;
        /**
         * The template body.
         */
        templateBody?: string;
        /**
         * The name of the provisioning template.
         */
        templateName?: string;
    }
    interface CaCertificateValidity {
        /**
         * The certificate is not valid after this date.
         */
        notAfter: string;
        /**
         * The certificate is not valid before this date.
         */
        notBefore: string;
    }
    interface DomainConfigurationAuthorizerConfig {
        /**
         * A Boolean that specifies whether the domain configuration's authorization service can be overridden.
         */
        allowAuthorizerOverride?: boolean;
        /**
         * The name of the authorization service for a domain configuration.
         */
        defaultAuthorizerName?: string;
    }
    interface DomainConfigurationTlsConfig {
        /**
         * The security policy for a domain configuration.
         */
        securityPolicy: string;
    }
    interface IndexingConfigurationThingGroupIndexingConfiguration {
        /**
         * A list of thing group fields to index. This list cannot contain any managed fields. See below.
         */
        customFields?: outputs.iot.IndexingConfigurationThingGroupIndexingConfigurationCustomField[];
        /**
         * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
         */
        managedFields: outputs.iot.IndexingConfigurationThingGroupIndexingConfigurationManagedField[];
        /**
         * Thing group indexing mode. Valid values: `OFF`, `ON`.
         */
        thingGroupIndexingMode: string;
    }
    interface IndexingConfigurationThingGroupIndexingConfigurationCustomField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }
    interface IndexingConfigurationThingGroupIndexingConfigurationManagedField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }
    interface IndexingConfigurationThingIndexingConfiguration {
        /**
         * Contains custom field names and their data type. See below.
         */
        customFields?: outputs.iot.IndexingConfigurationThingIndexingConfigurationCustomField[];
        /**
         * Device Defender indexing mode. Valid values: `VIOLATIONS`, `OFF`. Default: `OFF`.
         */
        deviceDefenderIndexingMode?: string;
        /**
         * Required if `namedShadowIndexingMode` is `ON`. Enables to add named shadows filtered by `filter` to fleet indexing configuration.
         */
        filter: outputs.iot.IndexingConfigurationThingIndexingConfigurationFilter;
        /**
         * Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
         */
        managedFields: outputs.iot.IndexingConfigurationThingIndexingConfigurationManagedField[];
        /**
         * [Named shadow](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html) indexing mode. Valid values: `ON`, `OFF`. Default: `OFF`.
         */
        namedShadowIndexingMode?: string;
        /**
         * Thing connectivity indexing mode. Valid values: `STATUS`, `OFF`. Default: `OFF`.
         */
        thingConnectivityIndexingMode?: string;
        /**
         * Thing indexing mode. Valid values: `REGISTRY`, `REGISTRY_AND_SHADOW`, `OFF`.
         */
        thingIndexingMode: string;
    }
    interface IndexingConfigurationThingIndexingConfigurationCustomField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }
    interface IndexingConfigurationThingIndexingConfigurationFilter {
        /**
         * List of shadow names that you select to index.
         */
        namedShadowNames?: string[];
    }
    interface IndexingConfigurationThingIndexingConfigurationManagedField {
        /**
         * The name of the field.
         */
        name?: string;
        /**
         * The data type of the field. Valid values: `Number`, `String`, `Boolean`.
         */
        type?: string;
    }
    interface ProvisioningTemplatePreProvisioningHook {
        /**
         * The version of the payload that was sent to the target function. The only valid (and the default) payload version is `"2020-04-01"`.
         */
        payloadVersion?: string;
        /**
         * The ARN of the target function.
         */
        targetArn: string;
    }
    interface ThingGroupMetadata {
        creationDate: string;
        /**
         * The name of the parent Thing Group.
         */
        parentGroupName: string;
        rootToParentGroups: outputs.iot.ThingGroupMetadataRootToParentGroup[];
    }
    interface ThingGroupMetadataRootToParentGroup {
        groupArn: string;
        groupName: string;
    }
    interface ThingGroupProperties {
        /**
         * The Thing Group attributes. Defined below.
         */
        attributePayload?: outputs.iot.ThingGroupPropertiesAttributePayload;
        /**
         * A description of the Thing Group.
         */
        description?: string;
    }
    interface ThingGroupPropertiesAttributePayload {
        /**
         * Key-value map.
         */
        attributes?: {
            [key: string]: string;
        };
    }
    interface ThingTypeProperties {
        /**
         * The description of the thing type.
         */
        description?: string;
        /**
         * A list of searchable thing attribute names.
         */
        searchableAttributes: string[];
    }
    interface TopicRuleCloudwatchAlarm {
        /**
         * The CloudWatch alarm name.
         */
        alarmName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
        /**
         * The reason for the alarm change.
         */
        stateReason: string;
        /**
         * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
         */
        stateValue: string;
    }
    interface TopicRuleCloudwatchLog {
        /**
         * The CloudWatch log group name.
         */
        logGroupName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }
    interface TopicRuleCloudwatchMetric {
        /**
         * The CloudWatch metric name.
         */
        metricName: string;
        /**
         * The CloudWatch metric namespace name.
         */
        metricNamespace: string;
        /**
         * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
         */
        metricTimestamp?: string;
        /**
         * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
         */
        metricUnit: string;
        /**
         * The CloudWatch metric value.
         */
        metricValue: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch metric.
         */
        roleArn: string;
    }
    interface TopicRuleDestinationVpcConfiguration {
        /**
         * The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
         */
        roleArn: string;
        /**
         * The security groups of the VPC destination.
         */
        securityGroups?: string[];
        /**
         * The subnet IDs of the VPC destination.
         */
        subnetIds: string[];
        /**
         * The ID of the VPC.
         */
        vpcId: string;
    }
    interface TopicRuleDynamodb {
        /**
         * The hash key name.
         */
        hashKeyField: string;
        /**
         * The hash key type. Valid values are "STRING" or "NUMBER".
         */
        hashKeyType?: string;
        /**
         * The hash key value.
         */
        hashKeyValue: string;
        /**
         * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
         */
        operation?: string;
        /**
         * The action payload.
         */
        payloadField?: string;
        /**
         * The range key name.
         */
        rangeKeyField?: string;
        /**
         * The range key type. Valid values are "STRING" or "NUMBER".
         */
        rangeKeyType?: string;
        /**
         * The range key value.
         */
        rangeKeyValue?: string;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    interface TopicRuleDynamodbv2 {
        /**
         * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
         */
        putItem?: outputs.iot.TopicRuleDynamodbv2PutItem;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
    }
    interface TopicRuleDynamodbv2PutItem {
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    interface TopicRuleElasticsearch {
        /**
         * The endpoint of your Elasticsearch domain.
         */
        endpoint: string;
        /**
         * The unique identifier for the document you are storing.
         */
        id: string;
        /**
         * The Elasticsearch index where you want to store your data.
         */
        index: string;
        /**
         * The IAM role ARN that has access to Elasticsearch.
         */
        roleArn: string;
        /**
         * The type of document you are storing.
         */
        type: string;
    }
    interface TopicRuleErrorAction {
        cloudwatchAlarm?: outputs.iot.TopicRuleErrorActionCloudwatchAlarm;
        cloudwatchLogs?: outputs.iot.TopicRuleErrorActionCloudwatchLogs;
        cloudwatchMetric?: outputs.iot.TopicRuleErrorActionCloudwatchMetric;
        dynamodb?: outputs.iot.TopicRuleErrorActionDynamodb;
        dynamodbv2?: outputs.iot.TopicRuleErrorActionDynamodbv2;
        elasticsearch?: outputs.iot.TopicRuleErrorActionElasticsearch;
        firehose?: outputs.iot.TopicRuleErrorActionFirehose;
        http?: outputs.iot.TopicRuleErrorActionHttp;
        iotAnalytics?: outputs.iot.TopicRuleErrorActionIotAnalytics;
        iotEvents?: outputs.iot.TopicRuleErrorActionIotEvents;
        kafka?: outputs.iot.TopicRuleErrorActionKafka;
        kinesis?: outputs.iot.TopicRuleErrorActionKinesis;
        lambda?: outputs.iot.TopicRuleErrorActionLambda;
        republish?: outputs.iot.TopicRuleErrorActionRepublish;
        s3?: outputs.iot.TopicRuleErrorActionS3;
        sns?: outputs.iot.TopicRuleErrorActionSns;
        sqs?: outputs.iot.TopicRuleErrorActionSqs;
        stepFunctions?: outputs.iot.TopicRuleErrorActionStepFunctions;
        timestream?: outputs.iot.TopicRuleErrorActionTimestream;
    }
    interface TopicRuleErrorActionCloudwatchAlarm {
        /**
         * The CloudWatch alarm name.
         */
        alarmName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
        /**
         * The reason for the alarm change.
         */
        stateReason: string;
        /**
         * The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
         */
        stateValue: string;
    }
    interface TopicRuleErrorActionCloudwatchLogs {
        /**
         * The CloudWatch log group name.
         */
        logGroupName: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch alarm.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionCloudwatchMetric {
        /**
         * The CloudWatch metric name.
         */
        metricName: string;
        /**
         * The CloudWatch metric namespace name.
         */
        metricNamespace: string;
        /**
         * An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
         */
        metricTimestamp?: string;
        /**
         * The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
         */
        metricUnit: string;
        /**
         * The CloudWatch metric value.
         */
        metricValue: string;
        /**
         * The IAM role ARN that allows access to the CloudWatch metric.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionDynamodb {
        /**
         * The hash key name.
         */
        hashKeyField: string;
        /**
         * The hash key type. Valid values are "STRING" or "NUMBER".
         */
        hashKeyType?: string;
        /**
         * The hash key value.
         */
        hashKeyValue: string;
        /**
         * The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
         */
        operation?: string;
        /**
         * The action payload.
         */
        payloadField?: string;
        /**
         * The range key name.
         */
        rangeKeyField?: string;
        /**
         * The range key type. Valid values are "STRING" or "NUMBER".
         */
        rangeKeyType?: string;
        /**
         * The range key value.
         */
        rangeKeyValue?: string;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    interface TopicRuleErrorActionDynamodbv2 {
        /**
         * Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
         */
        putItem?: outputs.iot.TopicRuleErrorActionDynamodbv2PutItem;
        /**
         * The ARN of the IAM role that grants access to the DynamoDB table.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionDynamodbv2PutItem {
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }
    interface TopicRuleErrorActionElasticsearch {
        /**
         * The endpoint of your Elasticsearch domain.
         */
        endpoint: string;
        /**
         * The unique identifier for the document you are storing.
         */
        id: string;
        /**
         * The Elasticsearch index where you want to store your data.
         */
        index: string;
        /**
         * The IAM role ARN that has access to Elasticsearch.
         */
        roleArn: string;
        /**
         * The type of document you are storing.
         */
        type: string;
    }
    interface TopicRuleErrorActionFirehose {
        /**
         * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
         */
        batchMode?: boolean;
        /**
         * The delivery stream name.
         */
        deliveryStreamName: string;
        /**
         * The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
         */
        roleArn: string;
        /**
         * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }
    interface TopicRuleErrorActionHttp {
        /**
         * The HTTPS URL used to verify ownership of `url`.
         */
        confirmationUrl?: string;
        /**
         * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
         */
        httpHeaders?: outputs.iot.TopicRuleErrorActionHttpHttpHeader[];
        /**
         * The HTTPS URL.
         */
        url: string;
    }
    interface TopicRuleErrorActionHttpHttpHeader {
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }
    interface TopicRuleErrorActionIotAnalytics {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
         */
        batchMode?: boolean;
        /**
         * Name of AWS IOT Analytics channel.
         */
        channelName: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionIotEvents {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
         */
        batchMode?: boolean;
        /**
         * The name of the AWS IoT Events input.
         */
        inputName: string;
        /**
         * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
         */
        messageId?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionKafka {
        /**
         * Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
         */
        clientProperties: {
            [key: string]: string;
        };
        /**
         * The ARN of Kafka action's VPC `aws.iot.TopicRuleDestination`.
         */
        destinationArn: string;
        /**
         * The list of Kafka headers that you specify. Nested arguments below.
         */
        headers?: outputs.iot.TopicRuleErrorActionKafkaHeader[];
        /**
         * The Kafka message key.
         */
        key?: string;
        /**
         * The Kafka message partition.
         */
        partition?: string;
        /**
         * The Kafka topic for messages to be sent to the Kafka broker.
         */
        topic: string;
    }
    interface TopicRuleErrorActionKafkaHeader {
        /**
         * The key of the Kafka header.
         */
        key: string;
        /**
         * The value of the Kafka header.
         */
        value: string;
    }
    interface TopicRuleErrorActionKinesis {
        /**
         * The partition key.
         */
        partitionKey?: string;
        /**
         * The ARN of the IAM role that grants access to the Amazon Kinesis stream.
         */
        roleArn: string;
        /**
         * The name of the Amazon Kinesis stream.
         */
        streamName: string;
    }
    interface TopicRuleErrorActionLambda {
        /**
         * The ARN of the Lambda function.
         */
        functionArn: string;
    }
    interface TopicRuleErrorActionRepublish {
        /**
         * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
         */
        qos?: number;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The name of the MQTT topic the message should be republished to.
         */
        topic: string;
    }
    interface TopicRuleErrorActionS3 {
        /**
         * The Amazon S3 bucket name.
         */
        bucketName: string;
        /**
         * The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
         */
        cannedAcl?: string;
        /**
         * The object key.
         */
        key: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleErrorActionSns {
        /**
         * The message format of the message to publish. Accepted values are "JSON" and "RAW".
         */
        messageFormat?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The ARN of the SNS topic.
         */
        targetArn: string;
    }
    interface TopicRuleErrorActionSqs {
        /**
         * The URL of the Amazon SQS queue.
         */
        queueUrl: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * Specifies whether to use Base64 encoding.
         */
        useBase64: boolean;
    }
    interface TopicRuleErrorActionStepFunctions {
        /**
         * The prefix used to generate, along with a UUID, the unique state machine execution name.
         */
        executionNamePrefix?: string;
        /**
         * The ARN of the IAM role that grants access to start execution of the state machine.
         */
        roleArn: string;
        /**
         * The name of the Step Functions state machine whose execution will be started.
         */
        stateMachineName: string;
    }
    interface TopicRuleErrorActionTimestream {
        /**
         * The name of an Amazon Timestream database.
         */
        databaseName: string;
        /**
         * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
         */
        dimensions: outputs.iot.TopicRuleErrorActionTimestreamDimension[];
        /**
         * The ARN of the role that grants permission to write to the Amazon Timestream database table.
         */
        roleArn: string;
        /**
         * The name of the database table into which to write the measure records.
         */
        tableName: string;
        /**
         * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
         */
        timestamp?: outputs.iot.TopicRuleErrorActionTimestreamTimestamp;
    }
    interface TopicRuleErrorActionTimestreamDimension {
        /**
         * The metadata dimension name. This is the name of the column in the Amazon Timestream database table record.
         */
        name: string;
        /**
         * The value to write in this column of the database record.
         */
        value: string;
    }
    interface TopicRuleErrorActionTimestreamTimestamp {
        /**
         * The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
         */
        unit: string;
        /**
         * An expression that returns a long epoch time value.
         */
        value: string;
    }
    interface TopicRuleFirehose {
        /**
         * The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
         */
        batchMode?: boolean;
        /**
         * The delivery stream name.
         */
        deliveryStreamName: string;
        /**
         * The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
         */
        roleArn: string;
        /**
         * A character separator that is used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }
    interface TopicRuleHttp {
        /**
         * The HTTPS URL used to verify ownership of `url`.
         */
        confirmationUrl?: string;
        /**
         * Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
         */
        httpHeaders?: outputs.iot.TopicRuleHttpHttpHeader[];
        /**
         * The HTTPS URL.
         */
        url: string;
    }
    interface TopicRuleHttpHttpHeader {
        /**
         * The name of the HTTP header.
         */
        key: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }
    interface TopicRuleIotAnalytic {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
         */
        batchMode?: boolean;
        /**
         * Name of AWS IOT Analytics channel.
         */
        channelName: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleIotEvent {
        /**
         * The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
         */
        batchMode?: boolean;
        /**
         * The name of the AWS IoT Events input.
         */
        inputName: string;
        /**
         * Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
         */
        messageId?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleKafka {
        /**
         * Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
         */
        clientProperties: {
            [key: string]: string;
        };
        /**
         * The ARN of Kafka action's VPC `aws.iot.TopicRuleDestination`.
         */
        destinationArn: string;
        /**
         * The list of Kafka headers that you specify. Nested arguments below.
         */
        headers?: outputs.iot.TopicRuleKafkaHeader[];
        /**
         * The Kafka message key.
         */
        key?: string;
        /**
         * The Kafka message partition.
         */
        partition?: string;
        /**
         * The Kafka topic for messages to be sent to the Kafka broker.
         */
        topic: string;
    }
    interface TopicRuleKafkaHeader {
        /**
         * The key of the Kafka header.
         */
        key: string;
        /**
         * The value of the Kafka header.
         */
        value: string;
    }
    interface TopicRuleKinesis {
        /**
         * The partition key.
         */
        partitionKey?: string;
        /**
         * The ARN of the IAM role that grants access to the Amazon Kinesis stream.
         */
        roleArn: string;
        /**
         * The name of the Amazon Kinesis stream.
         */
        streamName: string;
    }
    interface TopicRuleLambda {
        /**
         * The ARN of the Lambda function.
         */
        functionArn: string;
    }
    interface TopicRuleRepublish {
        /**
         * The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
         */
        qos?: number;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The name of the MQTT topic the message should be republished to.
         */
        topic: string;
    }
    interface TopicRuleS3 {
        /**
         * The Amazon S3 bucket name.
         */
        bucketName: string;
        /**
         * The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
         */
        cannedAcl?: string;
        /**
         * The object key.
         */
        key: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
    }
    interface TopicRuleSns {
        /**
         * The message format of the message to publish. Accepted values are "JSON" and "RAW".
         */
        messageFormat?: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * The ARN of the SNS topic.
         */
        targetArn: string;
    }
    interface TopicRuleSqs {
        /**
         * The URL of the Amazon SQS queue.
         */
        queueUrl: string;
        /**
         * The ARN of the IAM role that grants access.
         */
        roleArn: string;
        /**
         * Specifies whether to use Base64 encoding.
         */
        useBase64: boolean;
    }
    interface TopicRuleStepFunction {
        /**
         * The prefix used to generate, along with a UUID, the unique state machine execution name.
         */
        executionNamePrefix?: string;
        /**
         * The ARN of the IAM role that grants access to start execution of the state machine.
         */
        roleArn: string;
        /**
         * The name of the Step Functions state machine whose execution will be started.
         */
        stateMachineName: string;
    }
    interface TopicRuleTimestream {
        /**
         * The name of an Amazon Timestream database.
         */
        databaseName: string;
        /**
         * Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
         */
        dimensions: outputs.iot.TopicRuleTimestreamDimension[];
        /**
         * The ARN of the role that grants permission to write to the Amazon Timestream database table.
         */
        roleArn: string;
        /**
         * The name of the database table into which to write the measure records.
         */
        tableName: string;
        /**
         * Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
         */
        timestamp?: outputs.iot.TopicRuleTimestreamTimestamp;
    }
    interface TopicRuleTimestreamDimension {
        /**
         * The metadata dimension name. This is the name of the column in the Amazon Timestream database table record.
         */
        name: string;
        /**
         * The value to write in this column of the database record.
         */
        value: string;
    }
    interface TopicRuleTimestreamTimestamp {
        /**
         * The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
         */
        unit: string;
        /**
         * An expression that returns a long epoch time value.
         */
        value: string;
    }
}
export declare namespace ivs {
    interface RecordingConfigurationDestinationConfiguration {
        /**
         * S3 destination configuration where recorded videos will be stored.
         */
        s3: outputs.ivs.RecordingConfigurationDestinationConfigurationS3;
    }
    interface RecordingConfigurationDestinationConfigurationS3 {
        /**
         * S3 bucket name where recorded videos will be stored.
         *
         * The following arguments are optional:
         */
        bucketName: string;
    }
    interface RecordingConfigurationThumbnailConfiguration {
        /**
         * Thumbnail recording mode. Valid values: `DISABLED`, `INTERVAL`.
         */
        recordingMode: string;
        /**
         * The targeted thumbnail-generation interval in seconds.
         */
        targetIntervalSeconds: number;
    }
}
export declare namespace ivschat {
    interface LoggingConfigurationDestinationConfiguration {
        /**
         * An Amazon CloudWatch Logs destination configuration where chat activity will be logged.
         */
        cloudwatchLogs?: outputs.ivschat.LoggingConfigurationDestinationConfigurationCloudwatchLogs;
        /**
         * An Amazon Kinesis Data Firehose destination configuration where chat activity will be logged.
         */
        firehose?: outputs.ivschat.LoggingConfigurationDestinationConfigurationFirehose;
        /**
         * An Amazon S3 destination configuration where chat activity will be logged.
         */
        s3?: outputs.ivschat.LoggingConfigurationDestinationConfigurationS3;
    }
    interface LoggingConfigurationDestinationConfigurationCloudwatchLogs {
        /**
         * Name of the Amazon Cloudwatch Logs destination where chat activity will be logged.
         */
        logGroupName: string;
    }
    interface LoggingConfigurationDestinationConfigurationFirehose {
        /**
         * Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
         */
        deliveryStreamName: string;
    }
    interface LoggingConfigurationDestinationConfigurationS3 {
        /**
         * Name of the Amazon S3 bucket where chat activity will be logged.
         *
         * The following arguments are optional:
         */
        bucketName: string;
    }
    interface RoomMessageReviewHandler {
        /**
         * The fallback behavior (whether the message
         * is allowed or denied) if the handler does not return a valid response,
         * encounters an error, or times out. Valid values: `ALLOW`, `DENY`.
         */
        fallbackResult: string;
        /**
         * ARN of the lambda message review handler function.
         */
        uri?: string;
    }
}
export declare namespace kendra {
    interface DataSourceConfiguration {
        /**
         * A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
         */
        s3Configuration?: outputs.kendra.DataSourceConfigurationS3Configuration;
        /**
         * A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
         */
        webCrawlerConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfiguration;
    }
    interface DataSourceConfigurationS3Configuration {
        /**
         * A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see [Access control for S3 data sources](https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html). Detailed below.
         */
        accessControlListConfiguration?: outputs.kendra.DataSourceConfigurationS3ConfigurationAccessControlListConfiguration;
        /**
         * The name of the bucket that contains the documents.
         */
        bucketName: string;
        /**
         * A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
         */
        documentsMetadataConfiguration?: outputs.kendra.DataSourceConfigurationS3ConfigurationDocumentsMetadataConfiguration;
        /**
         * A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to [Exclusion Patterns for more examples](https://docs.aws.amazon.com/kendra/latest/dg/API_S3DataSourceConfiguration.html#Kendra-Type-S3DataSourceConfiguration-ExclusionPatterns).
         */
        exclusionPatterns?: string[];
        /**
         * A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to [Inclusion Patterns for more examples](https://docs.aws.amazon.com/kendra/latest/dg/API_S3DataSourceConfiguration.html#Kendra-Type-S3DataSourceConfiguration-InclusionPatterns).
         */
        inclusionPatterns?: string[];
        /**
         * A list of S3 prefixes for the documents that should be included in the index.
         */
        inclusionPrefixes?: string[];
    }
    interface DataSourceConfigurationS3ConfigurationAccessControlListConfiguration {
        /**
         * Path to the AWS S3 bucket that contains the ACL files.
         */
        keyPath?: string;
    }
    interface DataSourceConfigurationS3ConfigurationDocumentsMetadataConfiguration {
        /**
         * A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use `s3Prefix` to include only the desired metadata files.
         */
        s3Prefix?: string;
    }
    interface DataSourceConfigurationWebCrawlerConfiguration {
        /**
         * A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"` and the port is `443`, the standard port for HTTPS. Detailed below.
         */
        authenticationConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfiguration;
        /**
         * Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to `2`. Minimum value of `0`. Maximum value of `10`.
         */
        crawlDepth?: number;
        /**
         * The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to `50` MB. Minimum value of `1.0e-06`. Maximum value of `50`.
         */
        maxContentSizePerPageInMegaBytes?: number;
        /**
         * The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is `100`. Minimum value of `1`. Maximum value of `1000`.
         */
        maxLinksPerPage?: number;
        /**
         * The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is `300`. Minimum value of `1`. Maximum value of `300`.
         */
        maxUrlsPerMinuteCrawlRate?: number;
        /**
         * Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"` and the port is `443`, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html). Detailed below.
         */
        proxyConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationProxyConfiguration;
        /**
         * A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `150`.
         */
        urlExclusionPatterns?: string[];
        /**
         * A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `150`.
         */
        urlInclusionPatterns?: string[];
        /**
         * A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to `100` seed URLs and up to `3` sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the [Amazon Acceptable Use Policy](https://aws.amazon.com/aup/) and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
         */
        urls: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrls;
    }
    interface DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
        /**
         * The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
         */
        basicAuthentications?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication[];
    }
    interface DataSourceConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication {
        /**
         * Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
         */
        credentials: string;
        /**
         * The name of the website host you want to connect to using authentication credentials. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"`.
         */
        host: string;
        /**
         * The port number of the website host you want to connect to using authentication credentials. For example, the port for `https://a.example.com/page1.html` is `443`, the standard port for HTTPS.
         */
        port: number;
    }
    interface DataSourceConfigurationWebCrawlerConfigurationProxyConfiguration {
        /**
         * Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.
         */
        credentials?: string;
        /**
         * The name of the website host you want to connect to via a web proxy server. For example, the host name of `https://a.example.com/page1.html` is `"a.example.com"`.
         */
        host: string;
        /**
         * The port number of the website host you want to connect to via a web proxy server. For example, the port for `https://a.example.com/page1.html` is `443`, the standard port for HTTPS.
         */
        port: number;
    }
    interface DataSourceConfigurationWebCrawlerConfigurationUrls {
        /**
         * A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to `100` seed URLs. Detailed below.
         */
        seedUrlConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration;
        /**
         * A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to `3` sitemap URLs. Detailed below.
         */
        siteMapsConfiguration?: outputs.kendra.DataSourceConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration;
    }
    interface DataSourceConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
        /**
         * The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of `100` seed URLs. Array Members: Minimum number of `0` items. Maximum number of `100` items. Length Constraints: Minimum length of `1`. Maximum length of `2048`.
         */
        seedUrls: string[];
        /**
         * The default mode is set to `HOST_ONLY`. You can choose one of the following modes:
         * * `HOST_ONLY` – crawl only the website host names. For example, if the seed URL is `"abc.example.com"`, then only URLs with host name `"abc.example.com"` are crawled.
         * * `SUBDOMAINS` – crawl the website host names with subdomains. For example, if the seed URL is `"abc.example.com"`, then `"a.abc.example.com"` and `"b.abc.example.com"` are also crawled.
         * * `EVERYTHING` – crawl the website host names with subdomains and other domains that the webpages link to.
         */
        webCrawlerMode?: string;
    }
    interface DataSourceConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
        /**
         * The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of `3` sitemap URLs.
         */
        siteMaps: string[];
    }
    interface DataSourceCustomDocumentEnrichmentConfiguration {
        /**
         * Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of `0` items. Maximum number of `100` items. Detailed below.
         */
        inlineConfigurations?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfiguration[];
        /**
         * A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation). Detailed below.
         */
        postExtractionHookConfiguration?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration;
        /**
         * Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Advanced data manipulation](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation). Detailed below.
         */
        preExtractionHookConfiguration?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration;
        /**
         * The Amazon Resource Name (ARN) of a role with permission to run `preExtractionHookConfiguration` and `postExtractionHookConfiguration` for altering document metadata and content during the document ingestion process. For more information, see [IAM roles for Amazon Kendra](https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html).
         */
        roleArn?: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfiguration {
        /**
         * Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition.
         */
        condition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationCondition;
        /**
         * `TRUE` to delete content if the condition used for the target attribute is met.
         */
        documentContentDeletion?: boolean;
        /**
         * Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
         */
        target?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTarget;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTarget {
        /**
         * The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
         */
        targetDocumentAttributeKey?: string;
        /**
         * The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.
         */
        targetDocumentAttributeValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTargetTargetDocumentAttributeValue;
        /**
         * `TRUE` to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to `TRUE`. To create a target value (`TargetDocumentAttributeValue`), set this to `FALSE`.
         */
        targetDocumentAttributeValueDeletion?: boolean;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationInlineConfigurationTargetTargetDocumentAttributeValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
        /**
         * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
         */
        invocationCondition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition;
        /**
         * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
         */
        lambdaArn: string;
        /**
         * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda).
         */
        s3Bucket: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
        /**
         * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition.
         */
        invocationCondition?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition;
        /**
         * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
         */
        lambdaArn: string;
        /**
         * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda).
         */
        s3Bucket: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
        /**
         * The identifier of the document attribute used for the condition. For example, `_source_uri` could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support `_document_body` as an attribute key used for the condition.
         */
        conditionDocumentAttributeKey: string;
        /**
         * The value used by the operator. For example, you can specify the value 'financial' for strings in the `_source_uri` field that partially match or contain this value. See condition_on_value.
         */
        conditionOnValue?: outputs.kendra.DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue;
        /**
         * The condition operator. For example, you can use `Contains` to partially match a string. Valid Values: `GreaterThan` | `GreaterThanOrEquals` | `LessThan` | `LessThanOrEquals` | `Equals` | `NotEquals` | `Contains` | `NotContains` | `Exists` | `NotExists` | `BeginsWith`.
         */
        operator: string;
    }
    interface DataSourceCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue {
        /**
         * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, `2012-03-25T12:30:10+00:00`.
         */
        dateValue?: string;
        /**
         * A long integer value.
         */
        longValue?: number;
        /**
         * A list of strings.
         */
        stringListValues?: string[];
        stringValue?: string;
    }
    interface ExperienceConfiguration {
        /**
         * The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the `BatchPutDocument API`. The provider will only perform drift detection of its value when present in a configuration. Detailed below.
         */
        contentSourceConfiguration: outputs.kendra.ExperienceConfigurationContentSourceConfiguration;
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails. Detailed below.
         */
        userIdentityConfiguration?: outputs.kendra.ExperienceConfigurationUserIdentityConfiguration;
    }
    interface ExperienceConfigurationContentSourceConfiguration {
        /**
         * The identifiers of the data sources you want to use for your Amazon Kendra experience. Maximum number of 100 items.
         */
        dataSourceIds?: string[];
        /**
         * Whether to use documents you indexed directly using the `BatchPutDocument API`. Defaults to `false`.
         */
        directPutContent?: boolean;
        /**
         * The identifier of the FAQs that you want to use for your Amazon Kendra experience. Maximum number of 100 items.
         */
        faqIds?: string[];
    }
    interface ExperienceConfigurationUserIdentityConfiguration {
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails.
         */
        identityAttributeName: string;
    }
    interface ExperienceEndpoint {
        /**
         * The endpoint of your Amazon Kendra experience.
         */
        endpoint: string;
        /**
         * The type of endpoint for your Amazon Kendra experience.
         */
        endpointType: string;
    }
    interface FaqS3Path {
        /**
         * The name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * The name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }
    interface GetExperienceConfiguration {
        /**
         * The identifiers of your data sources and FAQs. This is the content you want to use for your Amazon Kendra Experience. Documented below.
         */
        contentSourceConfigurations: outputs.kendra.GetExperienceConfigurationContentSourceConfiguration[];
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails. Documented below.
         */
        userIdentityConfigurations: outputs.kendra.GetExperienceConfigurationUserIdentityConfiguration[];
    }
    interface GetExperienceConfigurationContentSourceConfiguration {
        /**
         * Identifiers of the data sources you want to use for your Amazon Kendra Experience.
         */
        dataSourceIds: string[];
        /**
         * Whether to use documents you indexed directly using the `BatchPutDocument API`.
         */
        directPutContent: boolean;
        /**
         * Identifier of the FAQs that you want to use for your Amazon Kendra Experience.
         */
        faqIds: string[];
    }
    interface GetExperienceConfigurationUserIdentityConfiguration {
        /**
         * The AWS SSO field name that contains the identifiers of your users, such as their emails.
         */
        identityAttributeName: string;
    }
    interface GetExperienceEndpoint {
        /**
         * Endpoint of your Amazon Kendra Experience.
         */
        endpoint: string;
        /**
         * Type of endpoint for your Amazon Kendra Experience.
         */
        endpointType: string;
    }
    interface GetFaqS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }
    interface GetIndexCapacityUnit {
        /**
         * The amount of extra query capacity for an index and GetQuerySuggestions capacity. For more information, refer to [QueryCapacityUnits](https://docs.aws.amazon.com/kendra/latest/APIReference/API_CapacityUnitsConfiguration.html#Kendra-Type-CapacityUnitsConfiguration-QueryCapacityUnits).
         */
        queryCapacityUnits: number;
        /**
         * The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. Minimum value of 0.
         */
        storageCapacityUnits: number;
    }
    interface GetIndexDocumentMetadataConfigurationUpdate {
        /**
         * Name of the index field. Minimum length of 1. Maximum length of 30.
         */
        name: string;
        /**
         * Block that provides manual tuning parameters to determine how the field affects the search results. Documented below.
         */
        relevances: outputs.kendra.GetIndexDocumentMetadataConfigurationUpdateRelevance[];
        /**
         * Block that provides information about how the field is used during a search. Documented below.
         */
        searches: outputs.kendra.GetIndexDocumentMetadataConfigurationUpdateSearch[];
        /**
         * Data type of the index field. Valid values are `STRING_VALUE`, `STRING_LIST_VALUE`, `LONG_VALUE`, `DATE_VALUE`.
         */
        type: string;
    }
    interface GetIndexDocumentMetadataConfigurationUpdateRelevance {
        /**
         * Time period that the boost applies to. For more information, refer to [Duration](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-Duration).
         */
        duration: string;
        /**
         * How "fresh" a document is. For more information, refer to [Freshness](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-Freshness).
         */
        freshness: boolean;
        /**
         * Relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers. Minimum value of 1. Maximum value of 10.
         */
        importance: number;
        /**
         * Determines how values should be interpreted. For more information, refer to [RankOrder](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-RankOrder).
         */
        rankOrder: string;
        /**
         * A list of values that should be given a different boost when they appear in the result list. For more information, refer to [ValueImportanceMap](https://docs.aws.amazon.com/kendra/latest/APIReference/API_Relevance.html#Kendra-Type-Relevance-ValueImportanceMap).
         */
        valuesImportanceMap: {
            [key: string]: number;
        };
    }
    interface GetIndexDocumentMetadataConfigurationUpdateSearch {
        /**
         * Determines whether the field is returned in the query response. The default is `true`.
         */
        displayable: boolean;
        /**
         * Whether the field can be used to create search facets, a count of results for each value in the field. The default is `false`.
         */
        facetable: boolean;
        /**
         * Determines whether the field is used in the search. If the Searchable field is true, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is `true` for `string` fields and `false` for `number` and `date` fields.
         */
        searchable: boolean;
        /**
         * Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have Sortable set to true, Amazon Kendra returns an exception. The default is `false`.
         */
        sortable: boolean;
    }
    interface GetIndexIndexStatistic {
        /**
         * Block that specifies the number of question and answer topics in the index. Documented below.
         */
        faqStatistics: outputs.kendra.GetIndexIndexStatisticFaqStatistic[];
        /**
         * A block that specifies the number of text documents indexed.
         */
        textDocumentStatistics: outputs.kendra.GetIndexIndexStatisticTextDocumentStatistic[];
    }
    interface GetIndexIndexStatisticFaqStatistic {
        /**
         * The total number of FAQ questions and answers contained in the index.
         */
        indexedQuestionAnswersCount: number;
    }
    interface GetIndexIndexStatisticTextDocumentStatistic {
        /**
         * Total size, in bytes, of the indexed documents.
         */
        indexedTextBytes: number;
        /**
         * The number of text documents indexed.
         */
        indexedTextDocumentsCount: number;
    }
    interface GetIndexServerSideEncryptionConfiguration {
        /**
         * Identifier of the AWS KMScustomer master key (CMK). Amazon Kendra doesn't support asymmetric CMKs.
         */
        kmsKeyId: string;
    }
    interface GetIndexUserGroupResolutionConfiguration {
        /**
         * The identity store provider (mode) you want to use to fetch access levels of groups and users. AWS Single Sign-On is currently the only available mode. Your users and groups must exist in an AWS SSO identity source in order to use this mode. Valid Values are `AWS_SSO` or `NONE`.
         */
        userGroupResolutionMode: string;
    }
    interface GetIndexUserTokenConfiguration {
        /**
         * A block that specifies the information about the JSON token type configuration.
         */
        jsonTokenTypeConfigurations: outputs.kendra.GetIndexUserTokenConfigurationJsonTokenTypeConfiguration[];
        /**
         * A block that specifies the information about the JWT token type configuration.
         */
        jwtTokenTypeConfigurations: outputs.kendra.GetIndexUserTokenConfigurationJwtTokenTypeConfiguration[];
    }
    interface GetIndexUserTokenConfigurationJsonTokenTypeConfiguration {
        /**
         * The group attribute field.
         */
        groupAttributeField: string;
        /**
         * The user name attribute field.
         */
        userNameAttributeField: string;
    }
    interface GetIndexUserTokenConfigurationJwtTokenTypeConfiguration {
        /**
         * Regular expression that identifies the claim.
         */
        claimRegex: string;
        /**
         * The group attribute field.
         */
        groupAttributeField: string;
        /**
         * Issuer of the token.
         */
        issuer: string;
        /**
         * Location of the key. Valid values are `URL` or `SECRET_MANAGER`
         */
        keyLocation: string;
        /**
         * ARN of the secret.
         */
        secretsManagerArn: string;
        /**
         * Signing key URL.
         */
        url: string;
        /**
         * The user name attribute field.
         */
        userNameAttributeField: string;
    }
    interface GetQuerySuggestionsBlockListSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }
    interface GetThesaurusSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         */
        key: string;
    }
    interface IndexCapacityUnits {
        /**
         * The amount of extra query capacity for an index and GetQuerySuggestions capacity. For more information, refer to [QueryCapacityUnits](https://docs.aws.amazon.com/kendra/latest/dg/API_CapacityUnitsConfiguration.html#Kendra-Type-CapacityUnitsConfiguration-QueryCapacityUnits).
         */
        queryCapacityUnits: number;
        /**
         * The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. Minimum value of 0.
         */
        storageCapacityUnits: number;
    }
    interface IndexDocumentMetadataConfigurationUpdate {
        /**
         * The name of the index field. Minimum length of 1. Maximum length of 30.
         */
        name: string;
        /**
         * A block that provides manual tuning parameters to determine how the field affects the search results. Detailed below
         */
        relevance: outputs.kendra.IndexDocumentMetadataConfigurationUpdateRelevance;
        /**
         * A block that provides information about how the field is used during a search. Documented below. Detailed below
         */
        search: outputs.kendra.IndexDocumentMetadataConfigurationUpdateSearch;
        /**
         * The data type of the index field. Valid values are `STRING_VALUE`, `STRING_LIST_VALUE`, `LONG_VALUE`, `DATE_VALUE`.
         */
        type: string;
    }
    interface IndexDocumentMetadataConfigurationUpdateRelevance {
        /**
         * Specifies the time period that the boost applies to. For more information, refer to [Duration](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-Duration).
         */
        duration: string;
        /**
         * Indicates that this field determines how "fresh" a document is. For more information, refer to [Freshness](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-Freshness).
         */
        freshness: boolean;
        /**
         * The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers. Minimum value of 1. Maximum value of 10.
         */
        importance: number;
        /**
         * Determines how values should be interpreted. For more information, refer to [RankOrder](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-RankOrder).
         */
        rankOrder: string;
        /**
         * A list of values that should be given a different boost when they appear in the result list. For more information, refer to [ValueImportanceMap](https://docs.aws.amazon.com/kendra/latest/dg/API_Relevance.html#Kendra-Type-Relevance-ValueImportanceMap).
         */
        valuesImportanceMap: {
            [key: string]: number;
        };
    }
    interface IndexDocumentMetadataConfigurationUpdateSearch {
        /**
         * Determines whether the field is returned in the query response. The default is `true`.
         */
        displayable: boolean;
        /**
         * Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is `false`.
         */
        facetable: boolean;
        /**
         * Determines whether the field is used in the search. If the Searchable field is true, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is `true` for `string` fields and `false` for `number` and `date` fields.
         */
        searchable: boolean;
        /**
         * Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have Sortable set to true, Amazon Kendra returns an exception. The default is `false`.
         */
        sortable: boolean;
    }
    interface IndexIndexStatistic {
        /**
         * A block that specifies the number of question and answer topics in the index. Detailed below.
         */
        faqStatistics: outputs.kendra.IndexIndexStatisticFaqStatistic[];
        /**
         * A block that specifies the number of text documents indexed. Detailed below.
         */
        textDocumentStatistics: outputs.kendra.IndexIndexStatisticTextDocumentStatistic[];
    }
    interface IndexIndexStatisticFaqStatistic {
        /**
         * The total number of FAQ questions and answers contained in the index.
         */
        indexedQuestionAnswersCount: number;
    }
    interface IndexIndexStatisticTextDocumentStatistic {
        /**
         * The total size, in bytes, of the indexed documents.
         */
        indexedTextBytes: number;
        /**
         * The number of text documents indexed.
         */
        indexedTextDocumentsCount: number;
    }
    interface IndexServerSideEncryptionConfiguration {
        /**
         * The identifier of the AWS KMScustomer master key (CMK). Amazon Kendra doesn't support asymmetric CMKs.
         */
        kmsKeyId?: string;
    }
    interface IndexUserGroupResolutionConfiguration {
        /**
         * The identity store provider (mode) you want to use to fetch access levels of groups and users. AWS Single Sign-On is currently the only available mode. Your users and groups must exist in an AWS SSO identity source in order to use this mode. Valid Values are `AWS_SSO` or `NONE`.
         */
        userGroupResolutionMode: string;
    }
    interface IndexUserTokenConfigurations {
        /**
         * A block that specifies the information about the JSON token type configuration. Detailed below.
         */
        jsonTokenTypeConfiguration?: outputs.kendra.IndexUserTokenConfigurationsJsonTokenTypeConfiguration;
        /**
         * A block that specifies the information about the JWT token type configuration. Detailed below.
         */
        jwtTokenTypeConfiguration?: outputs.kendra.IndexUserTokenConfigurationsJwtTokenTypeConfiguration;
    }
    interface IndexUserTokenConfigurationsJsonTokenTypeConfiguration {
        /**
         * The group attribute field. Minimum length of 1. Maximum length of 2048.
         */
        groupAttributeField: string;
        /**
         * The user name attribute field. Minimum length of 1. Maximum length of 2048.
         */
        userNameAttributeField: string;
    }
    interface IndexUserTokenConfigurationsJwtTokenTypeConfiguration {
        /**
         * The regular expression that identifies the claim. Minimum length of 1. Maximum length of 100.
         */
        claimRegex?: string;
        /**
         * The group attribute field. Minimum length of 1. Maximum length of 100.
         */
        groupAttributeField?: string;
        /**
         * The issuer of the token. Minimum length of 1. Maximum length of 65.
         */
        issuer?: string;
        /**
         * The location of the key. Valid values are `URL` or `SECRET_MANAGER`
         */
        keyLocation: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretsManagerArn?: string;
        /**
         * The signing key URL. Valid pattern is `^(https?|ftp|file):\/\/([^\s]*)`
         */
        url?: string;
        /**
         * The user name attribute field. Minimum length of 1. Maximum length of 100.
         */
        userNameAttributeField?: string;
    }
    interface QuerySuggestionsBlockListSourceS3Path {
        /**
         * Name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * Name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }
    interface ThesaurusSourceS3Path {
        /**
         * The name of the S3 bucket that contains the file.
         */
        bucket: string;
        /**
         * The name of the file.
         *
         * The following arguments are optional:
         */
        key: string;
    }
}
export declare namespace keyspaces {
    interface TableCapacitySpecification {
        /**
         * The throughput capacity specified for read operations defined in read capacity units (RCUs).
         */
        readCapacityUnits?: number;
        /**
         * The read/write throughput capacity mode for a table. Valid values: `PAY_PER_REQUEST`, `PROVISIONED`. The default value is `PAY_PER_REQUEST`.
         */
        throughputMode: string;
        /**
         * The throughput capacity specified for write operations defined in write capacity units (WCUs).
         */
        writeCapacityUnits?: number;
    }
    interface TableClientSideTimestamps {
        /**
         * Shows how to enable client-side timestamps settings for the specified table. Valid values: `ENABLED`.
         */
        status: string;
    }
    interface TableComment {
        /**
         * A description of the table.
         */
        message: string;
    }
    interface TableEncryptionSpecification {
        /**
         * The Amazon Resource Name (ARN) of the customer managed KMS key.
         */
        kmsKeyIdentifier?: string;
        /**
         * The encryption option specified for the table. Valid values: `AWS_OWNED_KMS_KEY`, `CUSTOMER_MANAGED_KMS_KEY`. The default value is `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }
    interface TablePointInTimeRecovery {
        /**
         * Valid values: `ENABLED`, `DISABLED`. The default value is `DISABLED`.
         */
        status: string;
    }
    interface TableSchemaDefinition {
        /**
         * The columns that are part of the clustering key of the table.
         */
        clusteringKeys?: outputs.keyspaces.TableSchemaDefinitionClusteringKey[];
        /**
         * The regular columns of the table.
         */
        columns: outputs.keyspaces.TableSchemaDefinitionColumn[];
        /**
         * The columns that are part of the partition key of the table .
         */
        partitionKeys: outputs.keyspaces.TableSchemaDefinitionPartitionKey[];
        /**
         * The columns that have been defined as `STATIC`. Static columns store values that are shared by all rows in the same partition.
         */
        staticColumns?: outputs.keyspaces.TableSchemaDefinitionStaticColumn[];
    }
    interface TableSchemaDefinitionClusteringKey {
        /**
         * The name of the clustering key column.
         */
        name: string;
        /**
         * The order modifier. Valid values: `ASC`, `DESC`.
         */
        orderBy: string;
    }
    interface TableSchemaDefinitionColumn {
        /**
         * The name of the column.
         */
        name: string;
        /**
         * The data type of the column. See the [Developer Guide](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) for a list of available data types.
         */
        type: string;
    }
    interface TableSchemaDefinitionPartitionKey {
        /**
         * The name of the partition key column.
         */
        name: string;
    }
    interface TableSchemaDefinitionStaticColumn {
        /**
         * The name of the static column.
         */
        name: string;
    }
    interface TableTtl {
        /**
         * Valid values: `ENABLED`.
         */
        status: string;
    }
}
export declare namespace kinesis {
    interface AnalyticsApplicationCloudwatchLoggingOptions {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The ARN of the CloudWatch Log Stream.
         */
        logStreamArn: string;
        /**
         * The ARN of the IAM Role used to send application messages.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationInputs {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The Kinesis Firehose configuration for the streaming source. Conflicts with `kinesisStream`.
         * See Kinesis Firehose below for more details.
         */
        kinesisFirehose?: outputs.kinesis.AnalyticsApplicationInputsKinesisFirehose;
        /**
         * The Kinesis Stream configuration for the streaming source. Conflicts with `kinesisFirehose`.
         * See Kinesis Stream below for more details.
         */
        kinesisStream?: outputs.kinesis.AnalyticsApplicationInputsKinesisStream;
        /**
         * The Name Prefix to use when creating an in-application stream.
         */
        namePrefix: string;
        /**
         * The number of Parallel in-application streams to create.
         * See Parallelism below for more details.
         */
        parallelism: outputs.kinesis.AnalyticsApplicationInputsParallelism;
        /**
         * The Processing Configuration to transform records as they are received from the stream.
         * See Processing Configuration below for more details.
         */
        processingConfiguration?: outputs.kinesis.AnalyticsApplicationInputsProcessingConfiguration;
        /**
         * The Schema format of the data in the streaming source. See Source Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationInputsSchema;
        /**
         * The point at which the application starts processing records from the streaming source.
         * See Starting Position Configuration below for more details.
         */
        startingPositionConfigurations: outputs.kinesis.AnalyticsApplicationInputsStartingPositionConfiguration[];
        streamNames: string[];
    }
    interface AnalyticsApplicationInputsKinesisFirehose {
        /**
         * The ARN of the Kinesis Firehose delivery stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationInputsKinesisStream {
        /**
         * The ARN of the Kinesis Stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationInputsParallelism {
        /**
         * The Count of streams.
         */
        count: number;
    }
    interface AnalyticsApplicationInputsProcessingConfiguration {
        /**
         * The Lambda function configuration. See Lambda below for more details.
         */
        lambda: outputs.kinesis.AnalyticsApplicationInputsProcessingConfigurationLambda;
    }
    interface AnalyticsApplicationInputsProcessingConfigurationLambda {
        /**
         * The ARN of the Lambda function.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the Lambda function.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationInputsSchema {
        /**
         * The Record Column mapping for the streaming source data element.
         * See Record Columns below for more details.
         */
        recordColumns: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordColumn[];
        /**
         * The Encoding of the record in the streaming source.
         */
        recordEncoding?: string;
        /**
         * The Record Format and mapping information to schematize a record.
         * See Record Format below for more details.
         */
        recordFormat: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormat;
    }
    interface AnalyticsApplicationInputsSchemaRecordColumn {
        /**
         * The Mapping reference to the data element.
         */
        mapping?: string;
        /**
         * Name of the column.
         */
        name: string;
        /**
         * The SQL Type of the column.
         */
        sqlType: string;
    }
    interface AnalyticsApplicationInputsSchemaRecordFormat {
        /**
         * The Mapping Information for the record format.
         * See Mapping Parameters below for more details.
         */
        mappingParameters?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParameters;
        /**
         * The type of Record Format. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }
    interface AnalyticsApplicationInputsSchemaRecordFormatMappingParameters {
        /**
         * Mapping information when the record format uses delimiters.
         * See CSV Mapping Parameters below for more details.
         */
        csv?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParametersCsv;
        /**
         * Mapping information when JSON is the record format on the streaming source.
         * See JSON Mapping Parameters below for more details.
         */
        json?: outputs.kinesis.AnalyticsApplicationInputsSchemaRecordFormatMappingParametersJson;
    }
    interface AnalyticsApplicationInputsSchemaRecordFormatMappingParametersCsv {
        /**
         * The Column Delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The Row Delimiter.
         */
        recordRowDelimiter: string;
    }
    interface AnalyticsApplicationInputsSchemaRecordFormatMappingParametersJson {
        /**
         * Path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }
    interface AnalyticsApplicationInputsStartingPositionConfiguration {
        /**
         * The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
         */
        startingPosition: string;
    }
    interface AnalyticsApplicationOutput {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The Kinesis Firehose configuration for the destination stream. Conflicts with `kinesisStream`.
         * See Kinesis Firehose below for more details.
         */
        kinesisFirehose?: outputs.kinesis.AnalyticsApplicationOutputKinesisFirehose;
        /**
         * The Kinesis Stream configuration for the destination stream. Conflicts with `kinesisFirehose`.
         * See Kinesis Stream below for more details.
         */
        kinesisStream?: outputs.kinesis.AnalyticsApplicationOutputKinesisStream;
        /**
         * The Lambda function destination. See Lambda below for more details.
         */
        lambda?: outputs.kinesis.AnalyticsApplicationOutputLambda;
        /**
         * The Name of the in-application stream.
         */
        name: string;
        /**
         * The Schema format of the data written to the destination. See Destination Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationOutputSchema;
    }
    interface AnalyticsApplicationOutputKinesisFirehose {
        /**
         * The ARN of the Kinesis Firehose delivery stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationOutputKinesisStream {
        /**
         * The ARN of the Kinesis Stream.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the stream.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationOutputLambda {
        /**
         * The ARN of the Lambda function.
         */
        resourceArn: string;
        /**
         * The ARN of the IAM Role used to access the Lambda function.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationOutputSchema {
        /**
         * The Format Type of the records on the output stream. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }
    interface AnalyticsApplicationReferenceDataSources {
        /**
         * The ARN of the Kinesis Analytics Application.
         */
        id: string;
        /**
         * The S3 configuration for the reference data source. See S3 Reference below for more details.
         */
        s3: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesS3;
        /**
         * The Schema format of the data in the streaming source. See Source Schema below for more details.
         */
        schema: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchema;
        /**
         * The in-application Table Name.
         */
        tableName: string;
    }
    interface AnalyticsApplicationReferenceDataSourcesS3 {
        /**
         * The S3 Bucket ARN.
         */
        bucketArn: string;
        /**
         * The File Key name containing reference data.
         */
        fileKey: string;
        /**
         * The IAM Role ARN to read the data.
         */
        roleArn: string;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchema {
        /**
         * The Record Column mapping for the streaming source data element.
         * See Record Columns below for more details.
         */
        recordColumns: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordColumn[];
        /**
         * The Encoding of the record in the streaming source.
         */
        recordEncoding?: string;
        /**
         * The Record Format and mapping information to schematize a record.
         * See Record Format below for more details.
         */
        recordFormat: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormat;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchemaRecordColumn {
        /**
         * The Mapping reference to the data element.
         */
        mapping?: string;
        /**
         * Name of the column.
         */
        name: string;
        /**
         * The SQL Type of the column.
         */
        sqlType: string;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormat {
        /**
         * The Mapping Information for the record format.
         * See Mapping Parameters below for more details.
         */
        mappingParameters?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParameters;
        /**
         * The type of Record Format. Can be `CSV` or `JSON`.
         */
        recordFormatType: string;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParameters {
        /**
         * Mapping information when the record format uses delimiters.
         * See CSV Mapping Parameters below for more details.
         */
        csv?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersCsv;
        /**
         * Mapping information when JSON is the record format on the streaming source.
         * See JSON Mapping Parameters below for more details.
         */
        json?: outputs.kinesis.AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersJson;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersCsv {
        /**
         * The Column Delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The Row Delimiter.
         */
        recordRowDelimiter: string;
    }
    interface AnalyticsApplicationReferenceDataSourcesSchemaRecordFormatMappingParametersJson {
        /**
         * Path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 0 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationCloudwatchLoggingOptions;
        /**
         * The endpoint to use when communicating with the cluster. Conflicts with `domainArn`.
         */
        clusterEndpoint?: string;
        /**
         * The ARN of the Amazon ES domain.  The pattern needs to be `arn:.*`.  Conflicts with `clusterEndpoint`.
         */
        domainArn?: string;
        /**
         * The Elasticsearch index name.
         */
        indexName: string;
        /**
         * The Elasticsearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are `NoRotation`, `OneHour`, `OneDay`, `OneWeek`, and `OneMonth`.  The default value is `OneDay`.
         */
        indexRotationPeriod?: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Amazon Elasticsearch, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon ES Configuration API and for indexing documents.  The IAM role must have permission for `DescribeElasticsearchDomain`, `DescribeElasticsearchDomains`, and `DescribeElasticsearchDomainConfig`.  The pattern needs to be `arn:.*`.
         */
        roleArn: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDocumentsOnly` and `AllDocuments`.  Default value is `FailedDocumentsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationS3Configuration;
        /**
         * The Elasticsearch type name with maximum length of 100 characters.
         */
        typeName?: string;
        /**
         * The VPC configuration for the delivery stream to connect to Elastic Search associated with the VPC. See `vpcConfig` block below for details.
         */
        vpcConfig?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationVpcConfig;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamElasticsearchConfigurationVpcConfig {
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon EC2 configuration API and for creating network interfaces. Make sure role has necessary [IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-es-vpc)
         */
        roleArn: string;
        /**
         * A list of security group IDs to associate with Kinesis Firehose.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs to associate with Kinesis Firehose.
         */
        subnetIds: string[];
        vpcId: string;
    }
    interface FirehoseDeliveryStreamExtendedS3Configuration {
        bucketArn: string;
        bufferingInterval?: number;
        bufferingSize?: number;
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationCloudwatchLoggingOptions;
        compressionFormat?: string;
        /**
         * The time zone you prefer. Valid values are `UTC` or a non-3-letter IANA time zones (for example, `America/Los_Angeles`). Default value is `UTC`.
         */
        customTimeZone?: string;
        /**
         * Nested argument for the serializer, deserializer, and schema for converting data from the JSON format to the Parquet or ORC format before writing it to Amazon S3. See `dataFormatConversionConfiguration` block below for details.
         */
        dataFormatConversionConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfiguration;
        /**
         * The configuration for dynamic partitioning. Required when using [dynamic partitioning](https://docs.aws.amazon.com/firehose/latest/dev/dynamic-partitioning.html). See `dynamicPartitioningConfiguration` block below for details.
         */
        dynamicPartitioningConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDynamicPartitioningConfiguration;
        errorOutputPrefix?: string;
        /**
         * The file extension to override the default file extension (for example, `.json`).
         */
        fileExtension?: string;
        kmsKeyArn?: string;
        prefix?: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfiguration;
        roleArn: string;
        /**
         * The configuration for backup in Amazon S3. Required if `s3BackupMode` is `Enabled`. Supports the same fields as `s3Configuration` object.
         */
        s3BackupConfiguration?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfiguration;
        /**
         * The Amazon S3 backup mode.  Valid values are `Disabled` and `Enabled`.  Default value is `Disabled`.
         */
        s3BackupMode?: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfiguration {
        /**
         * Defaults to `true`. Set it to `false` if you want to disable format conversion while preserving the configuration details.
         */
        enabled?: boolean;
        /**
         * Specifies the deserializer that you want Kinesis Data Firehose to use to convert the format of your data from JSON. See `inputFormatConfiguration` block below for details.
         */
        inputFormatConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration;
        /**
         * Specifies the serializer that you want Kinesis Data Firehose to use to convert the format of your data to the Parquet or ORC format. See `outputFormatConfiguration` block below for details.
         */
        outputFormatConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration;
        /**
         * Specifies the AWS Glue Data Catalog table that contains the column information. See `schemaConfiguration` block below for details.
         */
        schemaConfiguration: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration {
        /**
         * Specifies which deserializer to use. You can choose either the Apache Hive JSON SerDe or the OpenX JSON SerDe. See `deserializer` block below for details.
         */
        deserializer: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer {
        /**
         * Specifies the native Hive / HCatalog JsonSerDe. More details below. See `hiveJsonSerDe` block below for details.
         */
        hiveJsonSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe;
        /**
         * Specifies the OpenX SerDe. See `openXJsonSerDe` block below for details.
         */
        openXJsonSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJsonSerDe {
        /**
         * A list of how you want Kinesis Data Firehose to parse the date and time stamps that may be present in your input data JSON. To specify these format strings, follow the pattern syntax of JodaTime's DateTimeFormat format strings. For more information, see [Class DateTimeFormat](https://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html). You can also use the special value millis to parse time stamps in epoch milliseconds. If you don't specify a format, Kinesis Data Firehose uses java.sql.Timestamp::valueOf by default.
         */
        timestampFormats?: string[];
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJsonSerDe {
        /**
         * When set to true, which is the default, Kinesis Data Firehose converts JSON keys to lowercase before deserializing them.
         */
        caseInsensitive?: boolean;
        /**
         * A map of column names to JSON keys that aren't identical to the column names. This is useful when the JSON contains keys that are Hive keywords. For example, timestamp is a Hive keyword. If you have a JSON key named timestamp, set this parameter to `{ ts = "timestamp" }` to map this key to a column named ts.
         */
        columnToJsonKeyMappings?: {
            [key: string]: string;
        };
        /**
         * When set to `true`, specifies that the names of the keys include dots and that you want Kinesis Data Firehose to replace them with underscores. This is useful because Apache Hive does not allow dots in column names. For example, if the JSON contains a key whose name is "a.b", you can define the column name to be "aB" when using this option. Defaults to `false`.
         */
        convertDotsInJsonKeysToUnderscores?: boolean;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration {
        /**
         * Specifies which serializer to use. You can choose either the ORC SerDe or the Parquet SerDe. See `serializer` block below for details.
         */
        serializer: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer {
        /**
         * Specifies converting data to the ORC format before storing it in Amazon S3. For more information, see [Apache ORC](https://orc.apache.org/docs/). See `orcSerDe` block below for details.
         */
        orcSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe;
        /**
         * Specifies converting data to the Parquet format before storing it in Amazon S3. For more information, see [Apache Parquet](https://parquet.apache.org/docs/). More details below.
         */
        parquetSerDe?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe {
        /**
         * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
         */
        blockSizeBytes?: number;
        /**
         * A list of column names for which you want Kinesis Data Firehose to create bloom filters.
         */
        bloomFilterColumns?: string[];
        /**
         * The Bloom filter false positive probability (FPP). The lower the FPP, the bigger the Bloom filter. The default value is `0.05`, the minimum is `0`, and the maximum is `1`.
         */
        bloomFilterFalsePositiveProbability?: number;
        /**
         * The compression code to use over data blocks. The default is `SNAPPY`.
         */
        compression?: string;
        /**
         * A float that represents the fraction of the total number of non-null rows. To turn off dictionary encoding, set this fraction to a number that is less than the number of distinct keys in a dictionary. To always use dictionary encoding, set this threshold to `1`.
         */
        dictionaryKeyThreshold?: number;
        /**
         * Set this to `true` to indicate that you want stripes to be padded to the HDFS block boundaries. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is `false`.
         */
        enablePadding?: boolean;
        /**
         * The version of the file to write. The possible values are `V0_11` and `V0_12`. The default is `V0_12`.
         */
        formatVersion?: string;
        /**
         * A float between 0 and 1 that defines the tolerance for block padding as a decimal fraction of stripe size. The default value is `0.05`, which means 5 percent of stripe size. For the default values of 64 MiB ORC stripes and 256 MiB HDFS blocks, the default block padding tolerance of 5 percent reserves a maximum of 3.2 MiB for padding within the 256 MiB block. In such a case, if the available size within the block is more than 3.2 MiB, a new, smaller stripe is inserted to fit within that space. This ensures that no stripe crosses block boundaries and causes remote reads within a node-local task. Kinesis Data Firehose ignores this parameter when `enablePadding` is `false`.
         */
        paddingTolerance?: number;
        /**
         * The number of rows between index entries. The default is `10000` and the minimum is `1000`.
         */
        rowIndexStride?: number;
        /**
         * The number of bytes in each stripe. The default is 64 MiB and the minimum is 8 MiB.
         */
        stripeSizeBytes?: number;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe {
        /**
         * The Hadoop Distributed File System (HDFS) block size. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is 256 MiB and the minimum is 64 MiB. Kinesis Data Firehose uses this value for padding calculations.
         */
        blockSizeBytes?: number;
        /**
         * The compression code to use over data blocks. The possible values are `UNCOMPRESSED`, `SNAPPY`, and `GZIP`, with the default being `SNAPPY`. Use `SNAPPY` for higher decompression speed. Use `GZIP` if the compression ratio is more important than speed.
         */
        compression?: string;
        /**
         * Indicates whether to enable dictionary compression.
         */
        enableDictionaryCompression?: boolean;
        /**
         * The maximum amount of padding to apply. This is useful if you intend to copy the data from Amazon S3 to HDFS before querying. The default is `0`.
         */
        maxPaddingBytes?: number;
        /**
         * The Parquet page size. Column chunks are divided into pages. A page is conceptually an indivisible unit (in terms of compression and encoding). The minimum value is 64 KiB and the default is 1 MiB.
         */
        pageSizeBytes?: number;
        /**
         * Indicates the version of row format to output. The possible values are `V1` and `V2`. The default is `V1`.
         */
        writerVersion?: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration {
        /**
         * The ID of the AWS Glue Data Catalog. If you don't supply this, the AWS account ID is used by default.
         */
        catalogId: string;
        /**
         * Specifies the name of the AWS Glue database that contains the schema for the output data.
         */
        databaseName: string;
        /**
         * If you don't specify an AWS Region, the default is the current region.
         */
        region: string;
        /**
         * The role that Kinesis Data Firehose can use to access AWS Glue. This role must be in the same account you use for Kinesis Data Firehose. Cross-account roles aren't allowed.
         */
        roleArn: string;
        /**
         * Specifies the AWS Glue table that contains the column information that constitutes your data schema.
         */
        tableName: string;
        /**
         * Specifies the table version for the output data schema. Defaults to `LATEST`.
         */
        versionId?: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationDynamicPartitioningConfiguration {
        /**
         * Enables or disables dynamic partitioning. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * Total amount of seconds Firehose spends on retries. Valid values between 0 and 7200. Default is 300.
         *
         * > **NOTE:** You can enable dynamic partitioning only when you create a new delivery stream. Once you enable dynamic partitioning on a delivery stream, it cannot be disabled on this delivery stream. Therefore, the provider will recreate the resource whenever dynamic partitioning is enabled or disabled.
         */
        retryDuration?: number;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfiguration {
        bucketArn: string;
        bufferingInterval?: number;
        bufferingSize?: number;
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions;
        compressionFormat?: string;
        errorOutputPrefix?: string;
        kmsKeyArn?: string;
        prefix?: string;
        roleArn: string;
    }
    interface FirehoseDeliveryStreamExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfiguration {
        /**
         * The access key required for Kinesis Firehose to authenticate with the HTTP endpoint selected as the destination.
         */
        accessKey?: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300 (5 minutes).
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationCloudwatchLoggingOptions;
        /**
         * The HTTP endpoint name.
         */
        name?: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfiguration;
        /**
         * The request configuration.  See `requestConfiguration` block below for details.
         */
        requestConfiguration: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfiguration;
        /**
         * Total amount of seconds Firehose spends on retries. This duration starts after the initial attempt fails, It does not include the time periods during which Firehose waits for acknowledgment from the specified destination after each attempt. Valid values between `0` and `7200`. Default is `300`.
         */
        retryDuration?: number;
        /**
         * Kinesis Data Firehose uses this IAM role for all the permissions that the delivery stream needs. The pattern needs to be `arn:.*`.
         */
        roleArn?: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDataOnly` and `AllData`.  Default value is `FailedDataOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationS3Configuration;
        /**
         * The HTTP endpoint URL to which Kinesis Firehose sends your data.
         */
        url: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfiguration {
        /**
         * Describes the metadata sent to the HTTP endpoint destination. See `commonAttributes` block below for details.
         */
        commonAttributes?: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttribute[];
        /**
         * Kinesis Data Firehose uses the content encoding to compress the body of a request before sending the request to the destination. Valid values are `NONE` and `GZIP`.  Default value is `NONE`.
         */
        contentEncoding?: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttribute {
        /**
         * The name of the HTTP endpoint common attribute.
         */
        name: string;
        /**
         * The value of the HTTP endpoint common attribute.
         */
        value: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamHttpEndpointConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamKinesisSourceConfiguration {
        /**
         * The kinesis stream used as the source of the firehose delivery stream.
         */
        kinesisStreamArn: string;
        /**
         * The ARN of the role that provides access to the source Kinesis stream.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamMskSourceConfiguration {
        /**
         * The authentication configuration of the Amazon MSK cluster. See `authenticationConfiguration` block below for details.
         */
        authenticationConfiguration: outputs.kinesis.FirehoseDeliveryStreamMskSourceConfigurationAuthenticationConfiguration;
        /**
         * The ARN of the Amazon MSK cluster.
         */
        mskClusterArn: string;
        /**
         * The topic name within the Amazon MSK cluster.
         */
        topicName: string;
    }
    interface FirehoseDeliveryStreamMskSourceConfigurationAuthenticationConfiguration {
        /**
         * The type of connectivity used to access the Amazon MSK cluster. Valid values: `PUBLIC`, `PRIVATE`.
         */
        connectivity: string;
        /**
         * The ARN of the role used to access the Amazon MSK cluster.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 0 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationCloudwatchLoggingOptions;
        /**
         * The endpoint to use when communicating with the cluster. Conflicts with `domainArn`.
         */
        clusterEndpoint?: string;
        /**
         * The method for setting up document ID. See [`documentIdOptions` block] below for details.
         */
        documentIdOptions?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationDocumentIdOptions;
        /**
         * The ARN of the Amazon ES domain.  The pattern needs to be `arn:.*`.  Conflicts with `clusterEndpoint`.
         */
        domainArn?: string;
        /**
         * The OpenSearch index name.
         */
        indexName: string;
        /**
         * The OpenSearch index rotation period.  Index rotation appends a timestamp to the IndexName to facilitate expiration of old data.  Valid values are `NoRotation`, `OneHour`, `OneDay`, `OneWeek`, and `OneMonth`.  The default value is `OneDay`.
         */
        indexRotationPeriod?: string;
        /**
         * The data processing configuration. See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Amazon OpenSearch, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon ES Configuration API and for indexing documents.  The IAM role must have permission for `DescribeDomain`, `DescribeDomains`, and `DescribeDomainConfig`.  The pattern needs to be `arn:.*`.
         */
        roleArn: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDocumentsOnly` and `AllDocuments`.  Default value is `FailedDocumentsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationS3Configuration;
        /**
         * The Elasticsearch type name with maximum length of 100 characters. Types are deprecated in OpenSearch_1.1. TypeName must be empty.
         */
        typeName?: string;
        /**
         * The VPC configuration for the delivery stream to connect to OpenSearch associated with the VPC. See `vpcConfig` block below for details.
         */
        vpcConfig?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationVpcConfig;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationDocumentIdOptions {
        /**
         * The method for setting up document ID. Valid values: `FIREHOSE_DEFAULT`, `NO_DOCUMENT_ID`.
         */
        defaultDocumentIdFormat: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamOpensearchConfigurationVpcConfig {
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon EC2 configuration API and for creating network interfaces. Make sure role has necessary [IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-es-vpc)
         */
        roleArn: string;
        /**
         * A list of security group IDs to associate with Kinesis Firehose.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs to associate with Kinesis Firehose.
         */
        subnetIds: string[];
        vpcId: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 0 to 900, before delivering it to the destination.  The default value is 300s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 100, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationCloudwatchLoggingOptions;
        /**
         * The endpoint to use when communicating with the collection in the Serverless offering for Amazon OpenSearch Service.
         */
        collectionEndpoint: string;
        /**
         * The Serverless offering for Amazon OpenSearch Service index name.
         */
        indexName: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to the Serverless offering for Amazon OpenSearch Service, the total amount of time, in seconds between 0 to 7200, during which Kinesis Data Firehose retries delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The Amazon Resource Name (ARN) of the IAM role to be assumed by Kinesis Data Firehose for calling the Serverless offering for Amazon OpenSearch Service Configuration API and for indexing documents.  The pattern needs to be `arn:.*`.
         */
        roleArn: string;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedDocumentsOnly` and `AllDocuments`.  Default value is `FailedDocumentsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationS3Configuration;
        /**
         * The VPC configuration for the delivery stream to connect to OpenSearch Serverless associated with the VPC. See `vpcConfig` block below for details.
         */
        vpcConfig?: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationVpcConfig;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamOpensearchserverlessConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamOpensearchserverlessConfigurationVpcConfig {
        /**
         * The ARN of the IAM role to be assumed by Firehose for calling the Amazon EC2 configuration API and for creating network interfaces. Make sure role has necessary [IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html#using-iam-es-vpc)
         */
        roleArn: string;
        /**
         * A list of security group IDs to associate with Kinesis Firehose.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs to associate with Kinesis Firehose.
         */
        subnetIds: string[];
        vpcId: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfiguration {
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationCloudwatchLoggingOptions;
        /**
         * The jdbcurl of the redshift cluster.
         */
        clusterJdbcurl: string;
        /**
         * Copy options for copying the data from the s3 intermediate bucket into redshift, for example to change the default delimiter. For valid values, see the [AWS documentation](http://docs.aws.amazon.com/firehose/latest/APIReference/API_CopyCommand.html)
         */
        copyOptions?: string;
        /**
         * The data table columns that will be targeted by the copy command.
         */
        dataTableColumns?: string;
        /**
         * The name of the table in the redshift cluster that the s3 bucket will copy to.
         */
        dataTableName: string;
        /**
         * The password for the username above.
         */
        password: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfiguration;
        /**
         * The length of time during which Firehose retries delivery after a failure, starting from the initial request and including the first attempt. The default value is 3600 seconds (60 minutes). Firehose does not retry if the value of DurationInSeconds is 0 (zero) or if the first delivery attempt takes longer than the current value.
         */
        retryDuration?: number;
        /**
         * The arn of the role the stream assumes.
         */
        roleArn: string;
        /**
         * The configuration for backup in Amazon S3. Required if `s3BackupMode` is `Enabled`. Supports the same fields as `s3Configuration` object.
         */
        s3BackupConfiguration?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfiguration;
        /**
         * The Amazon S3 backup mode.  Valid values are `Disabled` and `Enabled`.  Default value is `Disabled`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See s3Configuration below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3Configuration;
        /**
         * The username that the firehose delivery stream will assume. It is strongly recommended that the username and password provided is used exclusively for Amazon Kinesis Firehose purposes, and that the permissions for the account are restricted for Amazon Redshift INSERT permissions.
         */
        username: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfiguration {
        bucketArn: string;
        bufferingInterval?: number;
        bufferingSize?: number;
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions;
        compressionFormat?: string;
        errorOutputPrefix?: string;
        kmsKeyArn?: string;
        prefix?: string;
        roleArn: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamRedshiftConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamServerSideEncryption {
        /**
         * Whether to enable encryption at rest. Default is `false`.
         */
        enabled?: boolean;
        /**
         * Amazon Resource Name (ARN) of the encryption key. Required when `keyType` is `CUSTOMER_MANAGED_CMK`.
         */
        keyArn?: string;
        /**
         * Type of encryption key. Default is `AWS_OWNED_CMK`. Valid values are `AWS_OWNED_CMK` and `CUSTOMER_MANAGED_CMK`
         */
        keyType?: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfiguration {
        /**
         * The URL of the Snowflake account. Format: https://[accountIdentifier].snowflakecomputing.com.
         */
        accountUrl: string;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationCloudwatchLoggingOptions;
        /**
         * The name of the content column.
         */
        contentColumnName?: string;
        /**
         * The data loading option.
         */
        dataLoadingOption?: string;
        /**
         * The Snowflake database name.
         */
        database: string;
        /**
         * The passphrase for the private key.
         */
        keyPassphrase?: string;
        /**
         * The name of the metadata column.
         */
        metadataColumnName?: string;
        /**
         * The private key for authentication.
         */
        privateKey: string;
        /**
         * The processing configuration. See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Snowflake, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 60s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * The ARN of the IAM role.
         */
        roleArn: string;
        /**
         * The S3 backup mode.
         */
        s3BackupMode?: string;
        /**
         * The S3 configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationS3Configuration;
        /**
         * The Snowflake schema name.
         */
        schema: string;
        /**
         * The configuration for Snowflake role.
         */
        snowflakeRoleConfiguration?: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationSnowflakeRoleConfiguration;
        /**
         * The VPC configuration for Snowflake.
         */
        snowflakeVpcConfiguration?: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationSnowflakeVpcConfiguration;
        /**
         * The Snowflake table name.
         */
        table: string;
        /**
         * The user for authentication.
         */
        user: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSnowflakeConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationSnowflakeRoleConfiguration {
        /**
         * Whether the Snowflake role is enabled.
         */
        enabled?: boolean;
        /**
         * The Snowflake role.
         */
        snowflakeRole?: string;
    }
    interface FirehoseDeliveryStreamSnowflakeConfigurationSnowflakeVpcConfiguration {
        /**
         * The VPCE ID for Firehose to privately connect with Snowflake.
         */
        privateLinkVpceId: string;
    }
    interface FirehoseDeliveryStreamSplunkConfiguration {
        /**
         * Buffer incoming data for the specified period of time, in seconds between 0 to 60, before delivering it to the destination.  The default value is 60s.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs between 1 to 5, before delivering it to the destination.  The default value is 5MB.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationCloudwatchLoggingOptions;
        /**
         * The amount of time, in seconds between 180 and 600, that Kinesis Firehose waits to receive an acknowledgment from Splunk after it sends it data.
         */
        hecAcknowledgmentTimeout?: number;
        /**
         * The HTTP Event Collector (HEC) endpoint to which Kinesis Firehose sends your data.
         */
        hecEndpoint: string;
        /**
         * The HEC endpoint type. Valid values are `Raw` or `Event`. The default value is `Raw`.
         */
        hecEndpointType?: string;
        /**
         * The GUID that you obtain from your Splunk cluster when you create a new HEC endpoint.
         */
        hecToken: string;
        /**
         * The data processing configuration.  See `processingConfiguration` block below for details.
         */
        processingConfiguration?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfiguration;
        /**
         * After an initial failure to deliver to Splunk, the total amount of time, in seconds between 0 to 7200, during which Firehose re-attempts delivery (including the first attempt).  After this time has elapsed, the failed documents are written to Amazon S3.  The default value is 300s.  There will be no retry if the value is 0.
         */
        retryDuration?: number;
        /**
         * Defines how documents should be delivered to Amazon S3.  Valid values are `FailedEventsOnly` and `AllEvents`.  Default value is `FailedEventsOnly`.
         */
        s3BackupMode?: string;
        /**
         * The S3 Configuration. See `s3Configuration` block below for details.
         */
        s3Configuration: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationS3Configuration;
    }
    interface FirehoseDeliveryStreamSplunkConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfiguration {
        /**
         * Enables or disables data processing.
         */
        enabled?: boolean;
        /**
         * Specifies the data processors as multiple blocks. See `processors` block below for details.
         */
        processors?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessor[];
    }
    interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessor {
        /**
         * Specifies the processor parameters as multiple blocks. See `parameters` block below for details.
         */
        parameters?: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessorParameter[];
        /**
         * The type of processor. Valid Values: `RecordDeAggregation`, `Lambda`, `MetadataExtraction`, `AppendDelimiterToRecord`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        type: string;
    }
    interface FirehoseDeliveryStreamSplunkConfigurationProcessingConfigurationProcessorParameter {
        /**
         * Parameter name. Valid Values: `LambdaArn`, `NumberOfRetries`, `MetadataExtractionQuery`, `JsonParsingEngine`, `RoleArn`, `BufferSizeInMBs`, `BufferIntervalInSeconds`, `SubRecordType`, `Delimiter`. Validation is done against [AWS SDK constants](https://docs.aws.amazon.com/sdk-for-go/api/service/firehose/#pkg-constants); so that values not explicitly listed may also work.
         */
        parameterName: string;
        /**
         * Parameter value. Must be between 1 and 512 length (inclusive). When providing a Lambda ARN, you should specify the resource version as well.
         *
         * > **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 1), and `BufferIntervalInSeconds`(default: 60), are not stored in Pulumi state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.
         */
        parameterValue: string;
    }
    interface FirehoseDeliveryStreamSplunkConfigurationS3Configuration {
        /**
         * The ARN of the S3 bucket
         */
        bucketArn: string;
        /**
         * Buffer incoming data for the specified period of time, in seconds, before delivering it to the destination. The default value is 300.
         */
        bufferingInterval?: number;
        /**
         * Buffer incoming data to the specified size, in MBs, before delivering it to the destination. The default value is 5.
         * We recommend setting SizeInMBs to a value greater than the amount of data you typically ingest into the delivery stream in 10 seconds. For example, if you typically ingest data at 1 MB/sec set SizeInMBs to be 10 MB or higher.
         */
        bufferingSize?: number;
        /**
         * The CloudWatch Logging Options for the delivery stream. See `cloudwatchLoggingOptions` block below for details.
         */
        cloudwatchLoggingOptions: outputs.kinesis.FirehoseDeliveryStreamSplunkConfigurationS3ConfigurationCloudwatchLoggingOptions;
        /**
         * The compression format. If no value is specified, the default is `UNCOMPRESSED`. Other supported values are `GZIP`, `ZIP`, `Snappy`, & `HADOOP_SNAPPY`.
         */
        compressionFormat?: string;
        /**
         * Prefix added to failed records before writing them to S3. Not currently supported for `redshift` destination. This prefix appears immediately following the bucket name. For information about how to specify this prefix, see [Custom Prefixes for Amazon S3 Objects](https://docs.aws.amazon.com/firehose/latest/dev/s3-prefixes.html).
         */
        errorOutputPrefix?: string;
        /**
         * Specifies the KMS key ARN the stream will use to encrypt data. If not set, no encryption will
         * be used.
         */
        kmsKeyArn?: string;
        /**
         * The "YYYY/MM/DD/HH" time format prefix is automatically used for delivered S3 files. You can specify an extra prefix to be added in front of the time format prefix. Note that if the prefix ends with a slash, it appears as a folder in the S3 bucket
         */
        prefix?: string;
        /**
         * The ARN of the AWS credentials.
         */
        roleArn: string;
    }
    interface FirehoseDeliveryStreamSplunkConfigurationS3ConfigurationCloudwatchLoggingOptions {
        /**
         * Enables or disables the logging. Defaults to `false`.
         */
        enabled?: boolean;
        /**
         * The CloudWatch group name for logging. This value is required if `enabled` is true.
         */
        logGroupName?: string;
        /**
         * The CloudWatch log stream name for logging. This value is required if `enabled` is true.
         */
        logStreamName?: string;
    }
    interface GetStreamStreamModeDetail {
        /**
         * Capacity mode of the stream. Either `ON_DEMAND` or `PROVISIONED`.
         */
        streamMode: string;
    }
    interface StreamStreamModeDetails {
        /**
         * Specifies the capacity mode of the stream. Must be either `PROVISIONED` or `ON_DEMAND`.
         */
        streamMode: string;
    }
}
export declare namespace kinesisanalyticsv2 {
    interface ApplicationApplicationConfiguration {
        /**
         * The code location and type parameters for the application.
         */
        applicationCodeConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfiguration;
        /**
         * Describes whether snapshots are enabled for a Flink-based application.
         */
        applicationSnapshotConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationSnapshotConfiguration;
        /**
         * Describes execution properties for a Flink-based application.
         */
        environmentProperties?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationEnvironmentProperties;
        /**
         * The configuration of a Flink-based application.
         */
        flinkApplicationConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfiguration;
        /**
         * Describes the starting properties for a Flink-based application.
         */
        runConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfiguration;
        /**
         * The configuration of a SQL-based application.
         */
        sqlApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfiguration;
        /**
         * The VPC configuration of a Flink-based application.
         */
        vpcConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationVpcConfiguration;
    }
    interface ApplicationApplicationConfigurationApplicationCodeConfiguration {
        /**
         * The location and type of the application code.
         */
        codeContent?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent;
        /**
         * Specifies whether the code content is in text or zip format. Valid values: `PLAINTEXT`, `ZIPFILE`.
         */
        codeContentType: string;
    }
    interface ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContent {
        /**
         * Information about the Amazon S3 bucket containing the application code.
         */
        s3ContentLocation?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation;
        /**
         * The text-format code for the application.
         */
        textContent?: string;
    }
    interface ApplicationApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
        /**
         * The ARN for the S3 bucket containing the application code.
         */
        bucketArn: string;
        /**
         * The file key for the object containing the application code.
         */
        fileKey: string;
        /**
         * The version of the object containing the application code.
         */
        objectVersion?: string;
    }
    interface ApplicationApplicationConfigurationApplicationSnapshotConfiguration {
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        snapshotsEnabled: boolean;
    }
    interface ApplicationApplicationConfigurationEnvironmentProperties {
        /**
         * Describes the execution property groups.
         */
        propertyGroups: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup[];
    }
    interface ApplicationApplicationConfigurationEnvironmentPropertiesPropertyGroup {
        /**
         * The key of the application execution property key-value map.
         */
        propertyGroupId: string;
        /**
         * Application execution property key-value map.
         */
        propertyMap: {
            [key: string]: string;
        };
    }
    interface ApplicationApplicationConfigurationFlinkApplicationConfiguration {
        /**
         * Describes an application's checkpointing configuration.
         */
        checkpointConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration;
        /**
         * Describes configuration parameters for CloudWatch logging for an application.
         */
        monitoringConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration;
        /**
         * Describes parameters for how an application executes multiple tasks simultaneously.
         */
        parallelismConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration;
    }
    interface ApplicationApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration {
        /**
         * Describes the interval in milliseconds between checkpoint operations.
         */
        checkpointInterval: number;
        /**
         * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
         */
        checkpointingEnabled: boolean;
        /**
         * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `checkpointingEnabled`, `checkpointInterval`, or `minPauseBetweenCheckpoints` attribute values to be effective. If this attribute is set to `DEFAULT`, the application will always use the following values:
         * * `checkpointingEnabled = true`
         * * `checkpointInterval = 60000`
         * * `minPauseBetweenCheckpoints = 5000`
         */
        configurationType: string;
        /**
         * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
         */
        minPauseBetweenCheckpoints: number;
    }
    interface ApplicationApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration {
        /**
         * Describes whether to use the default CloudWatch logging configuration for an application. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `logLevel` or `metricsLevel` attribute values to be effective.
         */
        configurationType: string;
        /**
         * Describes the verbosity of the CloudWatch Logs for an application. Valid values: `DEBUG`, `ERROR`, `INFO`, `WARN`.
         */
        logLevel: string;
        /**
         * Describes the granularity of the CloudWatch Logs for an application. Valid values: `APPLICATION`, `OPERATOR`, `PARALLELISM`, `TASK`.
         */
        metricsLevel: string;
    }
    interface ApplicationApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration {
        /**
         * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
         */
        autoScalingEnabled: boolean;
        /**
         * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. Valid values: `CUSTOM`, `DEFAULT`. Set this attribute to `CUSTOM` in order for any specified `autoScalingEnabled`, `parallelism`, or `parallelismPerKpu` attribute values to be effective.
         */
        configurationType: string;
        /**
         * Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
         */
        parallelism: number;
        /**
         * Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
         */
        parallelismPerKpu: number;
    }
    interface ApplicationApplicationConfigurationRunConfiguration {
        /**
         * The restore behavior of a restarting application.
         */
        applicationRestoreConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration;
        /**
         * The starting parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkRunConfiguration: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration;
    }
    interface ApplicationApplicationConfigurationRunConfigurationApplicationRestoreConfiguration {
        /**
         * Specifies how the application should be restored. Valid values: `RESTORE_FROM_CUSTOM_SNAPSHOT`, `RESTORE_FROM_LATEST_SNAPSHOT`, `SKIP_RESTORE_FROM_SNAPSHOT`.
         */
        applicationRestoreType: string;
        /**
         * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if `RESTORE_FROM_CUSTOM_SNAPSHOT` is specified for `applicationRestoreType`.
         */
        snapshotName?: string;
    }
    interface ApplicationApplicationConfigurationRunConfigurationFlinkRunConfiguration {
        /**
         * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is `false`.
         */
        allowNonRestoredState: boolean;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfiguration {
        /**
         * The input stream used by the application.
         */
        input?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInput;
        /**
         * The destination streams used by the application.
         */
        outputs?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutput[];
        /**
         * The reference data source used by the application.
         */
        referenceDataSource?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInput {
        inAppStreamNames: string[];
        inputId: string;
        /**
         * Describes the number of in-application streams to create.
         */
        inputParallelism: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism;
        /**
         * The input processing configuration for the input.
         * An input processor transforms records as they are received from the stream, before the application's SQL code executes.
         */
        inputProcessingConfiguration?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
         */
        inputSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema;
        /**
         * The point at which the application starts processing records from the streaming source.
         */
        inputStartingPositionConfigurations: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration[];
        /**
         * If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
         */
        kinesisFirehoseInput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput;
        /**
         * If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
         */
        kinesisStreamsInput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput;
        /**
         * The name prefix to use when creating an in-application stream.
         */
        namePrefix: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputParallelism {
        /**
         * The number of in-application streams to create.
         */
        count: number;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
        /**
         * Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
         */
        inputLambdaProcessor: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor {
        /**
         * The ARN of the Lambda function that operates on records in the stream.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
        /**
         * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
         */
        recordColumns: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn[];
        /**
         * Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
         */
        recordEncoding?: string;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: string;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: string;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
        /**
         * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters;
        /**
         * The type of record format. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        csvMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jsonMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters {
        /**
         * The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The row delimiter. For example, in a CSV format, `\n` is the typical row delimiter.
         */
        recordRowDelimiter: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration {
        /**
         * The starting position on the stream. Valid values: `LAST_STOPPED_POINT`, `NOW`, `TRIM_HORIZON`.
         */
        inputStartingPosition: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput {
        /**
         * The ARN of the delivery stream.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput {
        /**
         * The ARN of the input Kinesis data stream to read.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutput {
        /**
         * Describes the data format when records are written to the destination.
         */
        destinationSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema;
        /**
         * Identifies a Kinesis Data Firehose delivery stream as the destination.
         */
        kinesisFirehoseOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput;
        /**
         * Identifies a Kinesis data stream as the destination.
         */
        kinesisStreamsOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput;
        /**
         * Identifies a Lambda function as the destination.
         */
        lambdaOutput?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput;
        /**
         * The name of the in-application stream.
         */
        name: string;
        outputId: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema {
        /**
         * Specifies the format of the records on the output stream. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput {
        /**
         * The ARN of the destination delivery stream to write to.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput {
        /**
         * The ARN of the destination Kinesis data stream to write to.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput {
        /**
         * The ARN of the destination Lambda function to write to.
         */
        resourceArn: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
        referenceId: string;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
         */
        referenceSchema: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema;
        /**
         * Identifies the S3 bucket and object that contains the reference data.
         */
        s3ReferenceDataSource: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource;
        /**
         * The name of the in-application table to create.
         */
        tableName: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
        /**
         * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
         */
        recordColumns: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn[];
        /**
         * Specifies the encoding of the records in the streaming source. For example, `UTF-8`.
         */
        recordEncoding?: string;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: string;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: string;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
        /**
         * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters;
        /**
         * The type of record format. Valid values: `CSV`, `JSON`.
         */
        recordFormatType: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        csvMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jsonMappingParameters?: outputs.kinesisanalyticsv2.ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters {
        /**
         * The column delimiter. For example, in a CSV format, a comma (`,`) is the typical column delimiter.
         */
        recordColumnDelimiter: string;
        /**
         * The row delimiter. For example, in a CSV format, `\n` is the typical row delimiter.
         */
        recordRowDelimiter: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: string;
    }
    interface ApplicationApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
        /**
         * The ARN of the S3 bucket.
         */
        bucketArn: string;
        /**
         * The object key name containing the reference data.
         */
        fileKey: string;
    }
    interface ApplicationApplicationConfigurationVpcConfiguration {
        /**
         * The Security Group IDs used by the VPC configuration.
         */
        securityGroupIds: string[];
        /**
         * The Subnet IDs used by the VPC configuration.
         */
        subnetIds: string[];
        vpcConfigurationId: string;
        vpcId: string;
    }
    interface ApplicationCloudwatchLoggingOptions {
        cloudwatchLoggingOptionId: string;
        /**
         * The ARN of the CloudWatch log stream to receive application messages.
         */
        logStreamArn: string;
    }
}
export declare namespace kms {
    interface GetKeyMultiRegionConfiguration {
        /**
         * Indicates whether the KMS key is a `PRIMARY` or `REPLICA` key.
         */
        multiRegionKeyType: string;
        /**
         * The key ARN and Region of the primary key. This is the current KMS key if it is the primary key.
         */
        primaryKeys: outputs.kms.GetKeyMultiRegionConfigurationPrimaryKey[];
        /**
         * The key ARNs and Regions of all replica keys. Includes the current KMS key if it is a replica key.
         */
        replicaKeys: outputs.kms.GetKeyMultiRegionConfigurationReplicaKey[];
    }
    interface GetKeyMultiRegionConfigurationPrimaryKey {
        /**
         * The key ARN of a primary or replica key of a multi-Region key.
         */
        arn: string;
        /**
         * The AWS Region of a primary or replica key in a multi-Region key.
         */
        region: string;
    }
    interface GetKeyMultiRegionConfigurationReplicaKey {
        /**
         * The key ARN of a primary or replica key of a multi-Region key.
         */
        arn: string;
        /**
         * The AWS Region of a primary or replica key in a multi-Region key.
         */
        region: string;
    }
    interface GetKeyXksKeyConfiguration {
        /**
         * The globally unique identifier for the key
         */
        id: string;
    }
    interface GetSecretSecret {
        context?: {
            [key: string]: string;
        };
        grantTokens?: string[];
        name: string;
        payload: string;
    }
    interface GetSecretsSecret {
        /**
         * An optional mapping that makes up the Encryption Context for the secret.
         */
        context?: {
            [key: string]: string;
        };
        /**
         * The encryption algorithm that will be used to decrypt the ciphertext. This parameter is required only when the ciphertext was encrypted under an asymmetric KMS key. Valid Values: SYMMETRIC_DEFAULT | RSAES_OAEP_SHA_1 | RSAES_OAEP_SHA_256 | SM2PKE
         */
        encryptionAlgorithm?: string;
        /**
         * An optional list of Grant Tokens for the secret.
         */
        grantTokens?: string[];
        /**
         * Specifies the KMS key that AWS KMS uses to decrypt the ciphertext. This parameter is required only when the ciphertext was encrypted under an asymmetric KMS key.
         *
         * For more information on `context` and `grantTokens` see the [KMS
         * Concepts](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html)
         */
        keyId?: string;
        /**
         * Name to export this secret under in the attributes.
         */
        name: string;
        /**
         * Base64 encoded payload, as returned from a KMS encrypt operation.
         */
        payload: string;
    }
    interface GrantConstraint {
        /**
         * A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with `encryptionContextSubset`.
         */
        encryptionContextEquals?: {
            [key: string]: string;
        };
        /**
         * A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with `encryptionContextEquals`.
         */
        encryptionContextSubset?: {
            [key: string]: string;
        };
    }
}
export declare namespace lakeformation {
    interface DataCellsFilterTableData {
        /**
         * A list of column names and/or nested column attributes.
         */
        columnNames: string[];
        /**
         * A wildcard with exclusions. See Column Wildcard below for details.
         */
        columnWildcard?: outputs.lakeformation.DataCellsFilterTableDataColumnWildcard;
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * The name of the data cells filter.
         */
        name: string;
        /**
         * A PartiQL predicate. See Row Filter below for details.
         */
        rowFilter?: outputs.lakeformation.DataCellsFilterTableDataRowFilter;
        /**
         * The ID of the Data Catalog.
         */
        tableCatalogId: string;
        /**
         * The name of the table.
         */
        tableName: string;
        /**
         * ID of the data cells filter version.
         */
        versionId: string;
    }
    interface DataCellsFilterTableDataColumnWildcard {
        /**
         * (Optional) Excludes column names. Any column with this name will be excluded.
         */
        excludedColumnNames?: string[];
    }
    interface DataCellsFilterTableDataRowFilter {
        /**
         * (Optional) A wildcard that matches all rows.
         */
        allRowsWildcard?: outputs.lakeformation.DataCellsFilterTableDataRowFilterAllRowsWildcard;
        /**
         * (Optional) A filter expression.
         */
        filterExpression: string;
    }
    interface DataCellsFilterTableDataRowFilterAllRowsWildcard {
    }
    interface DataCellsFilterTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
    }
    interface DataLakeSettingsCreateDatabaseDefaultPermission {
        /**
         * List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
         */
        permissions: string[];
        /**
         * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
         */
        principal: string;
    }
    interface DataLakeSettingsCreateTableDefaultPermission {
        /**
         * List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
         */
        permissions: string[];
        /**
         * Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
         */
        principal: string;
    }
    interface GetDataLakeSettingsCreateDatabaseDefaultPermission {
        /**
         * List of permissions granted to the principal.
         */
        permissions: string[];
        /**
         * Principal who is granted permissions.
         */
        principal: string;
    }
    interface GetDataLakeSettingsCreateTableDefaultPermission {
        /**
         * List of permissions granted to the principal.
         */
        permissions: string[];
        /**
         * Principal who is granted permissions.
         */
        principal: string;
    }
    interface GetPermissionsDataCellsFilter {
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * The name of the data cells filter.
         */
        name: string;
        /**
         * The ID of the Data Catalog.
         */
        tableCatalogId: string;
        /**
         * The name of the table.
         */
        tableName: string;
    }
    interface GetPermissionsDataLocation {
        /**
         * ARN that uniquely identifies the data location resource.
         *
         * The following argument is optional:
         */
        arn: string;
        /**
         * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
         */
        catalogId: string;
    }
    interface GetPermissionsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }
    interface GetPermissionsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Key-name for the tag.
         */
        key: string;
        /**
         * List of possible values an attribute can take.
         *
         * The following argument is optional:
         */
        values: string[];
    }
    interface GetPermissionsLfTagPolicy {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
         *
         * The following argument is optional:
         */
        expressions: outputs.lakeformation.GetPermissionsLfTagPolicyExpression[];
        /**
         * Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
         */
        resourceType: string;
    }
    interface GetPermissionsLfTagPolicyExpression {
        /**
         * Key-name of an LF-Tag.
         */
        key: string;
        /**
         * List of possible values of an LF-Tag.
         */
        values: string[];
    }
    interface GetPermissionsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         *
         * The following arguments are optional:
         */
        databaseName: string;
        /**
         * Name of the table. At least one of `name` or `wildcard` is required.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
         */
        wildcard?: boolean;
    }
    interface GetPermissionsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table. At least one of `columnNames` or `excludedColumnNames` is required.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. At least one of `columnNames` or `excludedColumnNames` is required.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         *
         * The following arguments are optional:
         */
        name: string;
        wildcard?: boolean;
    }
    interface PermissionsDataCellsFilter {
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * The name of the data cells filter.
         */
        name: string;
        /**
         * The ID of the Data Catalog.
         */
        tableCatalogId: string;
        /**
         * The name of the table.
         */
        tableName: string;
    }
    interface PermissionsDataLocation {
        /**
         * Amazon Resource Name (ARN) that uniquely identifies the data location resource.
         *
         * The following argument is optional:
         */
        arn: string;
        /**
         * Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
         */
        catalogId: string;
    }
    interface PermissionsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }
    interface PermissionsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * The key-name for the tag.
         */
        key: string;
        /**
         * A list of possible values an attribute can take.
         *
         * The following argument is optional:
         */
        values: string[];
    }
    interface PermissionsLfTagPolicy {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
         *
         * The following argument is optional:
         */
        expressions: outputs.lakeformation.PermissionsLfTagPolicyExpression[];
        /**
         * The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
         */
        resourceType: string;
    }
    interface PermissionsLfTagPolicyExpression {
        /**
         * The key-name of an LF-Tag.
         */
        key: string;
        /**
         * A list of possible values of an LF-Tag.
         */
        values: string[];
    }
    interface PermissionsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. Defaults to `false`.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }
    interface PermissionsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         */
        name: string;
        /**
         * Whether to use a column wildcard. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }
    interface ResourceLfTagDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId?: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }
    interface ResourceLfTagLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Key name for an existing LF-tag.
         */
        key: string;
        /**
         * Value from the possible values for the LF-tag.
         *
         * The following argument is optional:
         */
        value: string;
    }
    interface ResourceLfTagTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId?: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name?: string;
        /**
         * Whether to use a wildcard representing every table under a database. Defaults to `false`.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }
    interface ResourceLfTagTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId?: string;
        /**
         * Set of column names for the table.
         */
        columnNames?: string[];
        /**
         * Option to add column wildcard. See Column Wildcard for more details.
         */
        columnWildcard?: outputs.lakeformation.ResourceLfTagTableWithColumnsColumnWildcard;
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table resource.
         *
         * The following arguments are optional:
         */
        name: string;
    }
    interface ResourceLfTagTableWithColumnsColumnWildcard {
        excludedColumnNames?: string[];
    }
    interface ResourceLfTagTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface ResourceLfTagsDatabase {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database resource. Unique to the Data Catalog.
         *
         * The following argument is optional:
         */
        name: string;
    }
    interface ResourceLfTagsLfTag {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Key name for an existing LF-tag.
         */
        key: string;
        /**
         * Value from the possible values for the LF-tag.
         *
         * The following argument is optional:
         */
        value: string;
    }
    interface ResourceLfTagsTable {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Name of the database for the table. Unique to a Data Catalog.
         */
        databaseName: string;
        /**
         * Name of the table.
         */
        name: string;
        /**
         * Whether to use a wildcard representing every table under a database. Defaults to `false`.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }
    interface ResourceLfTagsTableWithColumns {
        /**
         * Identifier for the Data Catalog. By default, it is the account ID of the caller.
         */
        catalogId: string;
        /**
         * Set of column names for the table.
         */
        columnNames?: string[];
        /**
         * Name of the database for the table with columns resource. Unique to the Data Catalog.
         */
        databaseName: string;
        /**
         * Set of column names for the table to exclude. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         */
        excludedColumnNames?: string[];
        /**
         * Name of the table resource.
         */
        name: string;
        /**
         * Whether to use a column wildcard. If `excludedColumnNames` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
         *
         * The following arguments are optional:
         */
        wildcard?: boolean;
    }
}
export declare namespace lambda {
    interface AliasRoutingConfig {
        /**
         * A map that defines the proportion of events that should be sent to different versions of a lambda function.
         */
        additionalVersionWeights?: {
            [key: string]: number;
        };
    }
    interface CodeSigningConfigAllowedPublishers {
        /**
         * The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
         */
        signingProfileVersionArns: string[];
    }
    interface CodeSigningConfigPolicies {
        /**
         * Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
         */
        untrustedArtifactOnDeployment: string;
    }
    interface EventSourceMappingAmazonManagedKafkaEventSourceConfig {
        /**
         * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
         */
        consumerGroupId: string;
    }
    interface EventSourceMappingDestinationConfig {
        /**
         * The destination configuration for failed invocations. Detailed below.
         */
        onFailure?: outputs.lambda.EventSourceMappingDestinationConfigOnFailure;
    }
    interface EventSourceMappingDestinationConfigOnFailure {
        destinationArn: string;
    }
    interface EventSourceMappingDocumentDbEventSourceConfig {
        /**
         * The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
         */
        collectionName?: string;
        /**
         * The name of the database to consume within the DocumentDB cluster.
         */
        databaseName: string;
        /**
         * Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
         */
        fullDocument?: string;
    }
    interface EventSourceMappingFilterCriteria {
        /**
         * A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
         */
        filters?: outputs.lambda.EventSourceMappingFilterCriteriaFilter[];
    }
    interface EventSourceMappingFilterCriteriaFilter {
        pattern?: string;
    }
    interface EventSourceMappingScalingConfig {
        /**
         * Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between `2` and `1000`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
         */
        maximumConcurrency?: number;
    }
    interface EventSourceMappingSelfManagedEventSource {
        /**
         * A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
         */
        endpoints: {
            [key: string]: string;
        };
    }
    interface EventSourceMappingSelfManagedKafkaEventSourceConfig {
        /**
         * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
         */
        consumerGroupId: string;
    }
    interface EventSourceMappingSourceAccessConfiguration {
        /**
         * The type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
         */
        type: string;
        /**
         * The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnetId` is the value you would find in an aws.ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `securityGroupId` is the value you would find in an aws.ec2.SecurityGroup resource's id attribute.
         */
        uri: string;
    }
    interface FunctionDeadLetterConfig {
        /**
         * ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
         */
        targetArn: string;
    }
    interface FunctionEnvironment {
        /**
         * Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
         */
        variables?: {
            [key: string]: string;
        };
    }
    interface FunctionEphemeralStorage {
        /**
         * The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeralStorage` value defaults to `512`MB and the maximum supported value is `10240`MB.
         */
        size: number;
    }
    interface FunctionEventInvokeConfigDestinationConfig {
        /**
         * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
         */
        onFailure?: outputs.lambda.FunctionEventInvokeConfigDestinationConfigOnFailure;
        /**
         * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
         */
        onSuccess?: outputs.lambda.FunctionEventInvokeConfigDestinationConfigOnSuccess;
    }
    interface FunctionEventInvokeConfigDestinationConfigOnFailure {
        destination: string;
    }
    interface FunctionEventInvokeConfigDestinationConfigOnSuccess {
        destination: string;
    }
    interface FunctionFileSystemConfig {
        /**
         * Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
         */
        arn: string;
        /**
         * Path where the function can access the file system, starting with /mnt/.
         */
        localMountPath: string;
    }
    interface FunctionImageConfig {
        /**
         * Parameters that you want to pass in with `entryPoint`.
         */
        commands?: string[];
        /**
         * Entry point to your application, which is typically the location of the runtime executable.
         */
        entryPoints?: string[];
        /**
         * Working directory.
         */
        workingDirectory?: string;
    }
    interface FunctionLoggingConfig {
        /**
         * for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
         */
        applicationLogLevel?: string;
        /**
         * select between `Text` and structured `JSON` format for your function's logs.
         */
        logFormat: string;
        /**
         * the CloudWatch log group your function sends logs to.
         */
        logGroup: string;
        /**
         * for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as `ERROR`, `DEBUG`, or `INFO`.
         */
        systemLogLevel?: string;
    }
    interface FunctionSnapStart {
        /**
         * Conditions where snap start is enabled. Valid values are `PublishedVersions`.
         */
        applyOn: string;
        /**
         * Optimization status of the snap start configuration. Valid values are `On` and `Off`.
         */
        optimizationStatus: string;
    }
    interface FunctionTracingConfig {
        /**
         * Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
         */
        mode: string;
    }
    interface FunctionUrlCors {
        /**
         * Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
         */
        allowCredentials?: boolean;
        /**
         * The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
         */
        allowHeaders?: string[];
        /**
         * The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
         */
        allowMethods?: string[];
        /**
         * The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
         */
        allowOrigins?: string[];
        /**
         * The HTTP headers in your function response that you want to expose to origins that call the function URL.
         */
        exposeHeaders?: string[];
        /**
         * The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
         */
        maxAge?: number;
    }
    interface FunctionVpcConfig {
        /**
         * Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is `false`.
         */
        ipv6AllowedForDualStack?: boolean;
        /**
         * List of security group IDs associated with the Lambda function.
         */
        securityGroupIds: string[];
        /**
         * List of subnet IDs associated with the Lambda function.
         */
        subnetIds: string[];
        /**
         * ID of the VPC.
         */
        vpcId: string;
    }
    interface GetCodeSigningConfigAllowedPublisher {
        /**
         * The ARN for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
         */
        signingProfileVersionArns: string[];
    }
    interface GetCodeSigningConfigPolicy {
        /**
         * Code signing configuration policy for deployment validation failure.
         */
        untrustedArtifactOnDeployment: string;
    }
    interface GetFunctionDeadLetterConfig {
        targetArn: string;
    }
    interface GetFunctionEnvironment {
        variables: {
            [key: string]: string;
        };
    }
    interface GetFunctionEphemeralStorage {
        size: number;
    }
    interface GetFunctionFileSystemConfig {
        /**
         * Unqualified (no `:QUALIFIER` or `:VERSION` suffix) ARN identifying your Lambda Function. See also `qualifiedArn`.
         */
        arn: string;
        localMountPath: string;
    }
    interface GetFunctionLoggingConfig {
        applicationLogLevel: string;
        logFormat: string;
        logGroup: string;
        systemLogLevel: string;
    }
    interface GetFunctionTracingConfig {
        mode: string;
    }
    interface GetFunctionUrlCor {
        allowCredentials: boolean;
        allowHeaders: string[];
        allowMethods: string[];
        allowOrigins: string[];
        exposeHeaders: string[];
        maxAge: number;
    }
    interface GetFunctionVpcConfig {
        ipv6AllowedForDualStack: boolean;
        securityGroupIds: string[];
        subnetIds: string[];
        vpcId: string;
    }
}
export declare namespace lb {
    interface GetListenerDefaultAction {
        authenticateCognitos: outputs.lb.GetListenerDefaultActionAuthenticateCognito[];
        authenticateOidcs: outputs.lb.GetListenerDefaultActionAuthenticateOidc[];
        fixedResponses: outputs.lb.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.lb.GetListenerDefaultActionForward[];
        order: number;
        redirects: outputs.lb.GetListenerDefaultActionRedirect[];
        targetGroupArn: string;
        type: string;
    }
    interface GetListenerDefaultActionAuthenticateCognito {
        authenticationRequestExtraParams: {
            [key: string]: string;
        };
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }
    interface GetListenerDefaultActionAuthenticateOidc {
        authenticationRequestExtraParams: {
            [key: string]: string;
        };
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest: string;
        scope: string;
        sessionCookieName: string;
        sessionTimeout: number;
        tokenEndpoint: string;
        userInfoEndpoint: string;
    }
    interface GetListenerDefaultActionFixedResponse {
        contentType: string;
        messageBody: string;
        statusCode: string;
    }
    interface GetListenerDefaultActionForward {
        stickinesses: outputs.lb.GetListenerDefaultActionForwardStickiness[];
        targetGroups: outputs.lb.GetListenerDefaultActionForwardTargetGroup[];
    }
    interface GetListenerDefaultActionForwardStickiness {
        duration: number;
        enabled: boolean;
    }
    interface GetListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the listener. Required if `loadBalancerArn` and `port` is not set.
         */
        arn: string;
        weight: number;
    }
    interface GetListenerDefaultActionRedirect {
        host: string;
        path: string;
        /**
         * Port of the listener. Required if `arn` is not set.
         */
        port: string;
        protocol: string;
        query: string;
        statusCode: string;
    }
    interface GetListenerMutualAuthentication {
        ignoreClientCertificateExpiry: boolean;
        mode: string;
        trustStoreArn: string;
    }
    interface GetLoadBalancerAccessLogs {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }
    interface GetLoadBalancerConnectionLog {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }
    interface GetLoadBalancerSubnetMapping {
        allocationId: string;
        ipv6Address: string;
        outpostId: string;
        privateIpv4Address: string;
        subnetId: string;
    }
    interface GetTargetGroupHealthCheck {
        enabled: boolean;
        healthyThreshold: number;
        interval: number;
        matcher: string;
        path: string;
        port: string;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }
    interface GetTargetGroupStickiness {
        cookieDuration: number;
        cookieName: string;
        enabled: boolean;
        type: string;
    }
    interface ListenerDefaultAction {
        /**
         * Configuration block for using Amazon Cognito to authenticate users. Specify only when `type` is `authenticate-cognito`. Detailed below.
         */
        authenticateCognito?: outputs.lb.ListenerDefaultActionAuthenticateCognito;
        /**
         * Configuration block for an identity provider that is compliant with OpenID Connect (OIDC). Specify only when `type` is `authenticate-oidc`. Detailed below.
         */
        authenticateOidc?: outputs.lb.ListenerDefaultActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.lb.ListenerDefaultActionFixedResponse;
        /**
         * Configuration block for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`. Detailed below.
         */
        forward?: outputs.lb.ListenerDefaultActionForward;
        /**
         * Order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first. Valid values are between `1` and `50000`.
         */
        order: number;
        /**
         * Configuration block for creating a redirect action. Required if `type` is `redirect`. Detailed below.
         */
        redirect?: outputs.lb.ListenerDefaultActionRedirect;
        /**
         * ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * Type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         *
         * The following arguments are optional:
         */
        type: string;
    }
    interface ListenerDefaultActionAuthenticateCognito {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10. Detailed below.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * Behavior if the user is not authenticated. Valid values are `deny`, `allow` and `authenticate`.
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * Domain prefix or fully-qualified domain name of the Cognito user pool.
         *
         * The following arguments are optional:
         */
        userPoolDomain: string;
    }
    interface ListenerDefaultActionAuthenticateOidc {
        /**
         * Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * Authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * Behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * Set of user claims to be requested from the IdP.
         */
        scope: string;
        /**
         * Name of the cookie used to maintain session information.
         */
        sessionCookieName: string;
        /**
         * Maximum duration of the authentication session, in seconds.
         */
        sessionTimeout: number;
        /**
         * Token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * User info endpoint of the IdP.
         *
         * The following arguments are optional:
         */
        userInfoEndpoint: string;
    }
    interface ListenerDefaultActionFixedResponse {
        /**
         * Content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         *
         * The following arguments are optional:
         */
        contentType: string;
        /**
         * Message body.
         */
        messageBody?: string;
        /**
         * HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }
    interface ListenerDefaultActionForward {
        /**
         * Configuration block for target group stickiness for the rule. Detailed below.
         */
        stickiness?: outputs.lb.ListenerDefaultActionForwardStickiness;
        /**
         * Set of 1-5 target group blocks. Detailed below.
         *
         * The following arguments are optional:
         */
        targetGroups: outputs.lb.ListenerDefaultActionForwardTargetGroup[];
    }
    interface ListenerDefaultActionForwardStickiness {
        /**
         * Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         *
         * The following arguments are optional:
         */
        duration: number;
        /**
         * Whether target group stickiness is enabled. Default is `false`.
         */
        enabled?: boolean;
    }
    interface ListenerDefaultActionForwardTargetGroup {
        /**
         * ARN of the target group.
         *
         * The following arguments are optional:
         */
        arn: string;
        /**
         * Weight. The range is 0 to 999.
         */
        weight?: number;
    }
    interface ListenerDefaultActionRedirect {
        /**
         * Hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * Port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * Protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         *
         * The following arguments are optional:
         */
        statusCode: string;
    }
    interface ListenerMutualAuthentication {
        /**
         * Whether client certificate expiry is ignored. Default is `false`.
         */
        ignoreClientCertificateExpiry?: boolean;
        /**
         * Valid values are `off`, `verify` and `passthrough`.
         */
        mode: string;
        /**
         * ARN of the elbv2 Trust Store.
         */
        trustStoreArn?: string;
    }
    interface ListenerRuleAction {
        /**
         * Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
         */
        authenticateCognito?: outputs.lb.ListenerRuleActionAuthenticateCognito;
        /**
         * Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
         */
        authenticateOidc?: outputs.lb.ListenerRuleActionAuthenticateOidc;
        /**
         * Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
         */
        fixedResponse?: outputs.lb.ListenerRuleActionFixedResponse;
        /**
         * Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `targetGroupArn` attribute, you can specify only one target group using `forward` and it must be the same target group specified in `targetGroupArn`.
         */
        forward?: outputs.lb.ListenerRuleActionForward;
        order: number;
        /**
         * Information for creating a redirect action. Required if `type` is `redirect`.
         */
        redirect?: outputs.lb.ListenerRuleActionRedirect;
        /**
         * The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
         */
        targetGroupArn?: string;
        /**
         * The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
         */
        type: string;
    }
    interface ListenerRuleActionAuthenticateCognito {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The ARN of the Cognito user pool.
         */
        userPoolArn: string;
        /**
         * The ID of the Cognito user pool client.
         */
        userPoolClientId: string;
        /**
         * The domain prefix or fully-qualified domain name of the Cognito user pool.
         */
        userPoolDomain: string;
    }
    interface ListenerRuleActionAuthenticateOidc {
        /**
         * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
         */
        authenticationRequestExtraParams?: {
            [key: string]: string;
        };
        /**
         * The authorization endpoint of the IdP.
         */
        authorizationEndpoint: string;
        /**
         * The OAuth 2.0 client identifier.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret.
         */
        clientSecret: string;
        /**
         * The OIDC issuer identifier of the IdP.
         */
        issuer: string;
        /**
         * The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
         */
        onUnauthenticatedRequest: string;
        /**
         * The set of user claims to be requested from the IdP.
         */
        scope?: string;
        /**
         * The name of the cookie used to maintain session information.
         */
        sessionCookieName?: string;
        /**
         * The maximum duration of the authentication session, in seconds.
         */
        sessionTimeout?: number;
        /**
         * The token endpoint of the IdP.
         */
        tokenEndpoint: string;
        /**
         * The user info endpoint of the IdP.
         */
        userInfoEndpoint: string;
    }
    interface ListenerRuleActionFixedResponse {
        /**
         * The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
         */
        contentType: string;
        /**
         * The message body.
         */
        messageBody?: string;
        /**
         * The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
         */
        statusCode: string;
    }
    interface ListenerRuleActionForward {
        /**
         * The target group stickiness for the rule.
         */
        stickiness?: outputs.lb.ListenerRuleActionForwardStickiness;
        /**
         * One or more target groups block.
         */
        targetGroups: outputs.lb.ListenerRuleActionForwardTargetGroup[];
    }
    interface ListenerRuleActionForwardStickiness {
        /**
         * The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
         */
        duration: number;
        /**
         * Indicates whether target group stickiness is enabled.
         */
        enabled?: boolean;
    }
    interface ListenerRuleActionForwardTargetGroup {
        /**
         * The Amazon Resource Name (ARN) of the target group.
         */
        arn: string;
        /**
         * The weight. The range is 0 to 999.
         */
        weight?: number;
    }
    interface ListenerRuleActionRedirect {
        /**
         * The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
         */
        host?: string;
        /**
         * The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
         */
        path?: string;
        /**
         * The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
         */
        port?: string;
        /**
         * The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
         */
        protocol?: string;
        /**
         * The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
         */
        query?: string;
        /**
         * The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
         */
        statusCode: string;
    }
    interface ListenerRuleCondition {
        /**
         * Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
         */
        hostHeader?: outputs.lb.ListenerRuleConditionHostHeader;
        /**
         * HTTP headers to match. HTTP Header block fields documented below.
         */
        httpHeader?: outputs.lb.ListenerRuleConditionHttpHeader;
        /**
         * Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         */
        httpRequestMethod?: outputs.lb.ListenerRuleConditionHttpRequestMethod;
        /**
         * Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `queryString` condition.
         */
        pathPattern?: outputs.lb.ListenerRuleConditionPathPattern;
        /**
         * Query strings to match. Query String block fields documented below.
         */
        queryStrings?: outputs.lb.ListenerRuleConditionQueryString[];
        /**
         * Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         *
         * > **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         */
        sourceIp?: outputs.lb.ListenerRuleConditionSourceIp;
    }
    interface ListenerRuleConditionHostHeader {
        values: string[];
    }
    interface ListenerRuleConditionHttpHeader {
        /**
         * Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
         */
        httpHeaderName: string;
        /**
         * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
         */
        values: string[];
    }
    interface ListenerRuleConditionHttpRequestMethod {
        values: string[];
    }
    interface ListenerRuleConditionPathPattern {
        values: string[];
    }
    interface ListenerRuleConditionQueryString {
        /**
         * Query string key pattern to match.
         */
        key?: string;
        /**
         * Query string value pattern to match.
         */
        value: string;
    }
    interface ListenerRuleConditionSourceIp {
        values: string[];
    }
    interface LoadBalancerAccessLogs {
        /**
         * S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `accessLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }
    interface LoadBalancerConnectionLogs {
        /**
         * S3 bucket name to store the logs in.
         */
        bucket: string;
        /**
         * Boolean to enable / disable `connectionLogs`. Defaults to `false`, even when `bucket` is specified.
         */
        enabled?: boolean;
        /**
         * S3 bucket prefix. Logs are stored in the root if not configured.
         */
        prefix?: string;
    }
    interface LoadBalancerSubnetMapping {
        /**
         * Allocation ID of the Elastic IP address for an internet-facing load balancer.
         */
        allocationId?: string;
        /**
         * IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
         */
        ipv6Address?: string;
        outpostId: string;
        /**
         * Private IPv4 address for an internal load balancer.
         */
        privateIpv4Address?: string;
        /**
         * ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
         */
        subnetId: string;
    }
    interface TargetGroupHealthCheck {
        /**
         * Whether health checks are enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
         */
        healthyThreshold?: number;
        /**
         * Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For `lambda` target groups, it needs to be greater than the timeout of the underlying `lambda`. Defaults to 30.
         */
        interval?: number;
        /**
         * The HTTP or gRPC codes to use when checking for a successful response from a target.
         * The `health_check.protocol` must be one of `HTTP` or `HTTPS` or the `targetType` must be `lambda`.
         * Values can be comma-separated individual values (e.g., "200,202") or a range of values (e.g., "200-299").
         * * For gRPC-based target groups (i.e., the `protocol` is one of `HTTP` or `HTTPS` and the `protocolVersion` is `GRPC`), values can be between `0` and `99`. The default is `12`.
         * * When used with an Application Load Balancer (i.e., the `protocol` is one of `HTTP` or `HTTPS` and the `protocolVersion` is not `GRPC`), values can be between `200` and `499`. The default is `200`.
         * * When used with a Network Load Balancer (i.e., the `protocol` is one of `TCP`, `TCP_UDP`, `UDP`, or `TLS`), values can be between `200` and `599`. The default is `200-399`.
         * * When the `targetType` is `lambda`, values can be between `200` and `499`. The default is `200`.
         */
        matcher: string;
        /**
         * Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
         * * For HTTP and HTTPS health checks, the default is `/`.
         * * For gRPC health checks, the default is `/Amazon Web Services.ALB/healthcheck`.
         */
        path: string;
        /**
         * The port the load balancer uses when performing health checks on targets.
         * Valid values are either `traffic-port`, to use the same port as the target group, or a valid port number between `1` and `65536`.
         * Default is `traffic-port`.
         */
        port?: string;
        /**
         * Protocol the load balancer uses when performing health checks on targets.
         * Must be one of `TCP`, `HTTP`, or `HTTPS`.
         * The `TCP` protocol is not supported for health checks if the protocol of the target group is `HTTP` or `HTTPS`.
         * Default is `HTTP`.
         * Cannot be specified when the `targetType` is `lambda`.
         */
        protocol?: string;
        /**
         * Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2–120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
         */
        timeout: number;
        /**
         * Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
         */
        unhealthyThreshold?: number;
    }
    interface TargetGroupStickiness {
        /**
         * Only used when the type is `lbCookie`. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
         */
        cookieDuration?: number;
        /**
         * Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is `appCookie`.
         */
        cookieName?: string;
        /**
         * Boolean to enable / disable `stickiness`. Default is `true`.
         */
        enabled?: boolean;
        /**
         * The type of sticky sessions. The only current possible values are `lbCookie`, `appCookie` for ALBs, `sourceIp` for NLBs, and `sourceIpDestIp`, `sourceIpDestIpProto` for GWLBs.
         */
        type: string;
    }
    interface TargetGroupTargetFailover {
        /**
         * Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onUnhealthy`. Default: `noRebalance`.
         */
        onDeregistration: string;
        /**
         * Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are `rebalance` and `noRebalance`. Must match the attribute value set for `onDeregistration`. Default: `noRebalance`.
         */
        onUnhealthy: string;
    }
    interface TargetGroupTargetHealthState {
        /**
         * Indicates whether the load balancer terminates connections to unhealthy targets. Possible values are `true` or `false`. Default: `true`.
         */
        enableUnhealthyConnectionTermination: boolean;
    }
}
export declare namespace lex {
    interface BotAbortStatement {
        messages: outputs.lex.BotAbortStatementMessage[];
        responseCard?: string;
    }
    interface BotAbortStatementMessage {
        /**
         * The text of the message.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response.
         */
        groupNumber?: number;
    }
    interface BotAliasConversationLogs {
        /**
         * The Amazon Resource Name (ARN) of the IAM role used to write your logs to CloudWatch Logs or an S3 bucket. Must be between 20 and 2048 characters in length.
         */
        iamRoleArn: string;
        /**
         * The settings for your conversation logs. You can log text, audio, or both. Attributes are documented under log_settings.
         */
        logSettings?: outputs.lex.BotAliasConversationLogsLogSetting[];
    }
    interface BotAliasConversationLogsLogSetting {
        /**
         * The destination where logs are delivered. Options are `CLOUDWATCH_LOGS` or `S3`.
         */
        destination: string;
        /**
         * The Amazon Resource Name (ARN) of the key used to encrypt audio logs in an S3 bucket. This can only be specified when `destination` is set to `S3`. Must be between 20 and 2048 characters in length.
         */
        kmsKeyArn?: string;
        /**
         * The type of logging that is enabled. Options are `AUDIO` or `TEXT`.
         */
        logType: string;
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or S3 bucket where the logs are delivered. Must be less than or equal to 2048 characters in length.
         */
        resourceArn: string;
        /**
         * The prefix of the S3 object key for `AUDIO` logs or the log stream name for `TEXT` logs.
         */
        resourcePrefix: string;
    }
    interface BotClarificationPrompt {
        maxAttempts: number;
        messages: outputs.lex.BotClarificationPromptMessage[];
        responseCard?: string;
    }
    interface BotClarificationPromptMessage {
        /**
         * The text of the message.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response.
         */
        groupNumber?: number;
    }
    interface BotIntent {
        /**
         * The name of the intent. Must be less than or equal to 100 characters in length.
         */
        intentName: string;
        /**
         * The version of the intent. Must be less than or equal to 64 characters in length.
         */
        intentVersion: string;
    }
    interface GetSlotTypeEnumerationValue {
        synonyms: string[];
        value: string;
    }
    interface IntentConclusionStatement {
        messages: outputs.lex.IntentConclusionStatementMessage[];
        responseCard?: string;
    }
    interface IntentConclusionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface IntentConfirmationPrompt {
        maxAttempts: number;
        messages: outputs.lex.IntentConfirmationPromptMessage[];
        responseCard?: string;
    }
    interface IntentConfirmationPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface IntentDialogCodeHook {
        messageVersion: string;
        uri: string;
    }
    interface IntentFollowUpPrompt {
        /**
         * Prompts for information from the user. Attributes are documented under prompt.
         */
        prompt: outputs.lex.IntentFollowUpPromptPrompt;
        /**
         * If the user answers "no" to the question defined in the prompt field,
         * Amazon Lex responds with this statement to acknowledge that the intent was canceled. Attributes are
         * documented below under statement.
         */
        rejectionStatement: outputs.lex.IntentFollowUpPromptRejectionStatement;
    }
    interface IntentFollowUpPromptPrompt {
        /**
         * The number of times to prompt the user for information. Must be a number between 1 and 5 (inclusive).
         */
        maxAttempts: number;
        /**
         * A set of messages, each of which provides a message string and its type.
         * You can specify the message string in plain text or in Speech Synthesis Markup Language (SSML).
         * Attributes are documented under message. Must contain between 1 and 15 messages.
         */
        messages: outputs.lex.IntentFollowUpPromptPromptMessage[];
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
    }
    interface IntentFollowUpPromptPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface IntentFollowUpPromptRejectionStatement {
        messages: outputs.lex.IntentFollowUpPromptRejectionStatementMessage[];
        responseCard?: string;
    }
    interface IntentFollowUpPromptRejectionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface IntentFulfillmentActivity {
        /**
         * A description of the Lambda function that is run to fulfill the intent.
         * Required if type is CodeHook. Attributes are documented under code_hook.
         */
        codeHook?: outputs.lex.IntentFulfillmentActivityCodeHook;
        /**
         * How the intent should be fulfilled, either by running a Lambda function or by
         * returning the slot data to the client application. Type can be either `ReturnIntent` or `CodeHook`, as documented [here](https://docs.aws.amazon.com/lex/latest/dg/API_FulfillmentActivity.html).
         */
        type: string;
    }
    interface IntentFulfillmentActivityCodeHook {
        /**
         * The version of the request-response that you want Amazon Lex to use
         * to invoke your Lambda function. For more information, see
         * [Using Lambda Functions](https://docs.aws.amazon.com/lex/latest/dg/using-lambda.html). Must be less than or equal to 5 characters in length.
         */
        messageVersion: string;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function.
         */
        uri: string;
    }
    interface IntentRejectionStatement {
        messages: outputs.lex.IntentRejectionStatementMessage[];
        responseCard?: string;
    }
    interface IntentRejectionStatementMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface IntentSlot {
        /**
         * A description of the bot. Must be less than or equal to 200 characters in length.
         */
        description?: string;
        /**
         * The name of the intent slot that you want to create. The name is case sensitive. Must be less than or equal to 100 characters in length.
         */
        name: string;
        /**
         * Directs Lex the order in which to elicit this slot value from the user.
         * For example, if the intent has two slots with priorities 1 and 2, AWS Lex first elicits a value for
         * the slot with priority 1. If multiple slots share the same priority, the order in which Lex elicits
         * values is arbitrary. Must be between 1 and 100.
         */
        priority?: number;
        /**
         * The response card. Amazon Lex will substitute session attributes and
         * slot values into the response card. For more information, see
         * [Example: Using a Response Card](https://docs.aws.amazon.com/lex/latest/dg/ex-resp-card.html). Must be less than or equal to 50000 characters in length.
         */
        responseCard?: string;
        /**
         * If you know a specific pattern with which users might respond to
         * an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This
         * is optional. In most cases, Amazon Lex is capable of understanding user utterances. Must have between 1 and 10 items in the list, and each item must be less than or equal to 200 characters in length.
         */
        sampleUtterances?: string[];
        /**
         * Specifies whether the slot is required or optional.
         */
        slotConstraint: string;
        /**
         * The type of the slot, either a custom slot type that you defined or one of
         * the built-in slot types. Must be less than or equal to 100 characters in length.
         */
        slotType: string;
        /**
         * The version of the slot type. Must be less than or equal to 64 characters in length.
         */
        slotTypeVersion?: string;
        /**
         * The prompt that Amazon Lex uses to elicit the slot value
         * from the user. Attributes are documented under prompt.
         */
        valueElicitationPrompt?: outputs.lex.IntentSlotValueElicitationPrompt;
    }
    interface IntentSlotValueElicitationPrompt {
        maxAttempts: number;
        messages: outputs.lex.IntentSlotValueElicitationPromptMessage[];
        responseCard?: string;
    }
    interface IntentSlotValueElicitationPromptMessage {
        /**
         * The text of the message. Must be less than or equal to 1000 characters in length.
         */
        content: string;
        /**
         * The content type of the message string.
         */
        contentType: string;
        /**
         * Identifies the message group that the message belongs to. When a group
         * is assigned to a message, Amazon Lex returns one message from each group in the response. Must be a number between 1 and 5 (inclusive).
         */
        groupNumber?: number;
    }
    interface SlotTypeEnumerationValue {
        /**
         * Additional values related to the slot type value. Each item must be less than or equal to 140 characters in length.
         */
        synonyms?: string[];
        /**
         * The value of the slot type. Must be less than or equal to 140 characters in length.
         */
        value: string;
    }
    interface V2modelsBotDataPrivacy {
        /**
         * (Required) -  For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying true or false in the childDirected field.
         */
        childDirected: boolean;
    }
    interface V2modelsBotLocaleTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface V2modelsBotLocaleVoiceSettings {
        /**
         * Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. Valid values are `standard` and `neural`. If not specified, the default is `standard`.
         */
        engine: string;
        /**
         * Identifier of the Amazon Polly voice to use.
         */
        voiceId: string;
    }
    interface V2modelsBotMember {
        /**
         * (Required) - Alias ID of a bot that is a member of this network of bots.
         */
        aliasId: string;
        /**
         * (Required) - Alias name of a bot that is a member of this network of bots.
         */
        aliasName: string;
        /**
         * (Required) - Unique ID of a bot that is a member of this network of bots.
         */
        id: string;
        /**
         * Name of the bot. The bot name must be unique in the account that creates the bot. Type String. Length Constraints: Minimum length of 1. Maximum length of 100.
         */
        name: string;
        /**
         * (Required) - Version of a bot that is a member of this network of bots.
         */
        version: string;
    }
    interface V2modelsBotTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface V2modelsBotVersionLocaleSpecification {
        sourceBotVersion: string;
    }
    interface V2modelsBotVersionTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface V2modelsIntentClosingSetting {
        /**
         * Whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
         */
        active?: boolean;
        /**
         * Configuration block for response that Amazon Lex sends to the user when the intent is complete. See `closingResponse`.
         */
        closingResponse?: outputs.lex.V2modelsIntentClosingSettingClosingResponse;
        /**
         * Configuration block for list of conditional branches associated with the intent's closing response. These branches are executed when the `nextStep` attribute is set to `EvalutateConditional`. See `conditional`.
         */
        conditional?: outputs.lex.V2modelsIntentClosingSettingConditional;
        /**
         * Next step that the bot executes after playing the intent's closing response. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentClosingSettingNextStep;
    }
    interface V2modelsIntentClosingSettingClosingResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroup[];
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariation[];
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingClosingResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingClosingResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranch;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentClosingSettingNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentClosingSettingNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentClosingSettingNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentClosingSettingNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentClosingSettingNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentClosingSettingNextStepIntentSlot[];
    }
    interface V2modelsIntentClosingSettingNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentClosingSettingNextStepIntentSlotValue;
    }
    interface V2modelsIntentClosingSettingNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSetting {
        /**
         * Whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
         */
        active?: boolean;
        /**
         * Configuration block for the intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is `invokeDialogCodeHook`.  See `codeHook`.
         */
        codeHook?: outputs.lex.V2modelsIntentConfirmationSettingCodeHook;
        /**
         * Configuration block for conditional branches to evaluate after the intent is closed. See `confirmationConditional`.
         */
        confirmationConditional?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditional;
        /**
         * Configuration block for the next step that the bot executes when the customer confirms the intent. See `confirmationNextStep`.
         */
        confirmationNextStep?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `confirmationResponse`.
         */
        confirmationResponse?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponse;
        /**
         * Configuration block for conditional branches to evaluate after the intent is declined. See `declinationConditional`.
         */
        declinationConditional?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditional;
        /**
         * Configuration block for the next step that the bot executes when the customer declines the intent. See `declinationNextStep`.
         */
        declinationNextStep?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationNextStep;
        /**
         * Configuration block for when the user answers "no" to the question defined in `promptSpecification`, Amazon Lex responds with this response to acknowledge that the intent was canceled. See `declinationResponse`.
         */
        declinationResponse?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponse;
        /**
         * Configuration block for when the code hook is invoked during confirmation prompt retries. See `elicitationCodeHook`.
         */
        elicitationCodeHook?: outputs.lex.V2modelsIntentConfirmationSettingElicitationCodeHook;
        /**
         * Configuration block for conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition. See `failureConditional`.
         */
        failureConditional?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditional;
        /**
         * Configuration block for the next step to take in the conversation if the confirmation step fails. See `failureNextStep`.
         */
        failureNextStep?: outputs.lex.V2modelsIntentConfirmationSettingFailureNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `failureResponse`.
         */
        failureResponse?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponse;
        /**
         * Configuration block for prompting the user to confirm the intent. This question should have a yes or no answer. Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. See `promptSpecification`.
         */
        promptSpecification: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecification;
    }
    interface V2modelsIntentConfirmationSettingCodeHook {
        /**
         * Whether a dialog code hook is used when the intent is activated.
         */
        active: boolean;
        /**
         * Whether a Lambda function should be invoked for the dialog.
         */
        enableCodeHookInvocation: boolean;
        /**
         * Label that indicates the dialog step from which the dialog code hook is happening.
         */
        invocationLabel?: string;
        /**
         * Configuration block that contains the responses and actions that Amazon Lex takes after the Lambda function is complete. See `postCodeHookSpecification`.
         */
        postCodeHookSpecification: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecification;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecification {
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureConditional?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed . See `failureNextStep`.
         */
        failureNextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `failureResponse`.
         */
        failureResponse?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponse;
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook finishes successfully. See `successConditional`.
         */
        successConditional?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook finishes successfully. See `successNextStep`.
         */
        successNextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `successResponse`.
         */
        successResponse?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponse;
        /**
         * Configuration block for conditional branches to evaluate if the code hook times out. See `timeoutConditional`.
         */
        timeoutConditional?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditional;
        /**
         * Configuration block for the next step that the bot runs when the code hook times out. See `timeoutNextStep`.
         */
        timeoutNextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond the user input. See `timeoutResponse`.
         */
        timeoutResponse?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingConfirmationNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingConfirmationNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingConfirmationResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingDeclinationNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingDeclinationNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingDeclinationResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingElicitationCodeHook {
        /**
         * Whether a Lambda function should be invoked for the dialog.
         */
        enableCodeHookInvocation?: boolean;
        /**
         * Label that indicates the dialog step from which the dialog code hook is happening.
         */
        invocationLabel?: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranch;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentConfirmationSettingFailureNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentConfirmationSettingFailureNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentConfirmationSettingFailureNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentConfirmationSettingFailureNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentConfirmationSettingFailureNextStepIntentSlot[];
    }
    interface V2modelsIntentConfirmationSettingFailureNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentConfirmationSettingFailureNextStepIntentSlotValue;
    }
    interface V2modelsIntentConfirmationSettingFailureNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroup[];
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingFailureResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecification {
        /**
         * Whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: boolean;
        /**
         * Maximum number of times the bot tries to elicit a response from the user using this prompt.
         */
        maxRetries: number;
        /**
         * Configuration block for messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroup[];
        /**
         * How a message is selected from a message group among retries. Valid values are `Random` and `Ordered`.
         */
        messageSelectionStrategy?: string;
        /**
         * Configuration block for advanced settings on each attempt of the prompt. See `promptAttemptsSpecification`.
         */
        promptAttemptsSpecifications?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecification[];
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariation[];
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecification {
        /**
         * Whether the user can interrupt a speech prompt attempt from the bot.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration block for the allowed input types of the prompt attempt. See `allowedInputTypes`.
         */
        allowedInputTypes: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAllowedInputTypes;
        /**
         * Configuration block for settings on audio and DTMF input. See `audioAndDtmfInputSpecification`.
         */
        audioAndDtmfInputSpecification?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecification;
        /**
         * Which attempt to configure. Valid values are `Initial`, `Retry1`, `Retry2`, `Retry3`, `Retry4`, `Retry5`.
         */
        mapBlockKey: string;
        /**
         * Configuration block for the settings on text input. See `textInputSpecification`.
         */
        textInputSpecification?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationTextInputSpecification;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAllowedInputTypes {
        /**
         * Whether audio input is allowed.
         */
        allowAudioInput: boolean;
        /**
         * Whether DTMF input is allowed.
         */
        allowDtmfInput: boolean;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecification {
        /**
         * Configuration block for the settings on audio input. See `audioSpecification`.
         */
        audioSpecification?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationAudioSpecification;
        /**
         * Configuration block for the settings on DTMF input. See `dtmfSpecification`.
         */
        dtmfSpecification?: outputs.lex.V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationDtmfSpecification;
        /**
         * Time for which a bot waits before assuming that the customer isn't going to speak or press a key. This timeout is shared between Audio and DTMF inputs.
         */
        startTimeoutMs: number;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationAudioSpecification {
        /**
         * Time for which a bot waits after the customer stops speaking to assume the utterance is finished.
         */
        endTimeoutMs: number;
        /**
         * Time for how long Amazon Lex waits before speech input is truncated and the speech is returned to application.
         */
        maxLengthMs: number;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationDtmfSpecification {
        /**
         * DTMF character that clears the accumulated DTMF digits and immediately ends the input.
         */
        deletionCharacter: string;
        /**
         * DTMF character that immediately ends input. If the user does not press this character, the input ends after the end timeout.
         */
        endCharacter: string;
        /**
         * How long the bot should wait after the last DTMF character input before assuming that the input has concluded.
         */
        endTimeoutMs: number;
        /**
         * Maximum number of DTMF digits allowed in an utterance.
         */
        maxLength: number;
    }
    interface V2modelsIntentConfirmationSettingPromptSpecificationPromptAttemptsSpecificationTextInputSpecification {
        /**
         * Time for which a bot waits before re-prompting a customer for text input.
         */
        startTimeoutMs: number;
    }
    interface V2modelsIntentDialogCodeHook {
        /**
         * Enables the dialog code hook so that it processes user requests.
         */
        enabled: boolean;
    }
    interface V2modelsIntentFulfillmentCodeHook {
        /**
         * Whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
         */
        active?: boolean;
        /**
         * Whether a Lambda function should be invoked to fulfill a specific intent.
         */
        enabled: boolean;
        /**
         * Configuration block for settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations. See `fulfillmentUpdatesSpecification`.
         */
        fulfillmentUpdatesSpecification?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecification;
        /**
         * Configuration block for settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations. See `postFulfillmentStatusSpecification`.
         */
        postFulfillmentStatusSpecification?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecification;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecification {
        /**
         * Whether fulfillment updates are sent to the user. When this field is true, updates are sent. If the active field is set to true, the `startResponse`, `updateResponse`, and `timeoutInSeconds` fields are required.
         */
        active: boolean;
        /**
         * Configuration block for the message sent to users when the fulfillment Lambda functions starts running.
         */
        startResponse?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponse;
        /**
         * Length of time that the fulfillment Lambda function should run before it times out.
         */
        timeoutInSeconds?: number;
        /**
         * Configuration block for messages sent periodically to the user while the fulfillment Lambda function is running.
         */
        updateResponse?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponse {
        /**
         * Whether the user can interrupt the start message while it is playing.
         */
        allowInterrupt?: boolean;
        /**
         * Delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
         */
        delayInSeconds?: number;
        /**
         * Between 1-5 configuration block message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationStartResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponse {
        /**
         * Whether the user can interrupt the start message while it is playing.
         */
        allowInterrupt?: boolean;
        /**
         * Frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
         */
        frequencyInSeconds: number;
        /**
         * Between 1-5 configuration block message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookFulfillmentUpdatesSpecificationUpdateResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecification {
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed. See `failureConditional`.
         */
        failureConditional?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed. See `failureNextStep`.
         */
        failureNextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `failureResponse`.
         */
        failureResponse?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponse;
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook finishes successfully. See `successConditional`.
         */
        successConditional?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook finishes successfully. See `successNextStep`.
         */
        successNextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `successResponse`.
         */
        successResponse?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponse;
        /**
         * Configuration block for conditional branches to evaluate if the code hook times out. See `timeoutConditional`.
         */
        timeoutConditional?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditional;
        /**
         * Configuration block for the next step that the bot runs when the code hook times out. See `timeoutNextStep`.
         */
        timeoutNextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond the user input. See `timeoutResponse`.
         */
        timeoutResponse?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranch;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationFailureResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranch;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationSuccessResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranch;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntentSlot[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntentSlotValue;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroup[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariation[];
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentFulfillmentCodeHookPostFulfillmentStatusSpecificationTimeoutResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSetting {
        /**
         * Configuration block for the dialog code hook that is called by Amazon Lex at a step of the conversation. See `codeHook`.
         */
        codeHook?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHook;
        /**
         * Configuration block for conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition. See `conditional`.
         */
        conditional?: outputs.lex.V2modelsIntentInitialResponseSettingConditional;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `initialResponse`.
         */
        initialResponse?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponse;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentInitialResponseSettingNextStep;
    }
    interface V2modelsIntentInitialResponseSettingCodeHook {
        /**
         * Whether a dialog code hook is used when the intent is activated.
         */
        active: boolean;
        /**
         * Whether a Lambda function should be invoked for the dialog.
         */
        enableCodeHookInvocation: boolean;
        /**
         * Label that indicates the dialog step from which the dialog code hook is happening.
         */
        invocationLabel?: string;
        /**
         * Configuration block that contains the responses and actions that Amazon Lex takes after the Lambda function is complete. See `postCodeHookSpecification`.
         */
        postCodeHookSpecification: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecification;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecification {
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureConditional?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed . See `failureNextStep`.
         */
        failureNextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `failureResponse`.
         */
        failureResponse?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponse;
        /**
         * Configuration block for conditional branches to evaluate after the dialog code hook finishes successfully. See `successConditional`.
         */
        successConditional?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditional;
        /**
         * Configuration block for the next step the bot runs after the dialog code hook finishes successfully. See `successNextStep`.
         */
        successNextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStep;
        /**
         * Configuration block for message groups that Amazon Lex uses to respond the user input. See `successResponse`.
         */
        successResponse?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponse;
        /**
         * Configuration block for conditional branches to evaluate if the code hook times out. See `timeoutConditional`.
         */
        timeoutConditional?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditional;
        /**
         * Configuration block for the next step that the bot runs when the code hook times out. See `timeoutNextStep`.
         */
        timeoutNextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond the user input. See `timeoutResponse`.
         */
        timeoutResponse?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranch;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationFailureResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranch;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationSuccessResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranch;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingCodeHookPostCodeHookSpecificationTimeoutResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditional {
        /**
         * Whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        active: boolean;
        /**
         * Configuration blocks for conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true. See `conditionalBranch`.
         */
        conditionalBranches?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranch[];
        /**
         * Configuration block for the conditional branch that should be followed when the conditions for other branches are not satisfied. A branch is made up of a condition, a response and a next step. See `defaultBranch`.
         */
        defaultBranch: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranch;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranch {
        /**
         * Configuration block for the expression to evaluate. If the condition is true, the branch's actions are taken. See `condition`.
         */
        condition: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchCondition;
        /**
         * Name of the branch.
         */
        name: string;
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchCondition {
        /**
         * Expression string that is evaluated.
         */
        expressionString: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalConditionalBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranch {
        /**
         * Configuration block for the next step in the conversation. See `nextStep`.
         */
        nextStep?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStep;
        /**
         * Configuration block for a list of message groups that Amazon Lex uses to respond to the user input. See `response`.
         */
        response?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponse;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingConditionalDefaultBranchResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponse {
        /**
         * Whether the user can interrupt a speech response from Amazon Lex.
         */
        allowInterrupt?: boolean;
        /**
         * Configuration blocks for responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime. See `messageGroup`.
         */
        messageGroups?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroup[];
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroup {
        /**
         * Configuration block for the primary message that Amazon Lex should send to the user. See `message`.
         */
        message: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessage;
        /**
         * Configuration blocks for message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user. See `variation`.
         */
        variations?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariation[];
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessage {
        /**
         * Configuration block for a message in a custom format defined by the client application. See `customPayload`.
         */
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageCustomPayload;
        /**
         * Configuration block for a message that defines a response card that the client application can show to the user. See `imageResponseCard`.
         */
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageImageResponseCard;
        /**
         * Configuration block for a message in plain text format. See `plainTextMessage`.
         */
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessagePlainTextMessage;
        /**
         * Configuration block for a message in Speech Synthesis Markup Language (SSML). See `ssmlMessage`.
         */
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessagePlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupMessageSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariation {
        customPayload?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationCustomPayload;
        imageResponseCard?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationCustomPayload {
        /**
         * String that is sent to your application.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationImageResponseCard {
        /**
         * Configuration blocks for buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button. See `button`.
         */
        buttons?: outputs.lex.V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationImageResponseCardButton[];
        /**
         * URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
         */
        imageUrl?: string;
        /**
         * Subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
         */
        subtitle?: string;
        /**
         * Title to display on the response card. The format of the title is determined by the platform displaying the response card.
         */
        title: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationImageResponseCardButton {
        /**
         * Text that appears on the button. Use this to tell the user what value is returned when they choose this button.
         */
        text: string;
        /**
         * Value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationPlainTextMessage {
        /**
         * Message to send to the user.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingInitialResponseMessageGroupVariationSsmlMessage {
        /**
         * SSML text that defines the prompt.
         */
        value: string;
    }
    interface V2modelsIntentInitialResponseSettingNextStep {
        /**
         * Configuration block for action that the bot executes at runtime when the conversation reaches this step. See `dialogAction`.
         */
        dialogAction?: outputs.lex.V2modelsIntentInitialResponseSettingNextStepDialogAction;
        /**
         * Configuration block for override settings to configure the intent state. See `intent`.
         */
        intent?: outputs.lex.V2modelsIntentInitialResponseSettingNextStepIntent;
        /**
         * Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
         */
        sessionAttributes?: {
            [key: string]: string;
        };
    }
    interface V2modelsIntentInitialResponseSettingNextStepDialogAction {
        /**
         * If the dialog action is `ElicitSlot`, defines the slot to elicit from the user.
         */
        slotToElicit?: string;
        /**
         * Whether the next message for the intent is _not_ used.
         */
        suppressNextMessage?: boolean;
        /**
         * Action that the bot should execute. Valid values are `ElicitIntent`, `StartIntent`, `ElicitSlot`, `EvaluateConditional`, `InvokeDialogCodeHook`, `ConfirmIntent`, `FulfillIntent`, `CloseIntent`, `EndConversation`.
         */
        type: string;
    }
    interface V2modelsIntentInitialResponseSettingNextStepIntent {
        /**
         * Name of the intent.
         */
        name?: string;
        /**
         * Configuration block for all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden. See `slot`.
         */
        slots?: outputs.lex.V2modelsIntentInitialResponseSettingNextStepIntentSlot[];
    }
    interface V2modelsIntentInitialResponseSettingNextStepIntentSlot {
        mapBlockKey: string;
        /**
         * When the shape value is `List`, `values` contains a list of slot values. When the value is `Scalar`, `value` contains a single value.
         */
        shape?: string;
        /**
         * Configuration block for the current value of the slot. See `value`.
         */
        value?: outputs.lex.V2modelsIntentInitialResponseSettingNextStepIntentSlotValue;
    }
    interface V2modelsIntentInitialResponseSettingNextStepIntentSlotValue {
        interpretedValue?: string;
    }
    interface V2modelsIntentInputContext {
        /**
         * Name of the context.
         */
        name: string;
    }
    interface V2modelsIntentKendraConfiguration {
        /**
         * ARN of the Amazon Kendra index that you want the AMAZON.KendraSearchIntent intent to search. The index must be in the same account and Region as the Amazon Lex bot.
         */
        kendraIndex: string;
        /**
         * Query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see [Filtering queries](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html).
         */
        queryFilterString?: string;
        /**
         * Whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
         */
        queryFilterStringEnabled?: boolean;
    }
    interface V2modelsIntentOutputContext {
        /**
         * Name of the output context.
         */
        name: string;
        /**
         * Amount of time, in seconds, that the output context should remain active. The time is figured from the first time the context is sent to the user.
         */
        timeToLiveInSeconds: number;
        /**
         * Number of conversation turns that the output context should remain active. The number of turns is counted from the first time that the context is sent to the user.
         */
        turnsToLive: number;
    }
    interface V2modelsIntentSampleUtterance {
        /**
         * Sample utterance that Amazon Lex uses to build its machine-learning model to recognize intents.
         */
        utterance: string;
    }
    interface V2modelsIntentSlotPriority {
        /**
         * Priority that Amazon Lex should apply to the slot.
         */
        priority: number;
        /**
         * Unique identifier of the slot.
         */
        slotId: string;
    }
    interface V2modelsIntentTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface V2modelsSlotMultipleValuesSetting {
        /**
         * Whether a slot can return multiple values. When `true`, the slot may return more than one value in a response. When `false`, the slot returns only a single value. Multi-value slots are only available in the `en-US` locale.
         */
        allowMultipleValues?: boolean;
    }
    interface V2modelsSlotObfuscationSetting {
        /**
         * Whether Amazon Lex obscures slot values in conversation logs. Valid values are `DefaultObfuscation` and `None`.
         */
        obfuscationSettingType: string;
    }
    interface V2modelsSlotTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface V2modelsSlotTypeCompositeSlotTypeSetting {
        /**
         * Subslots in the composite slot. Contains filtered or unexported fields. See [`subSlotTypeComposition` argument reference] below.
         */
        subSlots: any[];
    }
    interface V2modelsSlotTypeExternalSourceSetting {
        /**
         * Settings required for a slot type based on a grammar that you provide. See `grammarSlotTypeSetting` argument reference below.
         */
        grammarSlotTypeSetting?: outputs.lex.V2modelsSlotTypeExternalSourceSettingGrammarSlotTypeSetting;
    }
    interface V2modelsSlotTypeExternalSourceSettingGrammarSlotTypeSetting {
        /**
         * Source of the grammar used to create the slot type. See `grammarSlotTypeSource` argument reference below.
         */
        source?: outputs.lex.V2modelsSlotTypeExternalSourceSettingGrammarSlotTypeSettingSource;
    }
    interface V2modelsSlotTypeExternalSourceSettingGrammarSlotTypeSettingSource {
        kmsKeyArn: string;
        s3BucketName: string;
        s3ObjectKey: string;
    }
    interface V2modelsSlotTypeSlotTypeValues {
        /**
         * List of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for a slot. See `slotTypeValues` argument reference below.
         */
        slotTypeValues: any[];
        /**
         * Additional values related to the slot type entry. See `sampleValue` argument reference below.
         */
        synonyms?: outputs.lex.V2modelsSlotTypeSlotTypeValuesSynonym[];
    }
    interface V2modelsSlotTypeSlotTypeValuesSynonym {
        value: string;
    }
    interface V2modelsSlotTypeTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface V2modelsSlotTypeValueSelectionSetting {
        /**
         * Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances. See [`advancedRecognitionSetting` argument reference] below.
         */
        advancedRecognitionSettings?: outputs.lex.V2modelsSlotTypeValueSelectionSettingAdvancedRecognitionSetting[];
        /**
         * Used to validate the value of the slot. See [`regexFilter` argument reference] below.
         */
        regexFilters?: outputs.lex.V2modelsSlotTypeValueSelectionSettingRegexFilter[];
        /**
         * Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values: `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value. `TOP_RESOLUTION` If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned. If you don't specify the valueSelectionStrategy , the default is `ORIGINAL_VALUE`. Valid values are `OriginalValue`, `TopResolution`, and `Concatenation`.
         */
        resolutionStrategy: string;
    }
    interface V2modelsSlotTypeValueSelectionSettingAdvancedRecognitionSetting {
        audioRecognitionSetting?: string;
    }
    interface V2modelsSlotTypeValueSelectionSettingRegexFilter {
        pattern: string;
    }
    interface V2modelsSlotValueElicitationSetting {
        defaultValueSpecifications?: outputs.lex.V2modelsSlotValueElicitationSettingDefaultValueSpecification[];
        promptSpecification: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecification;
        sampleUtterances?: outputs.lex.V2modelsSlotValueElicitationSettingSampleUtterance[];
        slotConstraint: string;
        slotResolutionSettings?: outputs.lex.V2modelsSlotValueElicitationSettingSlotResolutionSetting[];
        waitAndContinueSpecifications?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecification[];
    }
    interface V2modelsSlotValueElicitationSettingDefaultValueSpecification {
        defaultValueLists?: outputs.lex.V2modelsSlotValueElicitationSettingDefaultValueSpecificationDefaultValueList[];
    }
    interface V2modelsSlotValueElicitationSettingDefaultValueSpecificationDefaultValueList {
        defaultValue: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecification {
        allowInterrupt?: boolean;
        maxRetries: number;
        messageGroups?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroup[];
        messageSelectionStrategy?: string;
        promptAttemptsSpecifications?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecification[];
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroup {
        message: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessage;
        variations?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariation[];
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessage {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessagePlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessagePlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupMessageSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariation {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationPlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationMessageGroupVariationSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecification {
        allowInterrupt?: boolean;
        allowedInputTypes: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAllowedInputTypes;
        audioAndDtmfInputSpecification?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecification;
        mapBlockKey: string;
        textInputSpecification?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationTextInputSpecification;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAllowedInputTypes {
        allowAudioInput: boolean;
        allowDtmfInput: boolean;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecification {
        audioSpecification?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationAudioSpecification;
        dtmfSpecification?: outputs.lex.V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationDtmfSpecification;
        startTimeoutMs: number;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationAudioSpecification {
        endTimeoutMs: number;
        maxLengthMs: number;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationAudioAndDtmfInputSpecificationDtmfSpecification {
        deletionCharacter: string;
        endCharacter: string;
        endTimeoutMs: number;
        maxLength: number;
    }
    interface V2modelsSlotValueElicitationSettingPromptSpecificationPromptAttemptsSpecificationTextInputSpecification {
        startTimeoutMs: number;
    }
    interface V2modelsSlotValueElicitationSettingSampleUtterance {
        utterance: string;
    }
    interface V2modelsSlotValueElicitationSettingSlotResolutionSetting {
        slotResolutionStrategy: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecification {
        active?: boolean;
        continueResponses?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponse[];
        stillWaitingResponses?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponse[];
        waitingResponses?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponse[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponse {
        allowInterrupt?: boolean;
        messageGroups?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroup[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroup {
        message: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessage;
        variations?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariation[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessage {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessagePlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessagePlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupMessageSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariation {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationPlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationContinueResponseMessageGroupVariationSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponse {
        allowInterrupt?: boolean;
        frequencyInSeconds: number;
        messageGroups?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroup[];
        timeoutInSeconds: number;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroup {
        message: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessage;
        variations?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariation[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessage {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessagePlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessagePlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupMessageSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariation {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationPlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationStillWaitingResponseMessageGroupVariationSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponse {
        allowInterrupt?: boolean;
        messageGroups?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroup[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroup {
        message: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessage;
        variations?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariation[];
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessage {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessagePlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessagePlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupMessageSsmlMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariation {
        customPayloads?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationCustomPayload[];
        imageResponseCard?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationImageResponseCard;
        plainTextMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationPlainTextMessage;
        ssmlMessage?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationSsmlMessage;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationCustomPayload {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationImageResponseCard {
        buttons?: outputs.lex.V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationImageResponseCardButton[];
        imageUrl?: string;
        subtitle?: string;
        title: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationImageResponseCardButton {
        text: string;
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationPlainTextMessage {
        value: string;
    }
    interface V2modelsSlotValueElicitationSettingWaitAndContinueSpecificationWaitingResponseMessageGroupVariationSsmlMessage {
        value: string;
    }
}
export declare namespace licensemanager {
    interface GetLicenseGrantsFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/license-manager/latest/APIReference/API_ListReceivedGrants.html#API_ListReceivedGrants_RequestSyntax).
         * For example, if filtering using `ProductSKU`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.licensemanager.getLicenseGrants({
         *     filters: [{
         *         name: "ProductSKU",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }
    interface GetReceivedLicenseConsumptionConfiguration {
        /**
         * Details about a borrow configuration. Detailed below
         */
        borrowConfigurations: outputs.licensemanager.GetReceivedLicenseConsumptionConfigurationBorrowConfiguration[];
        /**
         * Details about a provisional configuration. Detailed below
         */
        provisionalConfigurations: outputs.licensemanager.GetReceivedLicenseConsumptionConfigurationProvisionalConfiguration[];
        renewType: string;
    }
    interface GetReceivedLicenseConsumptionConfigurationBorrowConfiguration {
        /**
         * Indicates whether early check-ins are allowed.
         */
        allowEarlyCheckIn: boolean;
        /**
         * Maximum time for the provisional configuration, in minutes.
         */
        maxTimeToLiveInMinutes: number;
    }
    interface GetReceivedLicenseConsumptionConfigurationProvisionalConfiguration {
        /**
         * Maximum time for the provisional configuration, in minutes.
         */
        maxTimeToLiveInMinutes: number;
    }
    interface GetReceivedLicenseEntitlement {
        /**
         * Indicates whether check-ins are allowed.
         */
        allowCheckIn: boolean;
        /**
         * Maximum entitlement count. Use if the unit is not None.
         */
        maxCount: number;
        /**
         * The key name.
         */
        name: string;
        /**
         * Entitlement unit.
         */
        unit: string;
        /**
         * The value.
         */
        value: string;
    }
    interface GetReceivedLicenseIssuer {
        /**
         * Issuer key fingerprint.
         */
        keyFingerprint: string;
        /**
         * The key name.
         */
        name: string;
        /**
         * Asymmetric KMS key from AWS Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
         */
        signKey: string;
    }
    interface GetReceivedLicenseLicenseMetadata {
        /**
         * The key name.
         */
        name: string;
        /**
         * The value.
         */
        value: string;
    }
    interface GetReceivedLicenseReceivedMetadata {
        /**
         * A list of allowed operations.
         */
        allowedOperations: string[];
        /**
         * Received status.
         */
        receivedStatus: string;
        /**
         * Received status reason.
         */
        receivedStatusReason: string;
    }
    interface GetReceivedLicenseValidity {
        /**
         * Start of the validity time range.
         */
        begin: string;
        /**
         * End of the validity time range.
         */
        end: string;
    }
    interface GetReceivedLicensesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/license-manager/latest/APIReference/API_ListReceivedLicenses.html#API_ListReceivedLicenses_RequestSyntax).
         * For example, if filtering using `ProductSKU`, use:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as aws from "@pulumi/aws";
         *
         * const selected = aws.licensemanager.getReceivedLicenses({
         *     filters: [{
         *         name: "ProductSKU",
         *         values: [""],
         *     }],
         * });
         * ```
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values: string[];
    }
}
export declare namespace lightsail {
    interface CertificateDomainValidationOption {
        /**
         * A domain name for which the certificate should be issued.
         */
        domainName: string;
        resourceRecordName: string;
        resourceRecordType: string;
        resourceRecordValue: string;
    }
    interface ContainerServiceDeploymentVersionContainer {
        /**
         * The launch command for the container. A list of string.
         */
        commands?: string[];
        /**
         * The name for the container.
         */
        containerName: string;
        /**
         * A key-value map of the environment variables of the container.
         */
        environment?: {
            [key: string]: string;
        };
        /**
         * The name of the image used for the container. Container images sourced from your Lightsail container service, that are registered and stored on your service, start with a colon (`:`). For example, `:container-service-1.mystaticwebsite.1`. Container images sourced from a public registry like Docker Hub don't start with a colon. For example, `nginx:latest` or `nginx`.
         */
        image: string;
        /**
         * A key-value map of the open firewall ports of the container. Valid values: `HTTP`, `HTTPS`, `TCP`, `UDP`.
         */
        ports?: {
            [key: string]: string;
        };
    }
    interface ContainerServiceDeploymentVersionPublicEndpoint {
        /**
         * The name of the container for the endpoint.
         */
        containerName: string;
        /**
         * The port of the container to which traffic is forwarded to.
         */
        containerPort: number;
        /**
         * A configuration block that describes the health check configuration of the container. Detailed below.
         */
        healthCheck: outputs.lightsail.ContainerServiceDeploymentVersionPublicEndpointHealthCheck;
    }
    interface ContainerServiceDeploymentVersionPublicEndpointHealthCheck {
        /**
         * The number of consecutive health checks successes required before moving the container to the Healthy state. Defaults to 2.
         */
        healthyThreshold?: number;
        /**
         * The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. Defaults to 5.
         */
        intervalSeconds?: number;
        /**
         * The path on the container on which to perform the health check. Defaults to "/".
         */
        path?: string;
        /**
         * The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. Defaults to "200-499".
         */
        successCodes?: string;
        /**
         * The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. Defaults to 2.
         */
        timeoutSeconds?: number;
        /**
         * The number of consecutive health checks failures required before moving the container to the Unhealthy state. Defaults to 2.
         */
        unhealthyThreshold?: number;
    }
    interface ContainerServicePrivateRegistryAccess {
        /**
         * Describes a request to configure an Amazon Lightsail container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories. See ECR Image Puller Role below for more details.
         */
        ecrImagePullerRole: outputs.lightsail.ContainerServicePrivateRegistryAccessEcrImagePullerRole;
    }
    interface ContainerServicePrivateRegistryAccessEcrImagePullerRole {
        /**
         * A Boolean value that indicates whether to activate the role. The default is `false`.
         */
        isActive?: boolean;
        /**
         * The principal ARN of the container service. The principal ARN can be used to create a trust
         * relationship between your standard AWS account and your Lightsail container service. This allows you to give your
         * service permission to access resources in your standard AWS account.
         */
        principalArn: string;
    }
    interface ContainerServicePublicDomainNames {
        certificates: outputs.lightsail.ContainerServicePublicDomainNamesCertificate[];
    }
    interface ContainerServicePublicDomainNamesCertificate {
        certificateName: string;
        domainNames: string[];
    }
    interface DistributionCacheBehavior {
        /**
         * The cache behavior for the specified path.
         */
        behavior: string;
        /**
         * The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/\*), and file types (\*.html, \*jpg, \*js). Directories and file paths are case-sensitive.
         */
        path: string;
    }
    interface DistributionCacheBehaviorSettings {
        /**
         * The HTTP methods that are processed and forwarded to the distribution's origin.
         */
        allowedHttpMethods?: string;
        /**
         * The HTTP method responses that are cached by your distribution.
         */
        cachedHttpMethods?: string;
        /**
         * The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
         */
        defaultTtl?: number;
        /**
         * An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded. Detailed below
         */
        forwardedCookies?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedCookies;
        /**
         * An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded. Detailed below
         */
        forwardedHeaders?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedHeaders;
        /**
         * An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded. Detailed below
         */
        forwardedQueryStrings?: outputs.lightsail.DistributionCacheBehaviorSettingsForwardedQueryStrings;
        /**
         * The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        maximumTtl?: number;
        /**
         * The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        minimumTtl?: number;
    }
    interface DistributionCacheBehaviorSettingsForwardedCookies {
        /**
         * The specific cookies to forward to your distribution's origin.
         */
        cookiesAllowLists?: string[];
        /**
         * Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
         */
        option?: string;
    }
    interface DistributionCacheBehaviorSettingsForwardedHeaders {
        /**
         * The specific headers to forward to your distribution's origin.
         */
        headersAllowLists?: string[];
        /**
         * The headers that you want your distribution to forward to your origin and base caching on.
         */
        option?: string;
    }
    interface DistributionCacheBehaviorSettingsForwardedQueryStrings {
        /**
         * Indicates whether the distribution forwards and caches based on query strings.
         */
        option?: boolean;
        /**
         * The specific query strings that the distribution forwards to the origin.
         */
        queryStringsAllowedLists?: string[];
    }
    interface DistributionDefaultCacheBehavior {
        /**
         * The cache behavior of the distribution. Valid values: `cache` and `dont-cache`.
         */
        behavior: string;
    }
    interface DistributionLocation {
        /**
         * The Availability Zone. Follows the format us-east-2a (case-sensitive).
         */
        availabilityZone: string;
        /**
         * The AWS Region name.
         */
        regionName: string;
    }
    interface DistributionOrigin {
        /**
         * The name of the origin resource. Your origin can be an instance with an attached static IP, a bucket, or a load balancer that has at least one instance attached to it.
         */
        name: string;
        /**
         * The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
         */
        protocolPolicy?: string;
        /**
         * The AWS Region name of the origin resource.
         */
        regionName: string;
        /**
         * The resource type of the origin resource (e.g., Instance).
         */
        resourceType: string;
    }
    interface InstanceAddOn {
        /**
         * The daily time when an automatic snapshot will be created. Must be in HH:00 format, and in an hourly increment and specified in Coordinated Universal Time (UTC). The snapshot will be automatically created between the time specified and up to 45 minutes after.
         */
        snapshotTime: string;
        /**
         * The status of the add on. Valid Values: `Enabled`, `Disabled`.
         */
        status: string;
        /**
         * The add-on type. There is currently only one valid type `AutoSnapshot`.
         */
        type: string;
    }
    interface InstancePublicPortsPortInfo {
        /**
         * Set of CIDR aliases that define access for a preconfigured range of IP addresses.
         */
        cidrListAliases: string[];
        /**
         * Set of CIDR blocks.
         */
        cidrs: string[];
        /**
         * First port in a range of open ports on an instance.
         */
        fromPort: number;
        ipv6Cidrs: string[];
        /**
         * IP protocol name. Valid values are `tcp`, `all`, `udp`, and `icmp`.
         */
        protocol: string;
        /**
         * Last port in a range of open ports on an instance.
         *
         * The following arguments are optional:
         */
        toPort: number;
    }
    interface LbCertificateDomainValidationRecord {
        /**
         * The domain name (e.g., example.com) for your SSL/TLS certificate.
         */
        domainName: string;
        resourceRecordName: string;
        resourceRecordType: string;
        resourceRecordValue: string;
    }
}
export declare namespace location {
    interface GetMapConfiguration {
        /**
         * The map style selected from an available data provider.
         */
        style: string;
    }
    interface GetPlaceIndexDataSourceConfiguration {
        intendedUse: string;
    }
    interface MapConfiguration {
        /**
         * Specifies the map style selected from an available data provider. Valid values can be found in the [Location Service CreateMap API Reference](https://docs.aws.amazon.com/location/latest/APIReference/API_CreateMap.html).
         */
        style: string;
    }
    interface PlaceIndexDataSourceConfiguration {
        /**
         * Specifies how the results of an operation will be stored by the caller. Valid values: `SingleUse`, `Storage`. Default: `SingleUse`.
         */
        intendedUse?: string;
    }
}
export declare namespace m2 {
    interface ApplicationDefinition {
        /**
         * JSON application definition. Either this or `s3Location` must be specified.
         */
        content?: string;
        /**
         * Location of the application definition in S3. Either this or `content` must be specified.
         */
        s3Location?: string;
    }
    interface ApplicationTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface DeploymentTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface EnvironmentHighAvailabilityConfig {
        /**
         * Desired number of instances for the Environment.
         */
        desiredCapacity: number;
    }
    interface EnvironmentStorageConfiguration {
        efs?: outputs.m2.EnvironmentStorageConfigurationEfs;
        fsx?: outputs.m2.EnvironmentStorageConfigurationFsx;
    }
    interface EnvironmentStorageConfigurationEfs {
        /**
         * Id of the EFS filesystem to mount.
         */
        fileSystemId: string;
        /**
         * Path to mount the filesystem on, must start with `/m2/mount/`.
         */
        mountPoint: string;
    }
    interface EnvironmentStorageConfigurationFsx {
        /**
         * Id of the FSX filesystem to mount.
         */
        fileSystemId: string;
        /**
         * Path to mount the filesystem on, must start with `/m2/mount/`.
         */
        mountPoint: string;
    }
    interface EnvironmentTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
}
export declare namespace macie {
    interface FindingsFilterFindingCriteria {
        /**
         * A condition that specifies the property, operator, and one or more values to use to filter the results.  (documented below)
         */
        criterions?: outputs.macie.FindingsFilterFindingCriteriaCriterion[];
    }
    interface FindingsFilterFindingCriteriaCriterion {
        /**
         * The value for the property exclusively matches (equals an exact match for) all the specified values. If you specify multiple values, Amazon Macie uses AND logic to join the values.
         */
        eqExactMatches?: string[];
        /**
         * The value for the property matches (equals) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
         */
        eqs?: string[];
        /**
         * The name of the field to be evaluated.
         */
        field: string;
        /**
         * The value for the property is greater than the specified value.
         */
        gt?: string;
        /**
         * The value for the property is greater than or equal to the specified value.
         */
        gte?: string;
        /**
         * The value for the property is less than the specified value.
         */
        lt?: string;
        /**
         * The value for the property is less than or equal to the specified value.
         */
        lte?: string;
        /**
         * The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.
         */
        neqs?: string[];
    }
}
export declare namespace macie2 {
    interface ClassificationExportConfigurationS3Destination {
        /**
         * The Amazon S3 bucket name in which Amazon Macie exports the data classification results.
         */
        bucketName: string;
        /**
         * The object key for the bucket in which Amazon Macie exports the data classification results.
         */
        keyPrefix?: string;
        /**
         * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
         *
         * Additional information can be found in the [Storing and retaining sensitive data discovery results with Amazon Macie for AWS Macie documentation](https://docs.aws.amazon.com/macie/latest/user/discovery-results-repository-s3.html).
         */
        kmsKeyArn: string;
    }
    interface ClassificationJobS3JobDefinition {
        /**
         * The property- and tag-based conditions that determine which S3 buckets to include or exclude from the analysis. Conflicts with `bucketDefinitions`. (documented below)
         */
        bucketCriteria: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteria;
        /**
         * An array of objects, one for each AWS account that owns buckets to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for the account. Conflicts with `bucketCriteria`. (documented below)
         */
        bucketDefinitions?: outputs.macie2.ClassificationJobS3JobDefinitionBucketDefinition[];
        /**
         * The property- and tag-based conditions that determine which objects to include or exclude from the analysis. (documented below)
         */
        scoping: outputs.macie2.ClassificationJobS3JobDefinitionScoping;
    }
    interface ClassificationJobS3JobDefinitionBucketCriteria {
        /**
         * The property- or tag-based conditions that determine which S3 buckets to exclude from the analysis. (documented below)
         */
        excludes: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludes;
        /**
         * The property- or tag-based conditions that determine which S3 buckets to include in the analysis. (documented below)
         */
        includes: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludes;
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaExcludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAnd[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
         */
        simpleCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
         */
        tagCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterion;
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndSimpleCriterion {
        /**
         * The operator to use in a condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The object property to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionkeyforjob)
         */
        key: string;
        /**
         * An array that lists the values to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionforjob)
         */
        values: string[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterion {
        /**
         * The operator to use in the condition. Valid combination and values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The  tag key and value pairs to use in the condition. One or more blocks are allowed. (documented below)
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValue[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaExcludesAndTagCriterionTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaIncludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAnd[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an S3 buckets from the job. (documented below)
         */
        simpleCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an S3 buckets from the job. (documented below)
         */
        tagCriterion: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterion;
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndSimpleCriterion {
        /**
         * The operator to use in a condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The object property to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionkeyforjob)
         */
        key: string;
        /**
         * An array that lists the values to use in the condition. Valid combination of values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-simplecriterionforjob)
         */
        values: string[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterion {
        /**
         * The operator to use in the condition. Valid combination and values are available in the [AWS Documentation](https://docs.aws.amazon.com/macie/latest/APIReference/jobs.html#jobs-model-jobcomparator)
         */
        comparator: string;
        /**
         * The  tag key and value pairs to use in the condition. One or more blocks are allowed. (documented below)
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValue[];
    }
    interface ClassificationJobS3JobDefinitionBucketCriteriaIncludesAndTagCriterionTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }
    interface ClassificationJobS3JobDefinitionBucketDefinition {
        /**
         * The unique identifier for the AWS account that owns the buckets.
         */
        accountId: string;
        /**
         * An array that lists the names of the buckets.
         */
        buckets: string[];
    }
    interface ClassificationJobS3JobDefinitionScoping {
        /**
         * The property- or tag-based conditions that determine which objects to exclude from the analysis. (documented below)
         */
        excludes: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludes;
        /**
         * The property- or tag-based conditions that determine which objects to include in the analysis. (documented below)
         */
        includes: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludes;
    }
    interface ClassificationJobS3JobDefinitionScopingExcludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAnd[];
    }
    interface ClassificationJobS3JobDefinitionScopingExcludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
         */
        simpleScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndSimpleScopeTerm;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
         */
        tagScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTerm;
    }
    interface ClassificationJobS3JobDefinitionScopingExcludesAndSimpleScopeTerm {
        /**
         * The operator to use in a condition. Valid values are: `EQ`, `GT`, `GTE`, `LT`, `LTE`, `NE`, `CONTAINS`, `STARTS_WITH`
         */
        comparator: string;
        /**
         * The object property to use in the condition.
         */
        key: string;
        /**
         * An array that lists the values to use in the condition.
         */
        values: string[];
    }
    interface ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTerm {
        /**
         * The operator to use in the condition.
         */
        comparator: string;
        /**
         * The tag key to use in the condition. The only valid value is `TAG`.
         */
        key: string;
        /**
         * The tag keys or tag key and value pairs to use in the condition.
         */
        tagValues: outputs.macie2.ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTermTagValue[];
        /**
         * The type of object to apply the condition to. The only valid value is `S3_OBJECT`.
         */
        target: string;
    }
    interface ClassificationJobS3JobDefinitionScopingExcludesAndTagScopeTermTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }
    interface ClassificationJobS3JobDefinitionScopingIncludes {
        /**
         * An array of conditions, one for each condition that determines which objects to include or exclude from the job. (documented below)
         */
        ands: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAnd[];
    }
    interface ClassificationJobS3JobDefinitionScopingIncludesAnd {
        /**
         * A property-based condition that defines a property, operator, and one or more values for including or excluding an object from the job. (documented below)
         */
        simpleScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndSimpleScopeTerm;
        /**
         * A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding an object from the job. (documented below)
         */
        tagScopeTerm: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTerm;
    }
    interface ClassificationJobS3JobDefinitionScopingIncludesAndSimpleScopeTerm {
        /**
         * The operator to use in a condition. Valid values are: `EQ`, `GT`, `GTE`, `LT`, `LTE`, `NE`, `CONTAINS`, `STARTS_WITH`
         */
        comparator: string;
        /**
         * The object property to use in the condition.
         */
        key: string;
        /**
         * An array that lists the values to use in the condition.
         */
        values: string[];
    }
    interface ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTerm {
        /**
         * The operator to use in the condition.
         */
        comparator: string;
        /**
         * The tag key to use in the condition. The only valid value is `TAG`.
         */
        key: string;
        /**
         * The tag keys or tag key and value pairs to use in the condition.
         */
        tagValues?: outputs.macie2.ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTermTagValue[];
        /**
         * The type of object to apply the condition to. The only valid value is `S3_OBJECT`.
         */
        target: string;
    }
    interface ClassificationJobS3JobDefinitionScopingIncludesAndTagScopeTermTagValue {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }
    interface ClassificationJobScheduleFrequency {
        /**
         * Specifies a daily recurrence pattern for running the job.
         */
        dailySchedule?: boolean;
        /**
         * Specifies a monthly recurrence pattern for running the job.
         */
        monthlySchedule: number;
        /**
         * Specifies a weekly recurrence pattern for running the job.
         */
        weeklySchedule: string;
    }
    interface ClassificationJobUserPausedDetail {
        jobExpiresAt: string;
        jobImminentExpirationHealthEventArn: string;
        jobPausedAt: string;
    }
}
export declare namespace mediaconvert {
    interface QueueReservationPlanSettings {
        /**
         * The length of the term of your reserved queue pricing plan commitment. Valid value is `ONE_YEAR`.
         */
        commitment: string;
        /**
         * Specifies whether the term of your reserved queue pricing plan. Valid values are `AUTO_RENEW` or `EXPIRE`.
         */
        renewalType: string;
        /**
         * Specifies the number of reserved transcode slots (RTS) for queue.
         */
        reservedSlots: number;
    }
}
export declare namespace medialive {
    interface ChannelCdiInputSpecification {
        /**
         * Maximum CDI input resolution.
         */
        resolution: string;
    }
    interface ChannelDestination {
        /**
         * User-specified id. Ths is used in an output group or an output.
         */
        id: string;
        /**
         * Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details.
         */
        mediaPackageSettings?: outputs.medialive.ChannelDestinationMediaPackageSetting[];
        /**
         * Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details.
         */
        multiplexSettings?: outputs.medialive.ChannelDestinationMultiplexSettings;
        /**
         * Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details.
         */
        settings?: outputs.medialive.ChannelDestinationSetting[];
    }
    interface ChannelDestinationMediaPackageSetting {
        /**
         * ID of the channel in MediaPackage that is the destination for this output group.
         */
        channelId: string;
    }
    interface ChannelDestinationMultiplexSettings {
        /**
         * The ID of the Multiplex that the encoder is providing output to.
         */
        multiplexId: string;
        /**
         * The program name of the Multiplex program that the encoder is providing output to.
         */
        programName: string;
    }
    interface ChannelDestinationSetting {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam?: string;
        /**
         * Stream name RTMP destinations (URLs of type rtmp://)
         */
        streamName?: string;
        /**
         * A URL specifying a destination.
         */
        url?: string;
        /**
         * Username for destination.
         */
        username?: string;
    }
    interface ChannelEncoderSettings {
        /**
         * Audio descriptions for the channel. See Audio Descriptions for more details.
         */
        audioDescriptions?: outputs.medialive.ChannelEncoderSettingsAudioDescription[];
        /**
         * Settings for ad avail blanking. See Avail Blanking for more details.
         */
        availBlanking: outputs.medialive.ChannelEncoderSettingsAvailBlanking;
        /**
         * Caption Descriptions. See Caption Descriptions for more details.
         */
        captionDescriptions: outputs.medialive.ChannelEncoderSettingsCaptionDescription[];
        /**
         * Configuration settings that apply to the event as a whole. See Global Configuration for more details.
         */
        globalConfiguration?: outputs.medialive.ChannelEncoderSettingsGlobalConfiguration;
        /**
         * Settings for motion graphics. See Motion Graphics Configuration for more details.
         */
        motionGraphicsConfiguration?: outputs.medialive.ChannelEncoderSettingsMotionGraphicsConfiguration;
        /**
         * Nielsen configuration settings. See Nielsen Configuration for more details.
         */
        nielsenConfiguration?: outputs.medialive.ChannelEncoderSettingsNielsenConfiguration;
        /**
         * Output groups for the channel. See Output Groups for more details.
         */
        outputGroups: outputs.medialive.ChannelEncoderSettingsOutputGroup[];
        /**
         * Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details.
         */
        timecodeConfig: outputs.medialive.ChannelEncoderSettingsTimecodeConfig;
        /**
         * Video Descriptions. See Video Descriptions for more details.
         */
        videoDescriptions: outputs.medialive.ChannelEncoderSettingsVideoDescription[];
    }
    interface ChannelEncoderSettingsAudioDescription {
        /**
         * Advanced audio normalization settings. See Audio Normalization Settings for more details.
         */
        audioNormalizationSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings;
        /**
         * The name of the audio selector used as the source for this AudioDescription.
         */
        audioSelectorName: string;
        /**
         * Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1.
         */
        audioType: string;
        /**
         * Determined how audio type is determined.
         */
        audioTypeControl: string;
        /**
         * Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details.
         */
        audioWatermarkSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings;
        /**
         * Audio codec settings. See Audio Codec Settings for more details.
         */
        codecSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettings;
        languageCode: string;
        languageCodeControl: string;
        /**
         * The name of this audio description.
         */
        name: string;
        remixSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettings;
        streamName: string;
    }
    interface ChannelEncoderSettingsAudioDescriptionAudioNormalizationSettings {
        /**
         * Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification.
         */
        algorithm: string;
        /**
         * Algorithm control for the audio description.
         */
        algorithmControl: string;
        /**
         * Target LKFS (loudness) to adjust volume to.
         */
        targetLkfs: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettings {
        nielsenWatermarksSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings;
    }
    interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettings {
        nielsenCbetSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings;
        nielsenDistributionType: string;
        nielsenNaesIiNwSettings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting[];
    }
    interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenCbetSettings {
        cbetCheckDigitString: string;
        /**
         * Determines the method of CBET insertion mode when prior encoding is detected on the same layer.
         */
        cbetStepaside: string;
        /**
         * CBET source ID to use in the watermark.
         */
        csid: string;
    }
    interface ChannelEncoderSettingsAudioDescriptionAudioWatermarkSettingsNielsenWatermarksSettingsNielsenNaesIiNwSetting {
        checkDigitString: string;
        /**
         * The Nielsen Source ID to include in the watermark.
         */
        sid: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettings {
        aacSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings;
        ac3Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings;
        eac3AtmosSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings;
        eac3Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings;
        mp2Settings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings;
        passThroughSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings;
        wavSettings?: outputs.medialive.ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAacSettings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Mono, Stereo, or 5.1 channel layout.
         */
        codingMode: string;
        /**
         * Set to "broadcasterMixedAd" when input contains pre-mixed main audio + AD (narration) as a stereo pair.
         */
        inputType: string;
        /**
         * AAC profile.
         */
        profile: string;
        /**
         * The rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets LATM/LOAS AAC output for raw containers.
         */
        rawFormat: string;
        /**
         * Sample rate in Hz.
         */
        sampleRate: number;
        /**
         * Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers.
         */
        spec: string;
        /**
         * VBR Quality Level - Only used if rateControlMode is VBR.
         */
        vbrQuality: string;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsAc3Settings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
         */
        bitstreamMode: string;
        /**
         * Dolby Digital coding mode.
         */
        codingMode: string;
        /**
         * Sets the dialnorm of the output.
         */
        dialnorm: number;
        /**
         * If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification.
         */
        drcProfile: string;
        /**
         * When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding.
         */
        lfeFilter: string;
        /**
         * Metadata control.
         */
        metadataControl: string;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3AtmosSettings {
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Dolby Digital Plus with Dolby Atmos coding mode.
         */
        codingMode: string;
        /**
         * Sets the dialnorm for the output.
         */
        dialnorm: number;
        /**
         * Sets the Dolby dynamic range compression profile.
         */
        drcLine: string;
        /**
         * Sets the profile for heavy Dolby dynamic range compression.
         */
        drcRf: string;
        /**
         * Height dimensional trim.
         */
        heightTrim: number;
        /**
         * Surround dimensional trim.
         */
        surroundTrim: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsEac3Settings {
        /**
         * Sets the attenuation control.
         */
        attenuationControl: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Specifies the bitstream mode (bsmod) for the emitted AC-3 stream.
         */
        bitstreamMode: string;
        /**
         * Dolby Digital Plus coding mode.
         */
        codingMode: string;
        dcFilter: string;
        dialnorm: number;
        drcLine: string;
        drcRf: string;
        lfeControl: string;
        lfeFilter: string;
        loRoCenterMixLevel: number;
        loRoSurroundMixLevel: number;
        ltRtCenterMixLevel: number;
        ltRtSurroundMixLevel: number;
        metadataControl: string;
        passthroughControl: string;
        phaseControl: string;
        stereoDownmix: string;
        surroundExMode: string;
        surroundMode: string;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsMp2Settings {
        bitrate: number;
        codingMode: string;
        sampleRate: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsPassThroughSettings {
    }
    interface ChannelEncoderSettingsAudioDescriptionCodecSettingsWavSettings {
        bitDepth: number;
        codingMode: string;
        sampleRate: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionRemixSettings {
        channelMappings: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping[];
        channelsIn: number;
        channelsOut: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMapping {
        inputChannelLevels: outputs.medialive.ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel[];
        outputChannel: number;
    }
    interface ChannelEncoderSettingsAudioDescriptionRemixSettingsChannelMappingInputChannelLevel {
        gain: number;
        inputChannel: number;
    }
    interface ChannelEncoderSettingsAvailBlanking {
        /**
         * Blanking image to be used. See Avail Blanking Image for more details.
         */
        availBlankingImage?: outputs.medialive.ChannelEncoderSettingsAvailBlankingAvailBlankingImage;
        /**
         * When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added.
         */
        state: string;
    }
    interface ChannelEncoderSettingsAvailBlankingAvailBlankingImage {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * . Username to be used.
         */
        username: string;
    }
    interface ChannelEncoderSettingsCaptionDescription {
        /**
         * Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds.
         */
        accessibility?: string;
        /**
         * Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name.
         */
        captionSelectorName: string;
        /**
         * Additional settings for captions destination that depend on the destination type. See Destination Settings for more details.
         */
        destinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettings;
        /**
         * ISO 639-2 three-digit code.
         */
        languageCode?: string;
        /**
         * Human readable information to indicate captions available for players (eg. English, or Spanish).
         */
        languageDescription?: string;
        /**
         * Name of the caption description. Used to associate a caption description with an output. Names must be unique within an event.
         */
        name: string;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettings {
        /**
         * ARIB Destination Settings.
         */
        aribDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings;
        /**
         * Burn In Destination Settings. See Burn In Destination Settings for more details.
         */
        burnInDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings;
        /**
         * DVB Sub Destination Settings. See DVB Sub Destination Settings for more details.
         */
        dvbSubDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings;
        /**
         * EBU TT D Destination Settings. See EBU TT D Destination Settings for more details.
         */
        ebuTtDDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings;
        /**
         * Embedded Destination Settings.
         */
        embeddedDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings;
        /**
         * Embedded Plus SCTE20 Destination Settings.
         */
        embeddedPlusScte20DestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings;
        /**
         * RTMP Caption Info Destination Settings.
         */
        rtmpCaptionInfoDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings;
        /**
         * SCTE20 Plus Embedded Destination Settings.
         */
        scte20PlusEmbeddedDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings;
        /**
         * SCTE27 Destination Settings.
         */
        scte27DestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings;
        /**
         * SMPTE TT Destination Settings.
         */
        smpteTtDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings;
        /**
         * Teletext Destination Settings.
         */
        teletextDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings;
        /**
         * TTML Destination Settings. See TTML Destination Settings for more details.
         */
        ttmlDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings;
        /**
         * WebVTT Destination Settings. See WebVTT Destination Settings for more details.
         */
        webvttDestinationSettings?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsAribDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettings {
        /**
         * If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match.
         */
        alignment?: string;
        /**
         * Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
         */
        backgroundColor?: string;
        /**
         * Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
         */
        backgroundOpacity?: number;
        /**
         * External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
         */
        font?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont;
        /**
         * Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        fontColor?: string;
        /**
         * Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
         */
        fontOpacity?: number;
        /**
         * Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
         */
        fontResolution?: number;
        /**
         * When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
         */
        fontSize?: string;
        /**
         * Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        outlineColor: string;
        /**
         * Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        outlineSize?: number;
        /**
         * Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
         */
        shadowColor?: string;
        /**
         * Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
         */
        shadowOpacity?: number;
        /**
         * Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
         */
        shadowXOffset?: number;
        /**
         * Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
         */
        shadowYOffset?: number;
        /**
         * Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
         */
        teletextGridControl: string;
        /**
         * Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match.
         */
        xPosition?: number;
        /**
         * Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match.
         */
        yPosition?: number;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsBurnInDestinationSettingsFont {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * Username to be used.
         */
        username: string;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettings {
        /**
         * If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. This option is not valid for source captions that are STL or 608/embedded. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        alignment?: string;
        /**
         * Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match.
         */
        backgroundColor?: string;
        /**
         * Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
         */
        backgroundOpacity?: number;
        /**
         * External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details.
         */
        font?: outputs.medialive.ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont;
        /**
         * Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        fontColor?: string;
        /**
         * Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match.
         */
        fontOpacity?: number;
        /**
         * Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match.
         */
        fontResolution?: number;
        /**
         * When set to auto fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match.
         */
        fontSize: string;
        /**
         * Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        outlineColor?: string;
        /**
         * Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        outlineSize?: number;
        /**
         * Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match.
         */
        shadowColor?: string;
        /**
         * Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
         */
        shadowOpacity?: number;
        /**
         * Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
         */
        shadowXOffset?: number;
        /**
         * Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
         */
        shadowYOffset?: number;
        /**
         * Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs.
         */
        teletextGridControl?: string;
        /**
         * Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        xPosition?: number;
        /**
         * Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
         */
        yPosition?: number;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsDvbSubDestinationSettingsFont {
        /**
         * Key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * Path to a file accessible to the live stream.
         */
        uri: string;
        /**
         * Username to be used.
         */
        username: string;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEbuTtDDestinationSettings {
        /**
         * Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata.
         */
        copyrightHolder?: string;
        /**
         * Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled.
         */
        fillLineGap?: string;
        /**
         * Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”.
         */
        fontFamily?: string;
        /**
         * Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information.
         */
        styleControl: string;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsEmbeddedPlusScte20DestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsRtmpCaptionInfoDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte20PlusEmbeddedDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsScte27DestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsSmpteTtDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTeletextDestinationSettings {
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsTtmlDestinationSettings {
        /**
         * This field is not currently supported and will not affect the output styling. Leave the default value.
         */
        styleControl: string;
    }
    interface ChannelEncoderSettingsCaptionDescriptionDestinationSettingsWebvttDestinationSettings {
        /**
         * Controls whether the color and position of the source captions is passed through to the WebVTT output captions. PASSTHROUGH - Valid only if the source captions are EMBEDDED or TELETEXT. NO\_STYLE\_DATA - Don’t pass through the style. The output captions will not contain any font styling information.
         */
        styleControl: string;
    }
    interface ChannelEncoderSettingsGlobalConfiguration {
        /**
         * Value to set the initial audio gain for the Live Event.
         */
        initialAudioGain?: number;
        /**
         * Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API).
         */
        inputEndAction?: string;
        /**
         * Settings for system actions when input is lost. See Input Loss Behavior for more details.
         */
        inputLossBehavior?: outputs.medialive.ChannelEncoderSettingsGlobalConfigurationInputLossBehavior;
        /**
         * Indicates how MediaLive pipelines are synchronized. PIPELINE\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH\_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch.
         */
        outputLockingMode?: string;
        /**
         * Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream.
         */
        outputTimingSource?: string;
        /**
         * Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second.
         */
        supportLowFramerateInputs?: string;
    }
    interface ChannelEncoderSettingsGlobalConfigurationInputLossBehavior {
        blackFrameMsec?: number;
        inputLossImageColor?: string;
        inputLossImageSlate?: outputs.medialive.ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate;
        inputLossImageType?: string;
        repeatFrameMsec?: number;
    }
    interface ChannelEncoderSettingsGlobalConfigurationInputLossBehaviorInputLossImageSlate {
        passwordParam: string;
        uri: string;
        username: string;
    }
    interface ChannelEncoderSettingsMotionGraphicsConfiguration {
        /**
         * Motion Graphics Insertion.
         */
        motionGraphicsInsertion?: string;
        /**
         * Motion Graphics Settings. See Motion Graphics Settings for more details.
         */
        motionGraphicsSettings: outputs.medialive.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings;
    }
    interface ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettings {
        /**
         * Html Motion Graphics Settings.
         */
        htmlMotionGraphicsSettings?: outputs.medialive.ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings;
    }
    interface ChannelEncoderSettingsMotionGraphicsConfigurationMotionGraphicsSettingsHtmlMotionGraphicsSettings {
    }
    interface ChannelEncoderSettingsNielsenConfiguration {
        /**
         * Enter the Distributor ID assigned to your organization by Nielsen.
         */
        distributorId?: string;
        /**
         * Enables Nielsen PCM to ID3 tagging.
         */
        nielsenPcmToId3Tagging?: string;
    }
    interface ChannelEncoderSettingsOutputGroup {
        /**
         * Custom output group name defined by the user.
         */
        name?: string;
        /**
         * Settings associated with the output group. See Output Group Settings for more details.
         */
        outputGroupSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettings;
        /**
         * List of outputs. See Outputs for more details.
         */
        outputs: outputs.medialive.ChannelEncoderSettingsOutputGroupOutput[];
    }
    interface ChannelEncoderSettingsOutputGroupOutput {
        /**
         * The names of the audio descriptions used as audio sources for the output.
         */
        audioDescriptionNames?: string[];
        /**
         * The names of the caption descriptions used as caption sources for the output.
         */
        captionDescriptionNames: string[];
        /**
         * The name used to identify an output.
         */
        outputName?: string;
        /**
         * Settings for output. See Output Settings for more details.
         */
        outputSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettings;
        /**
         * The name of the video description used as video source for the output.
         */
        videoDescriptionName?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettings {
        /**
         * Archive group settings. See Archive Group Settings for more details.
         */
        archiveGroupSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting[];
        frameCaptureGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings;
        hlsGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings;
        /**
         * Media package group settings. See Media Package Group Settings for more details.
         */
        mediaPackageGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings;
        msSmoothGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings;
        multiplexGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings;
        /**
         * RTMP group settings. See RTMP Group Settings for more details.
         */
        rtmpGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings;
        udpGroupSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSetting {
        /**
         * Parameters that control the interactions with the CDN. See Archive CDN Settings for more details.
         */
        archiveCdnSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings;
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination;
        /**
         * Number of seconds to write to archive file before closing and starting a new one.
         */
        rolloverInterval?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettings {
        /**
         * Archive S3 Settings. See Archive S3 Settings for more details.
         */
        archiveS3Settings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingArchiveCdnSettingsArchiveS3Settings {
        /**
         * Specify the canned ACL to apply to each S3 request.
         */
        cannedAcl?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsArchiveGroupSettingDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettings {
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination;
        frameCaptureCdnSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettings {
        frameCaptureS3Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsFrameCaptureGroupSettingsFrameCaptureCdnSettingsFrameCaptureS3Settings {
        cannedAcl?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettings {
        adMarkers: string[];
        baseUrlContent: string;
        baseUrlContent1: string;
        baseUrlManifest: string;
        baseUrlManifest1: string;
        captionLanguageMappings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping[];
        captionLanguageSetting: string;
        clientCache: string;
        codecSpecification: string;
        constantIv: string;
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination;
        directoryStructure: string;
        discontinuityTags: string;
        encryptionType: string;
        hlsCdnSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting[];
        hlsId3SegmentTagging: string;
        iframeOnlyPlaylists: string;
        incompleteSegmentBehavior: string;
        indexNSegments: number;
        inputLossAction: string;
        ivInManifest: string;
        ivSource: string;
        keepSegments: number;
        keyFormat: string;
        keyFormatVersions: string;
        keyProviderSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings;
        manifestCompression: string;
        manifestDurationFormat: string;
        minSegmentLength: number;
        mode: string;
        outputSelection: string;
        programDateTime: string;
        programDateTimeClock: string;
        programDateTimePeriod: number;
        redundantManifest: string;
        segmentLength: number;
        segmentsPerSubdirectory: number;
        streamInfResolution: string;
        timedMetadataId3Frame: string;
        timedMetadataId3Period: number;
        timestampDeltaMilliseconds: number;
        tsFileMode: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsCaptionLanguageMapping {
        captionChannel: number;
        languageCode: string;
        languageDescription: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSetting {
        hlsAkamaiSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings;
        hlsBasicPutSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings;
        hlsMediaStoreSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings;
        hlsS3Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings;
        hlsWebdavSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsAkamaiSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode: string;
        numRetries?: number;
        restartDelay?: number;
        salt: string;
        token: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsBasicPutSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsMediaStoreSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        mediaStoreStorageClass: string;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsS3Settings {
        cannedAcl?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsHlsCdnSettingHlsWebdavSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode: string;
        numRetries?: number;
        restartDelay?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettings {
        staticKeySettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting[];
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySetting {
        keyProviderServer?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer;
        staticKeyValue: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsHlsGroupSettingsKeyProviderSettingsStaticKeySettingKeyProviderServer {
        passwordParam: string;
        uri: string;
        username: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettings {
        /**
         * A director and base filename where archive files should be written. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMediaPackageGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettings {
        acquisitionPointId: string;
        audioOnlyTimecodeControl: string;
        certificateMode: string;
        connectionRetryInterval: number;
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination;
        eventId: string;
        eventIdMode: string;
        eventStopBehavior: string;
        filecacheDuration?: number;
        fragmentLength: number;
        inputLossAction: string;
        numRetries?: number;
        restartDelay?: number;
        segmentationMode: string;
        sendDelayMs: number;
        sparseTrackType: string;
        streamManifestBehavior: string;
        timestampOffset: string;
        timestampOffsetMode: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMsSmoothGroupSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsMultiplexGroupSettings {
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsRtmpGroupSettings {
        /**
         * The ad marker type for this output group.
         */
        adMarkers?: string[];
        /**
         * Authentication scheme to use when connecting with CDN.
         */
        authenticationScheme: string;
        /**
         * Controls behavior when content cache fills up.
         */
        cacheFullBehavior: string;
        /**
         * Cache length in seconds, is used to calculate buffer size.
         */
        cacheLength: number;
        /**
         * Controls the types of data that passes to onCaptionInfo outputs.
         */
        captionData: string;
        /**
         * Controls the behavior of the RTMP group if input becomes unavailable.
         */
        inputLossAction: string;
        /**
         * Number of seconds to wait until a restart is initiated.
         */
        restartDelay?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputGroupSettingsUdpGroupSettings {
        /**
         * Specifies behavior of last resort when input video os lost.
         */
        inputLossAction: string;
        /**
         * Indicates ID3 frame that has the timecode.
         */
        timedMetadataId3Frame: string;
        timedMetadataId3Period: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettings {
        /**
         * Archive output settings. See Archive Output Settings for more details.
         */
        archiveOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings;
        frameCaptureOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings;
        hlsOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings;
        /**
         * Media package output settings. This can be set as an empty block.
         */
        mediaPackageOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings;
        msSmoothOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings;
        /**
         * Multiplex output settings. See Multiplex Output Settings for more details.
         */
        multiplexOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings;
        /**
         * RTMP output settings. See RTMP Output Settings for more details.
         */
        rtmpOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings;
        /**
         * UDP output settings. See UDP Output Settings for more details.
         */
        udpOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettings {
        /**
         * Settings specific to the container type of the file. See Container Settings for more details.
         */
        containerSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings;
        /**
         * Output file extension.
         */
        extension?: string;
        /**
         * String concatenated to the end of the destination filename. Required for multiple outputs of the same type.
         */
        nameModifier?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettings {
        /**
         * M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
         */
        m2tsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings;
        /**
         * Raw Settings. This can be set as an empty block.
         */
        rawSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettings {
        absentInputAudioBehavior: string;
        arib?: string;
        aribCaptionsPid: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids: string;
        audioStreamType?: string;
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
        dvbSubPids: string;
        dvbTdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
        dvbTeletextPid: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid: string;
        etvSignalPid: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids: string;
        scte35Control?: string;
        scte35Pid: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid: string;
        transportStreamId?: number;
        videoPid: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
        networkId: number;
        networkName: string;
        repInterval?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
        repInterval?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsArchiveOutputSettingsContainerSettingsRawSettings {
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsFrameCaptureOutputSettings {
        nameModifier: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettings {
        h265PackagingType: string;
        hlsSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings;
        nameModifier: string;
        segmentModifier: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettings {
        audioOnlyHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings;
        fmp4HlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings;
        frameCaptureHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings;
        standardHlsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettings {
        audioGroupId: string;
        audioOnlyImage?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage;
        audioTrackType: string;
        segmentType: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsAudioOnlyHlsSettingsAudioOnlyImage {
        passwordParam: string;
        uri: string;
        username: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFmp4HlsSettings {
        audioRenditionSets: string;
        nielsenId3Behavior: string;
        timedMetadataBehavior: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsFrameCaptureHlsSettings {
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettings {
        audioRenditionSets: string;
        m3u8Settings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsHlsOutputSettingsHlsSettingsStandardHlsSettingsM3u8Settings {
        audioFramesPerPes: number;
        audioPids: string;
        ecmPid: string;
        nielsenId3Behavior: string;
        patInterval: number;
        pcrControl: string;
        pcrPeriod: number;
        pcrPid: string;
        pmtInterval: number;
        pmtPid: string;
        programNum: number;
        scte35Behavior: string;
        scte35Pid: string;
        timedMetadataBehavior: string;
        timedMetadataPid: string;
        transportStreamId: number;
        videoPid: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMediaPackageOutputSettings {
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMsSmoothOutputSettings {
        h265PackagingType: string;
        nameModifier: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettings {
        /**
         * Destination is a multiplex. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsMultiplexOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettings {
        /**
         * Setting to allow self signed or verified RTMP certificates.
         */
        certificateMode: string;
        /**
         * Number of seconds to wait before retrying connection to the flash media server if the connection is lost.
         */
        connectionRetryInterval: number;
        /**
         * The RTMP endpoint excluding the stream name. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination;
        /**
         * Number of retry attempts.
         */
        numRetries: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsRtmpOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettings {
        /**
         * UDP output buffering in milliseconds.
         */
        bufferMsec: number;
        /**
         * UDP container settings. See Container Settings for more details.
         */
        containerSettings: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings;
        /**
         * Destination address and port number for RTP or UDP packets. See Destination for more details.
         */
        destination: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination;
        fecOutputSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettings {
        /**
         * M2TS Settings. See [M2TS Settings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-medialive-channel-m2tssettings.html) for more details.
         */
        m2tsSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettings {
        absentInputAudioBehavior: string;
        arib?: string;
        aribCaptionsPid: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids: string;
        audioStreamType?: string;
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings;
        dvbSubPids: string;
        dvbTdtSettings?: outputs.medialive.ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings;
        dvbTeletextPid: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid: string;
        etvSignalPid: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids: string;
        scte35Control?: string;
        scte35Pid: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid: string;
        transportStreamId?: number;
        videoPid: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbNitSettings {
        networkId: number;
        networkName: string;
        repInterval?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsContainerSettingsM2tsSettingsDvbTdtSettings {
        repInterval?: number;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsDestination {
        /**
         * Reference ID for the destination.
         */
        destinationRefId: string;
    }
    interface ChannelEncoderSettingsOutputGroupOutputOutputSettingsUdpOutputSettingsFecOutputSettings {
        /**
         * The height of the FEC protection matrix.
         */
        columnDepth: number;
        /**
         * Enables column only or column and row based FEC.
         */
        includeFec: string;
        /**
         * The width of the FEC protection matrix.
         */
        rowLength: number;
    }
    interface ChannelEncoderSettingsTimecodeConfig {
        /**
         * The source for the timecode that will be associated with the events outputs.
         */
        source: string;
        /**
         * Threshold in frames beyond which output timecode is resynchronized to the input timecode.
         */
        syncThreshold: number;
    }
    interface ChannelEncoderSettingsVideoDescription {
        /**
         * The video codec settings. See Video Codec Settings for more details.
         */
        codecSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettings;
        /**
         * Output video height in pixels.
         */
        height: number;
        /**
         * The name of the video description.
         */
        name: string;
        /**
         * Indicate how to respond to the AFD values that might be in the input video.
         */
        respondToAfd: string;
        /**
         * Behavior on how to scale.
         */
        scalingBehavior: string;
        /**
         * Changes the strength of the anti-alias filter used for scaling.
         */
        sharpness: number;
        /**
         * Output video width in pixels.
         */
        width: number;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettings {
        frameCaptureSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings;
        h264Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings;
        h265Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsFrameCaptureSettings {
        /**
         * The frequency at which to capture frames for inclusion in the output.
         */
        captureInterval: number;
        /**
         * Unit for the frame capture interval.
         */
        captureIntervalUnits: string;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264Settings {
        /**
         * Enables or disables adaptive quantization.
         */
        adaptiveQuantization: string;
        /**
         * Indicates that AFD values will be written into the output stream.
         */
        afdSignaling: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        bufFillPct: number;
        /**
         * Size of buffer in bits.
         */
        bufSize: number;
        /**
         * Includes color space metadata in the output.
         */
        colorMetadata: string;
        /**
         * Entropy encoding mode.
         */
        entropyEncoding: string;
        /**
         * Filters to apply to an encode. See H264 Filter Settings for more details.
         */
        filterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings;
        /**
         * Four bit AFD value to write on all frames of video in the output stream.
         */
        fixedAfd: string;
        flickerAq: string;
        /**
         * Controls whether coding is performed on a field basis or on a frame basis.
         */
        forceFieldPictures: string;
        /**
         * Indicates how the output video frame rate is specified.
         */
        framerateControl: string;
        /**
         * Framerate denominator.
         */
        framerateDenominator: number;
        /**
         * Framerate numerator.
         */
        framerateNumerator: number;
        /**
         * GOP-B reference.
         */
        gopBReference: string;
        /**
         * Frequency of closed GOPs.
         */
        gopClosedCadence: number;
        /**
         * Number of B-frames between reference frames.
         */
        gopNumBFrames: number;
        /**
         * GOP size in units of either frames of seconds per `gopSizeUnits`.
         */
        gopSize: number;
        /**
         * Indicates if the `gopSize` is specified in frames or seconds.
         */
        gopSizeUnits: string;
        /**
         * H264 level.
         */
        level: string;
        /**
         * Amount of lookahead.
         */
        lookAheadRateControl: string;
        /**
         * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         */
        maxBitrate: number;
        minIInterval: number;
        /**
         * Number of reference frames to use.
         */
        numRefFrames: number;
        /**
         * Indicates how the output pixel aspect ratio is specified.
         */
        parControl: string;
        /**
         * Pixel Aspect Ratio denominator.
         */
        parDenominator: number;
        /**
         * Pixel Aspect Ratio numerator.
         */
        parNumerator: number;
        /**
         * H264 profile.
         */
        profile: string;
        /**
         * Quality level.
         */
        qualityLevel: string;
        /**
         * Controls the target quality for the video encode.
         */
        qvbrQualityLevel: number;
        /**
         * Rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets the scan type of the output.
         */
        scanType: string;
        /**
         * Scene change detection.
         */
        sceneChangeDetect: string;
        /**
         * Number of slices per picture.
         */
        slices: number;
        /**
         * Softness.
         */
        softness: number;
        /**
         * Makes adjustments within each frame based on spatial variation of content complexity.
         */
        spatialAq: string;
        /**
         * Subgop length.
         */
        subgopLength: string;
        /**
         * Produces a bitstream compliant with SMPTE RP-2027.
         */
        syntax: string;
        /**
         * Makes adjustments within each frame based on temporal variation of content complexity.
         */
        temporalAq: string;
        /**
         * Determines how timecodes should be inserted into the video elementary stream.
         */
        timecodeInsertion: string;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH264SettingsFilterSettingsTemporalFilterSettings {
        /**
         * Post filter sharpening.
         */
        postFilterSharpening?: string;
        /**
         * Filter strength.
         */
        strength?: string;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings {
        /**
         * Enables or disables adaptive quantization.
         */
        adaptiveQuantization: string;
        /**
         * Indicates that AFD values will be written into the output stream.
         */
        afdSignaling: string;
        /**
         * Whether or not EML should insert an Alternative Transfer Function SEI message.
         */
        alternativeTransferFunction: string;
        /**
         * Average bitrate in bits/second.
         */
        bitrate: number;
        /**
         * Size of buffer in bits.
         */
        bufSize?: number;
        /**
         * Includes color space metadata in the output.
         */
        colorMetadata: string;
        /**
         * Define the color metadata for the output. H265 Color Space Settings for more details.
         */
        colorSpaceSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings;
        /**
         * Filters to apply to an encode. See H265 Filter Settings for more details.
         */
        filterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings;
        /**
         * Four bit AFD value to write on all frames of video in the output stream.
         */
        fixedAfd: string;
        flickerAq: string;
        /**
         * Framerate denominator.
         */
        framerateDenominator: number;
        /**
         * Framerate numerator.
         */
        framerateNumerator: number;
        /**
         * Frequency of closed GOPs.
         */
        gopClosedCadence?: number;
        /**
         * GOP size in units of either frames of seconds per `gopSizeUnits`.
         */
        gopSize?: number;
        /**
         * Indicates if the `gopSize` is specified in frames or seconds.
         */
        gopSizeUnits: string;
        /**
         * H265 level.
         */
        level: string;
        /**
         * Amount of lookahead.
         */
        lookAheadRateControl: string;
        /**
         * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         */
        maxBitrate?: number;
        minIInterval?: number;
        /**
         * Pixel Aspect Ratio denominator.
         */
        parDenominator?: number;
        /**
         * Pixel Aspect Ratio numerator.
         */
        parNumerator?: number;
        /**
         * H265 profile.
         */
        profile: string;
        /**
         * Controls the target quality for the video encode.
         */
        qvbrQualityLevel?: number;
        /**
         * Rate control mode.
         */
        rateControlMode: string;
        /**
         * Sets the scan type of the output.
         */
        scanType: string;
        /**
         * Scene change detection.
         */
        sceneChangeDetect: string;
        /**
         * Number of slices per picture.
         */
        slices?: number;
        /**
         * Set the H265 tier in the output.
         */
        tier: string;
        /**
         * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
         */
        timecodeBurninSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings;
        /**
         * Determines how timecodes should be inserted into the video elementary stream.
         */
        timecodeInsertion: string;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings {
        colorSpacePassthroughSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings;
        dolbyVision81Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings;
        hdr10Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings;
        rec601Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings;
        rec709Settings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsColorSpacePassthroughSettings {
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsDolbyVision81Settings {
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsHdr10Settings {
        maxCll?: number;
        maxFall?: number;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec601Settings {
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsRec709Settings {
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsTemporalFilterSettings {
        /**
         * Post filter sharpening.
         */
        postFilterSharpening?: string;
        /**
         * Filter strength.
         */
        strength?: string;
    }
    interface ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings {
        prefix: string;
        timecodeBurninFontSize: string;
        timecodeBurninPosition: string;
    }
    interface ChannelInputAttachment {
        /**
         * User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details.
         */
        automaticInputFailoverSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettings;
        /**
         * User-specified name for the attachment.
         */
        inputAttachmentName: string;
        /**
         * The ID of the input.
         */
        inputId: string;
        /**
         * Settings of an input. See Input Settings for more details.
         */
        inputSettings: outputs.medialive.ChannelInputAttachmentInputSettings;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettings {
        /**
         * This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input\_preference for the failover pair is set to PRIMARY\_INPUT\_PREFERRED, because after this time, MediaLive will switch back to the primary input.
         */
        errorClearTimeMsec?: number;
        /**
         * A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details.
         */
        failoverConditions?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition[];
        /**
         * Input preference when deciding which input to make active when a previously failed input has recovered.
         */
        inputPreference?: string;
        /**
         * The input ID of the secondary input in the automatic input failover pair.
         */
        secondaryInputId: string;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverCondition {
        failoverConditionSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettings {
        /**
         * MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details.
         */
        audioSilenceSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings;
        /**
         * MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details.
         */
        inputLossSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings;
        /**
         * MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details.
         */
        videoBlackSettings?: outputs.medialive.ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsAudioSilenceSettings {
        audioSelectorName: string;
        audioSilenceThresholdMsec?: number;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsInputLossSettings {
        inputLossThresholdMsec?: number;
    }
    interface ChannelInputAttachmentAutomaticInputFailoverSettingsFailoverConditionFailoverConditionSettingsVideoBlackSettings {
        blackDetectThreshold?: number;
        videoBlackThresholdMsec?: number;
    }
    interface ChannelInputAttachmentInputSettings {
        audioSelectors?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelector[];
        captionSelectors?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelector[];
        /**
         * Enable or disable the deblock filter when filtering.
         */
        deblockFilter?: string;
        /**
         * Enable or disable the denoise filter when filtering.
         */
        denoiseFilter?: string;
        /**
         * Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest).
         */
        filterStrength?: number;
        /**
         * Turns on the filter for the input.
         */
        inputFilter: string;
        /**
         * Input settings. See Network Input Settings for more details.
         */
        networkInputSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsNetworkInputSettings;
        /**
         * PID from which to read SCTE-35 messages.
         */
        scte35Pid?: number;
        /**
         * Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input.
         */
        smpte2038DataPreference?: string;
        /**
         * Loop input if it is a file.
         */
        sourceEndBehavior?: string;
        videoSelector?: outputs.medialive.ChannelInputAttachmentInputSettingsVideoSelector;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelector {
        /**
         * Name of the Channel.
         *
         * The following arguments are optional:
         */
        name: string;
        selectorSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettings {
        audioHlsRenditionSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection;
        audioLanguageSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection;
        audioPidSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection;
        audioTrackSelection?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioHlsRenditionSelection {
        /**
         * Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition.
         */
        groupId: string;
        /**
         * Specifies the NAME in the #EXT-X-MEDIA tag of the target HLS audio rendition.
         */
        name: string;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioLanguageSelection {
        /**
         * Selects a specific three-letter language code from within an audio source.
         */
        languageCode: string;
        /**
         * When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language.
         */
        languageSelectionPolicy?: string;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioPidSelection {
        /**
         * Selects a specific PID from within a source.
         */
        pid: number;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelection {
        /**
         * Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details.
         */
        dolbyEDecode?: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode;
        /**
         * Selects one or more unique audio tracks from within a source. See Audio Tracks for more details.
         */
        tracks: outputs.medialive.ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack[];
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionDolbyEDecode {
        /**
         * Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
         */
        programSelection: string;
    }
    interface ChannelInputAttachmentInputSettingsAudioSelectorSelectorSettingsAudioTrackSelectionTrack {
        track: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelector {
        languageCode?: string;
        /**
         * Name of the Channel.
         *
         * The following arguments are optional:
         */
        name: string;
        selectorSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettings {
        ancillarySourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings;
        aribSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings;
        dvbSubSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings;
        embeddedSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings;
        scte20SourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings;
        scte27SourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings;
        teletextSourceSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAncillarySourceSettings {
        /**
         * Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field.
         */
        sourceAncillaryChannelNumber?: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsAribSourceSettings {
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsDvbSubSourceSettings {
        /**
         * If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text.
         */
        ocrLanguage?: string;
        /**
         * When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
         */
        pid?: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsEmbeddedSourceSettings {
        /**
         * If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded.
         */
        convert608To708?: string;
        /**
         * Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions.
         */
        scte20Detection?: string;
        /**
         * Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
         */
        source608ChannelNumber?: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte20SourceSettings {
        convert608To708?: string;
        source608ChannelNumber?: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsScte27SourceSettings {
        ocrLanguage?: string;
        pid?: number;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettings {
        /**
         * Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details.
         */
        outputRectangle?: outputs.medialive.ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle;
        /**
         * Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix.
         */
        pageNumber?: string;
    }
    interface ChannelInputAttachmentInputSettingsCaptionSelectorSelectorSettingsTeletextSourceSettingsOutputRectangle {
        height: number;
        leftOffset: number;
        topOffset: number;
        width: number;
    }
    interface ChannelInputAttachmentInputSettingsNetworkInputSettings {
        /**
         * Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details.
         */
        hlsInputSettings?: outputs.medialive.ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings;
        /**
         * Check HTTPS server certificates.
         */
        serverValidation?: string;
    }
    interface ChannelInputAttachmentInputSettingsNetworkInputSettingsHlsInputSettings {
        /**
         * The bitrate is specified in bits per second, as in an HLS manifest.
         */
        bandwidth?: number;
        /**
         * Buffer segments.
         */
        bufferSegments?: number;
        /**
         * The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable.
         */
        retries?: number;
        /**
         * The number of seconds between retries when an attempt to read a manifest or segment fails.
         */
        retryInterval?: number;
        scte35Source?: string;
    }
    interface ChannelInputAttachmentInputSettingsVideoSelector {
        colorSpace?: string;
        colorSpaceUsage?: string;
    }
    interface ChannelInputSpecification {
        codec: string;
        inputResolution: string;
        maximumBitrate: string;
    }
    interface ChannelMaintenance {
        /**
         * The day of the week to use for maintenance.
         */
        maintenanceDay: string;
        /**
         * The hour maintenance will start.
         */
        maintenanceStartTime: string;
    }
    interface ChannelVpc {
        availabilityZones: string[];
        networkInterfaceIds: string[];
        /**
         * List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels.
         */
        publicAddressAllocationIds: string[];
        /**
         * A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used.
         */
        securityGroupIds: string[];
        /**
         * A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ).
         */
        subnetIds: string[];
    }
    interface GetInputDestination {
        ip: string;
        port: string;
        url: string;
        vpcs: any[];
    }
    interface GetInputInputDevice {
        /**
         * The ID of the Input.
         */
        id: string;
    }
    interface GetInputMediaConnectFlow {
        flowArn: string;
    }
    interface GetInputSource {
        passwordParam: string;
        url: string;
        username: string;
    }
    interface InputDestination {
        /**
         * A unique name for the location the RTMP stream is being pushed to.
         */
        streamName: string;
    }
    interface InputInputDevice {
        /**
         * The unique ID for the device.
         */
        id: string;
    }
    interface InputMediaConnectFlow {
        /**
         * The ARN of the MediaConnect Flow
         */
        flowArn: string;
    }
    interface InputSecurityGroupWhitelistRule {
        /**
         * The IPv4 CIDR that's whitelisted.
         */
        cidr: string;
    }
    interface InputSource {
        /**
         * The key used to extract the password from EC2 Parameter store.
         */
        passwordParam: string;
        /**
         * The URL where the stream is pulled from.
         */
        url: string;
        /**
         * The username for the input source.
         */
        username: string;
    }
    interface InputVpc {
        /**
         * A list of up to 5 EC2 VPC security group IDs to attach to the Input.
         */
        securityGroupIds?: string[];
        /**
         * A list of 2 VPC subnet IDs from the same VPC.
         */
        subnetIds: string[];
    }
    interface MultiplexMultiplexSettings {
        /**
         * Maximum video buffer delay.
         */
        maximumVideoBufferDelayMilliseconds: number;
        /**
         * Transport stream bit rate.
         */
        transportStreamBitrate: number;
        /**
         * Unique ID for each multiplex.
         */
        transportStreamId: number;
        /**
         * Transport stream reserved bit rate.
         */
        transportStreamReservedBitrate: number;
    }
    interface MultiplexProgramMultiplexProgramSettings {
        preferredChannelPipeline: string;
        programNumber: number;
        serviceDescriptor?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsServiceDescriptor;
        videoSettings?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsVideoSettings;
    }
    interface MultiplexProgramMultiplexProgramSettingsServiceDescriptor {
        /**
         * Unique provider name.
         */
        providerName: string;
        /**
         * Unique service name.
         */
        serviceName: string;
    }
    interface MultiplexProgramMultiplexProgramSettingsVideoSettings {
        /**
         * Constant bitrate value.
         */
        constantBitrate: number;
        /**
         * Statmux settings. See Statmux Settings for more details.
         */
        statmuxSettings?: outputs.medialive.MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings;
    }
    interface MultiplexProgramMultiplexProgramSettingsVideoSettingsStatmuxSettings {
        /**
         * Maximum bitrate.
         */
        maximumBitrate: number;
        /**
         * Minimum bitrate.
         */
        minimumBitrate: number;
        /**
         * Priority value.
         */
        priority: number;
    }
}
export declare namespace mediapackage {
    interface ChannelHlsIngest {
        /**
         * A list of the ingest endpoints
         */
        ingestEndpoints: outputs.mediapackage.ChannelHlsIngestIngestEndpoint[];
    }
    interface ChannelHlsIngestIngestEndpoint {
        /**
         * The password
         */
        password: string;
        /**
         * The URL
         */
        url: string;
        /**
         * The username
         */
        username: string;
    }
}
export declare namespace memorydb {
    interface ClusterClusterEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * The port number on which each of the nodes accepts connections. Defaults to `6379`.
         */
        port: number;
    }
    interface ClusterShard {
        /**
         * Name of the cluster. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        /**
         * Set of nodes in this shard.
         */
        nodes: outputs.memorydb.ClusterShardNode[];
        /**
         * Number of individual nodes in this shard.
         */
        numNodes: number;
        /**
         * Keyspace for this shard. Example: `0-16383`.
         */
        slots: string;
    }
    interface ClusterShardNode {
        /**
         * The Availability Zone in which the node resides.
         */
        availabilityZone: string;
        /**
         * The date and time when the node was created. Example: `2022-01-01T21:00:00Z`.
         */
        createTime: string;
        endpoints: outputs.memorydb.ClusterShardNodeEndpoint[];
        /**
         * Name of the cluster. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
    }
    interface ClusterShardNodeEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * The port number on which each of the nodes accepts connections. Defaults to `6379`.
         */
        port: number;
    }
    interface GetClusterClusterEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * Port number that this node is listening on.
         */
        port: number;
    }
    interface GetClusterShard {
        /**
         * Name of the cluster.
         */
        name: string;
        /**
         * Set of nodes in this shard.
         */
        nodes: outputs.memorydb.GetClusterShardNode[];
        /**
         * Number of individual nodes in this shard.
         */
        numNodes: number;
        /**
         * Keyspace for this shard. Example: `0-16383`.
         */
        slots: string;
    }
    interface GetClusterShardNode {
        /**
         * The Availability Zone in which the node resides.
         */
        availabilityZone: string;
        /**
         * The date and time when the node was created. Example: `2022-01-01T21:00:00Z`.
         */
        createTime: string;
        endpoints: outputs.memorydb.GetClusterShardNodeEndpoint[];
        /**
         * Name of the cluster.
         */
        name: string;
    }
    interface GetClusterShardNodeEndpoint {
        /**
         * DNS hostname of the node.
         */
        address: string;
        /**
         * Port number that this node is listening on.
         */
        port: number;
    }
    interface GetParameterGroupParameter {
        /**
         * Name of the parameter group.
         */
        name: string;
        /**
         * Value of the parameter.
         */
        value: string;
    }
    interface GetSnapshotClusterConfiguration {
        /**
         * Description for the cluster.
         */
        description: string;
        /**
         * Version number of the Redis engine used by the cluster.
         */
        engineVersion: string;
        /**
         * The weekly time range during which maintenance on the cluster is performed.
         */
        maintenanceWindow: string;
        /**
         * Name of the snapshot.
         */
        name: string;
        /**
         * Compute and memory capacity of the nodes in the cluster.
         */
        nodeType: string;
        /**
         * Number of shards in the cluster.
         */
        numShards: number;
        /**
         * Name of the parameter group associated with the cluster.
         */
        parameterGroupName: string;
        /**
         * Port number on which the cluster accepts connections.
         */
        port: number;
        /**
         * Number of days for which MemoryDB retains automatic snapshots before deleting them.
         */
        snapshotRetentionLimit: number;
        /**
         * The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of the shard.
         */
        snapshotWindow: string;
        /**
         * Name of the subnet group used by the cluster.
         */
        subnetGroupName: string;
        /**
         * ARN of the SNS topic to which cluster notifications are sent.
         */
        topicArn: string;
        /**
         * The VPC in which the cluster exists.
         */
        vpcId: string;
    }
    interface GetUserAuthenticationMode {
        /**
         * Number of passwords belonging to the user if `type` is set to `password`.
         */
        passwordCount: number;
        /**
         * Type of authentication configured.
         */
        type: string;
    }
    interface ParameterGroupParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }
    interface SnapshotClusterConfiguration {
        /**
         * Description for the cluster.
         */
        description: string;
        /**
         * Version number of the Redis engine used by the cluster.
         */
        engineVersion: string;
        /**
         * The weekly time range during which maintenance on the cluster is performed.
         */
        maintenanceWindow: string;
        /**
         * Name of the snapshot. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        /**
         * Compute and memory capacity of the nodes in the cluster.
         */
        nodeType: string;
        /**
         * Number of shards in the cluster.
         */
        numShards: number;
        /**
         * Name of the parameter group associated with the cluster.
         */
        parameterGroupName: string;
        /**
         * Port number on which the cluster accepts connections.
         */
        port: number;
        /**
         * Number of days for which MemoryDB retains automatic snapshots before deleting them.
         */
        snapshotRetentionLimit: number;
        /**
         * The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of the shard.
         */
        snapshotWindow: string;
        /**
         * Name of the subnet group used by the cluster.
         */
        subnetGroupName: string;
        /**
         * ARN of the SNS topic to which cluster notifications are sent.
         */
        topicArn: string;
        /**
         * The VPC in which the cluster exists.
         */
        vpcId: string;
    }
    interface UserAuthenticationMode {
        /**
         * Number of passwords belonging to the user if `type` is set to `password`.
         */
        passwordCount: number;
        /**
         * Set of passwords used for authentication if `type` is set to `password`. You can create up to two passwords for each user.
         */
        passwords?: string[];
        /**
         * Specifies the authentication type. Valid values are: `password` or `iam`.
         */
        type: string;
    }
}
export declare namespace mq {
    interface BrokerConfiguration {
        /**
         * The Configuration ID.
         */
        id: string;
        /**
         * Revision of the Configuration.
         */
        revision: number;
    }
    interface BrokerEncryptionOptions {
        /**
         * Amazon Resource Name (ARN) of Key Management Service (KMS) Customer Master Key (CMK) to use for encryption at rest. Requires setting `useAwsOwnedKey` to `false`. To perform drift detection when AWS-managed CMKs or customer-managed CMKs are in use, this value must be configured.
         */
        kmsKeyId: string;
        /**
         * Whether to enable an AWS-owned KMS CMK that is not in your account. Defaults to `true`. Setting to `false` without configuring `kmsKeyId` will create an AWS-managed CMK aliased to `aws/mq` in your account.
         */
        useAwsOwnedKey?: boolean;
    }
    interface BrokerInstance {
        /**
         * The URL of the [ActiveMQ Web Console](http://activemq.apache.org/web-console.html) or the [RabbitMQ Management UI](https://www.rabbitmq.com/management.html#external-monitoring) depending on `engineType`.
         */
        consoleUrl: string;
        /**
         * Broker's wire-level protocol endpoints in the following order & format referenceable e.g., as `instances.0.endpoints.0` (SSL):
         * * For `ActiveMQ`:
         * * `ssl://broker-id.mq.us-west-2.amazonaws.com:61617`
         * * `amqp+ssl://broker-id.mq.us-west-2.amazonaws.com:5671`
         * * `stomp+ssl://broker-id.mq.us-west-2.amazonaws.com:61614`
         * * `mqtt+ssl://broker-id.mq.us-west-2.amazonaws.com:8883`
         * * `wss://broker-id.mq.us-west-2.amazonaws.com:61619`
         * * For `RabbitMQ`:
         * * `amqps://broker-id.mq.us-west-2.amazonaws.com:5671`
         */
        endpoints: string[];
        /**
         * IP Address of the broker.
         */
        ipAddress: string;
    }
    interface BrokerLdapServerMetadata {
        /**
         * List of a fully qualified domain name of the LDAP server and an optional failover server.
         */
        hosts?: string[];
        /**
         * Fully qualified name of the directory to search for a user’s groups.
         */
        roleBase?: string;
        /**
         * Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
         */
        roleName?: string;
        /**
         * Search criteria for groups.
         */
        roleSearchMatching?: string;
        /**
         * Whether the directory search scope is the entire sub-tree.
         */
        roleSearchSubtree?: boolean;
        /**
         * Service account password.
         */
        serviceAccountPassword?: string;
        /**
         * Service account username.
         */
        serviceAccountUsername?: string;
        /**
         * Fully qualified name of the directory where you want to search for users.
         */
        userBase?: string;
        /**
         * Specifies the name of the LDAP attribute for the user group membership.
         */
        userRoleName?: string;
        /**
         * Search criteria for users.
         */
        userSearchMatching?: string;
        /**
         * Whether the directory search scope is the entire sub-tree.
         */
        userSearchSubtree?: boolean;
    }
    interface BrokerLogs {
        /**
         * Enables audit logging. Auditing is only possible for `engineType` of `ActiveMQ`. User management action made using JMX or the ActiveMQ Web Console is logged. Defaults to `false`.
         */
        audit?: boolean;
        /**
         * Enables general logging via CloudWatch. Defaults to `false`.
         */
        general?: boolean;
    }
    interface BrokerMaintenanceWindowStartTime {
        /**
         * Day of the week, e.g., `MONDAY`, `TUESDAY`, or `WEDNESDAY`.
         */
        dayOfWeek: string;
        /**
         * Time, in 24-hour format, e.g., `02:00`.
         */
        timeOfDay: string;
        /**
         * Time zone in either the Country/City format or the UTC offset format, e.g., `CET`.
         */
        timeZone: string;
    }
    interface BrokerUser {
        /**
         * Whether to enable access to the [ActiveMQ Web Console](http://activemq.apache.org/web-console.html) for the user. Applies to `engineType` of `ActiveMQ` only.
         */
        consoleAccess?: boolean;
        /**
         * List of groups (20 maximum) to which the ActiveMQ user belongs. Applies to `engineType` of `ActiveMQ` only.
         */
        groups?: string[];
        /**
         * Password of the user. It must be 12 to 250 characters long, at least 4 unique characters, and must not contain commas.
         */
        password: string;
        /**
         * Whether to set set replication user. Defaults to `false`.
         */
        replicationUser?: boolean;
        /**
         * Username of the user.
         *
         * > **NOTE:** AWS currently does not support updating RabbitMQ users. Updates to users can only be in the RabbitMQ UI.
         */
        username: string;
    }
    interface GetBrokerConfiguration {
        id: string;
        revision: number;
    }
    interface GetBrokerEncryptionOption {
        kmsKeyId: string;
        useAwsOwnedKey: boolean;
    }
    interface GetBrokerEngineTypesBrokerEngineType {
        /**
         * The MQ engine type to return version details for.
         */
        engineType: string;
        /**
         * The list of engine versions.
         */
        engineVersions: outputs.mq.GetBrokerEngineTypesBrokerEngineTypeEngineVersion[];
    }
    interface GetBrokerEngineTypesBrokerEngineTypeEngineVersion {
        name: string;
    }
    interface GetBrokerInstance {
        consoleUrl: string;
        endpoints: string[];
        ipAddress: string;
    }
    interface GetBrokerLdapServerMetadata {
        hosts: string[];
        roleBase: string;
        roleName: string;
        roleSearchMatching: string;
        roleSearchSubtree: boolean;
        serviceAccountPassword: string;
        serviceAccountUsername: string;
        userBase: string;
        userRoleName: string;
        userSearchMatching: string;
        userSearchSubtree: boolean;
    }
    interface GetBrokerLogs {
        audit: boolean;
        general: boolean;
    }
    interface GetBrokerMaintenanceWindowStartTime {
        dayOfWeek: string;
        timeOfDay: string;
        timeZone: string;
    }
    interface GetBrokerUser {
        consoleAccess: boolean;
        groups: string[];
        replicationUser: boolean;
        username: string;
    }
    interface GetInstanceTypeOfferingsBrokerInstanceOption {
        /**
         * List of available AZs. See Availability Zones. below
         */
        availabilityZones: outputs.mq.GetInstanceTypeOfferingsBrokerInstanceOptionAvailabilityZone[];
        /**
         * Filter response by engine type.
         */
        engineType: string;
        /**
         * Filter response by host instance type.
         */
        hostInstanceType: string;
        /**
         * Filter response by storage type.
         */
        storageType: string;
        /**
         * The list of supported deployment modes.
         */
        supportedDeploymentModes: string[];
        /**
         * The list of supported engine versions.
         */
        supportedEngineVersions: string[];
    }
    interface GetInstanceTypeOfferingsBrokerInstanceOptionAvailabilityZone {
        /**
         * Name of the Availability Zone.
         */
        name: string;
    }
}
export declare namespace msk {
    interface ClusterBrokerNodeGroupInfo {
        /**
         * The distribution of broker nodes across availability zones ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-model-brokerazdistribution)). Currently the only valid value is `DEFAULT`.
         */
        azDistribution?: string;
        /**
         * A list of subnets to connect to in client VPC ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-prop-brokernodegroupinfo-clientsubnets)).
         */
        clientSubnets: string[];
        /**
         * Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible ([documentation](https://docs.aws.amazon.com/msk/latest/developerguide/public-access.html)).
         */
        connectivityInfo: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfo;
        /**
         * Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. ([Pricing info](https://aws.amazon.com/msk/pricing/))
         */
        instanceType: string;
        /**
         * A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
         */
        securityGroups: string[];
        /**
         * A block that contains information about storage volumes attached to MSK broker nodes. See below.
         */
        storageInfo: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfo;
    }
    interface ClusterBrokerNodeGroupInfoConnectivityInfo {
        publicAccess: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccess;
        vpcConnectivity: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivity;
    }
    interface ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccess {
        type: string;
    }
    interface ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivity {
        /**
         * Configuration block for specifying a client authentication. See below.
         */
        clientAuthentication: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication;
    }
    interface ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthentication {
        /**
         * Configuration block for specifying SASL client authentication. See below.
         */
        sasl: outputs.msk.ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl;
        /**
         * Configuration block for specifying TLS client authentication. See below.
         */
        tls: boolean;
    }
    interface ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSasl {
        iam: boolean;
        scram: boolean;
    }
    interface ClusterBrokerNodeGroupInfoStorageInfo {
        ebsStorageInfo?: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfo;
    }
    interface ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfo {
        provisionedThroughput?: outputs.msk.ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput;
        volumeSize?: number;
    }
    interface ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughput {
        enabled?: boolean;
        volumeThroughput?: number;
    }
    interface ClusterClientAuthentication {
        /**
         * Configuration block for specifying SASL client authentication. See below.
         */
        sasl?: outputs.msk.ClusterClientAuthenticationSasl;
        /**
         * Configuration block for specifying TLS client authentication. See below.
         */
        tls?: outputs.msk.ClusterClientAuthenticationTls;
        /**
         * Enables unauthenticated access.
         */
        unauthenticated?: boolean;
    }
    interface ClusterClientAuthenticationSasl {
        iam?: boolean;
        scram?: boolean;
    }
    interface ClusterClientAuthenticationTls {
        certificateAuthorityArns?: string[];
    }
    interface ClusterConfigurationInfo {
        /**
         * Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
         */
        arn: string;
        /**
         * Revision of the MSK Configuration to use in the cluster.
         */
        revision: number;
    }
    interface ClusterEncryptionInfo {
        /**
         * You may specify a KMS key short ID or ARN (it will always output an ARN) to use for encrypting your data at rest.  If no key is specified, an AWS managed KMS ('aws/msk' managed service) key will be used for encrypting the data at rest.
         */
        encryptionAtRestKmsKeyArn: string;
        /**
         * Configuration block to specify encryption in transit. See below.
         */
        encryptionInTransit?: outputs.msk.ClusterEncryptionInfoEncryptionInTransit;
    }
    interface ClusterEncryptionInfoEncryptionInTransit {
        clientBroker?: string;
        inCluster?: boolean;
    }
    interface ClusterLoggingInfo {
        /**
         * Configuration block for Broker Logs settings for logging info. See below.
         */
        brokerLogs: outputs.msk.ClusterLoggingInfoBrokerLogs;
    }
    interface ClusterLoggingInfoBrokerLogs {
        cloudwatchLogs?: outputs.msk.ClusterLoggingInfoBrokerLogsCloudwatchLogs;
        firehose?: outputs.msk.ClusterLoggingInfoBrokerLogsFirehose;
        s3?: outputs.msk.ClusterLoggingInfoBrokerLogsS3;
    }
    interface ClusterLoggingInfoBrokerLogsCloudwatchLogs {
        enabled: boolean;
        logGroup?: string;
    }
    interface ClusterLoggingInfoBrokerLogsFirehose {
        deliveryStream?: string;
        enabled: boolean;
    }
    interface ClusterLoggingInfoBrokerLogsS3 {
        bucket?: string;
        enabled: boolean;
        prefix?: string;
    }
    interface ClusterOpenMonitoring {
        /**
         * Configuration block for Prometheus settings for open monitoring. See below.
         */
        prometheus: outputs.msk.ClusterOpenMonitoringPrometheus;
    }
    interface ClusterOpenMonitoringPrometheus {
        jmxExporter?: outputs.msk.ClusterOpenMonitoringPrometheusJmxExporter;
        nodeExporter?: outputs.msk.ClusterOpenMonitoringPrometheusNodeExporter;
    }
    interface ClusterOpenMonitoringPrometheusJmxExporter {
        enabledInBroker: boolean;
    }
    interface ClusterOpenMonitoringPrometheusNodeExporter {
        enabledInBroker: boolean;
    }
    interface GetBrokerNodesNodeInfoList {
        /**
         * Attached elastic network interface of the broker
         */
        attachedEniId: string;
        /**
         * ID of the broker
         */
        brokerId: number;
        /**
         * Client subnet to which this broker node belongs
         */
        clientSubnet: string;
        /**
         * The client virtual private cloud (VPC) IP address
         */
        clientVpcIpAddress: string;
        /**
         * Set of endpoints for accessing the broker. This does not include ports
         */
        endpoints: string[];
        /**
         * ARN of the node
         */
        nodeArn: string;
    }
    interface ReplicatorKafkaCluster {
        /**
         * Details of an Amazon MSK cluster.
         */
        amazonMskCluster: outputs.msk.ReplicatorKafkaClusterAmazonMskCluster;
        /**
         * Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
         */
        vpcConfig: outputs.msk.ReplicatorKafkaClusterVpcConfig;
    }
    interface ReplicatorKafkaClusterAmazonMskCluster {
        /**
         * The ARN of an Amazon MSK cluster.
         */
        mskClusterArn: string;
    }
    interface ReplicatorKafkaClusterVpcConfig {
        /**
         * The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
         */
        securityGroupsIds?: string[];
        /**
         * The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
         */
        subnetIds: string[];
    }
    interface ReplicatorReplicationInfoList {
        /**
         * Confguration relating to consumer group replication.
         */
        consumerGroupReplications: outputs.msk.ReplicatorReplicationInfoListConsumerGroupReplication[];
        sourceKafkaClusterAlias: string;
        /**
         * The ARN of the source Kafka cluster.
         */
        sourceKafkaClusterArn: string;
        /**
         * The type of compression to use writing records to target Kafka cluster.
         */
        targetCompressionType: string;
        targetKafkaClusterAlias: string;
        /**
         * The ARN of the target Kafka cluster.
         */
        targetKafkaClusterArn: string;
        /**
         * Configuration relating to topic replication.
         */
        topicReplications: outputs.msk.ReplicatorReplicationInfoListTopicReplication[];
    }
    interface ReplicatorReplicationInfoListConsumerGroupReplication {
        /**
         * List of regular expression patterns indicating the consumer groups that should not be replicated.
         */
        consumerGroupsToExcludes?: string[];
        /**
         * List of regular expression patterns indicating the consumer groups to copy.
         */
        consumerGroupsToReplicates: string[];
        /**
         * Whether to periodically check for new consumer groups.
         */
        detectAndCopyNewConsumerGroups?: boolean;
        /**
         * Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
         */
        synchroniseConsumerGroupOffsets?: boolean;
    }
    interface ReplicatorReplicationInfoListTopicReplication {
        /**
         * Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
         */
        copyAccessControlListsForTopics?: boolean;
        /**
         * Whether to periodically configure remote topics to match their corresponding upstream topics.
         */
        copyTopicConfigurations?: boolean;
        /**
         * Whether to periodically check for new topics and partitions.
         */
        detectAndCopyNewTopics?: boolean;
        /**
         * List of regular expression patterns indicating the topics that should not be replica.
         */
        topicsToExcludes?: string[];
        /**
         * List of regular expression patterns indicating the topics to copy.
         */
        topicsToReplicates: string[];
    }
    interface ServerlessClusterClientAuthentication {
        /**
         * Details for client authentication using SASL. See below.
         */
        sasl: outputs.msk.ServerlessClusterClientAuthenticationSasl;
    }
    interface ServerlessClusterClientAuthenticationSasl {
        /**
         * Details for client authentication using IAM. See below.
         */
        iam: outputs.msk.ServerlessClusterClientAuthenticationSaslIam;
    }
    interface ServerlessClusterClientAuthenticationSaslIam {
        /**
         * Whether SASL/IAM authentication is enabled or not.
         */
        enabled: boolean;
    }
    interface ServerlessClusterVpcConfig {
        /**
         * Specifies up to five security groups that control inbound and outbound traffic for the serverless cluster.
         */
        securityGroupIds: string[];
        /**
         * A list of subnets in at least two different Availability Zones that host your client applications.
         */
        subnetIds: string[];
    }
}
export declare namespace mskconnect {
    interface ConnectorCapacity {
        /**
         * Information about the auto scaling parameters for the connector. See below.
         */
        autoscaling?: outputs.mskconnect.ConnectorCapacityAutoscaling;
        /**
         * Details about a fixed capacity allocated to a connector. See below.
         */
        provisionedCapacity?: outputs.mskconnect.ConnectorCapacityProvisionedCapacity;
    }
    interface ConnectorCapacityAutoscaling {
        /**
         * The maximum number of workers allocated to the connector.
         */
        maxWorkerCount: number;
        /**
         * The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: `1`, `2`, `4`, `8`. The default value is `1`.
         */
        mcuCount?: number;
        /**
         * The minimum number of workers allocated to the connector.
         */
        minWorkerCount: number;
        /**
         * The scale-in policy for the connector. See below.
         */
        scaleInPolicy: outputs.mskconnect.ConnectorCapacityAutoscalingScaleInPolicy;
        /**
         * The scale-out policy for the connector. See below.
         */
        scaleOutPolicy: outputs.mskconnect.ConnectorCapacityAutoscalingScaleOutPolicy;
    }
    interface ConnectorCapacityAutoscalingScaleInPolicy {
        /**
         * Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
         */
        cpuUtilizationPercentage: number;
    }
    interface ConnectorCapacityAutoscalingScaleOutPolicy {
        /**
         * The CPU utilization percentage threshold at which you want connector scale out to be triggered.
         */
        cpuUtilizationPercentage: number;
    }
    interface ConnectorCapacityProvisionedCapacity {
        /**
         * The number of microcontroller units (MCUs) allocated to each connector worker. Valid values: `1`, `2`, `4`, `8`. The default value is `1`.
         */
        mcuCount?: number;
        /**
         * The number of workers that are allocated to the connector.
         */
        workerCount: number;
    }
    interface ConnectorKafkaCluster {
        /**
         * The Apache Kafka cluster to which the connector is connected.
         */
        apacheKafkaCluster: outputs.mskconnect.ConnectorKafkaClusterApacheKafkaCluster;
    }
    interface ConnectorKafkaClusterApacheKafkaCluster {
        /**
         * The bootstrap servers of the cluster.
         */
        bootstrapServers: string;
        /**
         * Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
         */
        vpc: outputs.mskconnect.ConnectorKafkaClusterApacheKafkaClusterVpc;
    }
    interface ConnectorKafkaClusterApacheKafkaClusterVpc {
        /**
         * The security groups for the connector.
         */
        securityGroups: string[];
        /**
         * The subnets for the connector.
         */
        subnets: string[];
    }
    interface ConnectorKafkaClusterClientAuthentication {
        /**
         * The type of client authentication used to connect to the Apache Kafka cluster. Valid values: `IAM`, `NONE`. A value of `NONE` means that no client authentication is used. The default value is `NONE`.
         */
        authenticationType?: string;
    }
    interface ConnectorKafkaClusterEncryptionInTransit {
        /**
         * The type of encryption in transit to the Apache Kafka cluster. Valid values: `PLAINTEXT`, `TLS`. The default values is `PLAINTEXT`.
         */
        encryptionType?: string;
    }
    interface ConnectorLogDelivery {
        /**
         * The workers can send worker logs to different destination types. This configuration specifies the details of these destinations. See below.
         */
        workerLogDelivery: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDelivery;
    }
    interface ConnectorLogDeliveryWorkerLogDelivery {
        /**
         * Details about delivering logs to Amazon CloudWatch Logs. See below.
         */
        cloudwatchLogs?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogs;
        /**
         * Details about delivering logs to Amazon Kinesis Data Firehose. See below.
         */
        firehose?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryFirehose;
        /**
         * Details about delivering logs to Amazon S3. See below.
         */
        s3?: outputs.mskconnect.ConnectorLogDeliveryWorkerLogDeliveryS3;
    }
    interface ConnectorLogDeliveryWorkerLogDeliveryCloudwatchLogs {
        /**
         * Whether log delivery to Amazon CloudWatch Logs is enabled.
         */
        enabled: boolean;
        /**
         * The name of the CloudWatch log group that is the destination for log delivery.
         */
        logGroup?: string;
    }
    interface ConnectorLogDeliveryWorkerLogDeliveryFirehose {
        /**
         * The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
         */
        deliveryStream?: string;
        /**
         * Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
         */
        enabled: boolean;
    }
    interface ConnectorLogDeliveryWorkerLogDeliveryS3 {
        /**
         * The name of the S3 bucket that is the destination for log delivery.
         */
        bucket?: string;
        /**
         * Specifies whether connector logs get sent to the specified Amazon S3 destination.
         */
        enabled: boolean;
        /**
         * The S3 prefix that is the destination for log delivery.
         */
        prefix?: string;
    }
    interface ConnectorPlugin {
        /**
         * Details about a custom plugin. See below.
         */
        customPlugin: outputs.mskconnect.ConnectorPluginCustomPlugin;
    }
    interface ConnectorPluginCustomPlugin {
        /**
         * The Amazon Resource Name (ARN) of the custom plugin.
         */
        arn: string;
        /**
         * The revision of the custom plugin.
         */
        revision: number;
    }
    interface ConnectorWorkerConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the worker configuration.
         */
        arn: string;
        /**
         * The revision of the worker configuration.
         */
        revision: number;
    }
    interface CustomPluginLocation {
        /**
         * Information of the plugin file stored in Amazon S3. See below.
         */
        s3: outputs.mskconnect.CustomPluginLocationS3;
    }
    interface CustomPluginLocationS3 {
        bucketArn: string;
        fileKey: string;
        objectVersion?: string;
    }
}
export declare namespace mwaa {
    interface EnvironmentLastUpdated {
        /**
         * The Created At date of the MWAA Environment
         */
        createdAt: string;
        errors: outputs.mwaa.EnvironmentLastUpdatedError[];
        /**
         * The status of the Amazon MWAA Environment
         */
        status: string;
    }
    interface EnvironmentLastUpdatedError {
        errorCode: string;
        errorMessage: string;
    }
    interface EnvironmentLoggingConfiguration {
        /**
         * (Optional) Log configuration options for processing DAGs. See Module logging configuration for more information. Disabled by default.
         */
        dagProcessingLogs: outputs.mwaa.EnvironmentLoggingConfigurationDagProcessingLogs;
        /**
         * Log configuration options for the schedulers. See Module logging configuration for more information. Disabled by default.
         */
        schedulerLogs: outputs.mwaa.EnvironmentLoggingConfigurationSchedulerLogs;
        /**
         * Log configuration options for DAG tasks. See Module logging configuration for more information. Enabled by default with `INFO` log level.
         */
        taskLogs: outputs.mwaa.EnvironmentLoggingConfigurationTaskLogs;
        /**
         * Log configuration options for the webservers. See Module logging configuration for more information. Disabled by default.
         */
        webserverLogs: outputs.mwaa.EnvironmentLoggingConfigurationWebserverLogs;
        /**
         * Log configuration options for the workers. See Module logging configuration for more information. Disabled by default.
         */
        workerLogs: outputs.mwaa.EnvironmentLoggingConfigurationWorkerLogs;
    }
    interface EnvironmentLoggingConfigurationDagProcessingLogs {
        cloudWatchLogGroupArn: string;
        enabled: boolean;
        logLevel: string;
    }
    interface EnvironmentLoggingConfigurationSchedulerLogs {
        cloudWatchLogGroupArn: string;
        enabled: boolean;
        logLevel: string;
    }
    interface EnvironmentLoggingConfigurationTaskLogs {
        cloudWatchLogGroupArn: string;
        enabled: boolean;
        logLevel: string;
    }
    interface EnvironmentLoggingConfigurationWebserverLogs {
        cloudWatchLogGroupArn: string;
        enabled: boolean;
        logLevel: string;
    }
    interface EnvironmentLoggingConfigurationWorkerLogs {
        cloudWatchLogGroupArn: string;
        enabled: boolean;
        logLevel: string;
    }
    interface EnvironmentNetworkConfiguration {
        /**
         * Security groups IDs for the environment. At least one of the security group needs to allow MWAA resources to talk to each other, otherwise MWAA cannot be provisioned.
         */
        securityGroupIds: string[];
        /**
         * The private subnet IDs in which the environment should be created. MWAA requires two subnets.
         */
        subnetIds: string[];
    }
}
export declare namespace neptune {
    interface ClusterParameterGroupParameter {
        /**
         * Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the neptune parameter.
         */
        name: string;
        /**
         * The value of the neptune parameter.
         */
        value: string;
    }
    interface ClusterServerlessV2ScalingConfiguration {
        maxCapacity?: number;
        minCapacity?: number;
    }
    interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster.
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster.
         */
        isWriter: boolean;
    }
    interface ParameterGroupParameter {
        /**
         * The apply method of the Neptune parameter. Valid values are `immediate` and `pending-reboot`. Defaults to `pending-reboot`.
         */
        applyMethod?: string;
        /**
         * The name of the Neptune parameter.
         */
        name: string;
        /**
         * The value of the Neptune parameter.
         */
        value: string;
    }
}
export declare namespace networkfirewall {
    interface FirewallEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }
    interface FirewallFirewallStatus {
        /**
         * Set of subnets configured for use by the firewall.
         */
        syncStates: outputs.networkfirewall.FirewallFirewallStatusSyncState[];
    }
    interface FirewallFirewallStatusSyncState {
        /**
         * Nested list describing the attachment status of the firewall's association with a single VPC subnet.
         */
        attachments: outputs.networkfirewall.FirewallFirewallStatusSyncStateAttachment[];
        /**
         * The Availability Zone where the subnet is configured.
         */
        availabilityZone: string;
    }
    interface FirewallFirewallStatusSyncStateAttachment {
        /**
         * The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
         */
        endpointId: string;
        /**
         * The unique identifier of the subnet that you've specified to be used for a firewall endpoint.
         */
        subnetId: string;
    }
    interface FirewallPolicyEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }
    interface FirewallPolicyFirewallPolicy {
        /**
         * . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
         */
        policyVariables?: outputs.networkfirewall.FirewallPolicyFirewallPolicyPolicyVariables;
        /**
         * Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `statefulEngineOptions` block with a `ruleOrder` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
         */
        statefulDefaultActions?: string[];
        /**
         * A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
         */
        statefulEngineOptions?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulEngineOptions;
        /**
         * Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
         */
        statefulRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulRuleGroupReference[];
        /**
         * Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `statelessDefaultActions`. See Stateless Custom Action below for details.
         */
        statelessCustomActions?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomAction[];
        /**
         * Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
         * In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
         */
        statelessDefaultActions: string[];
        /**
         * Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
         * In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
         */
        statelessFragmentDefaultActions: string[];
        /**
         * Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
         */
        statelessRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessRuleGroupReference[];
        /**
         * The (ARN) of the TLS Inspection policy to attach to the FW Policy.  This must be added at creation of the resource per AWS documentation. "You can only add a TLS inspection configuration to a new policy, not to an existing policy."  This cannot be removed from a FW Policy.
         */
        tlsInspectionConfigurationArn?: string;
    }
    interface FirewallPolicyFirewallPolicyPolicyVariables {
        ruleVariables?: outputs.networkfirewall.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable[];
    }
    interface FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable {
        /**
         * A configuration block that defines a set of IP addresses. See IP Set below for details.
         */
        ipSet: outputs.networkfirewall.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet;
        /**
         * An alphanumeric string to identify the `ipSet`. Valid values: `HOME_NET`
         */
        key: string;
    }
    interface FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet {
        /**
         * Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
         */
        definitions: string[];
    }
    interface FirewallPolicyFirewallPolicyStatefulEngineOptions {
        /**
         * Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
         */
        ruleOrder?: string;
        /**
         * Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
         */
        streamExceptionPolicy?: string;
    }
    interface FirewallPolicyFirewallPolicyStatefulRuleGroupReference {
        /**
         * Configuration block for override values
         */
        override?: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride;
        /**
         * An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `statefulEngineOptions` block with a `ruleOrder` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
         */
        priority?: number;
        /**
         * The Amazon Resource Name (ARN) of the stateful rule group.
         */
        resourceArn: string;
    }
    interface FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride {
        /**
         * The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
         */
        action?: string;
    }
    interface FirewallPolicyFirewallPolicyStatelessCustomAction {
        /**
         * A configuration block describing the custom action associated with the `actionName`. See Action Definition below for details.
         */
        actionDefinition: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition;
        /**
         * A friendly name of the custom action.
         */
        actionName: string;
    }
    interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition {
        /**
         * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
         */
        publishMetricAction: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction;
    }
    interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
        /**
         * Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
         */
        dimensions: outputs.networkfirewall.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];
    }
    interface FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
        /**
         * The string value to use in the custom metric dimension.
         */
        value: string;
    }
    interface FirewallPolicyFirewallPolicyStatelessRuleGroupReference {
        /**
         * An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
         */
        priority: number;
        /**
         * The Amazon Resource Name (ARN) of the stateless rule group.
         */
        resourceArn: string;
    }
    interface FirewallSubnetMapping {
        /**
         * The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
         */
        ipAddressType: string;
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }
    interface GetFirewallEncryptionConfiguration {
        /**
         * The ID of the AWS Key Management Service (AWS KMS) customer managed key.
         */
        keyId: string;
        /**
         * The type of the AWS Key Management Service (AWS KMS) key use by the firewall.
         */
        type: string;
    }
    interface GetFirewallFirewallStatus {
        /**
         * Aggregated count of all resources used by reference sets in a firewall.
         */
        capacityUsageSummaries: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummary[];
        /**
         * Summary of sync states for all availability zones in which the firewall is configured.
         */
        configurationSyncStateSummary: string;
        status: string;
        /**
         * Set of subnets configured for use by the firewall.
         */
        syncStates: outputs.networkfirewall.GetFirewallFirewallStatusSyncState[];
    }
    interface GetFirewallFirewallStatusCapacityUsageSummary {
        /**
         * Capacity usage of CIDR blocks used by IP set references in a firewall.
         */
        cidrs: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummaryCidr[];
    }
    interface GetFirewallFirewallStatusCapacityUsageSummaryCidr {
        /**
         * Available number of CIDR blocks available for use by the IP set references in a firewall.
         */
        availableCidrCount: number;
        /**
         * The list of IP set references used by a firewall.
         */
        ipSetReferences: outputs.networkfirewall.GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReference[];
        /**
         * Number of CIDR blocks used by the IP set references in a firewall.
         */
        utilizedCidrCount: number;
    }
    interface GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReference {
        /**
         * Total number of CIDR blocks used by the IP set references in a firewall.
         */
        resolvedCidrCount: number;
    }
    interface GetFirewallFirewallStatusSyncState {
        /**
         * Nested list describing the attachment status of the firewall's association with a single VPC subnet.
         */
        attachments: outputs.networkfirewall.GetFirewallFirewallStatusSyncStateAttachment[];
        /**
         * The Availability Zone where the subnet is configured.
         */
        availabilityZone: string;
    }
    interface GetFirewallFirewallStatusSyncStateAttachment {
        /**
         * The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
         */
        endpointId: string;
        status: string;
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }
    interface GetFirewallPolicyFirewallPolicy {
        statefulDefaultActions: string[];
        statefulEngineOptions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulEngineOption[];
        statefulRuleGroupReferences: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReference[];
        statelessCustomActions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomAction[];
        statelessDefaultActions: string[];
        statelessFragmentDefaultActions: string[];
        statelessRuleGroupReferences: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessRuleGroupReference[];
        tlsInspectionConfigurationArn: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatefulEngineOption {
        ruleOrder: string;
        streamExceptionPolicy: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatefulRuleGroupReference {
        overrides?: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride[];
        priority: number;
        resourceArn: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride {
        action?: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatelessCustomAction {
        actionDefinitions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition[];
        actionName: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition {
        publishMetricActions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction[];
    }
    interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction {
        dimensions: outputs.networkfirewall.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension[];
    }
    interface GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension {
        value: string;
    }
    interface GetFirewallPolicyFirewallPolicyStatelessRuleGroupReference {
        priority: number;
        resourceArn: string;
    }
    interface GetFirewallSubnetMapping {
        /**
         * The unique identifier for the subnet.
         */
        subnetId: string;
    }
    interface LoggingConfigurationLoggingConfiguration {
        /**
         * Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
         */
        logDestinationConfigs: outputs.networkfirewall.LoggingConfigurationLoggingConfigurationLogDestinationConfig[];
    }
    interface LoggingConfigurationLoggingConfigurationLogDestinationConfig {
        /**
         * A map describing the logging destination for the chosen `logDestinationType`.
         * * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
         * * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
         * * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
         */
        logDestination: {
            [key: string]: string;
        };
        /**
         * The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
         */
        logDestinationType: string;
        /**
         * The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
         */
        logType: string;
    }
    interface RuleGroupEncryptionConfiguration {
        /**
         * The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
         */
        keyId?: string;
        /**
         * The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
         */
        type: string;
    }
    interface RuleGroupRuleGroup {
        /**
         * A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `referenceSets` in a `ruleGroup`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
         */
        referenceSets?: outputs.networkfirewall.RuleGroupRuleGroupReferenceSets;
        /**
         * A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
         */
        ruleVariables?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariables;
        /**
         * A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
         */
        rulesSource: outputs.networkfirewall.RuleGroupRuleGroupRulesSource;
        /**
         * A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
         */
        statefulRuleOptions?: outputs.networkfirewall.RuleGroupRuleGroupStatefulRuleOptions;
    }
    interface RuleGroupRuleGroupReferenceSets {
        ipSetReferences?: outputs.networkfirewall.RuleGroupRuleGroupReferenceSetsIpSetReference[];
    }
    interface RuleGroupRuleGroupReferenceSetsIpSetReference {
        ipSetReferences: outputs.networkfirewall.RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference[];
        key: string;
    }
    interface RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference {
        /**
         * Set of Managed Prefix IP ARN(s)
         */
        referenceArn: string;
    }
    interface RuleGroupRuleGroupRuleVariables {
        /**
         * Set of configuration blocks that define IP address information. See IP Sets below for details.
         */
        ipSets?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSet[];
        /**
         * Set of configuration blocks that define port range information. See Port Sets below for details.
         */
        portSets?: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSet[];
    }
    interface RuleGroupRuleGroupRuleVariablesIpSet {
        /**
         * A configuration block that defines a set of IP addresses. See IP Set below for details.
         */
        ipSet: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSet;
        /**
         * A unique alphanumeric string to identify the `ipSet`.
         */
        key: string;
    }
    interface RuleGroupRuleGroupRuleVariablesIpSetIpSet {
        /**
         * Set of IP addresses and address ranges, in CIDR notation.
         */
        definitions: string[];
    }
    interface RuleGroupRuleGroupRuleVariablesPortSet {
        /**
         * An unique alphanumeric string to identify the `portSet`.
         */
        key: string;
        /**
         * A configuration block that defines a set of port ranges. See Port Set below for details.
         */
        portSet: outputs.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetPortSet;
    }
    interface RuleGroupRuleGroupRuleVariablesPortSetPortSet {
        /**
         * Set of port ranges.
         */
        definitions: string[];
    }
    interface RuleGroupRuleGroupRulesSource {
        /**
         * A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
         */
        rulesSourceList?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceRulesSourceList;
        /**
         * The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
         */
        rulesString?: string;
        /**
         * Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
         */
        statefulRules?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRule[];
        /**
         * A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
         */
        statelessRulesAndCustomActions?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions;
    }
    interface RuleGroupRuleGroupRulesSourceRulesSourceList {
        /**
         * String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
         */
        generatedRulesType: string;
        /**
         * Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
         */
        targetTypes: string[];
        /**
         * Set of domains that you want to inspect for in your traffic flows.
         */
        targets: string[];
    }
    interface RuleGroupRuleGroupRulesSourceStatefulRule {
        /**
         * Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
         */
        action: string;
        /**
         * A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
         */
        header: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRuleHeader;
        /**
         * Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
         */
        ruleOptions: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption[];
    }
    interface RuleGroupRuleGroupRulesSourceStatefulRuleHeader {
        /**
         * The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
         */
        destination: string;
        /**
         * The destination port to inspect for. To match with any address, specify `ANY`.
         */
        destinationPort: string;
        /**
         * The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
         */
        direction: string;
        /**
         * The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
         */
        protocol: string;
        /**
         * The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
         */
        source: string;
        /**
         * The source port to inspect for. To match with any address, specify `ANY`.
         */
        sourcePort: string;
    }
    interface RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption {
        /**
         * Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
         * See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
         */
        keyword: string;
        /**
         * Set of strings for additional settings to use in stateful rule inspection.
         */
        settings?: string[];
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions {
        /**
         * Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
         */
        customActions?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction[];
        /**
         * Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
         */
        statelessRules: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule[];
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction {
        /**
         * A configuration block describing the custom action associated with the `actionName`. See Action Definition below for details.
         */
        actionDefinition: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition;
        /**
         * A friendly name of the custom action.
         */
        actionName: string;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition {
        /**
         * A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
         */
        publishMetricAction: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction {
        /**
         * Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
         */
        dimensions: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension[];
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension {
        /**
         * The value to use in the custom metric dimension.
         */
        value: string;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule {
        /**
         * A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
         */
        priority: number;
        /**
         * A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
         */
        ruleDefinition: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition {
        /**
         * Set of actions to take on a packet that matches one of the stateless rule definition's `matchAttributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
         */
        actions: string[];
        /**
         * A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
         */
        matchAttributes: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes {
        /**
         * Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
         */
        destinationPorts?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort[];
        /**
         * Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
         */
        destinations?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination[];
        /**
         * Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
         */
        protocols?: number[];
        /**
         * Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
         */
        sourcePorts?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort[];
        /**
         * Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
         */
        sources?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource[];
        /**
         * Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
         */
        tcpFlags?: outputs.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag[];
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination {
        /**
         * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
         */
        addressDefinition: string;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort {
        /**
         * The lower limit of the port range. This must be less than or equal to the `toPort`.
         */
        fromPort: number;
        /**
         * The upper limit of the port range. This must be greater than or equal to the `fromPort`.
         */
        toPort?: number;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource {
        /**
         * An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
         */
        addressDefinition: string;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort {
        /**
         * The lower limit of the port range. This must be less than or equal to the `toPort`.
         */
        fromPort: number;
        /**
         * The upper limit of the port range. This must be greater than or equal to the `fromPort`.
         */
        toPort?: number;
    }
    interface RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag {
        /**
         * Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
         * Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
         */
        flags: string[];
        /**
         * Set of flags to consider in the inspection. To inspect all flags, leave this empty.
         * Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
         */
        masks?: string[];
    }
    interface RuleGroupRuleGroupStatefulRuleOptions {
        /**
         * Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
         */
        ruleOrder: string;
    }
}
export declare namespace networkmanager {
    interface ConnectAttachmentOptions {
        /**
         * The protocol used for the attachment connection. Possible values are `GRE` and `NO_ENCAP`.
         */
        protocol?: string;
    }
    interface ConnectPeerBgpOptions {
        peerAsn?: number;
    }
    interface ConnectPeerConfiguration {
        bgpConfigurations: outputs.networkmanager.ConnectPeerConfigurationBgpConfiguration[];
        /**
         * A Connect peer core network address.
         */
        coreNetworkAddress: string;
        /**
         * The inside IP addresses used for BGP peering. Required when the Connect attachment protocol is `GRE`. See `aws.networkmanager.ConnectAttachment` for details.
         */
        insideCidrBlocks: string[];
        /**
         * The Connect peer address.
         *
         * The following arguments are optional:
         */
        peerAddress: string;
        protocol: string;
    }
    interface ConnectPeerConfigurationBgpConfiguration {
        /**
         * A Connect peer core network address.
         */
        coreNetworkAddress: string;
        coreNetworkAsn: number;
        /**
         * The Connect peer address.
         *
         * The following arguments are optional:
         */
        peerAddress: string;
        peerAsn: number;
    }
    interface CoreNetworkEdge {
        /**
         * ASN of a core network edge.
         */
        asn: number;
        /**
         * Region where a core network edge is located.
         */
        edgeLocation: string;
        /**
         * Inside IP addresses used for core network edges.
         */
        insideCidrBlocks: string[];
    }
    interface CoreNetworkSegment {
        /**
         * Regions where the edges are located.
         */
        edgeLocations: string[];
        /**
         * Name of a core network segment.
         */
        name: string;
        /**
         * Shared segments of a core network.
         */
        sharedSegments: string[];
    }
    interface DeviceAwsLocation {
        /**
         * The Amazon Resource Name (ARN) of the subnet that the device is located in.
         */
        subnetArn?: string;
        /**
         * The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
         */
        zone?: string;
    }
    interface DeviceLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }
    interface GetCoreNetworkPolicyDocumentAttachmentPolicy {
        /**
         * Action to take when a condition is true. Detailed Below.
         */
        action: outputs.networkmanager.GetCoreNetworkPolicyDocumentAttachmentPolicyAction;
        /**
         * Valid values include `and` or `or`. This is a mandatory parameter only if you have more than one condition. The `conditionLogic` apply to all of the conditions for a rule, which also means nested conditions of `and` or `or` are not supported. Use `or` if you want to associate the attachment with the segment by either the segment name or attachment tag value, or by the chosen conditions. Use `and` if you want to associate the attachment with the segment by either the segment name or attachment tag value and by the chosen conditions. Detailed Below.
         */
        conditionLogic?: string;
        /**
         * A block argument. Detailed Below.
         */
        conditions: outputs.networkmanager.GetCoreNetworkPolicyDocumentAttachmentPolicyCondition[];
        /**
         * A user-defined description that further helps identify the rule.
         */
        description?: string;
        /**
         * An integer from `1` to `65535` indicating the rule's order number. Rules are processed in order from the lowest numbered rule to the highest. Rules stop processing when a rule is matched. It's important to make sure that you number your rules in the exact order that you want them processed.
         */
        ruleNumber: number;
    }
    interface GetCoreNetworkPolicyDocumentAttachmentPolicyAction {
        /**
         * Defines how a segment is mapped. Values can be `constant` or `tag`. `constant` statically defines the segment to associate the attachment to. `tag` uses the value of a tag to dynamically try to map to a segment.reference_policies_elements_condition_operators.html) to evaluate.
         */
        associationMethod: string;
        /**
         * Determines if this mapping should override the segment value for `requireAttachmentAcceptance`. You can only set this to `true`, indicating that this setting applies only to segments that have `requireAttachmentAcceptance` set to `false`. If the segment already has the default `requireAttachmentAcceptance`, you can set this to inherit segment’s acceptance value.
         */
        requireAcceptance?: boolean;
        /**
         * Name of the `segment` to share as defined in the `segments` section. This is used only when the `associationMethod` is `constant`.
         */
        segment?: string;
        /**
         * Maps the attachment to the value of a known key. This is used with the `associationMethod` is `tag`. For example a `tag` of `stage = “test”`, will map to a segment named `test`. The value must exactly match the name of a segment. This allows you to have many segments, but use only a single rule without having to define multiple nearly identical conditions. This prevents creating many similar conditions that all use the same keys to map to segments.
         */
        tagValueOfKey?: string;
    }
    interface GetCoreNetworkPolicyDocumentAttachmentPolicyCondition {
        /**
         * string value
         */
        key?: string;
        /**
         * Valid values include: `equals`, `not-equals`, `contains`, `begins-with`.
         */
        operator?: string;
        /**
         * Valid values include: `account-id`, `any`, `tag-value`, `tag-exists`, `resource-id`, `region`, `attachment-type`.
         */
        type: string;
        /**
         * string value
         */
        value?: string;
    }
    interface GetCoreNetworkPolicyDocumentCoreNetworkConfiguration {
        /**
         * List of strings containing Autonomous System Numbers (ASNs) to assign to Core Network Edges. By default, the core network automatically assigns an ASN for each Core Network Edge but you can optionally define the ASN in the edge-locations for each Region. The ASN uses an array of integer ranges only from `64512` to `65534` and `4200000000` to `4294967294` expressed as a string like `"64512-65534"`. No other ASN ranges can be used.
         */
        asnRanges: string[];
        /**
         * A block value of AWS Region locations where you're creating Core Network Edges. Detailed below.
         */
        edgeLocations: outputs.networkmanager.GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation[];
        /**
         * The Classless Inter-Domain Routing (CIDR) block range used to create tunnels for AWS Transit Gateway Connect. The format is standard AWS CIDR range (for example, `10.0.1.0/24`). You can optionally define the inside CIDR in the Core Network Edges section per Region. The minimum is a `/24` for IPv4 or `/64` for IPv6. You can provide multiple `/24` subnets or a larger CIDR range. If you define a larger CIDR range, new Core Network Edges will be automatically assigned `/24` and `/64` subnets from the larger CIDR. an Inside CIDR block is required for attaching Connect attachments to a Core Network Edge.
         */
        insideCidrBlocks?: string[];
        /**
         * Indicates whether the core network forwards traffic over multiple equal-cost routes using VPN. The value can be either `true` or `false`. The default is `true`.
         */
        vpnEcmpSupport?: boolean;
    }
    interface GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation {
        /**
         * ASN of the Core Network Edge in an AWS Region. By default, the ASN will be a single integer automatically assigned from `asnRanges`
         */
        asn?: string;
        /**
         * The local CIDR blocks for this Core Network Edge for AWS Transit Gateway Connect attachments. By default, this CIDR block will be one or more optional IPv4 and IPv6 CIDR prefixes auto-assigned from `insideCidrBlocks`.
         */
        insideCidrBlocks?: string[];
        location: string;
    }
    interface GetCoreNetworkPolicyDocumentSegment {
        /**
         * List of strings of segment names that explicitly allows only routes from the segments that are listed in the array. Use the `allowFilter` setting if a segment has a well-defined group of other segments that connectivity should be restricted to. It is applied after routes have been shared in `segmentActions`. If a segment is listed in `allowFilter`, attachments between the two segments will have routes if they are also shared in the segment-actions area. For example, you might have a segment named "video-producer" that should only ever share routes with a "video-distributor" segment, no matter how many other share statements are created.
         */
        allowFilters?: string[];
        /**
         * An array of segments that disallows routes from the segments listed in the array. It is applied only after routes have been shared in `segmentActions`. If a segment is listed in the `denyFilter`, attachments between the two segments will never have routes shared across them. For example, you might have a "financial" payment segment that should never share routes with a "development" segment, regardless of how many other share statements are created. Adding the payments segment to the deny-filter parameter prevents any shared routes from being created with other segments.
         */
        denyFilters?: string[];
        /**
         * A user-defined string describing the segment.
         */
        description?: string;
        /**
         * A list of strings of AWS Region names. Allows you to define a more restrictive set of Regions for a segment. The edge location must be a subset of the locations that are defined for `edgeLocations` in the `coreNetworkConfiguration`.
         */
        edgeLocations?: string[];
        /**
         * This Boolean setting determines whether attachments on the same segment can communicate with each other. If set to `true`, the only routes available will be either shared routes through the share actions, which are attachments in other segments, or static routes. The default value is `false`. For example, you might have a segment dedicated to "development" that should never allow VPCs to talk to each other, even if they’re on the same segment. In this example, you would keep the default parameter of `false`.
         */
        isolateAttachments?: boolean;
        /**
         * Unique name for a segment. The name is a string used in other parts of the policy document, as well as in the console for metrics and other reference points. Valid characters are a–z, and 0–9.
         */
        name: string;
        /**
         * This Boolean setting determines whether attachment requests are automatically approved or require acceptance. The default is `true`, indicating that attachment requests require acceptance. For example, you might use this setting to allow a "sandbox" segment to allow any attachment request so that a core network or attachment administrator does not need to review and approve attachment requests. In this example, `requireAttachmentAcceptance` is set to `false`.
         */
        requireAttachmentAcceptance?: boolean;
    }
    interface GetCoreNetworkPolicyDocumentSegmentAction {
        /**
         * Action to take for the chosen segment. Valid values `create-route` or `share`.
         */
        action: string;
        /**
         * A user-defined string describing the segment action.
         */
        description?: string;
        /**
         * List of strings containing CIDRs. You can define the IPv4 and IPv6 CIDR notation for each AWS Region. For example, `10.1.0.0/16` or `2001:db8::/56`. This is an array of CIDR notation strings.
         */
        destinationCidrBlocks?: string[];
        /**
         * A list of strings. Valid values include `["blackhole"]` or a list of attachment ids.
         */
        destinations?: string[];
        /**
         * String. This mode places the attachment and return routes in each of the `shareWith` segments. Valid values include: `attachment-route`.
         */
        mode?: string;
        /**
         * Name of the segment.
         */
        segment: string;
        /**
         * A set subtraction of segments to not share with.
         */
        shareWithExcepts?: string[];
        /**
         * A list of strings to share with. Must be a substring is all segments. Valid values include: `["*"]` or `["<segment-names>"]`.
         */
        shareWiths?: string[];
    }
    interface GetDeviceAwsLocation {
        /**
         * ARN of the subnet that the device is located in.
         */
        subnetArn: string;
        /**
         * Zone that the device is located in.
         */
        zone: string;
    }
    interface GetDeviceLocation {
        /**
         * Physical address.
         */
        address: string;
        /**
         * Latitude.
         */
        latitude: string;
        /**
         * Longitude.
         */
        longitude: string;
    }
    interface GetLinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed: number;
    }
    interface GetSiteLocation {
        /**
         * Address of the location.
         */
        address: string;
        /**
         * Latitude of the location.
         */
        latitude: string;
        /**
         * Longitude of the location.
         */
        longitude: string;
    }
    interface LinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed?: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed?: number;
    }
    interface SiteLocation {
        /**
         * Address of the location.
         */
        address?: string;
        /**
         * Latitude of the location.
         */
        latitude?: string;
        /**
         * Longitude of the location.
         */
        longitude?: string;
    }
    interface VpcAttachmentOptions {
        /**
         * Indicates whether appliance mode is supported.
         * If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
         * If the VPC attachment is pending acceptance, changing this value will recreate the resource.
         */
        applianceModeSupport?: boolean;
        /**
         * Indicates whether IPv6 is supported.
         * If the VPC attachment is pending acceptance, changing this value will recreate the resource.
         */
        ipv6Support?: boolean;
    }
}
export declare namespace opensearch {
    interface DomainAdvancedSecurityOptions {
        /**
         * Whether Anonymous auth is enabled. Enables fine-grained access control on an existing domain. Ignored unless `advancedSecurityOptions` are enabled. _Can only be enabled on an existing domain._
         */
        anonymousAuthEnabled: boolean;
        /**
         * Whether advanced security is enabled.
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled. Default is `false`.
         */
        internalUserDatabaseEnabled?: boolean;
        /**
         * Configuration block for the main user. Detailed below.
         */
        masterUserOptions?: outputs.opensearch.DomainAdvancedSecurityOptionsMasterUserOptions;
    }
    interface DomainAdvancedSecurityOptionsMasterUserOptions {
        /**
         * ARN for the main user. Only specify if `internalUserDatabaseEnabled` is not set or set to `false`.
         */
        masterUserArn?: string;
        /**
         * Main user's username, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserName?: string;
        /**
         * Main user's password, which is stored in the Amazon OpenSearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
         */
        masterUserPassword?: string;
    }
    interface DomainAutoTuneOptions {
        /**
         * Auto-Tune desired state for the domain. Valid values: `ENABLED` or `DISABLED`.
         */
        desiredState: string;
        /**
         * Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
         *
         * **NOTE:** Maintenance windows are deprecated and have been replaced with [off-peak windows](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html). Consequently, `maintenanceSchedule` configuration blocks cannot be specified when `useOffPeakWindow` is set to `true`.
         */
        maintenanceSchedules?: outputs.opensearch.DomainAutoTuneOptionsMaintenanceSchedule[];
        /**
         * Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `DEFAULT_ROLLBACK` or `NO_ROLLBACK`.
         */
        rollbackOnDisable: string;
        /**
         * Whether to schedule Auto-Tune optimizations that require blue/green deployments during the domain's configured daily off-peak window. Defaults to `false`.
         */
        useOffPeakWindow?: boolean;
    }
    interface DomainAutoTuneOptionsMaintenanceSchedule {
        /**
         * A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
         */
        duration: outputs.opensearch.DomainAutoTuneOptionsMaintenanceScheduleDuration;
        /**
         * Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }
    interface DomainAutoTuneOptionsMaintenanceScheduleDuration {
        /**
         * Unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `HOURS`.
         */
        unit: string;
        /**
         * An integer specifying the value of the duration of an Auto-Tune maintenance window.
         */
        value: number;
    }
    interface DomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration. Detailed below.
         */
        coldStorageOptions: outputs.opensearch.DomainClusterConfigColdStorageOptions;
        /**
         * Number of dedicated main nodes in the cluster.
         */
        dedicatedMasterCount?: number;
        /**
         * Whether dedicated main nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled?: boolean;
        /**
         * Instance type of the dedicated main nodes in the cluster.
         */
        dedicatedMasterType?: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount?: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType?: string;
        /**
         * Whether a multi-AZ domain is turned on with a standby AZ. For more information, see [Configuring a multi-AZ domain in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html).
         */
        multiAzWithStandbyEnabled?: boolean;
        /**
         * Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warmCount` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmCount?: number;
        /**
         * Whether to enable warm storage.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the OpenSearch cluster's warm nodes. Valid values are `ultrawarm1.medium.search`, `ultrawarm1.large.search` and `ultrawarm1.xlarge.search`. `warmType` can be only and must be set when `warmEnabled` is set to `true`.
         */
        warmType?: string;
        /**
         * Configuration block containing zone awareness settings. Detailed below.
         */
        zoneAwarenessConfig?: outputs.opensearch.DomainClusterConfigZoneAwarenessConfig;
        /**
         * Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availabilityZoneCount` within the `zoneAwarenessConfig` must be set to `3`.
         */
        zoneAwarenessEnabled?: boolean;
    }
    interface DomainClusterConfigColdStorageOptions {
        /**
         * Boolean to enable cold storage for an OpenSearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.
         */
        enabled: boolean;
    }
    interface DomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of Availability Zones for the domain to use with `zoneAwarenessEnabled`. Defaults to `2`. Valid values: `2` or `3`.
         */
        availabilityZoneCount?: number;
    }
    interface DomainCognitoOptions {
        /**
         * Whether Amazon Cognito authentication with Dashboard is enabled or not. Default is `false`.
         */
        enabled?: boolean;
        /**
         * ID of the Cognito Identity Pool to use.
         */
        identityPoolId: string;
        /**
         * ARN of the IAM role that has the AmazonOpenSearchServiceCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * ID of the Cognito User Pool to use.
         */
        userPoolId: string;
    }
    interface DomainDomainEndpointOptions {
        /**
         * Fully qualified domain for your custom endpoint.
         */
        customEndpoint?: string;
        /**
         * ACM certificate ARN for your custom endpoint.
         */
        customEndpointCertificateArn?: string;
        /**
         * Whether to enable custom endpoint for the OpenSearch domain.
         */
        customEndpointEnabled?: boolean;
        /**
         * Whether or not to require HTTPS. Defaults to `true`.
         */
        enforceHttps?: boolean;
        /**
         * Name of the TLS security policy that needs to be applied to the HTTPS endpoint. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_DomainEndpointOptions.html#opensearchservice-Type-DomainEndpointOptions-TLSSecurityPolicy). Pulumi will only perform drift detection if a configuration value is provided.
         */
        tlsSecurityPolicy: string;
    }
    interface DomainEbsOptions {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
         */
        iops: number;
        /**
         * Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GiB).
         */
        volumeSize?: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }
    interface DomainEncryptAtRest {
        /**
         * Whether to enable encryption at rest. If the `encryptAtRest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires an `engineVersion` of `OpenSearch_X.Y` or `Elasticsearch_5.1` or greater.
         */
        enabled: boolean;
        /**
         * KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead.
         */
        kmsKeyId: string;
    }
    interface DomainLogPublishingOption {
        /**
         * ARN of the Cloudwatch log group to which log needs to be published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Whether given log publishing option is enabled or not.
         */
        enabled?: boolean;
        /**
         * Type of OpenSearch log. Valid values: `INDEX_SLOW_LOGS`, `SEARCH_SLOW_LOGS`, `ES_APPLICATION_LOGS`, `AUDIT_LOGS`.
         */
        logType: string;
    }
    interface DomainNodeToNodeEncryption {
        /**
         * Whether to enable node-to-node encryption. If the `nodeToNodeEncryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `engineVersion` of `OpenSearch_X.Y` or `Elasticsearch_6.0` or greater.
         */
        enabled: boolean;
    }
    interface DomainOffPeakWindowOptions {
        /**
         * Enabled disabled toggle for off-peak update window.
         */
        enabled: boolean;
        offPeakWindow: outputs.opensearch.DomainOffPeakWindowOptionsOffPeakWindow;
    }
    interface DomainOffPeakWindowOptionsOffPeakWindow {
        /**
         * 10h window for updates
         */
        windowStartTime: outputs.opensearch.DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime;
    }
    interface DomainOffPeakWindowOptionsOffPeakWindowWindowStartTime {
        /**
         * Starting hour of the 10-hour window for updates
         */
        hours: number;
        /**
         * Starting minute of the 10-hour window for updates
         */
        minutes: number;
    }
    interface DomainSamlOptionsSamlOptions {
        /**
         * Whether SAML authentication is enabled.
         */
        enabled?: boolean;
        /**
         * Information from your identity provider.
         */
        idp?: outputs.opensearch.DomainSamlOptionsSamlOptionsIdp;
        /**
         * This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterBackendRole?: string;
        /**
         * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
         */
        masterUserName?: string;
        /**
         * Element of the SAML assertion to use for backend roles. Default is roles.
         */
        rolesKey?: string;
        /**
         * Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
         */
        sessionTimeoutMinutes?: number;
        /**
         * Element of the SAML assertion to use for username. Default is NameID.
         */
        subjectKey?: string;
    }
    interface DomainSamlOptionsSamlOptionsIdp {
        /**
         * Unique Entity ID of the application in SAML Identity Provider.
         */
        entityId: string;
        /**
         * Metadata of the SAML application in xml format.
         */
        metadataContent: string;
    }
    interface DomainSnapshotOptions {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }
    interface DomainSoftwareUpdateOptions {
        /**
         * Whether automatic service software updates are enabled for the domain. Defaults to `false`.
         */
        autoSoftwareUpdateEnabled: boolean;
    }
    interface DomainVpcOptions {
        /**
         * If the domain was created inside a VPC, the names of the availability zones the configured `subnetIds` were created inside.
         */
        availabilityZones: string[];
        /**
         * List of VPC Security Group IDs to be applied to the OpenSearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
         */
        securityGroupIds?: string[];
        /**
         * List of VPC Subnet IDs for the OpenSearch domain endpoints to be created in.
         */
        subnetIds?: string[];
        /**
         * If the domain was created inside a VPC, the ID of the VPC.
         */
        vpcId: string;
    }
    interface GetDomainAdvancedSecurityOption {
        anonymousAuthEnabled: boolean;
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Whether the internal user database is enabled.
         */
        internalUserDatabaseEnabled: boolean;
    }
    interface GetDomainAutoTuneOption {
        /**
         * Auto-Tune desired state for the domain.
         */
        desiredState: string;
        /**
         * A list of the nested configurations for the Auto-Tune maintenance windows of the domain.
         */
        maintenanceSchedules: outputs.opensearch.GetDomainAutoTuneOptionMaintenanceSchedule[];
        /**
         * Whether the domain is set to roll back to default Auto-Tune settings when disabling Auto-Tune.
         */
        rollbackOnDisable: string;
        /**
         * Whether to schedule Auto-Tune optimizations that require blue/green deployments during the domain's configured daily off-peak window.
         */
        useOffPeakWindow: boolean;
    }
    interface GetDomainAutoTuneOptionMaintenanceSchedule {
        /**
         * Cron expression for an Auto-Tune maintenance schedule.
         */
        cronExpressionForRecurrence: string;
        /**
         * Configuration block for the duration of the Auto-Tune maintenance window.
         */
        durations: outputs.opensearch.GetDomainAutoTuneOptionMaintenanceScheduleDuration[];
        /**
         * Date and time at which the Auto-Tune maintenance schedule starts in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
         */
        startAt: string;
    }
    interface GetDomainAutoTuneOptionMaintenanceScheduleDuration {
        /**
         * Unit of time.
         */
        unit: string;
        /**
         * Duration of an Auto-Tune maintenance window.
         */
        value: number;
    }
    interface GetDomainClusterConfig {
        /**
         * Configuration block containing cold storage configuration.
         */
        coldStorageOptions: outputs.opensearch.GetDomainClusterConfigColdStorageOption[];
        /**
         * Number of dedicated master nodes in the cluster.
         */
        dedicatedMasterCount: number;
        /**
         * Indicates whether dedicated master nodes are enabled for the cluster.
         */
        dedicatedMasterEnabled: boolean;
        /**
         * Instance type of the dedicated master nodes in the cluster.
         */
        dedicatedMasterType: string;
        /**
         * Number of instances in the cluster.
         */
        instanceCount: number;
        /**
         * Instance type of data nodes in the cluster.
         */
        instanceType: string;
        /**
         * Whether a multi-AZ domain is turned on with a standby AZ.
         */
        multiAzWithStandbyEnabled: boolean;
        /**
         * Number of warm nodes in the cluster.
         */
        warmCount: number;
        /**
         * Warm storage is enabled.
         */
        warmEnabled?: boolean;
        /**
         * Instance type for the OpenSearch cluster's warm nodes.
         */
        warmType: string;
        /**
         * Configuration block containing zone awareness settings.
         */
        zoneAwarenessConfigs: outputs.opensearch.GetDomainClusterConfigZoneAwarenessConfig[];
        /**
         * Indicates whether zone awareness is enabled.
         */
        zoneAwarenessEnabled: boolean;
    }
    interface GetDomainClusterConfigColdStorageOption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
    }
    interface GetDomainClusterConfigZoneAwarenessConfig {
        /**
         * Number of availability zones used.
         */
        availabilityZoneCount: number;
    }
    interface GetDomainCognitoOption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Cognito Identity pool used by the domain.
         */
        identityPoolId: string;
        /**
         * IAM Role with the AmazonOpenSearchServiceCognitoAccess policy attached.
         */
        roleArn: string;
        /**
         * Cognito User pool used by the domain.
         */
        userPoolId: string;
    }
    interface GetDomainEbsOption {
        /**
         * Whether EBS volumes are attached to data nodes in the domain.
         */
        ebsEnabled: boolean;
        /**
         * Baseline input/output (I/O) performance of EBS volumes attached to data nodes.
         */
        iops: number;
        /**
         * The throughput (in MiB/s) of the EBS volumes attached to data nodes.
         */
        throughput: number;
        /**
         * Size of EBS volumes attached to data nodes (in GB).
         */
        volumeSize: number;
        /**
         * Type of EBS volumes attached to data nodes.
         */
        volumeType: string;
    }
    interface GetDomainEncryptionAtRest {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * KMS key id used to encrypt data at rest.
         */
        kmsKeyId: string;
    }
    interface GetDomainLogPublishingOption {
        /**
         * CloudWatch Log Group where the logs are published.
         */
        cloudwatchLogGroupArn: string;
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        /**
         * Type of OpenSearch log being published.
         */
        logType: string;
    }
    interface GetDomainNodeToNodeEncryption {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
    }
    interface GetDomainOffPeakWindowOptions {
        /**
         * Enabled disabled toggle for off-peak update window
         */
        enabled: boolean;
        offPeakWindows: outputs.opensearch.GetDomainOffPeakWindowOptionsOffPeakWindow[];
    }
    interface GetDomainOffPeakWindowOptionsOffPeakWindow {
        /**
         * 10h window for updates
         */
        windowStartTimes: outputs.opensearch.GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTime[];
    }
    interface GetDomainOffPeakWindowOptionsOffPeakWindowWindowStartTime {
        /**
         * Starting hour of the 10-hour window for updates
         */
        hours: number;
        /**
         * Starting minute of the 10-hour window for updates
         */
        minutes: number;
    }
    interface GetDomainSnapshotOption {
        /**
         * Hour during which the service takes an automated daily snapshot of the indices in the domain.
         */
        automatedSnapshotStartHour: number;
    }
    interface GetDomainSoftwareUpdateOption {
        /**
         * Enabled or disabled.
         */
        autoSoftwareUpdateEnabled: boolean;
    }
    interface GetDomainVpcOption {
        /**
         * Availability zones used by the domain.
         */
        availabilityZones: string[];
        /**
         * Security groups used by the domain.
         */
        securityGroupIds: string[];
        /**
         * Subnets used by the domain.
         */
        subnetIds: string[];
        /**
         * VPC used by the domain.
         */
        vpcId: string;
    }
    interface GetServerlessSecurityConfigSamlOptions {
        /**
         * Group attribute for this SAML integration.
         */
        groupAttribute: string;
        /**
         * The XML IdP metadata file generated from your identity provider.
         */
        metadata: string;
        /**
         * Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
         */
        sessionTimeout: number;
        /**
         * User attribute for this SAML integration.
         */
        userAttribute: string;
    }
    interface OutboundConnectionConnectionProperties {
        /**
         * Configuration block for cross cluster search.
         */
        crossClusterSearch?: outputs.opensearch.OutboundConnectionConnectionPropertiesCrossClusterSearch;
        /**
         * The endpoint of the remote domain, is only set when `connectionMode` is `VPC_ENDPOINT` and `acceptConnection` is `TRUE`.
         */
        endpoint: string;
    }
    interface OutboundConnectionConnectionPropertiesCrossClusterSearch {
        /**
         * Skips unavailable clusters and can only be used for cross-cluster searches. Accepted values are `ENABLED` or `DISABLED`.
         */
        skipUnavailable?: string;
    }
    interface OutboundConnectionLocalDomainInfo {
        /**
         * The name of the local domain.
         */
        domainName: string;
        /**
         * The Account ID of the owner of the local domain.
         */
        ownerId: string;
        /**
         * The region of the local domain.
         */
        region: string;
    }
    interface OutboundConnectionRemoteDomainInfo {
        /**
         * The name of the remote domain.
         */
        domainName: string;
        /**
         * The Account ID of the owner of the remote domain.
         */
        ownerId: string;
        /**
         * The region of the remote domain.
         */
        region: string;
    }
    interface PackagePackageSource {
        /**
         * The name of the Amazon S3 bucket containing the package.
         */
        s3BucketName: string;
        /**
         * Key (file name) of the package.
         */
        s3Key: string;
    }
    interface ServerlessCollectionTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface ServerlessSecurityConfigSamlOptions {
        /**
         * Group attribute for this SAML integration.
         */
        groupAttribute?: string;
        /**
         * The XML IdP metadata file generated from your identity provider.
         */
        metadata: string;
        /**
         * Session timeout, in minutes. Minimum is 5 minutes and maximum is 720 minutes (12 hours). Default is 60 minutes.
         */
        sessionTimeout: number;
        /**
         * User attribute for this SAML integration.
         */
        userAttribute?: string;
    }
    interface ServerlessVpcEndpointTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface VpcEndpointVpcOptions {
        availabilityZones: string[];
        /**
         * The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
         */
        subnetIds: string[];
        vpcId: string;
    }
}
export declare namespace opensearchingest {
    interface PipelineBufferOptions {
        /**
         * Whether persistent buffering should be enabled.
         */
        persistentBufferEnabled: boolean;
    }
    interface PipelineEncryptionAtRestOptions {
        /**
         * The ARN of the KMS key used to encrypt data-at-rest in OpenSearch Ingestion. By default, data is encrypted using an AWS owned key.
         */
        kmsKeyArn: string;
    }
    interface PipelineLogPublishingOptions {
        /**
         * The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch Logs. This parameter is required if IsLoggingEnabled is set to true. See `cloudwatchLogDestination` below.
         */
        cloudwatchLogDestination?: outputs.opensearchingest.PipelineLogPublishingOptionsCloudwatchLogDestination;
        /**
         * Whether logs should be published.
         */
        isLoggingEnabled?: boolean;
    }
    interface PipelineLogPublishingOptionsCloudwatchLogDestination {
        /**
         * The name of the CloudWatch Logs group to send pipeline logs to. You can specify an existing log group or create a new one. For example, /aws/OpenSearchService/IngestionService/my-pipeline.
         */
        logGroup: string;
    }
    interface PipelineTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface PipelineVpcOptions {
        /**
         * A list of security groups associated with the VPC endpoint.
         */
        securityGroupIds?: string[];
        /**
         * A list of subnet IDs associated with the VPC endpoint.
         */
        subnetIds: string[];
    }
}
export declare namespace opsworks {
    interface ApplicationAppSource {
        /**
         * Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        password?: string;
        /**
         * For sources that are version-aware, the revision to use.
         */
        revision?: string;
        /**
         * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        sshKey?: string;
        /**
         * The type of source to use. For example, "archive".
         */
        type: string;
        /**
         * The URL where the app resource can be found.
         */
        url?: string;
        /**
         * Username to use when authenticating to the source.
         */
        username?: string;
    }
    interface ApplicationEnvironment {
        /**
         * Variable name.
         */
        key: string;
        /**
         * Set visibility of the variable value to `true` or `false`.
         */
        secure?: boolean;
        /**
         * Variable value.
         */
        value: string;
    }
    interface ApplicationSslConfiguration {
        /**
         * The contents of the certificate's domain.crt file.
         */
        certificate: string;
        /**
         * Can be used to specify an intermediate certificate authority key or client authentication.
         */
        chain?: string;
        /**
         * The private key; the contents of the certificate's domain.key file.
         */
        privateKey: string;
    }
    interface CustomLayerCloudwatchConfiguration {
        enabled?: boolean;
        /**
         * A block the specifies how an opsworks logs look like. See Log Streams.
         */
        logStreams?: outputs.opsworks.CustomLayerCloudwatchConfigurationLogStream[];
    }
    interface CustomLayerCloudwatchConfigurationLogStream {
        /**
         * Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
         */
        batchCount?: number;
        /**
         * Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
         */
        batchSize?: number;
        /**
         * Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
         */
        bufferDuration?: number;
        /**
         * Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
         */
        datetimeFormat?: string;
        /**
         * Specifies the encoding of the log file so that the file can be read correctly. The default is `utf8`.
         */
        encoding?: string;
        /**
         * Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
         */
        file: string;
        /**
         * Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
         */
        fileFingerprintLines?: string;
        /**
         * Specifies where to start to read data (`startOfFile` or `endOfFile`). The default is `startOfFile`.
         */
        initialPosition?: string;
        /**
         * Specifies the destination log group. A log group is created automatically if it doesn't already exist.
         */
        logGroupName: string;
        /**
         * Specifies the pattern for identifying the start of a log message.
         */
        multilineStartPattern?: string;
        /**
         * Specifies the time zone of log event time stamps.
         */
        timeZone?: string;
    }
    interface CustomLayerEbsVolume {
        /**
         * Encrypt the volume.
         */
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface CustomLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.CustomLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.CustomLayerLoadBasedAutoScalingUpscaling;
    }
    interface CustomLayerLoadBasedAutoScalingDownscaling {
        /**
         * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
         */
        alarms?: string[];
        /**
         * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
         */
        cpuThreshold?: number;
        /**
         * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
         */
        ignoreMetricsTime?: number;
        /**
         * The number of instances to add or remove when the load exceeds a threshold.
         */
        instanceCount?: number;
        /**
         * The load threshold. A value of -1 disables the threshold.
         */
        loadThreshold?: number;
        /**
         * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
         */
        memoryThreshold?: number;
        /**
         * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
         */
        thresholdsWaitTime?: number;
    }
    interface CustomLayerLoadBasedAutoScalingUpscaling {
        /**
         * Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
         */
        alarms?: string[];
        /**
         * The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
         */
        cpuThreshold?: number;
        /**
         * The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
         */
        ignoreMetricsTime?: number;
        /**
         * The number of instances to add or remove when the load exceeds a threshold.
         */
        instanceCount?: number;
        /**
         * The load threshold. A value of -1 disables the threshold.
         */
        loadThreshold?: number;
        /**
         * The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
         */
        memoryThreshold?: number;
        /**
         * The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
         */
        thresholdsWaitTime?: number;
    }
    interface EcsClusterLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.EcsClusterLayerCloudwatchConfigurationLogStream[];
    }
    interface EcsClusterLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface EcsClusterLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface EcsClusterLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.EcsClusterLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.EcsClusterLayerLoadBasedAutoScalingUpscaling;
    }
    interface EcsClusterLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface EcsClusterLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface GangliaLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.GangliaLayerCloudwatchConfigurationLogStream[];
    }
    interface GangliaLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface GangliaLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface GangliaLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.GangliaLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.GangliaLayerLoadBasedAutoScalingUpscaling;
    }
    interface GangliaLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface GangliaLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface HaproxyLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.HaproxyLayerCloudwatchConfigurationLogStream[];
    }
    interface HaproxyLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface HaproxyLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface HaproxyLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.HaproxyLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.HaproxyLayerLoadBasedAutoScalingUpscaling;
    }
    interface HaproxyLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface HaproxyLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface InstanceEbsBlockDevice {
        deleteOnTermination?: boolean;
        deviceName: string;
        iops: number;
        snapshotId: string;
        volumeSize: number;
        volumeType: string;
    }
    interface InstanceEphemeralBlockDevice {
        deviceName: string;
        virtualName: string;
    }
    interface InstanceRootBlockDevice {
        deleteOnTermination?: boolean;
        iops: number;
        volumeSize: number;
        volumeType: string;
    }
    interface JavaAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.JavaAppLayerCloudwatchConfigurationLogStream[];
    }
    interface JavaAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface JavaAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface JavaAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.JavaAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.JavaAppLayerLoadBasedAutoScalingUpscaling;
    }
    interface JavaAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface JavaAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface MemcachedLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.MemcachedLayerCloudwatchConfigurationLogStream[];
    }
    interface MemcachedLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface MemcachedLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface MemcachedLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.MemcachedLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.MemcachedLayerLoadBasedAutoScalingUpscaling;
    }
    interface MemcachedLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface MemcachedLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface MysqlLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.MysqlLayerCloudwatchConfigurationLogStream[];
    }
    interface MysqlLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface MysqlLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface MysqlLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.MysqlLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.MysqlLayerLoadBasedAutoScalingUpscaling;
    }
    interface MysqlLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface MysqlLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface NodejsAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.NodejsAppLayerCloudwatchConfigurationLogStream[];
    }
    interface NodejsAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface NodejsAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface NodejsAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.NodejsAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.NodejsAppLayerLoadBasedAutoScalingUpscaling;
    }
    interface NodejsAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface NodejsAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface PhpAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.PhpAppLayerCloudwatchConfigurationLogStream[];
    }
    interface PhpAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface PhpAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface PhpAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.PhpAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.PhpAppLayerLoadBasedAutoScalingUpscaling;
    }
    interface PhpAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface PhpAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface RailsAppLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.RailsAppLayerCloudwatchConfigurationLogStream[];
    }
    interface RailsAppLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface RailsAppLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface RailsAppLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.RailsAppLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.RailsAppLayerLoadBasedAutoScalingUpscaling;
    }
    interface RailsAppLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface RailsAppLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface StackCustomCookbooksSource {
        /**
         * Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
         */
        password?: string;
        /**
         * For sources that are version-aware, the revision to use.
         */
        revision?: string;
        /**
         * SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
         */
        sshKey?: string;
        /**
         * The type of source to use. For example, "archive".
         */
        type: string;
        /**
         * The URL where the cookbooks resource can be found.
         */
        url: string;
        /**
         * Username to use when authenticating to the source.
         */
        username?: string;
    }
    interface StaticWebLayerCloudwatchConfiguration {
        enabled?: boolean;
        logStreams?: outputs.opsworks.StaticWebLayerCloudwatchConfigurationLogStream[];
    }
    interface StaticWebLayerCloudwatchConfigurationLogStream {
        batchCount?: number;
        batchSize?: number;
        bufferDuration?: number;
        datetimeFormat?: string;
        encoding?: string;
        file: string;
        fileFingerprintLines?: string;
        initialPosition?: string;
        logGroupName: string;
        multilineStartPattern?: string;
        timeZone?: string;
    }
    interface StaticWebLayerEbsVolume {
        encrypted?: boolean;
        /**
         * For PIOPS volumes, the IOPS per disk.
         */
        iops?: number;
        /**
         * The path to mount the EBS volume on the layer's instances.
         */
        mountPoint: string;
        /**
         * The number of disks to use for the EBS volume.
         */
        numberOfDisks: number;
        /**
         * The RAID level to use for the volume.
         */
        raidLevel?: string;
        /**
         * The size of the volume in gigabytes.
         */
        size: number;
        /**
         * The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
         */
        type?: string;
    }
    interface StaticWebLayerLoadBasedAutoScaling {
        downscaling: outputs.opsworks.StaticWebLayerLoadBasedAutoScalingDownscaling;
        enable?: boolean;
        upscaling: outputs.opsworks.StaticWebLayerLoadBasedAutoScalingUpscaling;
    }
    interface StaticWebLayerLoadBasedAutoScalingDownscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
    interface StaticWebLayerLoadBasedAutoScalingUpscaling {
        alarms?: string[];
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }
}
export declare namespace organizations {
    interface GetDelegatedAdministratorsDelegatedAdministrator {
        /**
         * The ARN of the delegated administrator's account.
         */
        arn: string;
        /**
         * The date when the account was made a delegated administrator.
         */
        delegationEnabledDate: string;
        /**
         * The email address that is associated with the delegated administrator's AWS account.
         */
        email: string;
        /**
         * The unique identifier (ID) of the delegated administrator's account.
         */
        id: string;
        /**
         * The method by which the delegated administrator's account joined the organization.
         */
        joinedMethod: string;
        /**
         * The date when the delegated administrator's account became a part of the organization.
         */
        joinedTimestamp: string;
        /**
         * The friendly name of the delegated administrator's account.
         */
        name: string;
        /**
         * The status of the delegated administrator's account in the organization.
         */
        status: string;
    }
    interface GetDelegatedServicesDelegatedService {
        /**
         * The date that the account became a delegated administrator for this service.
         */
        delegationEnabledDate: string;
        /**
         * The name of an AWS service that can request an operation for the specified service.
         */
        servicePrincipal: string;
    }
    interface GetOrganizationAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }
    interface GetOrganizationNonMasterAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }
    interface GetOrganizationRoot {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * List of policy types enabled for this root. All elements have these attributes:
         */
        policyTypes: outputs.organizations.GetOrganizationRootPolicyType[];
    }
    interface GetOrganizationRootPolicyType {
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
        type: string;
    }
    interface GetOrganizationalUnitChildAccountsAccount {
        /**
         * The Amazon Resource Name (ARN) of the account.
         */
        arn: string;
        /**
         * The email address associated with the AWS account.
         */
        email: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * The friendly name of the account.
         */
        name: string;
        /**
         * The status of the account in the organization.
         */
        status: string;
    }
    interface GetOrganizationalUnitDescendantAccountsAccount {
        /**
         * The Amazon Resource Name (ARN) of the account.
         */
        arn: string;
        /**
         * The email address associated with the AWS account.
         */
        email: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * The friendly name of the account.
         */
        name: string;
        /**
         * The status of the account in the organization.
         */
        status: string;
    }
    interface GetOrganizationalUnitsChild {
        /**
         * ARN of the organizational unit
         */
        arn: string;
        /**
         * Parent identifier of the organizational units.
         */
        id: string;
        /**
         * Name of the organizational unit
         */
        name: string;
    }
    interface OrganizationAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }
    interface OrganizationNonMasterAccount {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
    }
    interface OrganizationRoot {
        /**
         * ARN of the root
         */
        arn: string;
        /**
         * Identifier of the root
         */
        id: string;
        /**
         * The name of the policy type
         */
        name: string;
        /**
         * List of policy types enabled for this root. All elements have these attributes:
         */
        policyTypes: outputs.organizations.OrganizationRootPolicyType[];
    }
    interface OrganizationRootPolicyType {
        /**
         * The status of the policy type as it relates to the associated root
         */
        status: string;
        type: string;
    }
    interface OrganizationalUnitAccount {
        /**
         * ARN of the organizational unit
         */
        arn: string;
        /**
         * Email of the account
         */
        email: string;
        /**
         * Identifier of the organization unit
         */
        id: string;
        /**
         * The name for the organizational unit
         */
        name: string;
    }
}
export declare namespace pinpoint {
    interface AppCampaignHook {
        /**
         * Lambda function name or ARN to be called for delivery. Conflicts with `webUrl`
         */
        lambdaFunctionName?: string;
        /**
         * What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
         */
        mode?: string;
        /**
         * Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambdaFunctionName`
         */
        webUrl?: string;
    }
    interface AppLimits {
        /**
         * The maximum number of messages that the campaign can send daily.
         */
        daily?: number;
        /**
         * The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
         */
        maximumDuration?: number;
        /**
         * The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
         */
        messagesPerSecond?: number;
        /**
         * The maximum total number of messages that the campaign can send.
         */
        total?: number;
    }
    interface AppQuietTime {
        /**
         * The default end time for quiet time in ISO 8601 format. Required if `start` is set
         */
        end?: string;
        /**
         * The default start time for quiet time in ISO 8601 format. Required if `end` is set
         */
        start?: string;
    }
}
export declare namespace pipes {
    interface PipeEnrichmentParameters {
        /**
         * Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge ApiDestination. If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence. Detailed below.
         */
        httpParameters?: outputs.pipes.PipeEnrichmentParametersHttpParameters;
        /**
         * Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
         */
        inputTemplate?: string;
    }
    interface PipeEnrichmentParametersHttpParameters {
        headerParameters?: {
            [key: string]: string;
        };
        pathParameterValues?: string;
        queryStringParameters?: {
            [key: string]: string;
        };
    }
    interface PipeSourceParameters {
        /**
         * The parameters for using an Active MQ broker as a source. Detailed below.
         */
        activemqBrokerParameters: outputs.pipes.PipeSourceParametersActivemqBrokerParameters;
        /**
         * The parameters for using a DynamoDB stream as a source.  Detailed below.
         */
        dynamodbStreamParameters: outputs.pipes.PipeSourceParametersDynamodbStreamParameters;
        /**
         * The collection of event patterns used to [filter events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-event-filtering.html). Detailed below.
         */
        filterCriteria?: outputs.pipes.PipeSourceParametersFilterCriteria;
        /**
         * The parameters for using a Kinesis stream as a source. Detailed below.
         */
        kinesisStreamParameters: outputs.pipes.PipeSourceParametersKinesisStreamParameters;
        /**
         * The parameters for using an MSK stream as a source. Detailed below.
         */
        managedStreamingKafkaParameters: outputs.pipes.PipeSourceParametersManagedStreamingKafkaParameters;
        /**
         * The parameters for using a Rabbit MQ broker as a source. Detailed below.
         */
        rabbitmqBrokerParameters: outputs.pipes.PipeSourceParametersRabbitmqBrokerParameters;
        /**
         * The parameters for using a self-managed Apache Kafka stream as a source. Detailed below.
         */
        selfManagedKafkaParameters: outputs.pipes.PipeSourceParametersSelfManagedKafkaParameters;
        /**
         * The parameters for using a Amazon SQS stream as a source. Detailed below.
         */
        sqsQueueParameters: outputs.pipes.PipeSourceParametersSqsQueueParameters;
    }
    interface PipeSourceParametersActivemqBrokerParameters {
        batchSize: number;
        credentials: outputs.pipes.PipeSourceParametersActivemqBrokerParametersCredentials;
        maximumBatchingWindowInSeconds: number;
        queueName: string;
    }
    interface PipeSourceParametersActivemqBrokerParametersCredentials {
        basicAuth: string;
    }
    interface PipeSourceParametersDynamodbStreamParameters {
        batchSize: number;
        deadLetterConfig?: outputs.pipes.PipeSourceParametersDynamodbStreamParametersDeadLetterConfig;
        maximumBatchingWindowInSeconds: number;
        maximumRecordAgeInSeconds: number;
        maximumRetryAttempts?: number;
        onPartialBatchItemFailure?: string;
        parallelizationFactor: number;
        startingPosition: string;
    }
    interface PipeSourceParametersDynamodbStreamParametersDeadLetterConfig {
        /**
         * ARN of this pipe.
         */
        arn?: string;
    }
    interface PipeSourceParametersFilterCriteria {
        filters?: outputs.pipes.PipeSourceParametersFilterCriteriaFilter[];
    }
    interface PipeSourceParametersFilterCriteriaFilter {
        pattern: string;
    }
    interface PipeSourceParametersKinesisStreamParameters {
        batchSize: number;
        deadLetterConfig?: outputs.pipes.PipeSourceParametersKinesisStreamParametersDeadLetterConfig;
        maximumBatchingWindowInSeconds: number;
        maximumRecordAgeInSeconds: number;
        maximumRetryAttempts?: number;
        onPartialBatchItemFailure?: string;
        parallelizationFactor: number;
        startingPosition: string;
        startingPositionTimestamp?: string;
    }
    interface PipeSourceParametersKinesisStreamParametersDeadLetterConfig {
        /**
         * ARN of this pipe.
         */
        arn?: string;
    }
    interface PipeSourceParametersManagedStreamingKafkaParameters {
        batchSize: number;
        consumerGroupId?: string;
        credentials?: outputs.pipes.PipeSourceParametersManagedStreamingKafkaParametersCredentials;
        maximumBatchingWindowInSeconds: number;
        startingPosition?: string;
        topicName: string;
    }
    interface PipeSourceParametersManagedStreamingKafkaParametersCredentials {
        clientCertificateTlsAuth?: string;
        saslScram512Auth?: string;
    }
    interface PipeSourceParametersRabbitmqBrokerParameters {
        batchSize: number;
        credentials: outputs.pipes.PipeSourceParametersRabbitmqBrokerParametersCredentials;
        maximumBatchingWindowInSeconds: number;
        queueName: string;
        virtualHost?: string;
    }
    interface PipeSourceParametersRabbitmqBrokerParametersCredentials {
        basicAuth: string;
    }
    interface PipeSourceParametersSelfManagedKafkaParameters {
        additionalBootstrapServers?: string[];
        batchSize: number;
        consumerGroupId?: string;
        credentials?: outputs.pipes.PipeSourceParametersSelfManagedKafkaParametersCredentials;
        maximumBatchingWindowInSeconds: number;
        serverRootCaCertificate?: string;
        startingPosition?: string;
        topicName: string;
        vpc?: outputs.pipes.PipeSourceParametersSelfManagedKafkaParametersVpc;
    }
    interface PipeSourceParametersSelfManagedKafkaParametersCredentials {
        basicAuth: string;
        clientCertificateTlsAuth?: string;
        saslScram256Auth?: string;
        saslScram512Auth?: string;
    }
    interface PipeSourceParametersSelfManagedKafkaParametersVpc {
        securityGroups?: string[];
        subnets?: string[];
    }
    interface PipeSourceParametersSqsQueueParameters {
        batchSize: number;
        maximumBatchingWindowInSeconds: number;
    }
    interface PipeTargetParameters {
        /**
         * The parameters for using an AWS Batch job as a target. Detailed below.
         */
        batchJobParameters?: outputs.pipes.PipeTargetParametersBatchJobParameters;
        /**
         * The parameters for using an CloudWatch Logs log stream as a target. Detailed below.
         */
        cloudwatchLogsParameters?: outputs.pipes.PipeTargetParametersCloudwatchLogsParameters;
        /**
         * The parameters for using an Amazon ECS task as a target. Detailed below.
         */
        ecsTaskParameters?: outputs.pipes.PipeTargetParametersEcsTaskParameters;
        /**
         * The parameters for using an EventBridge event bus as a target. Detailed below.
         */
        eventbridgeEventBusParameters?: outputs.pipes.PipeTargetParametersEventbridgeEventBusParameters;
        /**
         * These are custom parameter to be used when the target is an API Gateway REST APIs or EventBridge ApiDestinations. Detailed below.
         */
        httpParameters?: outputs.pipes.PipeTargetParametersHttpParameters;
        /**
         * Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
         */
        inputTemplate?: string;
        /**
         * The parameters for using a Kinesis stream as a source. Detailed below.
         */
        kinesisStreamParameters?: outputs.pipes.PipeTargetParametersKinesisStreamParameters;
        /**
         * The parameters for using a Lambda function as a target. Detailed below.
         */
        lambdaFunctionParameters?: outputs.pipes.PipeTargetParametersLambdaFunctionParameters;
        /**
         * These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the Amazon Redshift Data API BatchExecuteStatement. Detailed below.
         */
        redshiftDataParameters?: outputs.pipes.PipeTargetParametersRedshiftDataParameters;
        /**
         * The parameters for using a SageMaker pipeline as a target. Detailed below.
         */
        sagemakerPipelineParameters?: outputs.pipes.PipeTargetParametersSagemakerPipelineParameters;
        /**
         * The parameters for using a Amazon SQS stream as a target. Detailed below.
         */
        sqsQueueParameters?: outputs.pipes.PipeTargetParametersSqsQueueParameters;
        /**
         * The parameters for using a Step Functions state machine as a target. Detailed below.
         */
        stepFunctionStateMachineParameters?: outputs.pipes.PipeTargetParametersStepFunctionStateMachineParameters;
    }
    interface PipeTargetParametersBatchJobParameters {
        arrayProperties?: outputs.pipes.PipeTargetParametersBatchJobParametersArrayProperties;
        containerOverrides?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverrides;
        dependsOns?: outputs.pipes.PipeTargetParametersBatchJobParametersDependsOn[];
        jobDefinition: string;
        jobName: string;
        parameters?: {
            [key: string]: string;
        };
        retryStrategy?: outputs.pipes.PipeTargetParametersBatchJobParametersRetryStrategy;
    }
    interface PipeTargetParametersBatchJobParametersArrayProperties {
        size?: number;
    }
    interface PipeTargetParametersBatchJobParametersContainerOverrides {
        commands?: string[];
        environments?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverridesEnvironment[];
        instanceType?: string;
        resourceRequirements?: outputs.pipes.PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirement[];
    }
    interface PipeTargetParametersBatchJobParametersContainerOverridesEnvironment {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        value?: string;
    }
    interface PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirement {
        type: string;
        value: string;
    }
    interface PipeTargetParametersBatchJobParametersDependsOn {
        jobId?: string;
        type?: string;
    }
    interface PipeTargetParametersBatchJobParametersRetryStrategy {
        attempts?: number;
    }
    interface PipeTargetParametersCloudwatchLogsParameters {
        logStreamName?: string;
        timestamp?: string;
    }
    interface PipeTargetParametersEcsTaskParameters {
        capacityProviderStrategies?: outputs.pipes.PipeTargetParametersEcsTaskParametersCapacityProviderStrategy[];
        enableEcsManagedTags?: boolean;
        enableExecuteCommand?: boolean;
        group?: string;
        launchType?: string;
        networkConfiguration?: outputs.pipes.PipeTargetParametersEcsTaskParametersNetworkConfiguration;
        overrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverrides;
        placementConstraints?: outputs.pipes.PipeTargetParametersEcsTaskParametersPlacementConstraint[];
        placementStrategies?: outputs.pipes.PipeTargetParametersEcsTaskParametersPlacementStrategy[];
        platformVersion?: string;
        propagateTags?: string;
        referenceId?: string;
        /**
         * Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {
            [key: string]: string;
        };
        taskCount?: number;
        taskDefinitionArn: string;
    }
    interface PipeTargetParametersEcsTaskParametersCapacityProviderStrategy {
        base?: number;
        capacityProvider: string;
        weight?: number;
    }
    interface PipeTargetParametersEcsTaskParametersNetworkConfiguration {
        awsVpcConfiguration?: outputs.pipes.PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfiguration;
    }
    interface PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfiguration {
        assignPublicIp?: string;
        securityGroups?: string[];
        subnets?: string[];
    }
    interface PipeTargetParametersEcsTaskParametersOverrides {
        containerOverrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverride[];
        cpu?: string;
        ephemeralStorage?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesEphemeralStorage;
        executionRoleArn?: string;
        inferenceAcceleratorOverrides?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverride[];
        memory?: string;
        taskRoleArn?: string;
    }
    interface PipeTargetParametersEcsTaskParametersOverridesContainerOverride {
        commands?: string[];
        cpu?: number;
        environmentFiles?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFile[];
        environments?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironment[];
        memory?: number;
        memoryReservation?: number;
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        resourceRequirements?: outputs.pipes.PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirement[];
    }
    interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironment {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name?: string;
        value?: string;
    }
    interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFile {
        type: string;
        value: string;
    }
    interface PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirement {
        type: string;
        value: string;
    }
    interface PipeTargetParametersEcsTaskParametersOverridesEphemeralStorage {
        sizeInGib: number;
    }
    interface PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverride {
        deviceName?: string;
        deviceType?: string;
    }
    interface PipeTargetParametersEcsTaskParametersPlacementConstraint {
        expression?: string;
        type?: string;
    }
    interface PipeTargetParametersEcsTaskParametersPlacementStrategy {
        field?: string;
        type?: string;
    }
    interface PipeTargetParametersEventbridgeEventBusParameters {
        detailType?: string;
        endpointId?: string;
        resources?: string[];
        /**
         * Source resource of the pipe. This field typically requires an ARN (Amazon Resource Name). However, when using a self-managed Kafka cluster, you should use a different format. Instead of an ARN, use 'smk://' followed by the bootstrap server's address.
         */
        source?: string;
        time?: string;
    }
    interface PipeTargetParametersHttpParameters {
        headerParameters?: {
            [key: string]: string;
        };
        pathParameterValues?: string;
        queryStringParameters?: {
            [key: string]: string;
        };
    }
    interface PipeTargetParametersKinesisStreamParameters {
        partitionKey: string;
    }
    interface PipeTargetParametersLambdaFunctionParameters {
        invocationType: string;
    }
    interface PipeTargetParametersRedshiftDataParameters {
        database: string;
        dbUser?: string;
        secretManagerArn?: string;
        sqls: string[];
        statementName?: string;
        withEvent?: boolean;
    }
    interface PipeTargetParametersSagemakerPipelineParameters {
        pipelineParameters?: outputs.pipes.PipeTargetParametersSagemakerPipelineParametersPipelineParameter[];
    }
    interface PipeTargetParametersSagemakerPipelineParametersPipelineParameter {
        /**
         * Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `namePrefix`.
         */
        name: string;
        value: string;
    }
    interface PipeTargetParametersSqsQueueParameters {
        messageDeduplicationId?: string;
        messageGroupId?: string;
    }
    interface PipeTargetParametersStepFunctionStateMachineParameters {
        invocationType: string;
    }
}
export declare namespace polly {
    interface GetVoicesVoice {
        /**
         * Additional codes for languages available for the specified voice in addition to its default language.
         */
        additionalLanguageCodes: string[];
        /**
         * Gender of the voice.
         */
        gender: string;
        /**
         * Amazon Polly assigned voice ID.
         */
        id: string;
        /**
         * Language identification tag for filtering the list of voices returned. If not specified, all available voices are returned.
         */
        languageCode: string;
        /**
         * Human readable name of the language in English.
         */
        languageName: string;
        /**
         * Name of the voice.
         */
        name: string;
        /**
         * Specifies which engines are supported by a given voice.
         */
        supportedEngines: string[];
    }
}
export declare namespace pricing {
    interface GetProductFilter {
        /**
         * Product attribute name that you want to filter on.
         */
        field: string;
        /**
         * Product attribute value that you want to filter on.
         */
        value: string;
    }
}
export declare namespace qldb {
    interface StreamKinesisConfiguration {
        /**
         * Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the number of records sent per API call. Default: `true`.
         */
        aggregationEnabled?: boolean;
        /**
         * The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.
         */
        streamArn: string;
    }
}
export declare namespace quicksight {
    interface AnalysisParameters {
        /**
         * A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
         */
        dateTimeParameters?: outputs.quicksight.AnalysisParametersDateTimeParameter[];
        /**
         * A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
         */
        decimalParameters?: outputs.quicksight.AnalysisParametersDecimalParameter[];
        /**
         * A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
         */
        integerParameters?: outputs.quicksight.AnalysisParametersIntegerParameter[];
        /**
         * A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
         */
        stringParameters?: outputs.quicksight.AnalysisParametersStringParameter[];
    }
    interface AnalysisParametersDateTimeParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }
    interface AnalysisParametersDecimalParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: number[];
    }
    interface AnalysisParametersIntegerParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: number[];
    }
    interface AnalysisParametersStringParameter {
        /**
         * Display name for the analysis.
         *
         * The following arguments are optional:
         */
        name: string;
        values: string[];
    }
    interface AnalysisPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface AnalysisSourceEntity {
        /**
         * The source template. See source_template.
         */
        sourceTemplate?: outputs.quicksight.AnalysisSourceEntitySourceTemplate;
    }
    interface AnalysisSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * List of dataset references. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.AnalysisSourceEntitySourceTemplateDataSetReference[];
    }
    interface AnalysisSourceEntitySourceTemplateDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }
    interface DashboardDashboardPublishOptions {
        /**
         * Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
         */
        adHocFilteringOption?: outputs.quicksight.DashboardDashboardPublishOptionsAdHocFilteringOption;
        /**
         * The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
         */
        dataPointDrillUpDownOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointDrillUpDownOption;
        /**
         * The data point menu label options of a dashboard. See data_point_menu_label_option.
         */
        dataPointMenuLabelOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointMenuLabelOption;
        /**
         * The data point tool tip options of a dashboard. See data_point_tooltip_option.
         */
        dataPointTooltipOption?: outputs.quicksight.DashboardDashboardPublishOptionsDataPointTooltipOption;
        /**
         * Export to .csv option. See export_to_csv_option.
         */
        exportToCsvOption?: outputs.quicksight.DashboardDashboardPublishOptionsExportToCsvOption;
        /**
         * Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
         */
        exportWithHiddenFieldsOption?: outputs.quicksight.DashboardDashboardPublishOptionsExportWithHiddenFieldsOption;
        /**
         * Sheet controls option. See sheet_controls_option.
         */
        sheetControlsOption?: outputs.quicksight.DashboardDashboardPublishOptionsSheetControlsOption;
        /**
         * The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
         */
        sheetLayoutElementMaximizationOption?: outputs.quicksight.DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption;
        /**
         * The axis sort options of a dashboard. See visual_axis_sort_option.
         */
        visualAxisSortOption?: outputs.quicksight.DashboardDashboardPublishOptionsVisualAxisSortOption;
        /**
         * The menu options of a visual in a dashboard. See visual_menu_option.
         */
        visualMenuOption?: outputs.quicksight.DashboardDashboardPublishOptionsVisualMenuOption;
    }
    interface DashboardDashboardPublishOptionsAdHocFilteringOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsDataPointDrillUpDownOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsDataPointMenuLabelOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsDataPointTooltipOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsExportToCsvOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsExportWithHiddenFieldsOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsSheetControlsOption {
        /**
         * Visibility state. Possibles values: EXPANDED, COLLAPSED.
         */
        visibilityState?: string;
    }
    interface DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsVisualAxisSortOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardDashboardPublishOptionsVisualMenuOption {
        /**
         * Availability status. Possibles values: ENABLED, DISABLED.
         */
        availabilityStatus?: string;
    }
    interface DashboardParameters {
        /**
         * A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
         */
        dateTimeParameters?: outputs.quicksight.DashboardParametersDateTimeParameter[];
        /**
         * A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
         */
        decimalParameters?: outputs.quicksight.DashboardParametersDecimalParameter[];
        /**
         * A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
         */
        integerParameters?: outputs.quicksight.DashboardParametersIntegerParameter[];
        /**
         * A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
         */
        stringParameters?: outputs.quicksight.DashboardParametersStringParameter[];
    }
    interface DashboardParametersDateTimeParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: string[];
    }
    interface DashboardParametersDecimalParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: number[];
    }
    interface DashboardParametersIntegerParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: number[];
    }
    interface DashboardParametersStringParameter {
        /**
         * Display name for the dashboard.
         */
        name: string;
        values: string[];
    }
    interface DashboardPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface DashboardSourceEntity {
        /**
         * The source template. See source_template.
         */
        sourceTemplate?: outputs.quicksight.DashboardSourceEntitySourceTemplate;
    }
    interface DashboardSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * List of dataset references. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.DashboardSourceEntitySourceTemplateDataSetReference[];
    }
    interface DashboardSourceEntitySourceTemplateDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }
    interface DataSetColumnGroup {
        /**
         * Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
         */
        geoSpatialColumnGroup?: outputs.quicksight.DataSetColumnGroupGeoSpatialColumnGroup;
    }
    interface DataSetColumnGroupGeoSpatialColumnGroup {
        /**
         * Columns in this hierarchy.
         */
        columns: string[];
        /**
         * Country code. Valid values are `US`.
         */
        countryCode: string;
        /**
         * A display name for the hierarchy.
         */
        name: string;
    }
    interface DataSetColumnLevelPermissionRule {
        /**
         * An array of column names.
         */
        columnNames?: string[];
        /**
         * An array of ARNs for Amazon QuickSight users or groups.
         */
        principals?: string[];
    }
    interface DataSetDataSetUsageConfiguration {
        /**
         * Controls whether a child dataset of a direct query can use this dataset as a source.
         */
        disableUseAsDirectQuerySource: boolean;
        /**
         * Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
         */
        disableUseAsImportedSource: boolean;
    }
    interface DataSetFieldFolder {
        /**
         * An array of column names to add to the folder. A column can only be in one folder.
         */
        columns?: string[];
        /**
         * Field folder description.
         */
        description?: string;
        /**
         * Key of the field folder map.
         */
        fieldFoldersId: string;
    }
    interface DataSetLogicalTableMap {
        /**
         * A display name for the logical table.
         */
        alias: string;
        /**
         * Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
         */
        dataTransforms: outputs.quicksight.DataSetLogicalTableMapDataTransform[];
        /**
         * Key of the logical table map.
         */
        logicalTableMapId: string;
        /**
         * Source of this logical table. See source.
         */
        source: outputs.quicksight.DataSetLogicalTableMapSource;
    }
    interface DataSetLogicalTableMapDataTransform {
        /**
         * A transform operation that casts a column to a different type. See cast_column_type_operation.
         */
        castColumnTypeOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformCastColumnTypeOperation;
        /**
         * An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
         */
        createColumnsOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformCreateColumnsOperation;
        /**
         * An operation that filters rows based on some condition. See filter_operation.
         */
        filterOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformFilterOperation;
        /**
         * An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
         */
        projectOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformProjectOperation;
        /**
         * An operation that renames a column. See rename_column_operation.
         */
        renameColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformRenameColumnOperation;
        /**
         * An operation that tags a column with additional information. See tag_column_operation.
         */
        tagColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperation;
        /**
         * A transform operation that removes tags associated with a column. See untag_column_operation.
         */
        untagColumnOperation: outputs.quicksight.DataSetLogicalTableMapDataTransformUntagColumnOperation;
    }
    interface DataSetLogicalTableMapDataTransformCastColumnTypeOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
         */
        format: string;
        /**
         * New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
         */
        newColumnType: string;
    }
    interface DataSetLogicalTableMapDataTransformCreateColumnsOperation {
        /**
         * Calculated columns to create. See columns.
         */
        columns: outputs.quicksight.DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn[];
    }
    interface DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn {
        /**
         * A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
         */
        columnId: string;
        /**
         * Column name.
         */
        columnName: string;
        /**
         * An expression that defines the calculated column.
         */
        expression: string;
    }
    interface DataSetLogicalTableMapDataTransformFilterOperation {
        /**
         * An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
         */
        conditionExpression: string;
    }
    interface DataSetLogicalTableMapDataTransformProjectOperation {
        /**
         * Projected columns.
         */
        projectedColumns: string[];
    }
    interface DataSetLogicalTableMapDataTransformRenameColumnOperation {
        /**
         * Column to be renamed.
         */
        columnName: string;
        /**
         * New name for the column.
         */
        newColumnName: string;
    }
    interface DataSetLogicalTableMapDataTransformTagColumnOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * The dataset column tag, currently only used for geospatial type tagging. See tags.
         */
        tags: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperationTag[];
    }
    interface DataSetLogicalTableMapDataTransformTagColumnOperationTag {
        /**
         * A description for a column. See column_description.
         */
        columnDescription: outputs.quicksight.DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription;
        /**
         * A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
         */
        columnGeographicRole: string;
    }
    interface DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription {
        /**
         * The text of a description for a column.
         */
        text: string;
    }
    interface DataSetLogicalTableMapDataTransformUntagColumnOperation {
        /**
         * Column name.
         */
        columnName: string;
        /**
         * The column tags to remove from this column.
         */
        tagNames: string[];
    }
    interface DataSetLogicalTableMapSource {
        /**
         * ARN of the parent data set.
         */
        dataSetArn: string;
        /**
         * Specifies the result of a join of two logical tables. See join_instruction.
         */
        joinInstruction: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstruction;
        /**
         * Physical table ID.
         */
        physicalTableId: string;
    }
    interface DataSetLogicalTableMapSourceJoinInstruction {
        /**
         * Join key properties of the left operand. See left_join_key_properties.
         */
        leftJoinKeyProperties: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties;
        /**
         * Operand on the left side of a join.
         */
        leftOperand: string;
        /**
         * Join instructions provided in the ON clause of a join.
         */
        onClause: string;
        /**
         * Join key properties of the right operand. See right_join_key_properties.
         */
        rightJoinKeyProperties: outputs.quicksight.DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties;
        /**
         * Operand on the right side of a join.
         */
        rightOperand: string;
        /**
         * Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
         */
        type: string;
    }
    interface DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties {
        /**
         * A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
         */
        uniqueKey: boolean;
    }
    interface DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties {
        /**
         * A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
         */
        uniqueKey: boolean;
    }
    interface DataSetOutputColumn {
        description: string;
        /**
         * Display name for the dataset.
         */
        name: string;
        type: string;
    }
    interface DataSetPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface DataSetPhysicalTableMap {
        /**
         * A physical table type built from the results of the custom SQL query. See custom_sql.
         */
        customSql?: outputs.quicksight.DataSetPhysicalTableMapCustomSql;
        /**
         * Key of the physical table map.
         */
        physicalTableMapId: string;
        /**
         * A physical table type for relational data sources. See relational_table.
         */
        relationalTable?: outputs.quicksight.DataSetPhysicalTableMapRelationalTable;
        /**
         * A physical table type for as S3 data source. See s3_source.
         */
        s3Source: outputs.quicksight.DataSetPhysicalTableMapS3Source;
    }
    interface DataSetPhysicalTableMapCustomSql {
        /**
         * Column schema from the SQL query result set. See columns.
         */
        columns?: outputs.quicksight.DataSetPhysicalTableMapCustomSqlColumn[];
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Display name for the SQL query result.
         */
        name: string;
        /**
         * SQL query.
         */
        sqlQuery: string;
    }
    interface DataSetPhysicalTableMapCustomSqlColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }
    interface DataSetPhysicalTableMapRelationalTable {
        /**
         * Catalog associated with the table.
         */
        catalog?: string;
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Column schema of the table. See input_columns.
         */
        inputColumns: outputs.quicksight.DataSetPhysicalTableMapRelationalTableInputColumn[];
        /**
         * Name of the relational table.
         */
        name: string;
        /**
         * Schema name. This name applies to certain relational database engines.
         */
        schema?: string;
    }
    interface DataSetPhysicalTableMapRelationalTableInputColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }
    interface DataSetPhysicalTableMapS3Source {
        /**
         * ARN of the data source.
         */
        dataSourceArn: string;
        /**
         * Column schema of the table. See input_columns.
         */
        inputColumns: outputs.quicksight.DataSetPhysicalTableMapS3SourceInputColumn[];
        /**
         * Information about the format for the S3 source file or files. See upload_settings.
         */
        uploadSettings: outputs.quicksight.DataSetPhysicalTableMapS3SourceUploadSettings;
    }
    interface DataSetPhysicalTableMapS3SourceInputColumn {
        /**
         * Name of this column in the underlying data source.
         */
        name: string;
        /**
         * Data type of the column.
         */
        type: string;
    }
    interface DataSetPhysicalTableMapS3SourceUploadSettings {
        /**
         * Whether the file has a header row, or the files each have a header row.
         */
        containsHeader: boolean;
        /**
         * Delimiter between values in the file.
         */
        delimiter: string;
        /**
         * File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
         */
        format: string;
        /**
         * A row number to start reading data from.
         */
        startFromRow: number;
        /**
         * Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
         */
        textQualifier: string;
    }
    interface DataSetRefreshProperties {
        /**
         * The refresh configuration for the data set. See refresh_configuration.
         */
        refreshConfiguration: outputs.quicksight.DataSetRefreshPropertiesRefreshConfiguration;
    }
    interface DataSetRefreshPropertiesRefreshConfiguration {
        /**
         * The incremental refresh for the data set. See incremental_refresh.
         */
        incrementalRefresh: outputs.quicksight.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh;
    }
    interface DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh {
        /**
         * The lookback window setup for an incremental refresh configuration. See lookback_window.
         */
        lookbackWindow: outputs.quicksight.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow;
    }
    interface DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow {
        /**
         * The name of the lookback window column.
         */
        columnName: string;
        /**
         * The lookback window column size.
         */
        size: number;
        /**
         * The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
         */
        sizeUnit: string;
    }
    interface DataSetRowLevelPermissionDataSet {
        /**
         * ARN of the dataset that contains permissions for RLS.
         */
        arn: string;
        /**
         * User or group rules associated with the dataset that contains permissions for RLS.
         */
        formatVersion?: string;
        /**
         * Namespace associated with the dataset that contains permissions for RLS.
         */
        namespace?: string;
        /**
         * Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
         */
        permissionPolicy: string;
        /**
         * Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
         */
        status?: string;
    }
    interface DataSetRowLevelPermissionTagConfiguration {
        /**
         * The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
         */
        status?: string;
        /**
         * A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
         */
        tagRules: outputs.quicksight.DataSetRowLevelPermissionTagConfigurationTagRule[];
    }
    interface DataSetRowLevelPermissionTagConfigurationTagRule {
        /**
         * Column name that a tag key is assigned to.
         */
        columnName: string;
        /**
         * A string that you want to use to filter by all the values in a column in the dataset and don’t want to list the values one by one.
         */
        matchAllValue?: string;
        /**
         * Unique key for a tag.
         */
        tagKey: string;
        /**
         * A string that you want to use to delimit the values when you pass the values at run time.
         */
        tagMultiValueDelimiter?: string;
    }
    interface DataSourceCredentials {
        /**
         * The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
         * When the value is not null, the `credentialPair` from the data source in the ARN is used.
         */
        copySourceArn?: string;
        /**
         * Credential pair. See Credential Pair below for more details.
         */
        credentialPair?: outputs.quicksight.DataSourceCredentialsCredentialPair;
    }
    interface DataSourceCredentialsCredentialPair {
        /**
         * Password, maximum length of 1024 characters.
         */
        password: string;
        /**
         * User name, maximum length of 64 characters.
         */
        username: string;
    }
    interface DataSourceParameters {
        /**
         * Parameters for connecting to Amazon Elasticsearch.
         */
        amazonElasticsearch?: outputs.quicksight.DataSourceParametersAmazonElasticsearch;
        /**
         * Parameters for connecting to Athena.
         */
        athena?: outputs.quicksight.DataSourceParametersAthena;
        /**
         * Parameters for connecting to Aurora MySQL.
         */
        aurora?: outputs.quicksight.DataSourceParametersAurora;
        /**
         * Parameters for connecting to Aurora Postgresql.
         */
        auroraPostgresql?: outputs.quicksight.DataSourceParametersAuroraPostgresql;
        /**
         * Parameters for connecting to AWS IOT Analytics.
         */
        awsIotAnalytics?: outputs.quicksight.DataSourceParametersAwsIotAnalytics;
        /**
         * Parameters for connecting to Jira.
         */
        jira?: outputs.quicksight.DataSourceParametersJira;
        /**
         * Parameters for connecting to MariaDB.
         */
        mariaDb?: outputs.quicksight.DataSourceParametersMariaDb;
        /**
         * Parameters for connecting to MySQL.
         */
        mysql?: outputs.quicksight.DataSourceParametersMysql;
        /**
         * Parameters for connecting to Oracle.
         */
        oracle?: outputs.quicksight.DataSourceParametersOracle;
        /**
         * Parameters for connecting to Postgresql.
         */
        postgresql?: outputs.quicksight.DataSourceParametersPostgresql;
        /**
         * Parameters for connecting to Presto.
         */
        presto?: outputs.quicksight.DataSourceParametersPresto;
        /**
         * Parameters for connecting to RDS.
         */
        rds?: outputs.quicksight.DataSourceParametersRds;
        /**
         * Parameters for connecting to Redshift.
         */
        redshift?: outputs.quicksight.DataSourceParametersRedshift;
        /**
         * Parameters for connecting to S3.
         */
        s3?: outputs.quicksight.DataSourceParametersS3;
        /**
         * Parameters for connecting to ServiceNow.
         */
        serviceNow?: outputs.quicksight.DataSourceParametersServiceNow;
        /**
         * Parameters for connecting to Snowflake.
         */
        snowflake?: outputs.quicksight.DataSourceParametersSnowflake;
        /**
         * Parameters for connecting to Spark.
         */
        spark?: outputs.quicksight.DataSourceParametersSpark;
        /**
         * Parameters for connecting to SQL Server.
         */
        sqlServer?: outputs.quicksight.DataSourceParametersSqlServer;
        /**
         * Parameters for connecting to Teradata.
         */
        teradata?: outputs.quicksight.DataSourceParametersTeradata;
        /**
         * Parameters for connecting to Twitter.
         */
        twitter?: outputs.quicksight.DataSourceParametersTwitter;
    }
    interface DataSourceParametersAmazonElasticsearch {
        /**
         * The OpenSearch domain.
         */
        domain: string;
    }
    interface DataSourceParametersAthena {
        /**
         * The work-group to which to connect.
         */
        workGroup?: string;
    }
    interface DataSourceParametersAurora {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersAuroraPostgresql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersAwsIotAnalytics {
        /**
         * The name of the data set to which to connect.
         */
        dataSetName: string;
    }
    interface DataSourceParametersJira {
        /**
         * The base URL of the Jira instance's site to which to connect.
         */
        siteBaseUrl: string;
    }
    interface DataSourceParametersMariaDb {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersMysql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersOracle {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersPostgresql {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersPresto {
        /**
         * The catalog to which to connect.
         */
        catalog: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The port to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersRds {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The instance ID to which to connect.
         */
        instanceId: string;
    }
    interface DataSourceParametersRedshift {
        /**
         * The ID of the cluster to which to connect.
         */
        clusterId?: string;
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host?: string;
        /**
         * The port to which to connect.
         */
        port?: number;
    }
    interface DataSourceParametersS3 {
        /**
         * An object containing the S3 location of the S3 manifest file.
         */
        manifestFileLocation: outputs.quicksight.DataSourceParametersS3ManifestFileLocation;
    }
    interface DataSourceParametersS3ManifestFileLocation {
        /**
         * The name of the bucket that contains the manifest file.
         */
        bucket: string;
        /**
         * The key of the manifest file within the bucket.
         */
        key: string;
    }
    interface DataSourceParametersServiceNow {
        /**
         * The base URL of the Jira instance's site to which to connect.
         */
        siteBaseUrl: string;
    }
    interface DataSourceParametersSnowflake {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        warehouse: string;
    }
    interface DataSourceParametersSpark {
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersSqlServer {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersTeradata {
        /**
         * The database to which to connect.
         */
        database: string;
        /**
         * The host to which to connect.
         */
        host: string;
        /**
         * The warehouse to which to connect.
         */
        port: number;
    }
    interface DataSourceParametersTwitter {
        /**
         * The maximum number of rows to query.
         */
        maxRows: number;
        /**
         * The Twitter query to retrieve the data.
         */
        query: string;
    }
    interface DataSourcePermission {
        /**
         * Set of IAM actions to grant or revoke permissions on. Max of 16 items.
         */
        actions: string[];
        /**
         * The Amazon Resource Name (ARN) of the principal.
         */
        principal: string;
    }
    interface DataSourceSslProperties {
        /**
         * A Boolean option to control whether SSL should be disabled.
         */
        disableSsl: boolean;
    }
    interface DataSourceVpcConnectionProperties {
        /**
         * The Amazon Resource Name (ARN) for the VPC connection.
         */
        vpcConnectionArn: string;
    }
    interface FolderPermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface GetDataSetColumnGroup {
        geoSpatialColumnGroups: outputs.quicksight.GetDataSetColumnGroupGeoSpatialColumnGroup[];
    }
    interface GetDataSetColumnGroupGeoSpatialColumnGroup {
        columns: string[];
        countryCode: string;
        name: string;
    }
    interface GetDataSetColumnLevelPermissionRule {
        columnNames: string[];
        principals: string[];
    }
    interface GetDataSetDataSetUsageConfiguration {
        disableUseAsDirectQuerySource: boolean;
        disableUseAsImportedSource: boolean;
    }
    interface GetDataSetFieldFolder {
        columns: string[];
        description: string;
        fieldFoldersId: string;
    }
    interface GetDataSetLogicalTableMap {
        alias: string;
        dataTransforms: outputs.quicksight.GetDataSetLogicalTableMapDataTransform[];
        logicalTableMapId: string;
        sources: outputs.quicksight.GetDataSetLogicalTableMapSource[];
    }
    interface GetDataSetLogicalTableMapDataTransform {
        castColumnTypeOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCastColumnTypeOperation[];
        createColumnsOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCreateColumnsOperation[];
        filterOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformFilterOperation[];
        projectOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformProjectOperation[];
        renameColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformRenameColumnOperation[];
        tagColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperation[];
        untagColumnOperations: outputs.quicksight.GetDataSetLogicalTableMapDataTransformUntagColumnOperation[];
    }
    interface GetDataSetLogicalTableMapDataTransformCastColumnTypeOperation {
        columnName: string;
        format: string;
        newColumnType: string;
    }
    interface GetDataSetLogicalTableMapDataTransformCreateColumnsOperation {
        columns: outputs.quicksight.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumn[];
    }
    interface GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumn {
        columnId: string;
        columnName: string;
        expression: string;
    }
    interface GetDataSetLogicalTableMapDataTransformFilterOperation {
        conditionExpression: string;
    }
    interface GetDataSetLogicalTableMapDataTransformProjectOperation {
        projectedColumns: string[];
    }
    interface GetDataSetLogicalTableMapDataTransformRenameColumnOperation {
        columnName: string;
        newColumnName: string;
    }
    interface GetDataSetLogicalTableMapDataTransformTagColumnOperation {
        columnName: string;
        tags: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperationTag[];
    }
    interface GetDataSetLogicalTableMapDataTransformTagColumnOperationTag {
        columnDescriptions: outputs.quicksight.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription[];
        columnGeographicRole: string;
    }
    interface GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription {
        text: string;
    }
    interface GetDataSetLogicalTableMapDataTransformUntagColumnOperation {
        columnName: string;
        tagNames: string[];
    }
    interface GetDataSetLogicalTableMapSource {
        dataSetArn: string;
        joinInstructions: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstruction[];
        physicalTableId: string;
    }
    interface GetDataSetLogicalTableMapSourceJoinInstruction {
        leftJoinKeyProperties: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperty[];
        leftOperand: string;
        onClause: string;
        rightJoinKeyProperties: outputs.quicksight.GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperty[];
        rightOperand: string;
        type: string;
    }
    interface GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperty {
        uniqueKey: boolean;
    }
    interface GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperty {
        uniqueKey: boolean;
    }
    interface GetDataSetPermission {
        actions: string[];
        principal: string;
    }
    interface GetDataSetPhysicalTableMap {
        customSqls: outputs.quicksight.GetDataSetPhysicalTableMapCustomSql[];
        physicalTableMapId: string;
        relationalTables: outputs.quicksight.GetDataSetPhysicalTableMapRelationalTable[];
        s3Sources: outputs.quicksight.GetDataSetPhysicalTableMapS3Source[];
    }
    interface GetDataSetPhysicalTableMapCustomSql {
        columns: outputs.quicksight.GetDataSetPhysicalTableMapCustomSqlColumn[];
        dataSourceArn: string;
        name: string;
        sqlQuery: string;
    }
    interface GetDataSetPhysicalTableMapCustomSqlColumn {
        name: string;
        type: string;
    }
    interface GetDataSetPhysicalTableMapRelationalTable {
        catalog: string;
        dataSourceArn: string;
        inputColumns: outputs.quicksight.GetDataSetPhysicalTableMapRelationalTableInputColumn[];
        name: string;
        schema: string;
    }
    interface GetDataSetPhysicalTableMapRelationalTableInputColumn {
        name: string;
        type: string;
    }
    interface GetDataSetPhysicalTableMapS3Source {
        dataSourceArn: string;
        inputColumns: outputs.quicksight.GetDataSetPhysicalTableMapS3SourceInputColumn[];
        uploadSettings: outputs.quicksight.GetDataSetPhysicalTableMapS3SourceUploadSetting[];
    }
    interface GetDataSetPhysicalTableMapS3SourceInputColumn {
        name: string;
        type: string;
    }
    interface GetDataSetPhysicalTableMapS3SourceUploadSetting {
        containsHeader: boolean;
        delimiter: string;
        format: string;
        startFromRow: number;
        textQualifier: string;
    }
    interface GetDataSetRowLevelPermissionDataSet {
        arn: string;
        formatVersion: string;
        namespace: string;
        permissionPolicy: string;
        status: string;
    }
    interface GetDataSetRowLevelPermissionTagConfiguration {
        status: string;
        tagRules: outputs.quicksight.GetDataSetRowLevelPermissionTagConfigurationTagRule[];
    }
    interface GetDataSetRowLevelPermissionTagConfigurationTagRule {
        columnName: string;
        matchAllValue: string;
        tagKey: string;
        tagMultiValueDelimiter: string;
    }
    interface GetThemeConfiguration {
        /**
         * Color properties that apply to chart data colors. See data_color_palette.
         */
        dataColorPalettes: outputs.quicksight.GetThemeConfigurationDataColorPalette[];
        /**
         * Display options related to sheets. See sheet.
         */
        sheets: outputs.quicksight.GetThemeConfigurationSheet[];
        /**
         * Determines the typography options. See typography.
         */
        typographies: outputs.quicksight.GetThemeConfigurationTypography[];
        /**
         * Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
         */
        uiColorPalettes: outputs.quicksight.GetThemeConfigurationUiColorPalette[];
    }
    interface GetThemeConfigurationDataColorPalette {
        /**
         * List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
         */
        colors: string[];
        /**
         * The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
         */
        emptyFillColor: string;
        /**
         * The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
         */
        minMaxGradients: string[];
    }
    interface GetThemeConfigurationSheet {
        /**
         * The layout options for tiles. See tile_layout.
         */
        tileLayouts: outputs.quicksight.GetThemeConfigurationSheetTileLayout[];
        /**
         * The display options for tiles. See tile.
         */
        tiles: outputs.quicksight.GetThemeConfigurationSheetTile[];
    }
    interface GetThemeConfigurationSheetTile {
        /**
         * The border around a tile. See border.
         */
        borders: outputs.quicksight.GetThemeConfigurationSheetTileBorder[];
    }
    interface GetThemeConfigurationSheetTileBorder {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }
    interface GetThemeConfigurationSheetTileLayout {
        /**
         * The gutter settings that apply between tiles. See gutter.
         */
        gutters: outputs.quicksight.GetThemeConfigurationSheetTileLayoutGutter[];
        /**
         * The margin settings that apply around the outside edge of sheets. See margin.
         */
        margins: outputs.quicksight.GetThemeConfigurationSheetTileLayoutMargin[];
    }
    interface GetThemeConfigurationSheetTileLayoutGutter {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }
    interface GetThemeConfigurationSheetTileLayoutMargin {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show: boolean;
    }
    interface GetThemeConfigurationTypography {
        /**
         * Determines the list of font families. Maximum number of 5 items. See font_families.
         */
        fontFamilies: outputs.quicksight.GetThemeConfigurationTypographyFontFamily[];
    }
    interface GetThemeConfigurationTypographyFontFamily {
        /**
         * Font family name.
         */
        fontFamily: string;
    }
    interface GetThemeConfigurationUiColorPalette {
        /**
         * Color (hexadecimal) that applies to selected states and buttons.
         */
        accent: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
         */
        accentForeground: string;
        /**
         * Color (hexadecimal) that applies to error messages.
         */
        danger: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the error color.
         */
        dangerForeground: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
         */
        dimension: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
         */
        dimensionForeground: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as measures.
         */
        measure: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
         */
        measureForeground: string;
        /**
         * Color (hexadecimal) that applies to visuals and other high emphasis UI.
         */
        primaryBackground: string;
        /**
         * Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
         */
        primaryForeground: string;
        /**
         * Color (hexadecimal) that applies to the sheet background and sheet controls.
         */
        secondaryBackground: string;
        /**
         * Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
         */
        secondaryForeground: string;
        /**
         * Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
         */
        success: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the success color.
         */
        successForeground: string;
        /**
         * Color (hexadecimal) that applies to warning and informational messages.
         */
        warning: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
         */
        warningForeground: string;
    }
    interface GetThemePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface IamPolicyAssignmentIdentities {
        /**
         * Array of Quicksight group names to assign the policy to.
         */
        groups?: string[];
        /**
         * Array of Quicksight user names to assign the policy to.
         */
        users?: string[];
    }
    interface NamespaceTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface RefreshScheduleSchedule {
        /**
         * The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
         */
        refreshType: string;
        /**
         * The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
         */
        scheduleFrequency?: outputs.quicksight.RefreshScheduleScheduleScheduleFrequency;
        /**
         * Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
         */
        startAfterDateTime: string;
    }
    interface RefreshScheduleScheduleScheduleFrequency {
        /**
         * The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
         */
        interval: string;
        /**
         * The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
         */
        refreshOnDay?: outputs.quicksight.RefreshScheduleScheduleScheduleFrequencyRefreshOnDay;
        /**
         * The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
         */
        timeOfTheDay: string;
        /**
         * The timezone that you want the refresh schedule to use.
         */
        timezone: string;
    }
    interface RefreshScheduleScheduleScheduleFrequencyRefreshOnDay {
        /**
         * The day of the month that you want to schedule refresh on.
         */
        dayOfMonth?: string;
        /**
         * The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
         */
        dayOfWeek?: string;
    }
    interface TemplatePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface TemplateSourceEntity {
        /**
         * The source analysis, if it is based on an analysis.. Only one of `sourceAnalysis` or `sourceTemplate` should be configured. See source_analysis.
         */
        sourceAnalysis?: outputs.quicksight.TemplateSourceEntitySourceAnalysis;
        /**
         * The source template, if it is based on an template.. Only one of `sourceAnalysis` or `sourceTemplate` should be configured. See source_template.
         */
        sourceTemplate?: outputs.quicksight.TemplateSourceEntitySourceTemplate;
    }
    interface TemplateSourceEntitySourceAnalysis {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
        /**
         * A list of dataset references used as placeholders in the template. See data_set_references.
         */
        dataSetReferences: outputs.quicksight.TemplateSourceEntitySourceAnalysisDataSetReference[];
    }
    interface TemplateSourceEntitySourceAnalysisDataSetReference {
        /**
         * Dataset Amazon Resource Name (ARN).
         */
        dataSetArn: string;
        /**
         * Dataset placeholder.
         */
        dataSetPlaceholder: string;
    }
    interface TemplateSourceEntitySourceTemplate {
        /**
         * The Amazon Resource Name (ARN) of the resource.
         */
        arn: string;
    }
    interface ThemeConfiguration {
        /**
         * Color properties that apply to chart data colors. See data_color_palette.
         */
        dataColorPalette?: outputs.quicksight.ThemeConfigurationDataColorPalette;
        /**
         * Display options related to sheets. See sheet.
         */
        sheet?: outputs.quicksight.ThemeConfigurationSheet;
        /**
         * Determines the typography options. See typography.
         */
        typography?: outputs.quicksight.ThemeConfigurationTypography;
        /**
         * Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
         */
        uiColorPalette?: outputs.quicksight.ThemeConfigurationUiColorPalette;
    }
    interface ThemeConfigurationDataColorPalette {
        /**
         * List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
         */
        colors?: string[];
        /**
         * The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
         */
        emptyFillColor?: string;
        /**
         * The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
         */
        minMaxGradients?: string[];
    }
    interface ThemeConfigurationSheet {
        /**
         * The display options for tiles. See tile.
         */
        tile?: outputs.quicksight.ThemeConfigurationSheetTile;
        /**
         * The layout options for tiles. See tile_layout.
         */
        tileLayout?: outputs.quicksight.ThemeConfigurationSheetTileLayout;
    }
    interface ThemeConfigurationSheetTile {
        /**
         * The border around a tile. See border.
         */
        border?: outputs.quicksight.ThemeConfigurationSheetTileBorder;
    }
    interface ThemeConfigurationSheetTileBorder {
        /**
         * The option to enable display of borders for visuals.
         */
        show?: boolean;
    }
    interface ThemeConfigurationSheetTileLayout {
        /**
         * The gutter settings that apply between tiles. See gutter.
         */
        gutter?: outputs.quicksight.ThemeConfigurationSheetTileLayoutGutter;
        /**
         * The margin settings that apply around the outside edge of sheets. See margin.
         */
        margin?: outputs.quicksight.ThemeConfigurationSheetTileLayoutMargin;
    }
    interface ThemeConfigurationSheetTileLayoutGutter {
        /**
         * This Boolean value controls whether to display a gutter space between sheet tiles.
         */
        show?: boolean;
    }
    interface ThemeConfigurationSheetTileLayoutMargin {
        /**
         * This Boolean value controls whether to display sheet margins.
         */
        show?: boolean;
    }
    interface ThemeConfigurationTypography {
        /**
         * Determines the list of font families. Maximum number of 5 items. See font_families.
         */
        fontFamilies?: outputs.quicksight.ThemeConfigurationTypographyFontFamily[];
    }
    interface ThemeConfigurationTypographyFontFamily {
        /**
         * Font family name.
         */
        fontFamily?: string;
    }
    interface ThemeConfigurationUiColorPalette {
        /**
         * Color (hexadecimal) that applies to selected states and buttons.
         */
        accent?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
         */
        accentForeground?: string;
        /**
         * Color (hexadecimal) that applies to error messages.
         */
        danger?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the error color.
         */
        dangerForeground?: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
         */
        dimension?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
         */
        dimensionForeground?: string;
        /**
         * Color (hexadecimal) that applies to the names of fields that are identified as measures.
         */
        measure?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
         */
        measureForeground?: string;
        /**
         * Color (hexadecimal) that applies to visuals and other high emphasis UI.
         */
        primaryBackground?: string;
        /**
         * Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
         */
        primaryForeground?: string;
        /**
         * Color (hexadecimal) that applies to the sheet background and sheet controls.
         */
        secondaryBackground?: string;
        /**
         * Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
         */
        secondaryForeground?: string;
        /**
         * Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
         */
        success?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the success color.
         */
        successForeground?: string;
        /**
         * Color (hexadecimal) that applies to warning and informational messages.
         */
        warning?: string;
        /**
         * Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
         */
        warningForeground?: string;
    }
    interface ThemePermission {
        /**
         * List of IAM actions to grant or revoke permissions on.
         */
        actions: string[];
        /**
         * ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
         */
        principal: string;
    }
    interface VpcConnectionTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
}
export declare namespace ram {
    interface GetResourceShareFilter {
        /**
         * Name of the tag key to filter on.
         */
        name: string;
        /**
         * Value of the tag key.
         */
        values: string[];
    }
}
export declare namespace rbin {
    interface RuleLockConfiguration {
        /**
         * Information about the retention rule unlock delay. See `unlockDelay` below.
         */
        unlockDelay: outputs.rbin.RuleLockConfigurationUnlockDelay;
    }
    interface RuleLockConfigurationUnlockDelay {
        /**
         * The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.
         */
        unlockDelayUnit: string;
        /**
         * The unlock delay period, measured in the unit specified for UnlockDelayUnit.
         */
        unlockDelayValue: number;
    }
    interface RuleResourceTag {
        /**
         * The tag key.
         *
         * The following argument is optional:
         */
        resourceTagKey: string;
        /**
         * The tag value.
         */
        resourceTagValue?: string;
    }
    interface RuleRetentionPeriod {
        /**
         * The unit of time in which the retention period is measured. Currently, only DAYS is supported.
         */
        retentionPeriodUnit: string;
        /**
         * The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
         */
        retentionPeriodValue: number;
    }
}
export declare namespace rds {
    interface ClusterMasterUserSecret {
        /**
         * ARN for the KMS encryption key. When specifying `kmsKeyId`, `storageEncrypted` needs to be set to true.
         */
        kmsKeyId: string;
        /**
         * Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * Status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }
    interface ClusterParameterGroupParameter {
        /**
         * "immediate" (default), or "pending-reboot". Some
         * engines can't apply some parameters without a reboot, and you will need to
         * specify "pending-reboot" here.
         */
        applyMethod?: string;
        /**
         * The name of the DB parameter.
         */
        name: string;
        /**
         * The value of the DB parameter.
         */
        value: string;
    }
    interface ClusterRestoreToPointInTime {
        /**
         * Date and time in UTC format to restore the database cluster to. Conflicts with `useLatestRestorableTime`.
         */
        restoreToTime?: string;
        /**
         * Type of restore to be performed.
         * Valid options are `full-copy` (default) and `copy-on-write`.
         */
        restoreType?: string;
        /**
         * Identifier of the source database cluster from which to restore. When restoring from a cluster in another AWS account, the identifier is the ARN of that cluster.
         */
        sourceClusterIdentifier: string;
        /**
         * Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with `restoreToTime`.
         */
        useLatestRestorableTime?: boolean;
    }
    interface ClusterS3Import {
        bucketName: string;
        bucketPrefix?: string;
        ingestionRole: string;
        sourceEngine: string;
        sourceEngineVersion: string;
    }
    interface ClusterScalingConfiguration {
        /**
         * Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to `true`.
         */
        autoPause?: boolean;
        /**
         * Maximum capacity for an Aurora DB cluster in `serverless` DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `16`.
         */
        maxCapacity?: number;
        /**
         * Minimum capacity for an Aurora DB cluster in `serverless` DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are `1`, `2`, `4`, `8`, `16`, `32`, `64`, `128`, `256`. Valid Aurora PostgreSQL capacity values are (`2`, `4`, `8`, `16`, `32`, `64`, `192`, and `384`). Defaults to `1`.
         */
        minCapacity?: number;
        /**
         * Time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are `300` through `86400`. Defaults to `300`.
         */
        secondsUntilAutoPause?: number;
        /**
         * Action to take when the timeout is reached. Valid values: `ForceApplyCapacityChange`, `RollbackCapacityChange`. Defaults to `RollbackCapacityChange`. See [documentation](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v1.how-it-works.html#aurora-serverless.how-it-works.timeout-action).
         */
        timeoutAction?: string;
    }
    interface ClusterServerlessv2ScalingConfiguration {
        /**
         * Maximum capacity for an Aurora DB cluster in `provisioned` DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid capacity values are in a range of `0.5` up to `128` in steps of `0.5`.
         */
        maxCapacity: number;
        /**
         * Minimum capacity for an Aurora DB cluster in `provisioned` DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid capacity values are in a range of `0.5` up to `128` in steps of `0.5`.
         */
        minCapacity: number;
    }
    interface ExportTaskTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface GetClusterMasterUserSecret {
        kmsKeyId: string;
        secretArn: string;
        secretStatus: string;
    }
    interface GetClustersFilter {
        /**
         * Name of the filter field. Valid values can be found in the [RDS DescribeDBClusters API Reference](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetEngineVersionFilter {
        name: string;
        values: string[];
    }
    interface GetInstanceMasterUserSecret {
        /**
         * The Amazon Web Services KMS key identifier that is used to encrypt the secret.
         */
        kmsKeyId: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * The status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }
    interface GetInstancesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [RDS DescribeDBClusters API Reference](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html) or [RDS DescribeDBInstances API Reference](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetProxyAuth {
        authScheme: string;
        clientPasswordAuthType: string;
        description: string;
        iamAuth: string;
        secretArn: string;
        username: string;
    }
    interface GlobalClusterGlobalClusterMember {
        /**
         * Amazon Resource Name (ARN) of member DB Cluster
         */
        dbClusterArn: string;
        /**
         * Whether the member is the primary DB Cluster
         */
        isWriter: boolean;
    }
    interface InstanceBlueGreenUpdate {
        /**
         * Enables low-downtime updates when `true`.
         * Default is `false`.
         *
         * [instance-replication]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html
         * [instance-maintenance]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html
         * [blue-green]:
         * https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/blue-green-deployments.html
         */
        enabled?: boolean;
    }
    interface InstanceListenerEndpoint {
        /**
         * Specifies the DNS address of the DB instance.
         */
        address: string;
        /**
         * Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
         */
        hostedZoneId: string;
        /**
         * The port on which the DB accepts connections.
         */
        port: number;
    }
    interface InstanceMasterUserSecret {
        /**
         * The ARN for the KMS encryption key. If creating an
         * encrypted replica, set this to the destination KMS ARN.
         */
        kmsKeyId: string;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn: string;
        /**
         * The status of the secret. Valid Values: `creating` | `active` | `rotating` | `impaired`.
         */
        secretStatus: string;
    }
    interface InstanceRestoreToPointInTime {
        /**
         * The date and time to restore from. Value must be a time in Universal Coordinated Time (UTC) format and must be before the latest restorable time for the DB instance. Cannot be specified with `useLatestRestorableTime`.
         */
        restoreTime?: string;
        /**
         * The ARN of the automated backup from which to restore. Required if `sourceDbInstanceIdentifier` or `sourceDbiResourceId` is not specified.
         */
        sourceDbInstanceAutomatedBackupsArn?: string;
        /**
         * The identifier of the source DB instance from which to restore. Must match the identifier of an existing DB instance. Required if `sourceDbInstanceAutomatedBackupsArn` or `sourceDbiResourceId` is not specified.
         */
        sourceDbInstanceIdentifier?: string;
        /**
         * The resource ID of the source DB instance from which to restore. Required if `sourceDbInstanceIdentifier` or `sourceDbInstanceAutomatedBackupsArn` is not specified.
         */
        sourceDbiResourceId?: string;
        /**
         * A boolean value that indicates whether the DB instance is restored from the latest backup time. Defaults to `false`. Cannot be specified with `restoreTime`.
         */
        useLatestRestorableTime?: boolean;
    }
    interface InstanceS3Import {
        bucketName: string;
        bucketPrefix?: string;
        ingestionRole: string;
        sourceEngine: string;
        sourceEngineVersion: string;
    }
    interface OptionGroupOption {
        /**
         * List of DB Security Groups for which the option is enabled.
         */
        dbSecurityGroupMemberships?: string[];
        /**
         * Name of the option (e.g., MEMCACHED).
         */
        optionName: string;
        /**
         * The option settings to apply. See `optionSettings` Block below for more details.
         */
        optionSettings?: outputs.rds.OptionGroupOptionOptionSetting[];
        /**
         * Port number when connecting to the option (e.g., 11211). Leaving out or removing `port` from your configuration does not remove or clear a port from the option in AWS. AWS may assign a default port. Not including `port` in your configuration means that the AWS provider will ignore a previously set value, a value set by AWS, and any port changes.
         */
        port?: number;
        /**
         * Version of the option (e.g., 13.1.0.0). Leaving out or removing `version` from your configuration does not remove or clear a version from the option in AWS. AWS may assign a default version. Not including `version` in your configuration means that the AWS provider will ignore a previously set value, a value set by AWS, and any version changes.
         */
        version?: string;
        /**
         * List of VPC Security Groups for which the option is enabled.
         */
        vpcSecurityGroupMemberships?: string[];
    }
    interface OptionGroupOptionOptionSetting {
        /**
         * Name of the setting.
         */
        name: string;
        /**
         * Value of the setting.
         */
        value: string;
    }
    interface ParameterGroupParameter {
        /**
         * "immediate" (default), or "pending-reboot". Some
         * engines can't apply some parameters without a reboot, and you will need to
         * specify "pending-reboot" here.
         */
        applyMethod: string;
        /**
         * The name of the DB parameter.
         */
        name: string;
        /**
         * The value of the DB parameter.
         */
        value: string;
    }
    /**
     * parameterGroupParameterProvideDefaults sets the appropriate defaults for ParameterGroupParameter
     */
    function parameterGroupParameterProvideDefaults(val: ParameterGroupParameter): ParameterGroupParameter;
    interface ProxyAuth {
        /**
         * The type of authentication that the proxy uses for connections from the proxy to the underlying database. One of `SECRETS`.
         */
        authScheme?: string;
        /**
         * The type of authentication the proxy uses for connections from clients. Valid values are `MYSQL_NATIVE_PASSWORD`, `POSTGRES_SCRAM_SHA_256`, `POSTGRES_MD5`, and `SQL_SERVER_AUTHENTICATION`.
         */
        clientPasswordAuthType: string;
        /**
         * A user-specified description about the authentication used by a proxy to log in as a specific database user.
         */
        description?: string;
        /**
         * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. One of `DISABLED`, `REQUIRED`.
         */
        iamAuth?: string;
        /**
         * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
         */
        secretArn?: string;
        /**
         * The name of the database user to which the proxy connects.
         */
        username?: string;
    }
    interface ProxyDefaultTargetGroupConnectionPoolConfig {
        /**
         * The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
         */
        connectionBorrowTimeout?: number;
        /**
         * One or more SQL statements for the proxy to run when opening each new database connection. Typically used with `SET` statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single `SET` statement, such as `SET x=1, y=2`.
         */
        initQuery?: string;
        /**
         * The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the maxConnections setting for the RDS DB instance or Aurora DB cluster used by the target group.
         */
        maxConnectionsPercent?: number;
        /**
         * Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the maxConnections setting for the RDS DB instance or Aurora DB cluster used by the target group.
         */
        maxIdleConnectionsPercent?: number;
        /**
         * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Currently, the only allowed value is `EXCLUDE_VARIABLE_SETS`.
         */
        sessionPinningFilters?: string[];
    }
    interface ReservedInstanceRecurringCharge {
        recurringChargeAmount: number;
        recurringChargeFrequency: string;
    }
}
export declare namespace redshift {
    interface ClusterClusterNode {
        /**
         * Whether the node is a leader node or a compute node
         */
        nodeRole: string;
        /**
         * The private IP address of a node within a cluster
         */
        privateIpAddress: string;
        /**
         * The public IP address of a node within a cluster
         */
        publicIpAddress: string;
    }
    interface ClusterLogging {
        /**
         * The name of an existing S3 bucket where the log files are to be stored. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions.
         * For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
         */
        bucketName: string;
        /**
         * Enables logging information such as queries and connection attempts, for the specified Amazon Redshift cluster.
         */
        enable: boolean;
        /**
         * The log destination type. An enum with possible values of `s3` and `cloudwatch`.
         */
        logDestinationType?: string;
        /**
         * The collection of exported log types. Log types include the connection log, user log and user activity log. Required when `logDestinationType` is `cloudwatch`. Valid log types are `connectionlog`, `userlog`, and `useractivitylog`.
         */
        logExports?: string[];
        /**
         * The prefix applied to the log file names.
         */
        s3KeyPrefix: string;
    }
    interface ClusterSnapshotCopy {
        /**
         * The destination region that you want to copy snapshots to.
         */
        destinationRegion: string;
        /**
         * The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
         */
        grantName?: string;
        /**
         * The number of days to retain automated snapshots in the destination region after they are copied from the source region. Defaults to `7`.
         */
        retentionPeriod?: number;
    }
    interface EndpointAccessVpcEndpoint {
        /**
         * One or more network interfaces of the endpoint. Also known as an interface endpoint. See details below.
         */
        networkInterfaces: outputs.redshift.EndpointAccessVpcEndpointNetworkInterface[];
        /**
         * The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.
         */
        vpcEndpointId: string;
        /**
         * The VPC identifier that the endpoint is associated.
         */
        vpcId: string;
    }
    interface EndpointAccessVpcEndpointNetworkInterface {
        /**
         * The Availability Zone.
         */
        availabilityZone: string;
        /**
         * The network interface identifier.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The subnet identifier.
         */
        subnetId: string;
    }
    interface GetClusterClusterNode {
        /**
         * Whether the node is a leader node or a compute node
         */
        nodeRole: string;
        /**
         * Private IP address of a node within a cluster
         */
        privateIpAddress: string;
        /**
         * Public IP address of a node within a cluster
         */
        publicIpAddress: string;
    }
    interface GetDataSharesDataShare {
        /**
         * ARN (Amazon Resource Name) of the data share.
         */
        dataShareArn: string;
        /**
         * Identifier of a datashare to show its managing entity.
         */
        managedBy: string;
        /**
         * ARN (Amazon Resource Name) of the producer.
         */
        producerArn: string;
    }
    interface GetProducerDataSharesDataShare {
        /**
         * ARN (Amazon Resource Name) of the data share.
         */
        dataShareArn: string;
        /**
         * Identifier of a datashare to show its managing entity.
         */
        managedBy: string;
        /**
         * Amazon Resource Name (ARN) of the producer namespace that returns in the list of datashares.
         *
         * The following arguments are optional:
         */
        producerArn: string;
    }
    interface ParameterGroupParameter {
        /**
         * The name of the Redshift parameter.
         */
        name: string;
        /**
         * The value of the Redshift parameter.
         */
        value: string;
    }
    interface ScheduledActionTargetAction {
        /**
         * An action that runs a `PauseCluster` API operation. Documented below.
         */
        pauseCluster?: outputs.redshift.ScheduledActionTargetActionPauseCluster;
        /**
         * An action that runs a `ResizeCluster` API operation. Documented below.
         */
        resizeCluster?: outputs.redshift.ScheduledActionTargetActionResizeCluster;
        /**
         * An action that runs a `ResumeCluster` API operation. Documented below.
         */
        resumeCluster?: outputs.redshift.ScheduledActionTargetActionResumeCluster;
    }
    interface ScheduledActionTargetActionPauseCluster {
        /**
         * The identifier of the cluster to be paused.
         */
        clusterIdentifier: string;
    }
    interface ScheduledActionTargetActionResizeCluster {
        /**
         * A boolean value indicating whether the resize operation is using the classic resize process. Default: `false`.
         */
        classic?: boolean;
        /**
         * The unique identifier for the cluster to resize.
         */
        clusterIdentifier: string;
        /**
         * The new cluster type for the specified cluster.
         */
        clusterType?: string;
        /**
         * The new node type for the nodes you are adding.
         */
        nodeType?: string;
        /**
         * The new number of nodes for the cluster.
         */
        numberOfNodes?: number;
    }
    interface ScheduledActionTargetActionResumeCluster {
        /**
         * The identifier of the cluster to be resumed.
         */
        clusterIdentifier: string;
    }
}
export declare namespace redshiftdata {
    interface StatementParameter {
        name: string;
        value: string;
    }
}
export declare namespace redshiftserverless {
    interface EndpointAccessVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.EndpointAccessVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }
    interface EndpointAccessVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }
    interface GetWorkgroupEndpoint {
        /**
         * The DNS address of the VPC endpoint.
         */
        address: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        port: number;
        /**
         * The VPC endpoint or the Redshift Serverless workgroup. See `VPC Endpoint` below.
         */
        vpcEndpoints: outputs.redshiftserverless.GetWorkgroupEndpointVpcEndpoint[];
    }
    interface GetWorkgroupEndpointVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.GetWorkgroupEndpointVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }
    interface GetWorkgroupEndpointVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }
    interface WorkgroupConfigParameter {
        /**
         * The key of the parameter. The options are `autoMv`, `datestyle`, `enableCaseSensitiveIdentifier`, `enableUserActivityLogging`, `queryGroup`, `searchPath`, `requireSsl`, `useFipsSsl`, and [query monitoring metrics](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless) that let you define performance boundaries: `maxQueryCpuTime`, `maxQueryBlocksRead`, `maxScanRowCount`, `maxQueryExecutionTime`, `maxQueryQueueTime`, `maxQueryCpuUsagePercent`, `maxQueryTempBlocksToDisk`, `maxJoinRowCount` and `maxNestedLoopJoinRowCount`.
         */
        parameterKey: string;
        /**
         * The value of the parameter to set.
         */
        parameterValue: string;
    }
    interface WorkgroupEndpoint {
        /**
         * The DNS address of the VPC endpoint.
         */
        address: string;
        /**
         * The port number on which the cluster accepts incoming connections.
         */
        port: number;
        /**
         * The VPC endpoint or the Redshift Serverless workgroup. See `VPC Endpoint` below.
         */
        vpcEndpoints: outputs.redshiftserverless.WorkgroupEndpointVpcEndpoint[];
    }
    interface WorkgroupEndpointVpcEndpoint {
        /**
         * The network interfaces of the endpoint.. See `Network Interface` below.
         */
        networkInterfaces: outputs.redshiftserverless.WorkgroupEndpointVpcEndpointNetworkInterface[];
        /**
         * The DNS address of the VPC endpoint.
         */
        vpcEndpointId: string;
        /**
         * The port that Amazon Redshift Serverless listens on.
         */
        vpcId: string;
    }
    interface WorkgroupEndpointVpcEndpointNetworkInterface {
        /**
         * The availability Zone.
         */
        availabilityZone: string;
        /**
         * The unique identifier of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The IPv4 address of the network interface within the subnet.
         */
        privateIpAddress: string;
        /**
         * The unique identifier of the subnet.
         */
        subnetId: string;
    }
}
export declare namespace rekognition {
    interface CollectionTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
    }
    interface ProjectTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
}
export declare namespace resourceexplorer {
    interface IndexTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface SearchResource {
        /**
         * Amazon resource name of resource.
         */
        arn: string;
        /**
         * The date and time that the information about this resource property was last updated.
         */
        lastReportedAt: string;
        /**
         * Amazon Web Services account that owns the resource.
         */
        owningAccountId: string;
        /**
         * Structure with additional type-specific details about the resource.  See `properties` below.
         */
        properties: any[];
        /**
         * Amazon Web Services Region in which the resource was created and exists.
         */
        region: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * Amazon Web Service that owns the resource and is responsible for creating and updating it.
         */
        service: string;
    }
    interface SearchResourceCount {
        /**
         * Indicates whether the TotalResources value represents an exhaustive count of search results. If True, it indicates that the search was exhaustive. Every resource that matches the query was counted. If False, then the search reached the limit of 1,000 matching results, and stopped counting.
         */
        complete: boolean;
        /**
         * Number of resources that match the search query. This value can't exceed 1,000. If there are more than 1,000 resources that match the query, then only 1,000 are counted and the Complete field is set to false. We recommend that you refine your query to return a smaller number of results.
         */
        totalResources: number;
    }
    interface ViewFilters {
        /**
         * The string that contains the search keywords, prefixes, and operators to control the results that can be returned by a search operation. For more details, see [Search query syntax](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html).
         */
        filterString: string;
    }
    interface ViewIncludedProperty {
        /**
         * The name of the property that is included in this view. Valid values: `tags`.
         */
        name: string;
    }
}
export declare namespace resourcegroups {
    interface GroupConfiguration {
        /**
         * A collection of parameters for this group configuration item. See below for details.
         */
        parameters?: outputs.resourcegroups.GroupConfigurationParameter[];
        /**
         * Specifies the type of group configuration item.
         */
        type: string;
    }
    interface GroupConfigurationParameter {
        /**
         * The name of the group configuration parameter.
         */
        name: string;
        /**
         * The value or values to be used for the specified parameter.
         */
        values: string[];
    }
    interface GroupResourceQuery {
        /**
         * The resource query as a JSON string.
         */
        query: string;
        /**
         * The type of the resource query. Defaults to `TAG_FILTERS_1_0`.
         */
        type?: string;
    }
}
export declare namespace resourcegroupstaggingapi {
    interface GetResourcesResourceTagMappingList {
        /**
         * List of objects with information that shows whether a resource is compliant with the effective tag policy, including details on any noncompliant tag keys.
         */
        complianceDetails: outputs.resourcegroupstaggingapi.GetResourcesResourceTagMappingListComplianceDetail[];
        /**
         * ARN of the resource.
         */
        resourceArn: string;
        /**
         * Map of tags assigned to the resource.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetResourcesResourceTagMappingListComplianceDetail {
        /**
         * Whether the resource is compliant.
         * * `keysWithNoncompliantValues ` - Set of tag keys with non-compliant tag values.
         * * `nonCompliantKeys ` - Set of non-compliant tag keys.
         */
        complianceStatus: boolean;
        keysWithNoncompliantValues: string[];
        nonCompliantKeys: string[];
    }
    interface GetResourcesTagFilter {
        /**
         * One part of a key-value pair that makes up a tag.
         */
        key: string;
        /**
         * Optional part of a key-value pair that make up a tag.
         */
        values?: string[];
    }
}
export declare namespace rolesanywhere {
    interface TrustAnchorSource {
        /**
         * The data denoting the source of trust, documented below
         */
        sourceData: outputs.rolesanywhere.TrustAnchorSourceSourceData;
        /**
         * The type of the source of trust. Must be either `AWS_ACM_PCA` or `CERTIFICATE_BUNDLE`.
         */
        sourceType: string;
    }
    interface TrustAnchorSourceSourceData {
        /**
         * The ARN of an ACM Private Certificate Authority.
         */
        acmPcaArn?: string;
        x509CertificateData?: string;
    }
}
export declare namespace route53 {
    interface GetQueryLogConfigFilter {
        /**
         * The name of the query logging configuration.
         */
        name: string;
        values: string[];
    }
    interface GetResolverEndpointFilter {
        name: string;
        values: string[];
    }
    interface GetResolverFirewallRulesFirewallRule {
        /**
         * The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list.
         */
        action: string;
        /**
         * The DNS record's type.
         */
        blockOverrideDnsType: string;
        /**
         * The custom DNS record to send back in response to the query.
         */
        blockOverrideDomain: string;
        /**
         * The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record.
         */
        blockOverrideTtl: number;
        /**
         * The way that you want DNS Firewall to block the request.
         */
        blockResponse: string;
        /**
         * The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
         */
        creationTime: string;
        /**
         * A unique string defined by you to identify the request.
         */
        creatorRequestId: string;
        /**
         * The ID of the domain list that's used in the rule.
         */
        firewallDomainListId: string;
        /**
         * The unique identifier of the firewall rule group that you want to retrieve the rules for.
         */
        firewallRuleGroupId: string;
        /**
         * The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
         */
        modificationTime: string;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The setting that determines the processing order of the rules in a rule group.
         */
        priority: number;
    }
    interface GetTrafficPolicyDocumentEndpoint {
        /**
         * ID of an endpoint you want to assign.
         */
        id: string;
        /**
         * To route traffic to an Amazon S3 bucket that is configured as a website endpoint, specify the region in which you created the bucket for `region`.
         */
        region?: string;
        /**
         * Type of the endpoint. Valid values are `value` , `cloudfront` , `elastic-load-balancer`, `s3-website`
         */
        type?: string;
        /**
         * Value of the `type`.
         */
        value?: string;
    }
    interface GetTrafficPolicyDocumentRule {
        /**
         * Configuration block for when you add a geoproximity rule, you configure Amazon Route 53 to route traffic to your resources based on the geographic location of your resources. Only valid for `geoproximity` type. See below
         */
        geoProximityLocations?: outputs.route53.GetTrafficPolicyDocumentRuleGeoProximityLocation[];
        /**
         * ID of a rule you want to assign.
         */
        id: string;
        /**
         * Configuration block for when you add a multivalue answer rule, you configure your traffic policy to route traffic approximately randomly to your healthy resources.  Only valid for `multivalue` type. See below
         */
        items?: outputs.route53.GetTrafficPolicyDocumentRuleItem[];
        /**
         * Configuration block for when you add a geolocation rule, you configure your traffic policy to route your traffic based on the geographic location of your users.  Only valid for `geo` type. See below
         */
        locations?: outputs.route53.GetTrafficPolicyDocumentRuleLocation[];
        /**
         * Configuration block for the settings for the rule or endpoint that you want to route traffic to whenever the corresponding resources are available. Only valid for `failover` type. See below
         */
        primary?: outputs.route53.GetTrafficPolicyDocumentRulePrimary;
        regions?: outputs.route53.GetTrafficPolicyDocumentRuleRegion[];
        /**
         * Configuration block for the rule or endpoint that you want to route traffic to whenever the primary resources are not available. Only valid for `failover` type. See below
         */
        secondary?: outputs.route53.GetTrafficPolicyDocumentRuleSecondary;
        /**
         * Type of the rule.
         */
        type?: string;
    }
    interface GetTrafficPolicyDocumentRuleGeoProximityLocation {
        /**
         * Specify a value for `bias` if you want to route more traffic to an endpoint from nearby endpoints (positive values) or route less traffic to an endpoint (negative values).
         */
        bias?: string;
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Represents the location south (negative) or north (positive) of the equator. Valid values are -90 degrees to 90 degrees.
         */
        latitude?: string;
        /**
         * Represents the location west (negative) or east (positive) of the prime meridian. Valid values are -180 degrees to 180 degrees.
         */
        longitude?: string;
        /**
         * If your endpoint is an AWS resource, specify the AWS Region that you created the resource in.
         */
        region?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }
    interface GetTrafficPolicyDocumentRuleItem {
        endpointReference?: string;
        healthCheck?: string;
    }
    interface GetTrafficPolicyDocumentRuleLocation {
        /**
         * Value of a continent.
         */
        continent?: string;
        /**
         * Value of a country.
         */
        country?: string;
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Indicates whether this set of values represents the default location.
         */
        isDefault?: boolean;
        /**
         * References to a rule.
         */
        ruleReference?: string;
        /**
         * Value of a subdivision.
         */
        subdivision?: string;
    }
    interface GetTrafficPolicyDocumentRulePrimary {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }
    interface GetTrafficPolicyDocumentRuleRegion {
        /**
         * References to an endpoint.
         */
        endpointReference?: string;
        /**
         * Indicates whether you want Amazon Route 53 to evaluate the health of the endpoint and route traffic only to healthy endpoints.
         */
        evaluateTargetHealth?: boolean;
        /**
         * If you want to associate a health check with the endpoint or rule.
         */
        healthCheck?: string;
        /**
         * Region code for the AWS Region that you created the resource in.
         */
        region?: string;
        /**
         * References to a rule.
         */
        ruleReference?: string;
    }
    interface GetTrafficPolicyDocumentRuleSecondary {
        endpointReference?: string;
        evaluateTargetHealth?: boolean;
        healthCheck?: string;
        ruleReference?: string;
    }
    interface RecordAlias {
        /**
         * Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).
         */
        evaluateTargetHealth: boolean;
        /**
         * DNS domain name for a CloudFront distribution, S3 bucket, ELB, or another resource record set in this hosted zone.
         */
        name: string;
        /**
         * Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, or Route 53 hosted zone. See `resource_elb.zone_id` for example.
         */
        zoneId: string;
    }
    interface RecordCidrRoutingPolicy {
        /**
         * The CIDR collection ID. See the `aws.route53.CidrCollection` resource for more details.
         */
        collectionId: string;
        /**
         * The CIDR collection location name. See the `aws.route53.CidrLocation` resource for more details. A `locationName` with an asterisk `"*"` can be used to create a default CIDR record. `collectionId` is still required for default record.
         */
        locationName: string;
    }
    interface RecordFailoverRoutingPolicy {
        /**
         * `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets
         */
        type: string;
    }
    interface RecordGeolocationRoutingPolicy {
        /**
         * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
         */
        continent?: string;
        /**
         * A two-character country code or `*` to indicate a default resource record set.
         */
        country?: string;
        /**
         * A subdivision code for a country.
         */
        subdivision?: string;
    }
    interface RecordGeoproximityRoutingPolicy {
        awsRegion?: string;
        bias?: number;
        coordinates?: outputs.route53.RecordGeoproximityRoutingPolicyCoordinate[];
        localZoneGroup?: string;
    }
    interface RecordGeoproximityRoutingPolicyCoordinate {
        latitude: string;
        longitude: string;
    }
    interface RecordLatencyRoutingPolicy {
        /**
         * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
         */
        region: string;
    }
    interface RecordWeightedRoutingPolicy {
        /**
         * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
         */
        weight: number;
    }
    interface ResolverEndpointIpAddress {
        /**
         * The IP address in the subnet that you want to use for DNS queries.
         */
        ip: string;
        ipId: string;
        /**
         * The ID of the subnet that contains the IP address.
         */
        subnetId: string;
    }
    interface ResolverRuleTargetIp {
        /**
         * One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.
         */
        ip: string;
        /**
         * The port at `ip` that you want to forward DNS queries to. Default value is `53`.
         */
        port?: number;
        /**
         * The protocol for the resolver endpoint. Valid values can be found in the [AWS documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_TargetAddress.html). Default value is `Do53`.
         */
        protocol?: string;
    }
    interface ZoneVpc {
        /**
         * ID of the VPC to associate.
         */
        vpcId: string;
        /**
         * Region of the VPC to associate. Defaults to AWS provider region.
         */
        vpcRegion: string;
    }
}
export declare namespace route53domains {
    interface DelegationSignerRecordSigningAttributes {
        /**
         * Algorithm which was used to generate the digest from the public key.
         */
        algorithm: number;
        /**
         * Defines the type of key. It can be either a KSK (key-signing-key, value `257`) or ZSK (zone-signing-key, value `256`).
         */
        flags: number;
        /**
         * The base64-encoded public key part of the key pair that is passed to the registry.
         */
        publicKey: string;
    }
    interface DelegationSignerRecordTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface RegisteredDomainAdminContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {
            [key: string]: string;
        };
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }
    interface RegisteredDomainBillingContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {
            [key: string]: string;
        };
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }
    interface RegisteredDomainNameServer {
        /**
         * Glue IP addresses of a name server. The list can contain only one IPv4 and one IPv6 address.
         */
        glueIps?: string[];
        /**
         * The fully qualified host name of the name server.
         */
        name: string;
    }
    interface RegisteredDomainRegistrantContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {
            [key: string]: string;
        };
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }
    interface RegisteredDomainTechContact {
        /**
         * First line of the contact's address.
         */
        addressLine1: string;
        /**
         * Second line of contact's address, if any.
         */
        addressLine2: string;
        /**
         * The city of the contact's address.
         */
        city: string;
        /**
         * Indicates whether the contact is a person, company, association, or public organization. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-ContactType) for valid values.
         */
        contactType: string;
        /**
         * Code for the country of the contact's address. See the [AWS API documentation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html#Route53Domains-Type-domains_ContactDetail-CountryCode) for valid values.
         */
        countryCode: string;
        /**
         * Email address of the contact.
         */
        email: string;
        /**
         * A key-value map of parameters required by certain top-level domains.
         */
        extraParams: {
            [key: string]: string;
        };
        /**
         * Fax number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        fax: string;
        /**
         * First name of contact.
         */
        firstName: string;
        /**
         * Last name of contact.
         */
        lastName: string;
        /**
         * Name of the organization for contact types other than `PERSON`.
         */
        organizationName: string;
        /**
         * The phone number of the contact. Phone number must be specified in the format "+[country dialing code].[number including any area code]".
         */
        phoneNumber: string;
        /**
         * The state or province of the contact's city.
         */
        state: string;
        /**
         * The zip or postal code of the contact's address.
         */
        zipCode: string;
    }
}
export declare namespace route53recoverycontrol {
    interface ClusterClusterEndpoint {
        /**
         * Cluster endpoint.
         */
        endpoint: string;
        /**
         * Region of the endpoint.
         */
        region: string;
    }
    interface SafetyRuleRuleConfig {
        /**
         * Logical negation of the rule.
         */
        inverted: boolean;
        /**
         * Number of controls that must be set when you specify an `ATLEAST` type rule.
         */
        threshold: number;
        /**
         * Rule type. Valid values are `ATLEAST`, `AND`, and `OR`.
         */
        type: string;
    }
}
export declare namespace route53recoveryreadiness {
    interface ResourceSetResource {
        componentId: string;
        /**
         * Component for DNS/Routing Control Readiness Checks.
         */
        dnsTargetResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResource;
        /**
         * Recovery group ARN or cell ARN that contains this resource set.
         */
        readinessScopes?: string[];
        /**
         * ARN of the resource.
         */
        resourceArn?: string;
    }
    interface ResourceSetResourceDnsTargetResource {
        /**
         * DNS Name that acts as the ingress point to a portion of application.
         */
        domainName: string;
        /**
         * Hosted Zone ARN that contains the DNS record with the provided name of target resource.
         */
        hostedZoneArn?: string;
        /**
         * Route53 record set id to uniquely identify a record given a `domainName` and a `recordType`.
         */
        recordSetId?: string;
        /**
         * Type of DNS Record of target resource.
         */
        recordType?: string;
        /**
         * Target resource the R53 record specified with the above params points to.
         */
        targetResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResource;
    }
    interface ResourceSetResourceDnsTargetResourceTargetResource {
        /**
         * NLB resource a DNS Target Resource points to. Required if `r53Resource` is not set.
         */
        nlbResource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResourceNlbResource;
        /**
         * Route53 resource a DNS Target Resource record points to.
         */
        r53Resource?: outputs.route53recoveryreadiness.ResourceSetResourceDnsTargetResourceTargetResourceR53Resource;
    }
    interface ResourceSetResourceDnsTargetResourceTargetResourceNlbResource {
        /**
         * NLB resource ARN.
         */
        arn?: string;
    }
    interface ResourceSetResourceDnsTargetResourceTargetResourceR53Resource {
        /**
         * Domain name that is targeted.
         */
        domainName?: string;
        /**
         * Resource record set ID that is targeted.
         */
        recordSetId?: string;
    }
}
export declare namespace rum {
    interface AppMonitorAppMonitorConfiguration {
        /**
         * If you set this to `true`, RUM web client sets two cookies, a session cookie  and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
         */
        allowCookies?: boolean;
        /**
         * If you set this to `true`, RUM enables X-Ray tracing for the user sessions  that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests.
         */
        enableXray?: boolean;
        /**
         * A list of URLs in your website or application to exclude from RUM data collection.
         */
        excludedPages?: string[];
        /**
         * A list of pages in the CloudWatch RUM console that are to be displayed with a "favorite" icon.
         */
        favoritePages?: string[];
        /**
         * The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
         */
        guestRoleArn?: string;
        /**
         * The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
         */
        identityPoolId?: string;
        /**
         * If this app monitor is to collect data from only certain pages in your application, this structure lists those pages.
         */
        includedPages?: string[];
        /**
         * Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. Default value is `0.1`.
         */
        sessionSampleRate?: number;
        /**
         * An array that lists the types of telemetry data that this app monitor is to collect. Valid values are `errors`, `performance`, and `http`.
         */
        telemetries?: string[];
    }
    interface AppMonitorCustomEvents {
        /**
         * Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be `DISABLED`. Valid values are `DISABLED` and `ENABLED`.
         */
        status?: string;
    }
}
export declare namespace s3 {
    interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing policies or ACLs. When set to `true` causes the following behavior:
         * * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         * * PUT Object calls fail if the request includes a public ACL.
         * * PUT Bucket calls fail if the request includes a public ACL.
         */
        blockPublicAcls?: boolean;
        /**
         * Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing bucket policies. When set to `true` causes Amazon S3 to:
         * * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         */
        blockPublicPolicy?: boolean;
        /**
         * Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to `true` causes Amazon S3 to:
         * * Ignore all public ACLs on buckets in this account and any objects that they contain.
         */
        ignorePublicAcls?: boolean;
        /**
         * Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to `true`:
         * * Only the bucket owner and AWS Services can access buckets with public policies.
         */
        restrictPublicBuckets?: boolean;
    }
    interface AccessPointVpcConfiguration {
        /**
         * This access point will only allow connections from the specified VPC ID.
         */
        vpcId: string;
    }
    interface AnalyticsConfigurationFilter {
        /**
         * Object prefix for filtering.
         */
        prefix?: string;
        /**
         * Set of object tags for filtering.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface AnalyticsConfigurationStorageClassAnalysis {
        /**
         * Data export configuration (documented below).
         */
        dataExport: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExport;
    }
    interface AnalyticsConfigurationStorageClassAnalysisDataExport {
        /**
         * Specifies the destination for the exported analytics data (documented below).
         */
        destination: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExportDestination;
        /**
         * Schema version of exported analytics data. Allowed values: `V_1`. Default value: `V_1`.
         */
        outputSchemaVersion?: string;
    }
    interface AnalyticsConfigurationStorageClassAnalysisDataExportDestination {
        /**
         * Analytics data export currently only supports an S3 bucket destination (documented below).
         */
        s3BucketDestination: outputs.s3.AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestination;
    }
    interface AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestination {
        /**
         * Account ID that owns the destination bucket.
         */
        bucketAccountId?: string;
        /**
         * ARN of the destination bucket.
         */
        bucketArn: string;
        /**
         * Output format of exported analytics data. Allowed values: `CSV`. Default value: `CSV`.
         */
        format?: string;
        /**
         * Prefix to append to exported analytics data.
         */
        prefix?: string;
    }
    interface BucketAclV2AccessControlPolicy {
        /**
         * Set of `grant` configuration blocks. See below.
         */
        grants?: outputs.s3.BucketAclV2AccessControlPolicyGrant[];
        /**
         * Configuration block for the bucket owner's display name and ID. See below.
         */
        owner: outputs.s3.BucketAclV2AccessControlPolicyOwner;
    }
    interface BucketAclV2AccessControlPolicyGrant {
        /**
         * Configuration block for the person being granted permissions. See below.
         */
        grantee?: outputs.s3.BucketAclV2AccessControlPolicyGrantGrantee;
        /**
         * Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
         */
        permission: string;
    }
    interface BucketAclV2AccessControlPolicyGrantGrantee {
        displayName: string;
        /**
         * Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
         */
        emailAddress?: string;
        /**
         * Canonical user ID of the grantee.
         */
        id?: string;
        /**
         * Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
         */
        type: string;
        /**
         * URI of the grantee group.
         */
        uri?: string;
    }
    interface BucketAclV2AccessControlPolicyOwner {
        /**
         * Display name of the owner.
         */
        displayName: string;
        /**
         * ID of the owner.
         */
        id: string;
    }
    interface BucketCorsConfigurationV2CorsRule {
        /**
         * Set of Headers that are specified in the `Access-Control-Request-Headers` header.
         */
        allowedHeaders?: string[];
        /**
         * Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
         */
        allowedMethods: string[];
        /**
         * Set of origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
         */
        exposeHeaders?: string[];
        /**
         * Unique identifier for the rule. The value cannot be longer than 255 characters.
         */
        id?: string;
        /**
         * Time in seconds that your browser is to cache the preflight response for the specified resource.
         */
        maxAgeSeconds?: number;
    }
    interface BucketCorsRule {
        allowedHeaders?: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }
    interface BucketGrant {
        /**
         * Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
         */
        type: string;
        /**
         * Uri address to grant for. Used only when `type` is `Group`.
         */
        uri?: string;
    }
    interface BucketIntelligentTieringConfigurationFilter {
        /**
         * Object key name prefix that identifies the subset of objects to which the configuration applies.
         */
        prefix?: string;
        /**
         * All of these tags must exist in the object's tag set in order for the configuration to apply.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketIntelligentTieringConfigurationTiering {
        /**
         * S3 Intelligent-Tiering access tier. Valid values: `ARCHIVE_ACCESS`, `DEEP_ARCHIVE_ACCESS`.
         */
        accessTier: string;
        /**
         * Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
         */
        days: number;
    }
    interface BucketLifecycleConfigurationV2Rule {
        /**
         * Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
         */
        abortIncompleteMultipartUpload?: outputs.s3.BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUpload;
        /**
         * Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
         */
        expiration?: outputs.s3.BucketLifecycleConfigurationV2RuleExpiration;
        /**
         * Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the `rule` will default to using `prefix`.
         */
        filter?: outputs.s3.BucketLifecycleConfigurationV2RuleFilter;
        /**
         * Unique identifier for the rule. The value cannot be longer than 255 characters.
         */
        id: string;
        /**
         * Configuration block that specifies when noncurrent object versions expire. See below.
         */
        noncurrentVersionExpiration?: outputs.s3.BucketLifecycleConfigurationV2RuleNoncurrentVersionExpiration;
        /**
         * Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketLifecycleConfigurationV2RuleNoncurrentVersionTransition[];
        /**
         * **DEPRECATED** Use `filter` instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if `filter` is not specified.
         *
         * @deprecated Use filter instead
         */
        prefix?: string;
        /**
         * Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
         */
        status: string;
        /**
         * Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
         */
        transitions?: outputs.s3.BucketLifecycleConfigurationV2RuleTransition[];
    }
    interface BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUpload {
        /**
         * Number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation?: number;
    }
    interface BucketLifecycleConfigurationV2RuleExpiration {
        /**
         * Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
         */
        date?: string;
        /**
         * Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
         */
        days?: number;
        /**
         * Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
         */
        expiredObjectDeleteMarker: boolean;
    }
    interface BucketLifecycleConfigurationV2RuleFilter {
        /**
         * Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
         */
        and?: outputs.s3.BucketLifecycleConfigurationV2RuleFilterAnd;
        /**
         * Minimum object size (in bytes) to which the rule applies.
         */
        objectSizeGreaterThan?: string;
        /**
         * Maximum object size (in bytes) to which the rule applies.
         */
        objectSizeLessThan?: string;
        /**
         * Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
         */
        prefix?: string;
        /**
         * Configuration block for specifying a tag key and value. See below.
         */
        tag?: outputs.s3.BucketLifecycleConfigurationV2RuleFilterTag;
    }
    interface BucketLifecycleConfigurationV2RuleFilterAnd {
        /**
         * Minimum object size to which the rule applies. Value must be at least `0` if specified.
         */
        objectSizeGreaterThan?: number;
        /**
         * Maximum object size to which the rule applies. Value must be at least `1` if specified.
         */
        objectSizeLessThan?: number;
        /**
         * Prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketLifecycleConfigurationV2RuleFilterTag {
        /**
         * Name of the object key.
         */
        key: string;
        /**
         * Value of the tag.
         */
        value: string;
    }
    interface BucketLifecycleConfigurationV2RuleNoncurrentVersionExpiration {
        /**
         * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
         */
        newerNoncurrentVersions?: string;
        /**
         * Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
         */
        noncurrentDays?: number;
    }
    interface BucketLifecycleConfigurationV2RuleNoncurrentVersionTransition {
        /**
         * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
         */
        newerNoncurrentVersions?: string;
        /**
         * Number of days an object is noncurrent before Amazon S3 can perform the associated action.
         */
        noncurrentDays?: number;
        /**
         * Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
         */
        storageClass: string;
    }
    interface BucketLifecycleConfigurationV2RuleTransition {
        /**
         * Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
         */
        date?: string;
        /**
         * Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storageClass`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
         */
        days?: number;
        /**
         * Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
         */
        storageClass: string;
    }
    interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
         */
        abortIncompleteMultipartUploadDays?: number;
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expiration?: outputs.s3.BucketLifecycleRuleExpiration;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire (documented below).
         */
        noncurrentVersionExpiration?: outputs.s3.BucketLifecycleRuleNoncurrentVersionExpiration;
        /**
         * Specifies when noncurrent object versions transitions (documented below).
         *
         * At least one of `abortIncompleteMultipartUploadDays`, `expiration`, `transition`, `noncurrentVersionExpiration`, `noncurrentVersionTransition` must be specified.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies object tags key and value.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * Specifies a period in the object's transitions (documented below).
         */
        transitions?: outputs.s3.BucketLifecycleRuleTransition[];
    }
    interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }
    interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions expire.
         */
        days?: number;
    }
    interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }
    interface BucketLifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }
    interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }
    interface BucketLoggingV2TargetGrant {
        /**
         * Configuration block for the person being granted permissions. See below.
         */
        grantee: outputs.s3.BucketLoggingV2TargetGrantGrantee;
        /**
         * Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
         */
        permission: string;
    }
    interface BucketLoggingV2TargetGrantGrantee {
        displayName: string;
        /**
         * Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
         */
        emailAddress?: string;
        /**
         * Canonical user ID of the grantee.
         */
        id?: string;
        /**
         * Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
         */
        type: string;
        /**
         * URI of the grantee group.
         */
        uri?: string;
    }
    interface BucketLoggingV2TargetObjectKeyFormat {
        /**
         * Partitioned S3 key for log objects. See below.
         */
        partitionedPrefix?: outputs.s3.BucketLoggingV2TargetObjectKeyFormatPartitionedPrefix;
        /**
         * Use the simple format for S3 keys for log objects. To use, set `simplePrefix {}`.
         */
        simplePrefix?: outputs.s3.BucketLoggingV2TargetObjectKeyFormatSimplePrefix;
    }
    interface BucketLoggingV2TargetObjectKeyFormatPartitionedPrefix {
        /**
         * Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
         */
        partitionDateSource: string;
    }
    interface BucketLoggingV2TargetObjectKeyFormatSimplePrefix {
    }
    interface BucketMetricFilter {
        /**
         * S3 Access Point ARN for filtering (singular).
         */
        accessPoint?: string;
        /**
         * Object prefix for filtering (singular).
         */
        prefix?: string;
        /**
         * Object tags for filtering (up to 10).
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketNotificationLambdaFunction {
        /**
         * [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * Lambda function ARN.
         */
        lambdaFunctionArn?: string;
    }
    interface BucketNotificationQueue {
        /**
         * Specifies [event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * SQS queue ARN.
         */
        queueArn: string;
    }
    interface BucketNotificationTopic {
        /**
         * [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
         */
        events: string[];
        /**
         * Object key name prefix.
         */
        filterPrefix?: string;
        /**
         * Object key name suffix.
         */
        filterSuffix?: string;
        /**
         * Unique identifier for each of the notification configurations.
         */
        id: string;
        /**
         * SNS topic ARN.
         */
        topicArn: string;
    }
    interface BucketObjectLockConfiguration {
        /**
         * Indicates whether this bucket has an Object Lock configuration enabled. Valid value is `Enabled`.
         */
        objectLockEnabled: string;
        /**
         * The Object Lock rule in place for this bucket.
         */
        rule?: outputs.s3.BucketObjectLockConfigurationRule;
    }
    interface BucketObjectLockConfigurationRule {
        /**
         * The default retention period that you want to apply to new objects placed in this bucket.
         */
        defaultRetention: outputs.s3.BucketObjectLockConfigurationRuleDefaultRetention;
    }
    interface BucketObjectLockConfigurationRuleDefaultRetention {
        /**
         * The number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * The default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
         */
        mode: string;
        /**
         * The number of years that you want to specify for the default retention period.
         *
         * Either `days` or `years` must be specified, but not both.
         *
         * > **NOTE on `objectLockConfiguration`:** You can only enable S3 Object Lock for new buckets. If you need to turn on S3 Object Lock for an existing bucket, please contact AWS Support.
         * When you create a bucket with S3 Object Lock enabled, Amazon S3 automatically enables versioning for the bucket.
         * Once you create a bucket with S3 Object Lock enabled, you can't disable Object Lock or suspend versioning for the bucket.
         */
        years?: number;
    }
    interface BucketObjectLockConfigurationV2Rule {
        /**
         * Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
         */
        defaultRetention: outputs.s3.BucketObjectLockConfigurationV2RuleDefaultRetention;
    }
    interface BucketObjectLockConfigurationV2RuleDefaultRetention {
        /**
         * Number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
         */
        mode?: string;
        /**
         * Number of years that you want to specify for the default retention period.
         */
        years?: number;
    }
    interface BucketObjectv2OverrideProvider {
        /**
         * Override the provider `defaultTags` configuration block.
         */
        defaultTags?: outputs.s3.BucketObjectv2OverrideProviderDefaultTags;
    }
    interface BucketObjectv2OverrideProviderDefaultTags {
        /**
         * Map of tags to assign to the object. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketOwnershipControlsRule {
        /**
         * Object ownership. Valid values: `BucketOwnerPreferred`, `ObjectWriter` or `BucketOwnerEnforced`
         * * `BucketOwnerPreferred` - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the `bucket-owner-full-control` canned ACL.
         * * `ObjectWriter` - Uploading account will own the object if the object is uploaded with the `bucket-owner-full-control` canned ACL.
         * * `BucketOwnerEnforced` - Bucket owner automatically owns and has full control over every object in the bucket. ACLs no longer affect permissions to data in the S3 bucket.
         */
        objectOwnership: string;
    }
    interface BucketReplicationConfigRule {
        /**
         * Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when `filter` is used)documented below.
         */
        deleteMarkerReplication?: outputs.s3.BucketReplicationConfigRuleDeleteMarkerReplication;
        /**
         * Specifies the destination for the rule. See below.
         */
        destination: outputs.s3.BucketReplicationConfigRuleDestination;
        /**
         * Replicate existing objects in the source bucket according to the rule configurations. See below.
         */
        existingObjectReplication?: outputs.s3.BucketReplicationConfigRuleExistingObjectReplication;
        /**
         * Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the `rule` will default to using `prefix`.
         */
        filter?: outputs.s3.BucketReplicationConfigRuleFilter;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string (`""`) if `filter` is not specified.
         *
         * @deprecated Use filter instead
         */
        prefix?: string;
        /**
         * Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria. See below.
         */
        sourceSelectionCriteria?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteria;
        /**
         * Status of the rule. Either `"Enabled"` or `"Disabled"`. The rule is ignored if status is not "Enabled".
         */
        status: string;
    }
    interface BucketReplicationConfigRuleDeleteMarkerReplication {
        /**
         * Whether delete markers should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }
    interface BucketReplicationConfigRuleDestination {
        /**
         * Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with `account` owner override configuration.
         */
        accessControlTranslation?: outputs.s3.BucketReplicationConfigRuleDestinationAccessControlTranslation;
        /**
         * Account ID to specify the replica ownership. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        account?: string;
        /**
         * ARN of the bucket where you want Amazon S3 to store the results.
         */
        bucket: string;
        /**
         * Configuration block that provides information about encryption. See below. If `sourceSelectionCriteria` is specified, you must specify this element.
         */
        encryptionConfiguration?: outputs.s3.BucketReplicationConfigRuleDestinationEncryptionConfiguration;
        /**
         * Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
         */
        metrics?: outputs.s3.BucketReplicationConfigRuleDestinationMetrics;
        /**
         * Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with `metrics`.
         */
        replicationTime?: outputs.s3.BucketReplicationConfigRuleDestinationReplicationTime;
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }
    interface BucketReplicationConfigRuleDestinationAccessControlTranslation {
        /**
         * Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference. Valid values: `Destination`.
         */
        owner: string;
    }
    interface BucketReplicationConfigRuleDestinationEncryptionConfiguration {
        /**
         * ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
         */
        replicaKmsKeyId: string;
    }
    interface BucketReplicationConfigRuleDestinationMetrics {
        /**
         * Configuration block that specifies the time threshold for emitting the `s3:Replication:OperationMissedThreshold` event. See below.
         */
        eventThreshold?: outputs.s3.BucketReplicationConfigRuleDestinationMetricsEventThreshold;
        /**
         * Status of the Destination Metrics. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }
    interface BucketReplicationConfigRuleDestinationMetricsEventThreshold {
        /**
         * Time in minutes. Valid values: `15`.
         */
        minutes: number;
    }
    interface BucketReplicationConfigRuleDestinationReplicationTime {
        /**
         * Status of the Replication Time Control. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
        /**
         * Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
         */
        time: outputs.s3.BucketReplicationConfigRuleDestinationReplicationTimeTime;
    }
    interface BucketReplicationConfigRuleDestinationReplicationTimeTime {
        /**
         * Time in minutes. Valid values: `15`.
         */
        minutes: number;
    }
    interface BucketReplicationConfigRuleExistingObjectReplication {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }
    interface BucketReplicationConfigRuleFilter {
        /**
         * Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
         */
        and?: outputs.s3.BucketReplicationConfigRuleFilterAnd;
        /**
         * Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Configuration block for specifying a tag key and value. See below.
         */
        tag?: outputs.s3.BucketReplicationConfigRuleFilterTag;
    }
    interface BucketReplicationConfigRuleFilterAnd {
        /**
         * Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketReplicationConfigRuleFilterTag {
        /**
         * Name of the object key.
         */
        key: string;
        /**
         * Value of the tag.
         */
        value: string;
    }
    interface BucketReplicationConfigRuleSourceSelectionCriteria {
        /**
         * Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when `filter` is specified), you can specify this element and set the status to `Enabled` to replicate modifications on replicas.
         */
        replicaModifications?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModifications;
        /**
         * Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, `replicaKmsKeyId` in `destination` `encryptionConfiguration` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjects;
    }
    interface BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModifications {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }
    interface BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjects {
        /**
         * Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
         */
        status: string;
    }
    interface BucketReplicationConfiguration {
        role: string;
        rules: outputs.s3.BucketReplicationConfigurationRule[];
    }
    interface BucketReplicationConfigurationRule {
        /**
         * Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
         */
        deleteMarkerReplicationStatus?: string;
        /**
         * Specifies the destination for the rule (documented below).
         */
        destination: outputs.s3.BucketReplicationConfigurationRuleDestination;
        /**
         * Filter that identifies subset of objects to which the replication rule applies (documented below).
         */
        filter?: outputs.s3.BucketReplicationConfigurationRuleFilter;
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id?: string;
        /**
         * Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * The priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria (documented below).
         */
        sourceSelectionCriteria?: outputs.s3.BucketReplicationConfigurationRuleSourceSelectionCriteria;
        /**
         * The status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
         *
         * > **NOTE:** Replication to multiple destination buckets requires that `priority` is specified in the `rules` object. If the corresponding rule requires no filter, an empty configuration block `filter {}` must be specified.
         */
        status: string;
    }
    interface BucketReplicationConfigurationRuleDestination {
        /**
         * Specifies the overrides to use for object owners on replication. Must be used in conjunction with `accountId` owner override configuration.
         */
        accessControlTranslation?: outputs.s3.BucketReplicationConfigurationRuleDestinationAccessControlTranslation;
        /**
         * The Account ID to use for overriding the object owner on replication. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        accountId?: string;
        /**
         * The ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
         */
        bucket: string;
        /**
         * Enables replication metrics (required for S3 RTC) (documented below).
         */
        metrics?: outputs.s3.BucketReplicationConfigurationRuleDestinationMetrics;
        /**
         * Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
         * `sseKmsEncryptedObjects` source selection criteria.
         */
        replicaKmsKeyId?: string;
        /**
         * Enables S3 Replication Time Control (S3 RTC) (documented below).
         */
        replicationTime?: outputs.s3.BucketReplicationConfigurationRuleDestinationReplicationTime;
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }
    interface BucketReplicationConfigurationRuleDestinationAccessControlTranslation {
        /**
         * The override value for the owner on replicated objects. Currently only `Destination` is supported.
         */
        owner: string;
    }
    interface BucketReplicationConfigurationRuleDestinationMetrics {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * The status of replication metrics. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }
    interface BucketReplicationConfigurationRuleDestinationReplicationTime {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * The status of RTC. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }
    interface BucketReplicationConfigurationRuleFilter {
        /**
         * Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * A map of tags that identifies subset of objects to which the rule applies.
         * The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketReplicationConfigurationRuleSourceSelectionCriteria {
        /**
         * Match SSE-KMS encrypted objects (documented below). If specified, `replicaKmsKeyId`
         * in `destination` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjects;
    }
    interface BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjects {
        /**
         * Boolean which indicates if this criteria is enabled.
         */
        enabled: boolean;
    }
    interface BucketServerSideEncryptionConfiguration {
        /**
         * A single object for server-side encryption by default configuration. (documented below)
         */
        rule: outputs.s3.BucketServerSideEncryptionConfigurationRule;
    }
    interface BucketServerSideEncryptionConfigurationRule {
        /**
         * A single object for setting server-side encryption by default. (documented below)
         */
        applyServerSideEncryptionByDefault: outputs.s3.BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }
    interface BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
        /**
         * The AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * The server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
         */
        sseAlgorithm: string;
    }
    interface BucketServerSideEncryptionConfigurationV2Rule {
        /**
         * Single object for setting server-side encryption by default. See below.
         */
        applyServerSideEncryptionByDefault?: outputs.s3.BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefault;
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }
    interface BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefault {
        /**
         * AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
         */
        sseAlgorithm: string;
    }
    interface BucketV2CorsRule {
        /**
         * List of headers allowed.
         */
        allowedHeaders?: string[];
        /**
         * One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * One or more origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }
    interface BucketV2Grant {
        /**
         * Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
         */
        type: string;
        /**
         * Uri address to grant for. Used only when `type` is `Group`.
         */
        uri?: string;
    }
    interface BucketV2LifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
         */
        abortIncompleteMultipartUploadDays?: number;
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire. See Expiration below for details.
         */
        expirations?: outputs.s3.BucketV2LifecycleRuleExpiration[];
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
         */
        noncurrentVersionExpirations?: outputs.s3.BucketV2LifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
         */
        noncurrentVersionTransitions?: outputs.s3.BucketV2LifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix?: string;
        /**
         * Specifies object tags key and value.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * Specifies a period in the object's transitions. See Transition below for details.
         */
        transitions?: outputs.s3.BucketV2LifecycleRuleTransition[];
    }
    interface BucketV2LifecycleRuleExpiration {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }
    interface BucketV2LifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions expire.
         */
        days?: number;
    }
    interface BucketV2LifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }
    interface BucketV2LifecycleRuleTransition {
        /**
         * Specifies the date after which you want the corresponding action to take effect.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         */
        days?: number;
        /**
         * Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
         */
        storageClass: string;
    }
    interface BucketV2Logging {
        /**
         * Name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }
    interface BucketV2ObjectLockConfiguration {
        /**
         * Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
         *
         * @deprecated Use the top-level parameter objectLockEnabled instead
         */
        objectLockEnabled?: string;
        /**
         * Object Lock rule in place for this bucket (documented below).
         *
         * @deprecated Use the aws.s3.BucketObjectLockConfigurationV2 resource instead
         */
        rules?: outputs.s3.BucketV2ObjectLockConfigurationRule[];
    }
    interface BucketV2ObjectLockConfigurationRule {
        /**
         * Default retention period that you want to apply to new objects placed in this bucket (documented below).
         */
        defaultRetentions: outputs.s3.BucketV2ObjectLockConfigurationRuleDefaultRetention[];
    }
    interface BucketV2ObjectLockConfigurationRuleDefaultRetention {
        /**
         * Number of days that you want to specify for the default retention period.
         */
        days?: number;
        /**
         * Default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
         */
        mode: string;
        /**
         * Number of years that you want to specify for the default retention period.
         */
        years?: number;
    }
    interface BucketV2ReplicationConfiguration {
        /**
         * ARN of the IAM role for Amazon S3 to assume when replicating the objects.
         */
        role: string;
        /**
         * Specifies the rules managing the replication (documented below).
         */
        rules: outputs.s3.BucketV2ReplicationConfigurationRule[];
    }
    interface BucketV2ReplicationConfigurationRule {
        /**
         * Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
         */
        deleteMarkerReplicationStatus?: string;
        /**
         * Specifies the destination for the rule (documented below).
         */
        destinations: outputs.s3.BucketV2ReplicationConfigurationRuleDestination[];
        /**
         * Filter that identifies subset of objects to which the replication rule applies (documented below).
         */
        filters?: outputs.s3.BucketV2ReplicationConfigurationRuleFilter[];
        /**
         * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
         */
        id?: string;
        /**
         * Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
         */
        priority?: number;
        /**
         * Specifies special object selection criteria (documented below).
         */
        sourceSelectionCriterias?: outputs.s3.BucketV2ReplicationConfigurationRuleSourceSelectionCriteria[];
        /**
         * Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
         */
        status: string;
    }
    interface BucketV2ReplicationConfigurationRuleDestination {
        /**
         * Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `accountId` owner override configuration.
         */
        accessControlTranslations?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslation[];
        /**
         * Account ID to use for overriding the object owner on replication. Must be used in conjunction with `accessControlTranslation` override configuration.
         */
        accountId?: string;
        /**
         * ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
         */
        bucket: string;
        /**
         * Enables replication metrics (required for S3 RTC) (documented below).
         */
        metrics?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationMetric[];
        /**
         * Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
         * `sseKmsEncryptedObjects` source selection criteria.
         */
        replicaKmsKeyId?: string;
        /**
         * Enables S3 Replication Time Control (S3 RTC) (documented below).
         */
        replicationTimes?: outputs.s3.BucketV2ReplicationConfigurationRuleDestinationReplicationTime[];
        /**
         * The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
         */
        storageClass?: string;
    }
    interface BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslation {
        /**
         * Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
         */
        owner: string;
    }
    interface BucketV2ReplicationConfigurationRuleDestinationMetric {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * Status of replication metrics. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }
    interface BucketV2ReplicationConfigurationRuleDestinationReplicationTime {
        /**
         * Threshold within which objects are to be replicated. The only valid value is `15`.
         */
        minutes?: number;
        /**
         * Status of RTC. Either `Enabled` or `Disabled`.
         */
        status?: string;
    }
    interface BucketV2ReplicationConfigurationRuleFilter {
        /**
         * Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
         */
        prefix?: string;
        /**
         * A map of tags that identifies subset of objects to which the rule applies.
         * The rule applies only to objects having all the tags in its tagset.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface BucketV2ReplicationConfigurationRuleSourceSelectionCriteria {
        /**
         * Match SSE-KMS encrypted objects (documented below). If specified, `replicaKmsKeyId`
         * in `destination` must be specified as well.
         */
        sseKmsEncryptedObjects?: outputs.s3.BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObject[];
    }
    interface BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObject {
        /**
         * Boolean which indicates if this criteria is enabled.
         */
        enabled: boolean;
    }
    interface BucketV2ServerSideEncryptionConfiguration {
        /**
         * Single object for server-side encryption by default configuration. (documented below)
         */
        rules: outputs.s3.BucketV2ServerSideEncryptionConfigurationRule[];
    }
    interface BucketV2ServerSideEncryptionConfigurationRule {
        /**
         * Single object for setting server-side encryption by default. (documented below)
         */
        applyServerSideEncryptionByDefaults: outputs.s3.BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault[];
        /**
         * Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
         */
        bucketKeyEnabled?: boolean;
    }
    interface BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
        /**
         * AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sseAlgorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sseAlgorithm` is `aws:kms`.
         */
        kmsMasterKeyId?: string;
        /**
         * Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
         */
        sseAlgorithm: string;
    }
    interface BucketV2Versioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
         */
        enabled?: boolean;
        /**
         * Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
         */
        mfaDelete?: boolean;
    }
    interface BucketV2Website {
        /**
         * Absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument?: string;
        /**
         * Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
         * describing redirect behavior and when redirects are applied.
         */
        routingRules?: string;
    }
    interface BucketVersioning {
        /**
         * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
         */
        enabled?: boolean;
        /**
         * Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
         */
        mfaDelete?: boolean;
    }
    interface BucketVersioningV2VersioningConfiguration {
        /**
         * Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
         */
        mfaDelete: string;
        /**
         * Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
         */
        status: string;
    }
    interface BucketWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument?: string;
        /**
         * A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * A json array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
         * describing redirect behavior and when redirects are applied.
         *
         * The `CORS` object supports the following:
         */
        routingRules?: string;
    }
    interface BucketWebsiteConfigurationV2ErrorDocument {
        /**
         * Object key name to use when a 4XX class error occurs.
         */
        key: string;
    }
    interface BucketWebsiteConfigurationV2IndexDocument {
        /**
         * Suffix that is appended to a request that is for a directory on the website endpoint.
         * For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
         * The suffix must not be empty and must not include a slash character.
         */
        suffix: string;
    }
    interface BucketWebsiteConfigurationV2RedirectAllRequestsTo {
        /**
         * Name of the host where requests are redirected.
         */
        hostName: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
         */
        protocol?: string;
    }
    interface BucketWebsiteConfigurationV2RoutingRule {
        /**
         * Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
         */
        condition?: outputs.s3.BucketWebsiteConfigurationV2RoutingRuleCondition;
        /**
         * Configuration block for redirect information. See below.
         */
        redirect: outputs.s3.BucketWebsiteConfigurationV2RoutingRuleRedirect;
    }
    interface BucketWebsiteConfigurationV2RoutingRuleCondition {
        /**
         * HTTP error code when the redirect is applied. If specified with `keyPrefixEquals`, then both must be true for the redirect to be applied.
         */
        httpErrorCodeReturnedEquals?: string;
        /**
         * Object key name prefix when the redirect is applied. If specified with `httpErrorCodeReturnedEquals`, then both must be true for the redirect to be applied.
         */
        keyPrefixEquals?: string;
    }
    interface BucketWebsiteConfigurationV2RoutingRuleRedirect {
        /**
         * Host name to use in the redirect request.
         */
        hostName?: string;
        /**
         * HTTP redirect code to use on the response.
         */
        httpRedirectCode?: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
         */
        protocol?: string;
        /**
         * Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `keyPrefixEquals` set to `docs/` and in the `redirect` set `replaceKeyPrefixWith` to `/documents`.
         */
        replaceKeyPrefixWith?: string;
        /**
         * Specific object key to use in the redirect request. For example, redirect request to `error.html`.
         */
        replaceKeyWith?: string;
    }
    interface DirectoryBucketLocation {
        /**
         * [Availability Zone ID](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#az-ids).
         */
        name: string;
        /**
         * Location type. Valid values: `AvailabilityZone`.
         */
        type: string;
    }
    interface InventoryDestination {
        /**
         * S3 bucket configuration where inventory results are published (documented below).
         */
        bucket: outputs.s3.InventoryDestinationBucket;
    }
    interface InventoryDestinationBucket {
        /**
         * ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
         */
        accountId?: string;
        /**
         * Amazon S3 bucket ARN of the destination.
         */
        bucketArn: string;
        /**
         * Contains the type of server-side encryption to use to encrypt the inventory (documented below).
         */
        encryption?: outputs.s3.InventoryDestinationBucketEncryption;
        /**
         * Specifies the output format of the inventory results. Can be `CSV`, [`ORC`](https://orc.apache.org/) or [`Parquet`](https://parquet.apache.org/).
         */
        format: string;
        /**
         * Prefix that is prepended to all inventory results.
         */
        prefix?: string;
    }
    interface InventoryDestinationBucketEncryption {
        /**
         * Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
         */
        sseKms?: outputs.s3.InventoryDestinationBucketEncryptionSseKms;
        /**
         * Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
         */
        sseS3?: outputs.s3.InventoryDestinationBucketEncryptionSseS3;
    }
    interface InventoryDestinationBucketEncryptionSseKms {
        /**
         * ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
         */
        keyId: string;
    }
    interface InventoryDestinationBucketEncryptionSseS3 {
    }
    interface InventoryFilter {
        /**
         * Prefix that an object must have to be included in the inventory results.
         */
        prefix?: string;
    }
    interface InventorySchedule {
        /**
         * Specifies how frequently inventory results are produced. Valid values: `Daily`, `Weekly`.
         */
        frequency: string;
    }
    interface ObjectCopyGrant {
        /**
         * Email address of the grantee. Used only when `type` is `AmazonCustomerByEmail`.
         */
        email?: string;
        /**
         * Canonical user ID of the grantee. Used only when `type` is `CanonicalUser`.
         */
        id?: string;
        /**
         * List of permissions to grant to grantee. Valid values are `READ`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
         */
        permissions: string[];
        /**
         * Type of grantee. Valid values are `CanonicalUser`, `Group`, and `AmazonCustomerByEmail`.
         *
         * This configuration block has the following optional arguments (one of the three is required):
         */
        type: string;
        /**
         * URI of the grantee group. Used only when `type` is `Group`.
         */
        uri?: string;
    }
}
export declare namespace s3control {
    interface AccessGrantAccessGrantsLocationConfiguration {
        /**
         * Sub-prefix.
         */
        s3SubPrefix?: string;
    }
    interface AccessGrantGrantee {
        /**
         * Grantee identifier.
         */
        granteeIdentifier: string;
        /**
         * Grantee types. Valid values: `DIRECTORY_USER`, `DIRECTORY_GROUP`, `IAM`.
         */
        granteeType: string;
    }
    interface BucketLifecycleConfigurationRule {
        /**
         * Configuration block containing settings for abort incomplete multipart upload.
         */
        abortIncompleteMultipartUpload?: outputs.s3control.BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload;
        /**
         * Configuration block containing settings for expiration of objects.
         */
        expiration?: outputs.s3control.BucketLifecycleConfigurationRuleExpiration;
        /**
         * Configuration block containing settings for filtering.
         */
        filter?: outputs.s3control.BucketLifecycleConfigurationRuleFilter;
        /**
         * Unique identifier for the rule.
         */
        id: string;
        /**
         * Status of the rule. Valid values: `Enabled` and `Disabled`. Defaults to `Enabled`.
         */
        status?: string;
    }
    interface BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload {
        /**
         * Number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation: number;
    }
    interface BucketLifecycleConfigurationRuleExpiration {
        /**
         * Date the object is to be deleted. Should be in `YYYY-MM-DD` date format, e.g., `2020-09-30`.
         */
        date?: string;
        /**
         * Number of days before the object is to be deleted.
         */
        days?: number;
        /**
         * Enable to remove a delete marker with no noncurrent versions. Cannot be specified with `date` or `days`.
         */
        expiredObjectDeleteMarker?: boolean;
    }
    interface BucketLifecycleConfigurationRuleFilter {
        /**
         * Object prefix for rule filtering.
         */
        prefix?: string;
        /**
         * Key-value map of object tags for rule filtering.
         */
        tags?: {
            [key: string]: string;
        };
    }
    interface GetMultiRegionAccessPointPublicAccessBlock {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs). When set to `true` causes the following behavior:
         * * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         * * PUT Object calls fail if the request includes a public ACL.
         * * PUT Bucket calls fail if the request includes a public ACL.
         */
        blockPublicAcls: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. When set to `true` causes Amazon S3 to:
         * * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         */
        blockPublicPolicy: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. When set to `true` causes Amazon S3 to:
         * * Ignore all public ACLs on buckets in this account and any objects that they contain.
         */
        ignorePublicAcls: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. When set to `true`:
         * * Only the bucket owner and AWS Services can access buckets with public policies.
         */
        restrictPublicBuckets: boolean;
    }
    interface GetMultiRegionAccessPointRegion {
        /**
         * The name of the bucket.
         */
        bucket: string;
        /**
         * The AWS account ID that owns the bucket.
         */
        bucketAccountId: string;
        /**
         * The name of the region.
         */
        region: string;
    }
    interface MultiRegionAccessPointDetails {
        name: string;
        publicAccessBlock?: outputs.s3control.MultiRegionAccessPointDetailsPublicAccessBlock;
        regions: outputs.s3control.MultiRegionAccessPointDetailsRegion[];
    }
    interface MultiRegionAccessPointDetailsPublicAccessBlock {
        blockPublicAcls?: boolean;
        blockPublicPolicy?: boolean;
        ignorePublicAcls?: boolean;
        restrictPublicBuckets?: boolean;
    }
    interface MultiRegionAccessPointDetailsRegion {
        bucket: string;
        bucketAccountId: string;
        region: string;
    }
    interface MultiRegionAccessPointPolicyDetails {
        /**
         * The name of the Multi-Region Access Point.
         */
        name: string;
        /**
         * A valid JSON document that specifies the policy that you want to associate with this Multi-Region Access Point. Once applied, the policy can be edited, but not deleted. For more information, see the documentation on [Multi-Region Access Point Permissions](https://docs.aws.amazon.com/AmazonS3/latest/userguide/MultiRegionAccessPointPermissions.html).
         *
         * > **NOTE:** When you update the `policy`, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
         */
        policy: string;
    }
    interface ObjectLambdaAccessPointConfiguration {
        /**
         * Allowed features. Valid values: `GetObject-Range`, `GetObject-PartNumber`.
         */
        allowedFeatures?: string[];
        /**
         * Whether or not the CloudWatch metrics configuration is enabled.
         */
        cloudWatchMetricsEnabled?: boolean;
        /**
         * Standard access point associated with the Object Lambda Access Point.
         */
        supportingAccessPoint: string;
        /**
         * List of transformation configurations for the Object Lambda Access Point. See Transformation Configuration below for more details.
         */
        transformationConfigurations: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfiguration[];
    }
    interface ObjectLambdaAccessPointConfigurationTransformationConfiguration {
        /**
         * The actions of an Object Lambda Access Point configuration. Valid values: `GetObject`.
         */
        actions: string[];
        /**
         * The content transformation of an Object Lambda Access Point configuration. See Content Transformation below for more details.
         */
        contentTransformation: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformation;
    }
    interface ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformation {
        /**
         * Configuration for an AWS Lambda function. See AWS Lambda below for more details.
         */
        awsLambda: outputs.s3control.ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformationAwsLambda;
    }
    interface ObjectLambdaAccessPointConfigurationTransformationConfigurationContentTransformationAwsLambda {
        /**
         * The Amazon Resource Name (ARN) of the AWS Lambda function.
         */
        functionArn: string;
        /**
         * Additional JSON that provides supplemental data to the Lambda function used to transform objects.
         */
        functionPayload?: string;
    }
    interface StorageLensConfigurationStorageLensConfiguration {
        /**
         * The account-level configurations of the S3 Storage Lens configuration. See Account Level below for more details.
         */
        accountLevel: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevel;
        /**
         * The Amazon Web Services organization for the S3 Storage Lens configuration. See AWS Org below for more details.
         */
        awsOrg?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAwsOrg;
        /**
         * Properties of S3 Storage Lens metrics export including the destination, schema and format. See Data Export below for more details.
         */
        dataExport?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExport;
        /**
         * Whether the S3 Storage Lens configuration is enabled.
         */
        enabled: boolean;
        /**
         * What is excluded in this configuration. Conflicts with `include`. See Exclude below for more details.
         */
        exclude?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationExclude;
        /**
         * What is included in this configuration. Conflicts with `exclude`. See Include below for more details.
         */
        include?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationInclude;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevel {
        /**
         * S3 Storage Lens activity metrics. See Activity Metrics below for more details.
         */
        activityMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelActivityMetrics;
        /**
         * Advanced cost-optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics below for more details.
         */
        advancedCostOptimizationMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics;
        /**
         * Advanced data-protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics below for more details.
         */
        advancedDataProtectionMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics;
        /**
         * S3 Storage Lens bucket-level configuration. See Bucket Level below for more details.
         */
        bucketLevel: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevel;
        /**
         * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics below for more details.
         */
        detailedStatusCodeMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelActivityMetrics {
        /**
         * Whether the activity metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics {
        /**
         * Whether advanced cost-optimization metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics {
        /**
         * Whether advanced data-protection metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevel {
        /**
         * S3 Storage Lens activity metrics. See Activity Metrics above for more details.
         */
        activityMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelActivityMetrics;
        /**
         * Advanced cost-optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics above for more details.
         */
        advancedCostOptimizationMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics;
        /**
         * Advanced data-protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics above for more details.
         */
        advancedDataProtectionMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics;
        /**
         * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics above for more details.
         */
        detailedStatusCodeMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics;
        /**
         * Prefix-level metrics for S3 Storage Lens. See Prefix Level below for more details.
         */
        prefixLevel?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevel;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelActivityMetrics {
        /**
         * Whether the activity metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics {
        /**
         * Whether advanced cost-optimization metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics {
        /**
         * Whether advanced data-protection metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics {
        /**
         * Whether detailed status code metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevel {
        /**
         * Prefix-level storage metrics for S3 Storage Lens. See Prefix Level Storage Metrics below for more details.
         */
        storageMetrics: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics {
        /**
         * Whether prefix-level storage metrics are enabled.
         */
        enabled?: boolean;
        /**
         * Selection criteria. See Selection Criteria below for more details.
         */
        selectionCriteria?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria {
        /**
         * The delimiter of the selection criteria being used.
         */
        delimiter?: string;
        /**
         * The max depth of the selection criteria.
         */
        maxDepth?: number;
        /**
         * The minimum number of storage bytes percentage whose metrics will be selected.
         */
        minStorageBytesPercentage?: number;
    }
    interface StorageLensConfigurationStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics {
        /**
         * Whether detailed status code metrics are enabled.
         */
        enabled?: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationAwsOrg {
        /**
         * The Amazon Resource Name (ARN) of the Amazon Web Services organization.
         */
        arn: string;
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExport {
        /**
         * Amazon CloudWatch publishing for S3 Storage Lens metrics. See Cloud Watch Metrics below for more details.
         */
        cloudWatchMetrics?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportCloudWatchMetrics;
        /**
         * The bucket where the S3 Storage Lens metrics export will be located. See S3 Bucket Destination below for more details.
         */
        s3BucketDestination?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestination;
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExportCloudWatchMetrics {
        /**
         * Whether CloudWatch publishing for S3 Storage Lens metrics is enabled.
         */
        enabled: boolean;
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestination {
        /**
         * The account ID of the owner of the S3 Storage Lens metrics export bucket.
         */
        accountId: string;
        /**
         * The Amazon Resource Name (ARN) of the bucket.
         */
        arn: string;
        /**
         * Encryption of the metrics exports in this bucket. See Encryption below for more details.
         */
        encryption?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryption;
        /**
         * The export format. Valid values: `CSV`, `Parquet`.
         */
        format: string;
        /**
         * The schema version of the export file. Valid values: `V_1`.
         */
        outputSchemaVersion: string;
        /**
         * The prefix of the destination bucket where the metrics export will be delivered.
         */
        prefix?: string;
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryption {
        /**
         * SSE-KMS encryption. See SSE KMS below for more details.
         */
        sseKms?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms;
        /**
         * SSE-S3 encryption. An empty configuration block `{}` should be used.
         */
        sseS3s?: outputs.s3control.StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseS3[];
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms {
        /**
         * KMS key ARN.
         */
        keyId: string;
    }
    interface StorageLensConfigurationStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseS3 {
    }
    interface StorageLensConfigurationStorageLensConfigurationExclude {
        /**
         * List of S3 bucket ARNs.
         */
        buckets?: string[];
        /**
         * List of AWS Regions.
         */
        regions?: string[];
    }
    interface StorageLensConfigurationStorageLensConfigurationInclude {
        /**
         * List of S3 bucket ARNs.
         */
        buckets?: string[];
        /**
         * List of AWS Regions.
         */
        regions?: string[];
    }
}
export declare namespace s3outposts {
    interface EndpointNetworkInterface {
        /**
         * Identifier of the Elastic Network Interface (ENI).
         */
        networkInterfaceId: string;
    }
}
export declare namespace sagemaker {
    interface AppImageConfigCodeEditorAppImageConfig {
        /**
         * The configuration used to run the application image container. See Container Config details below.
         */
        containerConfig?: outputs.sagemaker.AppImageConfigCodeEditorAppImageConfigContainerConfig;
        /**
         * The URL where the Git repository is located. See File System Config details below.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigCodeEditorAppImageConfigFileSystemConfig;
    }
    interface AppImageConfigCodeEditorAppImageConfigContainerConfig {
        /**
         * The arguments for the container when you're running the application.
         */
        containerArguments?: string[];
        /**
         * The entrypoint used to run the application in the container.
         */
        containerEntrypoints?: string[];
        /**
         * The environment variables to set in the container.
         */
        containerEnvironmentVariables?: {
            [key: string]: string;
        };
    }
    interface AppImageConfigCodeEditorAppImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to `100`. Valid values are `0` and `100`.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to `1000`. Valid values are `0` and `1000`.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to `/home/sagemaker-user`.
         *
         * > **Note:** When specifying `defaultGid` and `defaultUid`, Valid value pairs are [`0`, `0`] and [`100`, `1000`].
         */
        mountPath?: string;
    }
    interface AppImageConfigJupyterLabImageConfig {
        /**
         * The configuration used to run the application image container. See Container Config details below.
         */
        containerConfig?: outputs.sagemaker.AppImageConfigJupyterLabImageConfigContainerConfig;
        /**
         * The URL where the Git repository is located. See File System Config details below.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigJupyterLabImageConfigFileSystemConfig;
    }
    interface AppImageConfigJupyterLabImageConfigContainerConfig {
        /**
         * The arguments for the container when you're running the application.
         */
        containerArguments?: string[];
        /**
         * The entrypoint used to run the application in the container.
         */
        containerEntrypoints?: string[];
        /**
         * The environment variables to set in the container.
         */
        containerEnvironmentVariables?: {
            [key: string]: string;
        };
    }
    interface AppImageConfigJupyterLabImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to `100`. Valid values are `0` and `100`.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to `1000`. Valid values are `0` and `1000`.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to `/home/sagemaker-user`.
         *
         * > **Note:** When specifying `defaultGid` and `defaultUid`, Valid value pairs are [`0`, `0`] and [`100`, `1000`].
         */
        mountPath?: string;
    }
    interface AppImageConfigKernelGatewayImageConfig {
        /**
         * The URL where the Git repository is located. See File System Config details below.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigKernelGatewayImageConfigFileSystemConfig;
        /**
         * The default branch for the Git repository. See Kernel Spec details below.
         */
        kernelSpec: outputs.sagemaker.AppImageConfigKernelGatewayImageConfigKernelSpec;
    }
    interface AppImageConfigKernelGatewayImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to `100`. Valid values are `0` and `100`.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to `1000`. Valid values are `0` and `1000`.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to `/home/sagemaker-user`.
         *
         * > **Note:** When specifying `defaultGid` and `defaultUid`, Valid value pairs are [`0`, `0`] and [`100`, `1000`].
         */
        mountPath?: string;
    }
    interface AppImageConfigKernelGatewayImageConfigKernelSpec {
        /**
         * The display name of the kernel.
         */
        displayName?: string;
        /**
         * The name of the kernel.
         */
        name: string;
    }
    interface AppResourceSpec {
        /**
         * The instance type that the image version runs on. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface CodeRepositoryGitConfig {
        /**
         * The default branch for the Git repository.
         */
        branch?: string;
        /**
         * The URL where the Git repository is located.
         */
        repositoryUrl: string;
        /**
         * The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format: `{"username": UserName, "password": Password}`
         */
        secretArn?: string;
    }
    interface DataQualityJobDefinitionDataQualityAppSpecification {
        /**
         * Sets the environment variables in the container that the monitoring job runs. A list of key value pairs.
         */
        environment?: {
            [key: string]: string;
        };
        /**
         * The container image that the data quality monitoring job runs.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers.
         */
        recordPreprocessorSourceUri?: string;
    }
    interface DataQualityJobDefinitionDataQualityBaselineConfig {
        /**
         * The constraints resource for a monitoring job. Fields are documented below.
         */
        constraintsResource?: outputs.sagemaker.DataQualityJobDefinitionDataQualityBaselineConfigConstraintsResource;
        /**
         * The statistics resource for a monitoring job. Fields are documented below.
         */
        statisticsResource?: outputs.sagemaker.DataQualityJobDefinitionDataQualityBaselineConfigStatisticsResource;
    }
    interface DataQualityJobDefinitionDataQualityBaselineConfigConstraintsResource {
        /**
         * The Amazon S3 URI for the constraints resource.
         */
        s3Uri?: string;
    }
    interface DataQualityJobDefinitionDataQualityBaselineConfigStatisticsResource {
        /**
         * The Amazon S3 URI for the statistics resource.
         */
        s3Uri?: string;
    }
    interface DataQualityJobDefinitionDataQualityJobInput {
        /**
         * Input object for the batch transform job. Fields are documented below.
         */
        batchTransformInput?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInput;
        /**
         * Input object for the endpoint. Fields are documented below.
         */
        endpointInput?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputEndpointInput;
    }
    interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInput {
        /**
         * The Amazon S3 location being used to capture the data.
         */
        dataCapturedDestinationS3Uri: string;
        /**
         * The dataset format for your batch transform job. Fields are documented below.
         */
        datasetFormat: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormat;
        /**
         * Path to the filesystem where the batch transform data is available to the container. Defaults to `/opt/ml/processing/input`.
         */
        localPath?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to `FullyReplicated`. Valid values are `FullyReplicated` or `ShardedByS3Key`
         */
        s3DataDistributionType: string;
        /**
         * Whether the `Pipe` or `File` is used as the input mode for transferring data for the monitoring job. `Pipe` mode is recommended for large datasets. `File` mode is useful for small files that fit in memory. Defaults to `File`.  Valid values are `Pipe` or `File`
         */
        s3InputMode: string;
    }
    interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormat {
        /**
         * The CSV dataset used in the monitoring job. Fields are documented below.
         */
        csv?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatCsv;
        /**
         * The JSON dataset used in the monitoring job. Fields are documented below.
         */
        json?: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatJson;
    }
    interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatCsv {
        /**
         * Indicates if the CSV data has a header.
         */
        header?: boolean;
    }
    interface DataQualityJobDefinitionDataQualityJobInputBatchTransformInputDatasetFormatJson {
        /**
         * Indicates if the file should be read as a json object per line.
         */
        line?: boolean;
    }
    interface DataQualityJobDefinitionDataQualityJobInputEndpointInput {
        /**
         * An endpoint in customer's account which has `dataCaptureConfig` enabled.
         */
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container. Defaults to `/opt/ml/processing/input`.
         */
        localPath?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defaults to `FullyReplicated`. Valid values are `FullyReplicated` or `ShardedByS3Key`
         */
        s3DataDistributionType: string;
        /**
         * Whether the `Pipe` or `File` is used as the input mode for transferring data for the monitoring job. `Pipe` mode is recommended for large datasets. `File` mode is useful for small files that fit in memory. Defaults to `File`.  Valid values are `Pipe` or `File`
         */
        s3InputMode: string;
    }
    interface DataQualityJobDefinitionDataQualityJobOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded. Fields are documented below.
         */
        monitoringOutputs: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputs;
    }
    interface DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputs {
        /**
         * The Amazon S3 storage location where the results of a monitoring job are saved. Fields are documented below.
         */
        s3Output: outputs.sagemaker.DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputsS3Output;
    }
    interface DataQualityJobDefinitionDataQualityJobOutputConfigMonitoringOutputsS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data. Defaults to `/opt/ml/processing/output`.
         */
        localPath?: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes. Valid values are `Continuous` or `EndOfJob`
         */
        s3UploadMode: string;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }
    interface DataQualityJobDefinitionJobResources {
        /**
         * The configuration for the cluster resources used to run the processing job. Fields are documented below.
         */
        clusterConfig: outputs.sagemaker.DataQualityJobDefinitionJobResourcesClusterConfig;
    }
    interface DataQualityJobDefinitionJobResourcesClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: number;
    }
    interface DataQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between the instances used for the monitoring jobs. Choose `true` to encrypt communications. Encryption provides greater security for distributed jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the monitoring job.
         */
        enableNetworkIsolation?: boolean;
        /**
         * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. Fields are documented below.
         */
        vpcConfig?: outputs.sagemaker.DataQualityJobDefinitionNetworkConfigVpcConfig;
    }
    interface DataQualityJobDefinitionNetworkConfigVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the `subnets` field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect your training job or model.
         */
        subnets: string[];
    }
    interface DataQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }
    interface DeviceDevice {
        /**
         * A description for the device.
         */
        description?: string;
        /**
         * The name of the device.
         */
        deviceName: string;
        /**
         * Amazon Web Services Internet of Things (IoT) object name.
         */
        iotThingName?: string;
    }
    interface DeviceFleetOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
         */
        kmsKeyId?: string;
        /**
         * The Amazon Simple Storage (S3) bucker URI.
         */
        s3OutputLocation: string;
    }
    interface DomainDefaultSpaceSettings {
        /**
         * The execution role for the space.
         */
        executionRole: string;
        /**
         * The Jupyter server's app settings. See `jupyterServerAppSettings` Block below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See `kernelGatewayAppSettings` Block below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the space uses for communication.
         */
        securityGroups?: string[];
    }
    interface DomainDefaultSpaceSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see `codeRepository` Block below.
         */
        codeRepositories?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultSpaceSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface DomainDefaultSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultSpaceSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see `customImage` Block below.
         */
        customImages?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultSpaceSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface DomainDefaultSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettings {
        /**
         * The Canvas app settings. See `canvasAppSettings` Block below.
         */
        canvasAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettings;
        /**
         * The Code Editor application settings. See `codeEditorAppSettings` Block below.
         */
        codeEditorAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsCodeEditorAppSettings;
        /**
         * The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio. See `customFileSystemConfig` Block below.
         */
        customFileSystemConfigs?: outputs.sagemaker.DomainDefaultUserSettingsCustomFileSystemConfig[];
        /**
         * Details about the POSIX identity that is used for file system operations. See `customPosixUserConfig` Block below.
         */
        customPosixUserConfig?: outputs.sagemaker.DomainDefaultUserSettingsCustomPosixUserConfig;
        /**
         * The default experience that the user is directed to when accessing the domain. The supported values are: `studio::`: Indicates that Studio is the default experience. This value can only be passed if StudioWebPortal is set to ENABLED. `app:JupyterServer:`: Indicates that Studio Classic is the default experience.
         */
        defaultLandingUri: string;
        /**
         * The execution role ARN for the user.
         */
        executionRole: string;
        /**
         * The settings for the JupyterLab application. See `jupyterLabAppSettings` Block below.
         */
        jupyterLabAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsJupyterLabAppSettings;
        /**
         * The Jupyter server's app settings. See `jupyterServerAppSettings` Block below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See `kernelGatewayAppSettings` Block below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettings;
        /**
         * The RSession app settings. See `rSessionAppSettings` Block below.
         */
        rSessionAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettings;
        /**
         * A collection of settings that configure user interaction with the RStudioServerPro app. See `rStudioServerProAppSettings` Block below.
         */
        rStudioServerProAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsRStudioServerProAppSettings;
        /**
         * A list of security group IDs that will be attached to the user.
         */
        securityGroups?: string[];
        /**
         * The sharing settings. See `sharingSettings` Block below.
         */
        sharingSettings?: outputs.sagemaker.DomainDefaultUserSettingsSharingSettings;
        /**
         * The storage settings for a private space. See `spaceStorageSettings` Block below.
         */
        spaceStorageSettings: outputs.sagemaker.DomainDefaultUserSettingsSpaceStorageSettings;
        /**
         * Whether the user can access Studio. If this value is set to `DISABLED`, the user cannot access Studio, even if that is the default experience for the domain. Valid values are `ENABLED` and `DISABLED`.
         */
        studioWebPortal: string;
        /**
         * The TensorBoard app settings. See `tensorBoardAppSettings` Block below.
         */
        tensorBoardAppSettings?: outputs.sagemaker.DomainDefaultUserSettingsTensorBoardAppSettings;
    }
    interface DomainDefaultUserSettingsCanvasAppSettings {
        /**
         * The model deployment settings for the SageMaker Canvas application. See `directDeploySettings` Block below.
         */
        directDeploySettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsDirectDeploySettings;
        /**
         * The settings for connecting to an external data source with OAuth. See `identityProviderOauthSettings` Block below.
         */
        identityProviderOauthSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsIdentityProviderOauthSetting[];
        /**
         * The settings for document querying. See `kendraSettings` Block below.
         */
        kendraSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsKendraSettings;
        /**
         * The model registry settings for the SageMaker Canvas application. See `modelRegisterSettings` Block below.
         */
        modelRegisterSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsModelRegisterSettings;
        /**
         * Time series forecast settings for the Canvas app. See `timeSeriesForecastingSettings` Block below.
         */
        timeSeriesForecastingSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings;
        /**
         * The workspace settings for the SageMaker Canvas application. See `workspaceSettings` Block below.
         */
        workspaceSettings?: outputs.sagemaker.DomainDefaultUserSettingsCanvasAppSettingsWorkspaceSettings;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsDirectDeploySettings {
        /**
         * Describes whether model deployment permissions are enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsIdentityProviderOauthSetting {
        /**
         * The name of the data source that you're connecting to. Canvas currently supports OAuth for Snowflake and Salesforce Data Cloud. Valid values are `SalesforceGenie` and `Snowflake`.
         */
        dataSourceName?: string;
        /**
         * The ARN of an Amazon Web Services Secrets Manager secret that stores the credentials from your identity provider, such as the client ID and secret, authorization URL, and token URL.
         */
        secretArn: string;
        /**
         * Describes whether OAuth for a data source is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsKendraSettings {
        /**
         * Describes whether the document querying feature is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsModelRegisterSettings {
        /**
         * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
         */
        crossAccountModelRegisterRoleArn?: string;
        /**
         * Describes whether the integration to the model registry is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
        /**
         * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the [AmazonSageMakerCanvasForecastAccess](https://docs.aws.amazon.com/sagemaker/latest/dg/security-iam-awsmanpol-canvas.html#security-iam-awsmanpol-AmazonSageMakerCanvasForecastAccess) policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
         */
        amazonForecastRoleArn?: string;
        /**
         * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface DomainDefaultUserSettingsCanvasAppSettingsWorkspaceSettings {
        /**
         * The Amazon S3 bucket used to store artifacts generated by Canvas. Updating the Amazon S3 location impacts existing configuration settings, and Canvas users no longer have access to their artifacts. Canvas users must log out and log back in to apply the new location.
         */
        s3ArtifactPath?: string;
        /**
         * The Amazon Web Services Key Management Service (KMS) encryption key ID that is used to encrypt artifacts generated by Canvas in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
    }
    interface DomainDefaultUserSettingsCodeEditorAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsCodeEditorAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultUserSettingsCodeEditorAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettingsCustomFileSystemConfig {
        /**
         * The default EBS storage settings for a private space. See `efsFileSystemConfig` Block below.
         */
        efsFileSystemConfig?: outputs.sagemaker.DomainDefaultUserSettingsCustomFileSystemConfigEfsFileSystemConfig;
    }
    interface DomainDefaultUserSettingsCustomFileSystemConfigEfsFileSystemConfig {
        /**
         * The ID of your Amazon EFS file system.
         */
        fileSystemId: string;
        /**
         * The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
         */
        fileSystemPath: string;
    }
    interface DomainDefaultUserSettingsCustomPosixUserConfig {
        /**
         * The POSIX group ID.
         */
        gid: number;
        /**
         * The POSIX user ID.
         */
        uid: number;
    }
    interface DomainDefaultUserSettingsJupyterLabAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see `codeRepository` Block below.
         */
        codeRepositories?: outputs.sagemaker.DomainDefaultUserSettingsJupyterLabAppSettingsCodeRepository[];
        /**
         * A list of custom SageMaker images that are configured to run as a JupyterLab app. see `customImage` Block below.
         */
        customImages?: outputs.sagemaker.DomainDefaultUserSettingsJupyterLabAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsJupyterLabAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultUserSettingsJupyterLabAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface DomainDefaultUserSettingsJupyterLabAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface DomainDefaultUserSettingsJupyterLabAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see `codeRepository` Block below.
         */
        codeRepositories?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultUserSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface DomainDefaultUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see `customImage` Block below.
         */
        customImages?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface DomainDefaultUserSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface DomainDefaultUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettingsRSessionAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a RSession app. see `customImage` Block below.
         */
        customImages?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block above.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec;
    }
    interface DomainDefaultUserSettingsRSessionAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface DomainDefaultUserSettingsRSessionAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDefaultUserSettingsRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app. Valid values are `ENABLED` and `DISABLED`.
         */
        accessStatus?: string;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to `R_STUDIO_USER`. The `R_STUDIO_ADMIN` value allows the user access to the RStudio Administrative Dashboard. Valid values are `R_STUDIO_USER` and `R_STUDIO_ADMIN`.
         */
        userGroup?: string;
    }
    interface DomainDefaultUserSettingsSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is `Disabled`. Valid values are `Allowed` and `Disabled`.
         */
        notebookOutputOption?: string;
        /**
         * When `notebookOutputOption` is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When `notebookOutputOption` is Allowed, the Amazon S3 bucket used to save the notebook cell output.
         */
        s3OutputPath?: string;
    }
    interface DomainDefaultUserSettingsSpaceStorageSettings {
        /**
         * The default EBS storage settings for a private space. See `defaultEbsStorageSettings` Block below.
         */
        defaultEbsStorageSettings?: outputs.sagemaker.DomainDefaultUserSettingsSpaceStorageSettingsDefaultEbsStorageSettings;
    }
    interface DomainDefaultUserSettingsSpaceStorageSettingsDefaultEbsStorageSettings {
        /**
         * The default size of the EBS storage volume for a private space.
         */
        defaultEbsVolumeSizeInGb: number;
        /**
         * The maximum size of the EBS storage volume for a private space.
         */
        maximumEbsVolumeSizeInGb: number;
    }
    interface DomainDefaultUserSettingsTensorBoardAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block below.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec;
    }
    interface DomainDefaultUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainDomainSettings {
        /**
         * The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key [AWS Docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html). Valid values are `USER_PROFILE_NAME` and `DISABLED`.
         */
        executionRoleIdentityConfig?: string;
        /**
         * A collection of settings that configure the RStudioServerPro Domain-level app. see `rStudioServerProDomainSettings` Block below.
         */
        rStudioServerProDomainSettings?: outputs.sagemaker.DomainDomainSettingsRStudioServerProDomainSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
         */
        securityGroupIds?: string[];
    }
    interface DomainDomainSettingsRStudioServerProDomainSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see `defaultResourceSpec` Block above.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec;
        /**
         * The ARN of the execution role for the RStudioServerPro Domain-level app.
         */
        domainExecutionRoleArn: string;
        /**
         * A URL pointing to an RStudio Connect server.
         */
        rStudioConnectUrl?: string;
        /**
         * A URL pointing to an RStudio Package Manager server.
         */
        rStudioPackageManagerUrl?: string;
    }
    interface DomainDomainSettingsRStudioServerProDomainSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface DomainRetentionPolicy {
        /**
         * The retention policy for data stored on an Amazon Elastic File System (EFS) volume. Valid values are `Retain` or `Delete`.  Default value is `Retain`.
         */
        homeEfsFileSystem?: string;
    }
    interface EndpointConfigurationAsyncInferenceConfig {
        /**
         * Configures the behavior of the client used by Amazon SageMaker to interact with the model container during asynchronous inference.
         */
        clientConfig?: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigClientConfig;
        /**
         * Specifies the configuration for asynchronous inference invocation outputs.
         */
        outputConfig: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigOutputConfig;
    }
    interface EndpointConfigurationAsyncInferenceConfigClientConfig {
        /**
         * The maximum number of concurrent requests sent by the SageMaker client to the model container. If no value is provided, Amazon SageMaker will choose an optimal value for you.
         */
        maxConcurrentInvocationsPerInstance?: number;
    }
    interface EndpointConfigurationAsyncInferenceConfigOutputConfig {
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the asynchronous inference output in Amazon S3.
         */
        kmsKeyId?: string;
        /**
         * Specifies the configuration for notifications of inference results for asynchronous inference.
         */
        notificationConfig?: outputs.sagemaker.EndpointConfigurationAsyncInferenceConfigOutputConfigNotificationConfig;
        /**
         * The Amazon S3 location to upload failure inference responses to.
         */
        s3FailurePath?: string;
        /**
         * The Amazon S3 location to upload inference responses to.
         */
        s3OutputPath: string;
    }
    interface EndpointConfigurationAsyncInferenceConfigOutputConfigNotificationConfig {
        /**
         * Amazon SNS topic to post a notification to when inference fails. If no topic is provided, no notification is sent on failure.
         */
        errorTopic?: string;
        /**
         * The Amazon SNS topics where you want the inference response to be included. Valid values are `SUCCESS_NOTIFICATION_TOPIC` and `ERROR_NOTIFICATION_TOPIC`.
         */
        includeInferenceResponseIns?: string[];
        /**
         * Amazon SNS topic to post a notification to when inference completes successfully. If no topic is provided, no notification is sent on success.
         */
        successTopic?: string;
    }
    interface EndpointConfigurationDataCaptureConfig {
        /**
         * The content type headers to capture. Fields are documented below.
         */
        captureContentTypeHeader?: outputs.sagemaker.EndpointConfigurationDataCaptureConfigCaptureContentTypeHeader;
        /**
         * Specifies what data to capture. Fields are documented below.
         */
        captureOptions: outputs.sagemaker.EndpointConfigurationDataCaptureConfigCaptureOption[];
        /**
         * The URL for S3 location where the captured data is stored.
         */
        destinationS3Uri: string;
        /**
         * Flag to enable data capture. Defaults to `false`.
         */
        enableCapture?: boolean;
        /**
         * Portion of data to capture. Should be between 0 and 100.
         */
        initialSamplingPercentage: number;
        /**
         * Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt the captured data on Amazon S3.
         */
        kmsKeyId?: string;
    }
    interface EndpointConfigurationDataCaptureConfigCaptureContentTypeHeader {
        /**
         * The CSV content type headers to capture.
         */
        csvContentTypes?: string[];
        /**
         * The JSON content type headers to capture.
         */
        jsonContentTypes?: string[];
    }
    interface EndpointConfigurationDataCaptureConfigCaptureOption {
        /**
         * Specifies the data to be captured. Should be one of `Input` or `Output`.
         */
        captureMode: string;
    }
    interface EndpointConfigurationProductionVariant {
        /**
         * The size of the Elastic Inference (EI) instance to use for the production variant.
         */
        acceleratorType?: string;
        /**
         * The timeout value, in seconds, for your inference container to pass health check by SageMaker Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests). Valid values between `60` and `3600`.
         */
        containerStartupHealthCheckTimeoutInSeconds?: number;
        /**
         * Specifies configuration for a core dump from the model container when the process crashes. Fields are documented below.
         */
        coreDumpConfig?: outputs.sagemaker.EndpointConfigurationProductionVariantCoreDumpConfig;
        /**
         * You can use this parameter to turn on native Amazon Web Services Systems Manager (SSM) access for a production variant behind an endpoint. By default, SSM access is disabled for all production variants behind an endpoints.
         */
        enableSsmAccess?: boolean;
        /**
         * Initial number of instances used for auto-scaling.
         */
        initialInstanceCount?: number;
        /**
         * Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. If unspecified, it defaults to `1.0`.
         */
        initialVariantWeight?: number;
        /**
         * The type of instance to start.
         */
        instanceType?: string;
        /**
         * The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this production variant. Valid values between `60` and `3600`.
         */
        modelDataDownloadTimeoutInSeconds?: number;
        /**
         * The name of the model to use.
         */
        modelName: string;
        /**
         * Sets how the endpoint routes incoming traffic. See routingConfig below.
         */
        routingConfigs?: outputs.sagemaker.EndpointConfigurationProductionVariantRoutingConfig[];
        /**
         * Specifies configuration for how an endpoint performs asynchronous inference.
         */
        serverlessConfig?: outputs.sagemaker.EndpointConfigurationProductionVariantServerlessConfig;
        /**
         * The name of the variant. If omitted, this provider will assign a random, unique name.
         */
        variantName: string;
        /**
         * The size, in GB, of the ML storage volume attached to individual inference instance associated with the production variant. Valid values between `1` and `512`.
         */
        volumeSizeInGb: number;
    }
    interface EndpointConfigurationProductionVariantCoreDumpConfig {
        /**
         * The Amazon S3 bucket to send the core dump to.
         */
        destinationS3Uri: string;
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
    }
    interface EndpointConfigurationProductionVariantRoutingConfig {
        /**
         * Sets how the endpoint routes incoming traffic. Valid values are `LEAST_OUTSTANDING_REQUESTS` and `RANDOM`. `LEAST_OUTSTANDING_REQUESTS` routes requests to the specific instances that have more capacity to process them. `RANDOM` routes each request to a randomly chosen instance.
         */
        routingStrategy: string;
    }
    interface EndpointConfigurationProductionVariantServerlessConfig {
        /**
         * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between `1` and `200`.
         */
        maxConcurrency: number;
        /**
         * The memory size of your serverless endpoint. Valid values are in 1 GB increments: `1024` MB, `2048` MB, `3072` MB, `4096` MB, `5120` MB, or `6144` MB.
         */
        memorySizeInMb: number;
        /**
         * The amount of provisioned concurrency to allocate for the serverless endpoint. Should be less than or equal to `maxConcurrency`. Valid values are between `1` and `200`.
         */
        provisionedConcurrency?: number;
    }
    interface EndpointConfigurationShadowProductionVariant {
        acceleratorType?: string;
        containerStartupHealthCheckTimeoutInSeconds?: number;
        coreDumpConfig?: outputs.sagemaker.EndpointConfigurationShadowProductionVariantCoreDumpConfig;
        enableSsmAccess?: boolean;
        initialInstanceCount?: number;
        initialVariantWeight?: number;
        instanceType?: string;
        modelDataDownloadTimeoutInSeconds?: number;
        modelName: string;
        routingConfigs?: outputs.sagemaker.EndpointConfigurationShadowProductionVariantRoutingConfig[];
        serverlessConfig?: outputs.sagemaker.EndpointConfigurationShadowProductionVariantServerlessConfig;
        variantName: string;
        volumeSizeInGb?: number;
    }
    interface EndpointConfigurationShadowProductionVariantCoreDumpConfig {
        /**
         * The Amazon S3 bucket to send the core dump to.
         */
        destinationS3Uri: string;
        /**
         * The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker uses to encrypt the core dump data at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId: string;
    }
    interface EndpointConfigurationShadowProductionVariantRoutingConfig {
        /**
         * Sets how the endpoint routes incoming traffic. Valid values are `LEAST_OUTSTANDING_REQUESTS` and `RANDOM`. `LEAST_OUTSTANDING_REQUESTS` routes requests to the specific instances that have more capacity to process them. `RANDOM` routes each request to a randomly chosen instance.
         */
        routingStrategy: string;
    }
    interface EndpointConfigurationShadowProductionVariantServerlessConfig {
        /**
         * The maximum number of concurrent invocations your serverless endpoint can process. Valid values are between `1` and `200`.
         */
        maxConcurrency: number;
        /**
         * The memory size of your serverless endpoint. Valid values are in 1 GB increments: `1024` MB, `2048` MB, `3072` MB, `4096` MB, `5120` MB, or `6144` MB.
         */
        memorySizeInMb: number;
        /**
         * The amount of provisioned concurrency to allocate for the serverless endpoint. Should be less than or equal to `maxConcurrency`. Valid values are between `1` and `200`.
         */
        provisionedConcurrency?: number;
    }
    interface EndpointDeploymentConfig {
        /**
         * Automatic rollback configuration for handling endpoint deployment failures and recovery. See Auto Rollback Configuration.
         */
        autoRollbackConfiguration?: outputs.sagemaker.EndpointDeploymentConfigAutoRollbackConfiguration;
        /**
         * Update policy for a blue/green deployment. If this update policy is specified, SageMaker creates a new fleet during the deployment while maintaining the old fleet. SageMaker flips traffic to the new fleet according to the specified traffic routing configuration. Only one update policy should be used in the deployment configuration. If no update policy is specified, SageMaker uses a blue/green deployment strategy with all at once traffic shifting by default. See Blue Green Update Config.
         */
        blueGreenUpdatePolicy?: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicy;
        /**
         * Specifies a rolling deployment strategy for updating a SageMaker endpoint. See Rolling Update Policy.
         */
        rollingUpdatePolicy?: outputs.sagemaker.EndpointDeploymentConfigRollingUpdatePolicy;
    }
    interface EndpointDeploymentConfigAutoRollbackConfiguration {
        /**
         * List of CloudWatch alarms in your account that are configured to monitor metrics on an endpoint. If any alarms are tripped during a deployment, SageMaker rolls back the deployment. See Alarms.
         */
        alarms?: outputs.sagemaker.EndpointDeploymentConfigAutoRollbackConfigurationAlarm[];
    }
    interface EndpointDeploymentConfigAutoRollbackConfigurationAlarm {
        /**
         * The name of a CloudWatch alarm in your account.
         */
        alarmName: string;
    }
    interface EndpointDeploymentConfigBlueGreenUpdatePolicy {
        maximumExecutionTimeoutInSeconds?: number;
        terminationWaitInSeconds?: number;
        trafficRoutingConfiguration: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfiguration;
    }
    interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfiguration {
        /**
         * Batch size for the first step to turn on traffic on the new endpoint fleet. Value must be less than or equal to 50% of the variant's total instance count. See Canary Size.
         */
        canarySize?: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationCanarySize;
        /**
         * Batch size for each step to turn on traffic on the new endpoint fleet. Value must be 10-50% of the variant's total instance count. See Linear Step Size.
         */
        linearStepSize?: outputs.sagemaker.EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationLinearStepSize;
        /**
         * Traffic routing strategy type. Valid values are: `ALL_AT_ONCE`, `CANARY`, and `LINEAR`.
         */
        type: string;
        /**
         * The waiting time (in seconds) between incremental steps to turn on traffic on the new endpoint fleet. Valid values are between `0` and `3600`.
         */
        waitIntervalInSeconds: number;
    }
    interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationCanarySize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }
    interface EndpointDeploymentConfigBlueGreenUpdatePolicyTrafficRoutingConfigurationLinearStepSize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }
    interface EndpointDeploymentConfigRollingUpdatePolicy {
        /**
         * Batch size for each rolling step to provision capacity and turn on traffic on the new endpoint fleet, and terminate capacity on the old endpoint fleet. Value must be between 5% to 50% of the variant's total instance count. See Maximum Batch Size.
         */
        maximumBatchSize: outputs.sagemaker.EndpointDeploymentConfigRollingUpdatePolicyMaximumBatchSize;
        /**
         * The time limit for the total deployment. Exceeding this limit causes a timeout. Valid values are between `600` and `14400`.
         */
        maximumExecutionTimeoutInSeconds?: number;
        /**
         * Batch size for rollback to the old endpoint fleet. Each rolling step to provision capacity and turn on traffic on the old endpoint fleet, and terminate capacity on the new endpoint fleet. If this field is absent, the default value will be set to 100% of total capacity which means to bring up the whole capacity of the old fleet at once during rollback. See Rollback Maximum Batch Size.
         */
        rollbackMaximumBatchSize?: outputs.sagemaker.EndpointDeploymentConfigRollingUpdatePolicyRollbackMaximumBatchSize;
        /**
         * The length of the baking period, during which SageMaker monitors alarms for each batch on the new fleet. Valid values are between `0` and `3600`.
         */
        waitIntervalInSeconds: number;
    }
    interface EndpointDeploymentConfigRollingUpdatePolicyMaximumBatchSize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }
    interface EndpointDeploymentConfigRollingUpdatePolicyRollbackMaximumBatchSize {
        /**
         * Specifies the endpoint capacity type. Valid values are: `INSTANCE_COUNT`, or `CAPACITY_PERCENT`.
         */
        type: string;
        /**
         * Defines the capacity size, either as a number of instances or a capacity percentage.
         */
        value: number;
    }
    interface FeatureGroupFeatureDefinition {
        /**
         * The name of a feature. `featureName` cannot be any of the following: `isDeleted`, `writeTime`, `apiInvocationTime`.
         */
        featureName?: string;
        /**
         * The value type of a feature. Valid values are `Integral`, `Fractional`, or `String`.
         */
        featureType?: string;
    }
    interface FeatureGroupOfflineStoreConfig {
        /**
         * The meta data of the Glue table that is autogenerated when an OfflineStore is created. See Data Catalog Config Below.
         */
        dataCatalogConfig: outputs.sagemaker.FeatureGroupOfflineStoreConfigDataCatalogConfig;
        disableGlueTableCreation?: boolean;
        /**
         * The Amazon Simple Storage (Amazon S3) location of OfflineStore. See S3 Storage Config Below.
         */
        s3StorageConfig: outputs.sagemaker.FeatureGroupOfflineStoreConfigS3StorageConfig;
        /**
         * Format for the offline store table. Supported formats are `Glue` (Default) and Apache `Iceberg` (https://iceberg.apache.org/).
         */
        tableFormat?: string;
    }
    interface FeatureGroupOfflineStoreConfigDataCatalogConfig {
        /**
         * The name of the Glue table catalog.
         */
        catalog: string;
        /**
         * The name of the Glue table database.
         */
        database: string;
        /**
         * The name of the Glue table.
         */
        tableName: string;
    }
    interface FeatureGroupOfflineStoreConfigS3StorageConfig {
        /**
         * The AWS Key Management Service (KMS) key ID of the key used to encrypt any objects written into the OfflineStore S3 location.
         */
        kmsKeyId?: string;
        /**
         * The S3 path where offline records are written.
         */
        resolvedOutputS3Uri: string;
        /**
         * The S3 URI, or location in Amazon S3, of OfflineStore.
         */
        s3Uri: string;
    }
    interface FeatureGroupOnlineStoreConfig {
        enableOnlineStore?: boolean;
        /**
         * Security config for at-rest encryption of your OnlineStore. See Security Config Below.
         */
        securityConfig?: outputs.sagemaker.FeatureGroupOnlineStoreConfigSecurityConfig;
        /**
         * Option for different tiers of low latency storage for real-time data retrieval. Valid values are `Standard`, or `InMemory`.
         */
        storageType?: string;
        /**
         * Time to live duration, where the record is hard deleted after the expiration time is reached; ExpiresAt = EventTime + TtlDuration.. See TTl Duration Below.
         */
        ttlDuration?: outputs.sagemaker.FeatureGroupOnlineStoreConfigTtlDuration;
    }
    interface FeatureGroupOnlineStoreConfigSecurityConfig {
        /**
         * The ID of the AWS Key Management Service (AWS KMS) key that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
    }
    interface FeatureGroupOnlineStoreConfigTtlDuration {
        /**
         * TtlDuration time unit. Valid values are `Seconds`, `Minutes`, `Hours`, `Days`, or `Weeks`.
         */
        unit?: string;
        /**
         * TtlDuration time value.
         */
        value?: number;
    }
    interface FlowDefinitionHumanLoopActivationConfig {
        /**
         * defines under what conditions SageMaker creates a human loop. See Human Loop Activation Conditions Config details below.
         */
        humanLoopActivationConditionsConfig?: outputs.sagemaker.FlowDefinitionHumanLoopActivationConfigHumanLoopActivationConditionsConfig;
    }
    interface FlowDefinitionHumanLoopActivationConfigHumanLoopActivationConditionsConfig {
        /**
         * A JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team. For more information about how to structure the JSON, see [JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI](https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html).
         */
        humanLoopActivationConditions: string;
    }
    interface FlowDefinitionHumanLoopConfig {
        /**
         * The Amazon Resource Name (ARN) of the human task user interface.
         */
        humanTaskUiArn: string;
        /**
         * Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. See Public Workforce Task Price details below.
         */
        publicWorkforceTaskPrice?: outputs.sagemaker.FlowDefinitionHumanLoopConfigPublicWorkforceTaskPrice;
        /**
         * The length of time that a task remains available for review by human workers. Valid value range between `1` and `864000`.
         */
        taskAvailabilityLifetimeInSeconds?: number;
        /**
         * The number of distinct workers who will perform the same task on each object. Valid value range between `1` and `3`.
         */
        taskCount: number;
        /**
         * A description for the human worker task.
         */
        taskDescription: string;
        /**
         * An array of keywords used to describe the task so that workers can discover the task.
         */
        taskKeywords?: string[];
        /**
         * The amount of time that a worker has to complete a task. The default value is `3600` seconds.
         */
        taskTimeLimitInSeconds?: number;
        /**
         * A title for the human worker task.
         */
        taskTitle: string;
        /**
         * The Amazon Resource Name (ARN) of the human task user interface. Amazon Resource Name (ARN) of a team of workers. For Public workforces see [AWS Docs](https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management-public.html).
         */
        workteamArn: string;
    }
    interface FlowDefinitionHumanLoopConfigPublicWorkforceTaskPrice {
        /**
         * Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars. See Amount In Usd details below.
         */
        amountInUsd?: outputs.sagemaker.FlowDefinitionHumanLoopConfigPublicWorkforceTaskPriceAmountInUsd;
    }
    interface FlowDefinitionHumanLoopConfigPublicWorkforceTaskPriceAmountInUsd {
        /**
         * The fractional portion, in cents, of the amount. Valid value range between `0` and `99`.
         */
        cents?: number;
        /**
         * The whole number of dollars in the amount. Valid value range between `0` and `2`.
         */
        dollars?: number;
        /**
         * Fractions of a cent, in tenths. Valid value range between `0` and `9`.
         */
        tenthFractionsOfACent?: number;
    }
    interface FlowDefinitionHumanLoopRequestSource {
        /**
         * Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source. Valid values are: `AWS/Rekognition/DetectModerationLabels/Image/V3` and `AWS/Textract/AnalyzeDocument/Forms/V1`.
         */
        awsManagedHumanLoopRequestSource: string;
    }
    interface FlowDefinitionOutputConfig {
        /**
         * The Amazon Key Management Service (KMS) key ARN for server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * The Amazon S3 path where the object containing human output will be made available.
         */
        s3OutputPath: string;
    }
    interface HumanTaskUIUiTemplate {
        /**
         * The content of the Liquid template for the worker user interface.
         */
        content?: string;
        /**
         * The SHA-256 digest of the contents of the template.
         */
        contentSha256: string;
        /**
         * The URL for the user interface template.
         */
        url: string;
    }
    interface ModelContainer {
        /**
         * The DNS host name for the container.
         */
        containerHostname?: string;
        /**
         * Environment variables for the Docker container.
         * A list of key value pairs.
         */
        environment?: {
            [key: string]: string;
        };
        /**
         * The registry path where the inference code image is stored in Amazon ECR.
         */
        image?: string;
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). For more information see [Using a Private Docker Registry for Real-Time Inference Containers](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html). see Image Config.
         */
        imageConfig?: outputs.sagemaker.ModelContainerImageConfig;
        /**
         * The container hosts value `SingleModel/MultiModel`. The default value is `SingleModel`.
         */
        mode?: string;
        /**
         * The location of model data to deploy. Use this for uncompressed model deployment. For information about how to deploy an uncompressed model, see [Deploying uncompressed models](https://docs.aws.amazon.com/sagemaker/latest/dg/large-model-inference-uncompressed.html) in the _AWS SageMaker Developer Guide_.
         */
        modelDataSource: outputs.sagemaker.ModelContainerModelDataSource;
        /**
         * The URL for the S3 location where model artifacts are stored.
         */
        modelDataUrl?: string;
        /**
         * The Amazon Resource Name (ARN) of the model package to use to create the model.
         */
        modelPackageName?: string;
    }
    interface ModelContainerImageConfig {
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: `Platform` and `Vpc`.
         */
        repositoryAccessMode: string;
        /**
         * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
         */
        repositoryAuthConfig?: outputs.sagemaker.ModelContainerImageConfigRepositoryAuthConfig;
    }
    interface ModelContainerImageConfigRepositoryAuthConfig {
        /**
         * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see [Create a Lambda function with the console](https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html) in the _AWS Lambda Developer Guide_.
         */
        repositoryCredentialsProviderArn: string;
    }
    interface ModelContainerModelDataSource {
        /**
         * The S3 location of model data to deploy.
         */
        s3DataSources: outputs.sagemaker.ModelContainerModelDataSourceS3DataSource[];
    }
    interface ModelContainerModelDataSourceS3DataSource {
        /**
         * How the model data is prepared. Allowed values are: `None` and `Gzip`.
         */
        compressionType: string;
        /**
         * The type of model data to deploy. Allowed values are: `S3Object` and `S3Prefix`.
         */
        s3DataType: string;
        /**
         * The S3 path of model data to deploy.
         */
        s3Uri: string;
    }
    interface ModelInferenceExecutionConfig {
        mode: string;
    }
    interface ModelPrimaryContainer {
        containerHostname?: string;
        environment?: {
            [key: string]: string;
        };
        image?: string;
        imageConfig?: outputs.sagemaker.ModelPrimaryContainerImageConfig;
        mode?: string;
        modelDataSource: outputs.sagemaker.ModelPrimaryContainerModelDataSource;
        modelDataUrl?: string;
        modelPackageName?: string;
    }
    interface ModelPrimaryContainerImageConfig {
        /**
         * Specifies whether the model container is in Amazon ECR or a private Docker registry accessible from your Amazon Virtual Private Cloud (VPC). Allowed values are: `Platform` and `Vpc`.
         */
        repositoryAccessMode: string;
        /**
         * Specifies an authentication configuration for the private docker registry where your model image is hosted. Specify a value for this property only if you specified Vpc as the value for the RepositoryAccessMode field, and the private Docker registry where the model image is hosted requires authentication. see Repository Auth Config.
         */
        repositoryAuthConfig?: outputs.sagemaker.ModelPrimaryContainerImageConfigRepositoryAuthConfig;
    }
    interface ModelPrimaryContainerImageConfigRepositoryAuthConfig {
        /**
         * The Amazon Resource Name (ARN) of an AWS Lambda function that provides credentials to authenticate to the private Docker registry where your model image is hosted. For information about how to create an AWS Lambda function, see [Create a Lambda function with the console](https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html) in the _AWS Lambda Developer Guide_.
         */
        repositoryCredentialsProviderArn: string;
    }
    interface ModelPrimaryContainerModelDataSource {
        /**
         * The S3 location of model data to deploy.
         */
        s3DataSources: outputs.sagemaker.ModelPrimaryContainerModelDataSourceS3DataSource[];
    }
    interface ModelPrimaryContainerModelDataSourceS3DataSource {
        /**
         * How the model data is prepared. Allowed values are: `None` and `Gzip`.
         */
        compressionType: string;
        /**
         * The type of model data to deploy. Allowed values are: `S3Object` and `S3Prefix`.
         */
        s3DataType: string;
        /**
         * The S3 path of model data to deploy.
         */
        s3Uri: string;
    }
    interface ModelVpcConfig {
        securityGroupIds: string[];
        subnets: string[];
    }
    interface MonitoringScheduleMonitoringScheduleConfig {
        /**
         * The name of the monitoring job definition to schedule.
         */
        monitoringJobDefinitionName: string;
        /**
         * The type of the monitoring job definition to schedule. Valid values are `DataQuality`, `ModelQuality`, `ModelBias` or `ModelExplainability`
         */
        monitoringType: string;
        /**
         * Configures the monitoring schedule. Fields are documented below.
         */
        scheduleConfig: outputs.sagemaker.MonitoringScheduleMonitoringScheduleConfigScheduleConfig;
    }
    interface MonitoringScheduleMonitoringScheduleConfigScheduleConfig {
        /**
         * A cron expression that describes details about the monitoring schedule. For example, and hourly schedule would be `cron(0 * ? * * *)`.
         */
        scheduleExpression: string;
    }
    interface NotebookInstanceInstanceMetadataServiceConfiguration {
        /**
         * Indicates the minimum IMDS version that the notebook instance supports. When passed "1" is passed. This means that both IMDSv1 and IMDSv2 are supported. Valid values are `1` and `2`.
         */
        minimumInstanceMetadataServiceVersion: string;
    }
    interface PipelineParallelismConfiguration {
        /**
         * The max number of steps that can be executed in parallel.
         */
        maxParallelExecutionSteps: number;
    }
    interface PipelinePipelineDefinitionS3Location {
        /**
         * Name of the S3 bucket.
         */
        bucket: string;
        /**
         * The object key (or key name) uniquely identifies the object in an S3 bucket.
         */
        objectKey: string;
        /**
         * Version Id of the pipeline definition file. If not specified, Amazon SageMaker will retrieve the latest version.
         */
        versionId?: string;
    }
    interface ProjectServiceCatalogProvisioningDetails {
        /**
         * The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
         */
        pathId?: string;
        /**
         * The ID of the product to provision.
         */
        productId: string;
        /**
         * The ID of the provisioning artifact.
         */
        provisioningArtifactId: string;
        /**
         * A list of key value pairs that you specify when you provision a product. See Provisioning Parameter below.
         */
        provisioningParameters?: outputs.sagemaker.ProjectServiceCatalogProvisioningDetailsProvisioningParameter[];
    }
    interface ProjectServiceCatalogProvisioningDetailsProvisioningParameter {
        /**
         * The key that identifies a provisioning parameter.
         */
        key: string;
        /**
         * The value of the provisioning parameter.
         */
        value?: string;
    }
    interface SpaceOwnershipSettings {
        /**
         * The user profile who is the owner of the private space.
         */
        ownerUserProfileName: string;
    }
    interface SpaceSpaceSettings {
        /**
         * The type of app created within the space.
         */
        appType?: string;
        /**
         * The Code Editor application settings. See Code Editor App Settings below.
         */
        codeEditorAppSettings?: outputs.sagemaker.SpaceSpaceSettingsCodeEditorAppSettings;
        /**
         * A file system, created by you, that you assign to a space for an Amazon SageMaker Domain. See Custom File System below.
         */
        customFileSystems?: outputs.sagemaker.SpaceSpaceSettingsCustomFileSystem[];
        /**
         * The settings for the JupyterLab application. See Jupyter Lab App Settings below.
         */
        jupyterLabAppSettings?: outputs.sagemaker.SpaceSpaceSettingsJupyterLabAppSettings;
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettings;
        spaceStorageSettings: outputs.sagemaker.SpaceSpaceSettingsSpaceStorageSettings;
    }
    interface SpaceSpaceSettingsCodeEditorAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsCodeEditorAppSettingsDefaultResourceSpec;
    }
    interface SpaceSpaceSettingsCodeEditorAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface SpaceSpaceSettingsCustomFileSystem {
        /**
         * A custom file system in Amazon EFS. see EFS File System below.
         */
        efsFileSystem: outputs.sagemaker.SpaceSpaceSettingsCustomFileSystemEfsFileSystem;
    }
    interface SpaceSpaceSettingsCustomFileSystemEfsFileSystem {
        /**
         * The ID of your Amazon EFS file system.
         */
        fileSystemId: string;
    }
    interface SpaceSpaceSettingsJupyterLabAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.SpaceSpaceSettingsJupyterLabAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsJupyterLabAppSettingsDefaultResourceSpec;
    }
    interface SpaceSpaceSettingsJupyterLabAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface SpaceSpaceSettingsJupyterLabAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface SpaceSpaceSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface SpaceSpaceSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface SpaceSpaceSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface SpaceSpaceSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec: outputs.sagemaker.SpaceSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface SpaceSpaceSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface SpaceSpaceSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type.
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image created on the instance.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface SpaceSpaceSettingsSpaceStorageSettings {
        ebsStorageSettings: outputs.sagemaker.SpaceSpaceSettingsSpaceStorageSettingsEbsStorageSettings;
    }
    interface SpaceSpaceSettingsSpaceStorageSettingsEbsStorageSettings {
        ebsVolumeSizeInGb: number;
    }
    interface SpaceSpaceSharingSettings {
        /**
         * Specifies the sharing type of the space. Valid values are `Private` and `Shared`.
         */
        sharingType: string;
    }
    interface UserProfileUserSettings {
        /**
         * The Canvas app settings. See Canvas App Settings below.
         */
        canvasAppSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettings;
        /**
         * The Code Editor application settings. See Code Editor App Settings below.
         */
        codeEditorAppSettings?: outputs.sagemaker.UserProfileUserSettingsCodeEditorAppSettings;
        /**
         * The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio. See Custom File System Config below.
         */
        customFileSystemConfigs?: outputs.sagemaker.UserProfileUserSettingsCustomFileSystemConfig[];
        /**
         * Details about the POSIX identity that is used for file system operations. See Custom Posix User Config below.
         */
        customPosixUserConfig?: outputs.sagemaker.UserProfileUserSettingsCustomPosixUserConfig;
        /**
         * The default experience that the user is directed to when accessing the domain. The supported values are: `studio::`: Indicates that Studio is the default experience. This value can only be passed if StudioWebPortal is set to ENABLED. `app:JupyterServer:`: Indicates that Studio Classic is the default experience.
         */
        defaultLandingUri?: string;
        /**
         * The execution role ARN for the user.
         */
        executionRole: string;
        /**
         * The settings for the JupyterLab application. See Jupyter Lab App Settings below.
         */
        jupyterLabAppSettings?: outputs.sagemaker.UserProfileUserSettingsJupyterLabAppSettings;
        /**
         * The Jupyter server's app settings. See Jupyter Server App Settings below.
         */
        jupyterServerAppSettings?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettings;
        /**
         * The kernel gateway app settings. See Kernel Gateway App Settings below.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettings;
        /**
         * The RSession app settings. See RSession App Settings below.
         */
        rSessionAppSettings?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettings;
        /**
         * A collection of settings that configure user interaction with the RStudioServerPro app. See RStudioServerProAppSettings below.
         */
        rStudioServerProAppSettings?: outputs.sagemaker.UserProfileUserSettingsRStudioServerProAppSettings;
        /**
         * A list of security group IDs that will be attached to the user.
         */
        securityGroups?: string[];
        /**
         * The sharing settings. See Sharing Settings below.
         */
        sharingSettings?: outputs.sagemaker.UserProfileUserSettingsSharingSettings;
        /**
         * The storage settings for a private space. See Space Storage Settings below.
         */
        spaceStorageSettings: outputs.sagemaker.UserProfileUserSettingsSpaceStorageSettings;
        /**
         * Whether the user can access Studio. If this value is set to `DISABLED`, the user cannot access Studio, even if that is the default experience for the domain. Valid values are `ENABLED` and `DISABLED`.
         */
        studioWebPortal: string;
        /**
         * The TensorBoard app settings. See TensorBoard App Settings below.
         */
        tensorBoardAppSettings?: outputs.sagemaker.UserProfileUserSettingsTensorBoardAppSettings;
    }
    interface UserProfileUserSettingsCanvasAppSettings {
        /**
         * The model deployment settings for the SageMaker Canvas application. See Direct Deploy Settings below.
         */
        directDeploySettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsDirectDeploySettings;
        /**
         * The settings for connecting to an external data source with OAuth. See Identity Provider OAuth Settings below.
         */
        identityProviderOauthSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsIdentityProviderOauthSetting[];
        /**
         * The settings for document querying. See Kendra Settings below.
         */
        kendraSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsKendraSettings;
        /**
         * The model registry settings for the SageMaker Canvas application. See Model Register Settings below.
         */
        modelRegisterSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsModelRegisterSettings;
        /**
         * Time series forecast settings for the Canvas app. See Time Series Forecasting Settings below.
         */
        timeSeriesForecastingSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings;
        /**
         * The workspace settings for the SageMaker Canvas application. See Workspace Settings below.
         */
        workspaceSettings?: outputs.sagemaker.UserProfileUserSettingsCanvasAppSettingsWorkspaceSettings;
    }
    interface UserProfileUserSettingsCanvasAppSettingsDirectDeploySettings {
        /**
         * Describes whether model deployment permissions are enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface UserProfileUserSettingsCanvasAppSettingsIdentityProviderOauthSetting {
        /**
         * The name of the data source that you're connecting to. Canvas currently supports OAuth for Snowflake and Salesforce Data Cloud. Valid values are `SalesforceGenie` and `Snowflake`.
         */
        dataSourceName?: string;
        /**
         * The ARN of an Amazon Web Services Secrets Manager secret that stores the credentials from your identity provider, such as the client ID and secret, authorization URL, and token URL.
         */
        secretArn: string;
        /**
         * Describes whether OAuth for a data source is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface UserProfileUserSettingsCanvasAppSettingsKendraSettings {
        /**
         * Describes whether the document querying feature is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface UserProfileUserSettingsCanvasAppSettingsModelRegisterSettings {
        /**
         * The Amazon Resource Name (ARN) of the SageMaker model registry account. Required only to register model versions created by a different SageMaker Canvas AWS account than the AWS account in which SageMaker model registry is set up.
         */
        crossAccountModelRegisterRoleArn?: string;
        /**
         * Describes whether the integration to the model registry is enabled or disabled in the Canvas application. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface UserProfileUserSettingsCanvasAppSettingsTimeSeriesForecastingSettings {
        /**
         * The IAM role that Canvas passes to Amazon Forecast for time series forecasting. By default, Canvas uses the execution role specified in the UserProfile that launches the Canvas app. If an execution role is not specified in the UserProfile, Canvas uses the execution role specified in the Domain that owns the UserProfile. To allow time series forecasting, this IAM role should have the [AmazonSageMakerCanvasForecastAccess](https://docs.aws.amazon.com/sagemaker/latest/dg/security-iam-awsmanpol-canvas.html#security-iam-awsmanpol-AmazonSageMakerCanvasForecastAccess) policy attached and forecast.amazonaws.com added in the trust relationship as a service principal.
         */
        amazonForecastRoleArn?: string;
        /**
         * Describes whether time series forecasting is enabled or disabled in the Canvas app. Valid values are `ENABLED` and `DISABLED`.
         */
        status?: string;
    }
    interface UserProfileUserSettingsCanvasAppSettingsWorkspaceSettings {
        /**
         * The Amazon S3 bucket used to store artifacts generated by Canvas. Updating the Amazon S3 location impacts existing configuration settings, and Canvas users no longer have access to their artifacts. Canvas users must log out and log back in to apply the new location.
         */
        s3ArtifactPath?: string;
        /**
         * The Amazon Web Services Key Management Service (KMS) encryption key ID that is used to encrypt artifacts generated by Canvas in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
    }
    interface UserProfileUserSettingsCodeEditorAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsCodeEditorAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface UserProfileUserSettingsCodeEditorAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface UserProfileUserSettingsCustomFileSystemConfig {
        /**
         * The default EBS storage settings for a private space. See EFS File System Config below.
         */
        efsFileSystemConfigs?: outputs.sagemaker.UserProfileUserSettingsCustomFileSystemConfigEfsFileSystemConfig[];
    }
    interface UserProfileUserSettingsCustomFileSystemConfigEfsFileSystemConfig {
        /**
         * The ID of your Amazon EFS file system.
         */
        fileSystemId: string;
        /**
         * The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
         */
        fileSystemPath?: string;
    }
    interface UserProfileUserSettingsCustomPosixUserConfig {
        /**
         * The POSIX group ID.
         */
        gid: number;
        /**
         * The POSIX user ID.
         */
        uid: number;
    }
    interface UserProfileUserSettingsJupyterLabAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.UserProfileUserSettingsJupyterLabAppSettingsCodeRepository[];
        customImages?: outputs.sagemaker.UserProfileUserSettingsJupyterLabAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsJupyterLabAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface UserProfileUserSettingsJupyterLabAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface UserProfileUserSettingsJupyterLabAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface UserProfileUserSettingsJupyterLabAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface UserProfileUserSettingsJupyterServerAppSettings {
        /**
         * A list of Git repositories that SageMaker automatically displays to users for cloning in the JupyterServer application. see Code Repository below.
         */
        codeRepositories?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettingsCodeRepository[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsJupyterServerAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface UserProfileUserSettingsJupyterServerAppSettingsCodeRepository {
        /**
         * The URL of the Git repository.
         */
        repositoryUrl: string;
    }
    interface UserProfileUserSettingsJupyterServerAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface UserProfileUserSettingsKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsKernelGatewayAppSettingsDefaultResourceSpec;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configurations.
         */
        lifecycleConfigArns?: string[];
    }
    interface UserProfileUserSettingsKernelGatewayAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface UserProfileUserSettingsKernelGatewayAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface UserProfileUserSettingsRSessionAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app. see Custom Image below.
         */
        customImages?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettingsCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsRSessionAppSettingsDefaultResourceSpec;
    }
    interface UserProfileUserSettingsRSessionAppSettingsCustomImage {
        /**
         * The name of the App Image Config.
         */
        appImageConfigName: string;
        /**
         * The name of the Custom Image.
         */
        imageName: string;
        /**
         * The version number of the Custom Image.
         */
        imageVersionNumber?: number;
    }
    interface UserProfileUserSettingsRSessionAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface UserProfileUserSettingsRStudioServerProAppSettings {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app. Valid values are `ENABLED` and `DISABLED`.
         */
        accessStatus?: string;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to `R_STUDIO_USER`. The `R_STUDIO_ADMIN` value allows the user access to the RStudio Administrative Dashboard. Valid values are `R_STUDIO_USER` and `R_STUDIO_ADMIN`.
         */
        userGroup?: string;
    }
    interface UserProfileUserSettingsSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is `Disabled`. Valid values are `Allowed` and `Disabled`.
         */
        notebookOutputOption?: string;
        /**
         * When `notebookOutputOption` is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When `notebookOutputOption` is Allowed, the Amazon S3 bucket used to save the notebook cell output.
         */
        s3OutputPath?: string;
    }
    interface UserProfileUserSettingsSpaceStorageSettings {
        /**
         * The default EBS storage settings for a private space. See Default EBS Storage Settings below.
         */
        defaultEbsStorageSettings?: outputs.sagemaker.UserProfileUserSettingsSpaceStorageSettingsDefaultEbsStorageSettings;
    }
    interface UserProfileUserSettingsSpaceStorageSettingsDefaultEbsStorageSettings {
        /**
         * The default size of the EBS storage volume for a private space.
         */
        defaultEbsVolumeSizeInGb: number;
        /**
         * The maximum size of the EBS storage volume for a private space.
         */
        maximumEbsVolumeSizeInGb: number;
    }
    interface UserProfileUserSettingsTensorBoardAppSettings {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance. see Default Resource Spec below.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileUserSettingsTensorBoardAppSettingsDefaultResourceSpec;
    }
    interface UserProfileUserSettingsTensorBoardAppSettingsDefaultResourceSpec {
        /**
         * The instance type that the image version runs on.. For valid values see [SageMaker Instance Types](https://docs.aws.amazon.com/sagemaker/latest/dg/notebooks-available-instance-types.html).
         */
        instanceType?: string;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration attached to the Resource.
         */
        lifecycleConfigArn?: string;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sagemakerImageArn?: string;
        /**
         * The SageMaker Image Version Alias.
         */
        sagemakerImageVersionAlias?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sagemakerImageVersionArn?: string;
    }
    interface WorkforceCognitoConfig {
        /**
         * The client ID for your Amazon Cognito user pool.
         */
        clientId: string;
        /**
         * ID for your Amazon Cognito user pool.
         */
        userPool: string;
    }
    interface WorkforceOidcConfig {
        /**
         * The OIDC IdP authorization endpoint used to configure your private workforce.
         */
        authorizationEndpoint: string;
        /**
         * The OIDC IdP client ID used to configure your private workforce.
         */
        clientId: string;
        /**
         * The OIDC IdP client secret used to configure your private workforce.
         */
        clientSecret: string;
        /**
         * The OIDC IdP issuer used to configure your private workforce.
         */
        issuer: string;
        /**
         * The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.
         */
        jwksUri: string;
        /**
         * The OIDC IdP logout endpoint used to configure your private workforce.
         */
        logoutEndpoint: string;
        /**
         * The OIDC IdP token endpoint used to configure your private workforce.
         */
        tokenEndpoint: string;
        /**
         * The OIDC IdP user information endpoint used to configure your private workforce.
         */
        userInfoEndpoint: string;
    }
    interface WorkforceSourceIpConfig {
        /**
         * A list of up to 10 CIDR values.
         */
        cidrs: string[];
    }
    interface WorkforceWorkforceVpcConfig {
        /**
         * The VPC security group IDs. The security groups must be for the same VPC as specified in the subnet.
         */
        securityGroupIds?: string[];
        /**
         * The ID of the subnets in the VPC that you want to connect.
         */
        subnets?: string[];
        /**
         * The IDs for the VPC service endpoints of your VPC workforce.
         */
        vpcEndpointId: string;
        /**
         * The ID of the VPC that the workforce uses for communication.
         */
        vpcId?: string;
    }
    interface WorkteamMemberDefinition {
        /**
         * The Amazon Cognito user group that is part of the work team. See Cognito Member Definition details below.
         */
        cognitoMemberDefinition?: outputs.sagemaker.WorkteamMemberDefinitionCognitoMemberDefinition;
        /**
         * A list user groups that exist in your OIDC Identity Provider (IdP). One to ten groups can be used to create a single private work team. See Cognito Member Definition details below.
         */
        oidcMemberDefinition?: outputs.sagemaker.WorkteamMemberDefinitionOidcMemberDefinition;
    }
    interface WorkteamMemberDefinitionCognitoMemberDefinition {
        /**
         * An identifier for an application client. You must create the app client ID using Amazon Cognito.
         */
        clientId: string;
        /**
         * An identifier for a user group.
         */
        userGroup: string;
        /**
         * An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
         */
        userPool: string;
    }
    interface WorkteamMemberDefinitionOidcMemberDefinition {
        /**
         * A list of comma separated strings that identifies user groups in your OIDC IdP. Each user group is made up of a group of private workers.
         */
        groups: string[];
    }
    interface WorkteamNotificationConfiguration {
        /**
         * The ARN for the SNS topic to which notifications should be published.
         */
        notificationTopicArn?: string;
    }
}
export declare namespace scheduler {
    interface ScheduleFlexibleTimeWindow {
        /**
         * Maximum time window during which a schedule can be invoked. Ranges from `1` to `1440` minutes.
         */
        maximumWindowInMinutes?: number;
        /**
         * Determines whether the schedule is invoked within a flexible time window. One of: `OFF`, `FLEXIBLE`.
         */
        mode: string;
    }
    interface ScheduleTarget {
        /**
         * ARN of the target of this schedule, such as a SQS queue or ECS cluster. For universal targets, this is a [Service ARN specific to the target service](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html#supported-universal-targets).
         */
        arn: string;
        /**
         * Information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue. Detailed below.
         */
        deadLetterConfig?: outputs.scheduler.ScheduleTargetDeadLetterConfig;
        /**
         * Templated target type for the Amazon ECS [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation. Detailed below.
         */
        ecsParameters?: outputs.scheduler.ScheduleTargetEcsParameters;
        /**
         * Templated target type for the EventBridge [`PutEvents`](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation. Detailed below.
         */
        eventbridgeParameters?: outputs.scheduler.ScheduleTargetEventbridgeParameters;
        /**
         * Text, or well-formed JSON, passed to the target. Read more in [Universal target](https://docs.aws.amazon.com/scheduler/latest/UserGuide/managing-targets-universal.html).
         */
        input?: string;
        /**
         * Templated target type for the Amazon Kinesis [`PutRecord`](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html) API operation. Detailed below.
         */
        kinesisParameters?: outputs.scheduler.ScheduleTargetKinesisParameters;
        /**
         * Information about the retry policy settings. Detailed below.
         */
        retryPolicy?: outputs.scheduler.ScheduleTargetRetryPolicy;
        /**
         * ARN of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked. Read more in [Set up the execution role](https://docs.aws.amazon.com/scheduler/latest/UserGuide/setting-up.html#setting-up-execution-role).
         *
         * The following arguments are optional:
         */
        roleArn: string;
        /**
         * Templated target type for the Amazon SageMaker [`StartPipelineExecution`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation. Detailed below.
         */
        sagemakerPipelineParameters?: outputs.scheduler.ScheduleTargetSagemakerPipelineParameters;
        /**
         * The templated target type for the Amazon SQS [`SendMessage`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Detailed below.
         */
        sqsParameters?: outputs.scheduler.ScheduleTargetSqsParameters;
    }
    interface ScheduleTargetDeadLetterConfig {
        /**
         * ARN of the SQS queue specified as the destination for the dead-letter queue.
         */
        arn: string;
    }
    interface ScheduleTargetEcsParameters {
        /**
         * Up to `6` capacity provider strategies to use for the task. Detailed below.
         */
        capacityProviderStrategies?: outputs.scheduler.ScheduleTargetEcsParametersCapacityProviderStrategy[];
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon ECS Developer Guide.
         */
        enableEcsManagedTags?: boolean;
        /**
         * Specifies whether to enable the execute command functionality for the containers in this task.
         */
        enableExecuteCommand?: boolean;
        /**
         * Specifies an ECS task group for the task. At most 255 characters.
         */
        group?: string;
        /**
         * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. One of: `EC2`, `FARGATE`, `EXTERNAL`.
         */
        launchType?: string;
        /**
         * Configures the networking associated with the task. Detailed below.
         */
        networkConfiguration?: outputs.scheduler.ScheduleTargetEcsParametersNetworkConfiguration;
        /**
         * A set of up to 10 placement constraints to use for the task. Detailed below.
         */
        placementConstraints?: outputs.scheduler.ScheduleTargetEcsParametersPlacementConstraint[];
        /**
         * A set of up to 5 placement strategies. Detailed below.
         */
        placementStrategies?: outputs.scheduler.ScheduleTargetEcsParametersPlacementStrategy[];
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`.
         */
        platformVersion?: string;
        /**
         * Specifies whether to propagate the tags from the task definition to the task. One of: `TASK_DEFINITION`.
         */
        propagateTags?: string;
        /**
         * Reference ID to use for the task.
         */
        referenceId?: string;
        /**
         * The metadata that you apply to the task. Each tag consists of a key and an optional value. For more information, see [`RunTask`](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the Amazon ECS API Reference.
         */
        tags?: {
            [key: string]: string;
        };
        /**
         * The number of tasks to create. Ranges from `1` (default) to `10`.
         */
        taskCount?: number;
        /**
         * ARN of the task definition to use.
         *
         * The following arguments are optional:
         */
        taskDefinitionArn: string;
    }
    interface ScheduleTargetEcsParametersCapacityProviderStrategy {
        /**
         * How many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Ranges from `0` (default) to `100000`.
         */
        base?: number;
        /**
         * Short name of the capacity provider.
         */
        capacityProvider: string;
        /**
         * Designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Ranges from from `0` to `1000`.
         */
        weight?: number;
    }
    interface ScheduleTargetEcsParametersNetworkConfiguration {
        /**
         * Specifies whether the task's elastic network interface receives a public IP address. This attribute is a boolean type, where `true` maps to `ENABLED` and `false` to `DISABLED`. You can specify `true` only when the `launchType` is set to `FARGATE`.
         */
        assignPublicIp?: boolean;
        /**
         * Set of 1 to 5 Security Group ID-s to be associated with the task. These security groups must all be in the same VPC.
         */
        securityGroups?: string[];
        /**
         * Set of 1 to 16 subnets to be associated with the task. These subnets must all be in the same VPC.
         */
        subnets: string[];
    }
    interface ScheduleTargetEcsParametersPlacementConstraint {
        /**
         * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is `distinctInstance`. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the Amazon ECS Developer Guide.
         */
        expression?: string;
        /**
         * The type of constraint. One of: `distinctInstance`, `memberOf`.
         */
        type: string;
    }
    interface ScheduleTargetEcsParametersPlacementStrategy {
        /**
         * The field to apply the placement strategy against.
         */
        field?: string;
        /**
         * The type of placement strategy. One of: `random`, `spread`, `binpack`.
         */
        type: string;
    }
    interface ScheduleTargetEventbridgeParameters {
        /**
         * Free-form string used to decide what fields to expect in the event detail. Up to 128 characters.
         */
        detailType: string;
        /**
         * Source of the event.
         */
        source: string;
    }
    interface ScheduleTargetKinesisParameters {
        /**
         * Specifies the shard to which EventBridge Scheduler sends the event. Up to 256 characters.
         */
        partitionKey: string;
    }
    interface ScheduleTargetRetryPolicy {
        /**
         * Maximum amount of time, in seconds, to continue to make retry attempts. Ranges from `60` to `86400` (default).
         */
        maximumEventAgeInSeconds?: number;
        /**
         * Maximum number of retry attempts to make before the request fails. Ranges from `0` to `185` (default).
         */
        maximumRetryAttempts?: number;
    }
    interface ScheduleTargetSagemakerPipelineParameters {
        /**
         * Set of up to 200 parameter names and values to use when executing the SageMaker Model Building Pipeline. Detailed below.
         */
        pipelineParameters?: outputs.scheduler.ScheduleTargetSagemakerPipelineParametersPipelineParameter[];
    }
    interface ScheduleTargetSagemakerPipelineParametersPipelineParameter {
        /**
         * Name of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        name: string;
        /**
         * Value of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        value: string;
    }
    interface ScheduleTargetSqsParameters {
        /**
         * FIFO message group ID to use as the target.
         */
        messageGroupId?: string;
    }
}
export declare namespace secretsmanager {
    interface GetSecretRotationRotationRule {
        automaticallyAfterDays: number;
        duration: string;
        scheduleExpression: string;
    }
    interface GetSecretsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [Secrets Manager ListSecrets API Reference](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_ListSecrets.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface SecretReplica {
        /**
         * ARN, Key ID, or Alias of the AWS KMS key within the region secret is replicated to. If one is not specified, then Secrets Manager defaults to using the AWS account's default KMS key (`aws/secretsmanager`) in the region or creates one for use if non-existent.
         */
        kmsKeyId: string;
        /**
         * Date that you last accessed the secret in the Region.
         */
        lastAccessedDate: string;
        /**
         * Region for replicating the secret.
         */
        region: string;
        /**
         * Status can be `InProgress`, `Failed`, or `InSync`.
         */
        status: string;
        /**
         * Message such as `Replication succeeded` or `Secret with this name already exists in this region`.
         */
        statusMessage: string;
    }
    interface SecretRotationRotationRules {
        /**
         * Specifies the number of days between automatic scheduled rotations of the secret. Either `automaticallyAfterDays` or `scheduleExpression` must be specified.
         */
        automaticallyAfterDays?: number;
        /**
         * The length of the rotation window in hours. For example, `3h` for a three hour window.
         */
        duration?: string;
        /**
         * A `cron()` or `rate()` expression that defines the schedule for rotating your secret. Either `automaticallyAfterDays` or `scheduleExpression` must be specified.
         */
        scheduleExpression?: string;
    }
}
export declare namespace securityhub {
    interface AutomationRuleAction {
        /**
         * A block that specifies that the automation rule action is an update to a finding field.  Documented below.
         */
        findingFieldsUpdate?: outputs.securityhub.AutomationRuleActionFindingFieldsUpdate;
        /**
         * Specifies that the rule action should update the `Types` finding field. The `Types` finding field classifies findings in the format of namespace/category/classifier.
         */
        type?: string;
    }
    interface AutomationRuleActionFindingFieldsUpdate {
        /**
         * The rule action updates the `Confidence` field of a finding.
         */
        confidence?: number;
        /**
         * The rule action updates the `Criticality` field of a finding.
         */
        criticality?: number;
        /**
         * A resource block that updates the note. Documented below.
         */
        note?: outputs.securityhub.AutomationRuleActionFindingFieldsUpdateNote;
        /**
         * A resource block that the rule action updates the `RelatedFindings` field of a finding. Documented below.
         */
        relatedFindings?: outputs.securityhub.AutomationRuleActionFindingFieldsUpdateRelatedFinding[];
        /**
         * A resource block that updates to the severity information for a finding. Documented below.
         */
        severity?: outputs.securityhub.AutomationRuleActionFindingFieldsUpdateSeverity;
        /**
         * The rule action updates the `Types` field of a finding.
         */
        types?: string[];
        /**
         * The rule action updates the `UserDefinedFields` field of a finding.
         */
        userDefinedFields?: {
            [key: string]: string;
        };
        /**
         * The rule action updates the `VerificationState` field of a finding. The allowed values are the following `UNKNOWN`, `TRUE_POSITIVE`, `FALSE_POSITIVE` and `BENIGN_POSITIVE`.
         */
        verificationState?: string;
        /**
         * A resource block that is used to update information about the investigation into the finding. Documented below.
         */
        workflow?: outputs.securityhub.AutomationRuleActionFindingFieldsUpdateWorkflow;
    }
    interface AutomationRuleActionFindingFieldsUpdateNote {
        /**
         * The updated note text.
         */
        text: string;
        /**
         * The principal that updated the note.
         */
        updatedBy: string;
    }
    interface AutomationRuleActionFindingFieldsUpdateRelatedFinding {
        /**
         * The product-generated identifier for a related finding.
         */
        id: string;
        /**
         * The ARN of the product that generated a related finding.
         */
        productArn: string;
    }
    interface AutomationRuleActionFindingFieldsUpdateSeverity {
        /**
         * The severity value of the finding. The allowed values are the following `INFORMATIONAL`, `LOW`, `MEDIUM`, `HIGH` and `CRITICAL`.
         */
        label: string;
        /**
         * The native severity as defined by the AWS service or integrated partner product that generated the finding.
         */
        product?: number;
    }
    interface AutomationRuleActionFindingFieldsUpdateWorkflow {
        /**
         * The status of the investigation into the finding. The allowed values are the following `NEW`, `NOTIFIED`, `RESOLVED` and `SUPPRESSED`.
         */
        status?: string;
    }
    interface AutomationRuleCriteria {
        /**
         * The AWS account ID in which a finding was generated. Documented below.
         */
        awsAccountIds?: outputs.securityhub.AutomationRuleCriteriaAwsAccountId[];
        /**
         * The name of the AWS account in which a finding was generated. Documented below.
         */
        awsAccountNames?: outputs.securityhub.AutomationRuleCriteriaAwsAccountName[];
        /**
         * The name of the company for the product that generated the finding. For control-based findings, the company is AWS. Documented below.
         */
        companyNames?: outputs.securityhub.AutomationRuleCriteriaCompanyName[];
        /**
         * The unique identifier of a standard in which a control is enabled. Documented below.
         */
        complianceAssociatedStandardsIds?: outputs.securityhub.AutomationRuleCriteriaComplianceAssociatedStandardsId[];
        /**
         * The security control ID for which a finding was generated. Security control IDs are the same across standards. Documented below.
         */
        complianceSecurityControlIds?: outputs.securityhub.AutomationRuleCriteriaComplianceSecurityControlId[];
        /**
         * The result of a security check. This field is only used for findings generated from controls. Documented below.
         */
        complianceStatuses?: outputs.securityhub.AutomationRuleCriteriaComplianceStatus[];
        /**
         * The likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. `Confidence` is scored on a 0–100 basis using a ratio scale. A value of `0` means 0 percent confidence, and a value of `100` means 100 percent confidence. Documented below.
         */
        confidences?: outputs.securityhub.AutomationRuleCriteriaConfidence[];
        /**
         * A timestamp that indicates when this finding record was created. Documented below.
         */
        createdAts?: outputs.securityhub.AutomationRuleCriteriaCreatedAt[];
        /**
         * The level of importance that is assigned to the resources that are associated with a finding. Documented below.
         */
        criticalities?: outputs.securityhub.AutomationRuleCriteriaCriticality[];
        /**
         * A finding's description. Documented below.
         */
        descriptions?: outputs.securityhub.AutomationRuleCriteriaDescription[];
        /**
         * A timestamp that indicates when the potential security issue captured by a finding was first observed by the security findings product. Documented below.
         */
        firstObservedAts?: outputs.securityhub.AutomationRuleCriteriaFirstObservedAt[];
        /**
         * The identifier for the solution-specific component that generated a finding. Documented below.
         */
        generatorIds?: outputs.securityhub.AutomationRuleCriteriaGeneratorId[];
        /**
         * The product-specific identifier for a finding. Documented below.
         */
        ids?: outputs.securityhub.AutomationRuleCriteriaId[];
        /**
         * A timestamp that indicates when the potential security issue captured by a finding was most recently observed by the security findings product. Documented below.
         */
        lastObservedAts?: outputs.securityhub.AutomationRuleCriteriaLastObservedAt[];
        /**
         * The text of a user-defined note that's added to a finding. Documented below.
         */
        noteTexts?: outputs.securityhub.AutomationRuleCriteriaNoteText[];
        /**
         * The timestamp of when the note was updated. Documented below.
         */
        noteUpdatedAts?: outputs.securityhub.AutomationRuleCriteriaNoteUpdatedAt[];
        /**
         * The principal that created a note. Documented below.
         */
        noteUpdatedBies?: outputs.securityhub.AutomationRuleCriteriaNoteUpdatedBy[];
        /**
         * The Amazon Resource Name (ARN) for a third-party product that generated a finding in Security Hub. Documented below.
         */
        productArns?: outputs.securityhub.AutomationRuleCriteriaProductArn[];
        /**
         * Provides the name of the product that generated the finding. For control-based findings, the product name is Security Hub. Documented below.
         */
        productNames?: outputs.securityhub.AutomationRuleCriteriaProductName[];
        /**
         * Provides the current state of a finding. Documented below.
         */
        recordStates?: outputs.securityhub.AutomationRuleCriteriaRecordState[];
        /**
         * The product-generated identifier for a related finding.  Documented below.
         */
        relatedFindingsIds?: outputs.securityhub.AutomationRuleCriteriaRelatedFindingsId[];
        /**
         * The ARN for the product that generated a related finding. Documented below.
         */
        relatedFindingsProductArns?: outputs.securityhub.AutomationRuleCriteriaRelatedFindingsProductArn[];
        /**
         * The Amazon Resource Name (ARN) of the application that is related to a finding. Documented below.
         */
        resourceApplicationArns?: outputs.securityhub.AutomationRuleCriteriaResourceApplicationArn[];
        /**
         * The name of the application that is related to a finding. Documented below.
         */
        resourceApplicationNames?: outputs.securityhub.AutomationRuleCriteriaResourceApplicationName[];
        /**
         * Custom fields and values about the resource that a finding pertains to. Documented below.
         */
        resourceDetailsOthers?: outputs.securityhub.AutomationRuleCriteriaResourceDetailsOther[];
        /**
         * The identifier for the given resource type. For AWS resources that are identified by Amazon Resource Names (ARNs), this is the ARN. For AWS resources that lack ARNs, this is the identifier as defined by the AWS service that created the resource. For non-AWS resources, this is a unique identifier that is associated with the resource. Documented below.
         */
        resourceIds?: outputs.securityhub.AutomationRuleCriteriaResourceId[];
        /**
         * The partition in which the resource that the finding pertains to is located. A partition is a group of AWS Regions. Each AWS account is scoped to one partition. Documented below.
         */
        resourcePartitions?: outputs.securityhub.AutomationRuleCriteriaResourcePartition[];
        /**
         * The AWS Region where the resource that a finding pertains to is located. Documented below.
         */
        resourceRegions?: outputs.securityhub.AutomationRuleCriteriaResourceRegion[];
        /**
         * A list of AWS tags associated with a resource at the time the finding was processed. Documented below.
         */
        resourceTags?: outputs.securityhub.AutomationRuleCriteriaResourceTag[];
        /**
         * The type of resource that the finding pertains to. Documented below.
         */
        resourceTypes?: outputs.securityhub.AutomationRuleCriteriaResourceType[];
        /**
         * The severity value of the finding. Documented below.
         */
        severityLabels?: outputs.securityhub.AutomationRuleCriteriaSeverityLabel[];
        /**
         * Provides a URL that links to a page about the current finding in the finding product. Documented below.
         */
        sourceUrls?: outputs.securityhub.AutomationRuleCriteriaSourceUrl[];
        /**
         * A finding's title. Documented below.
         */
        titles?: outputs.securityhub.AutomationRuleCriteriaTitle[];
        /**
         * One or more finding types in the format of namespace/category/classifier that classify a finding. Documented below.
         */
        types?: outputs.securityhub.AutomationRuleCriteriaType[];
        /**
         * A timestamp that indicates when the finding record was most recently updated. Documented below.
         */
        updatedAts?: outputs.securityhub.AutomationRuleCriteriaUpdatedAt[];
        /**
         * A list of user-defined name and value string pairs added to a finding. Documented below.
         */
        userDefinedFields?: outputs.securityhub.AutomationRuleCriteriaUserDefinedField[];
        /**
         * Provides the veracity of a finding. Documented below.
         */
        verificationStates?: outputs.securityhub.AutomationRuleCriteriaVerificationState[];
        /**
         * Provides information about the status of the investigation into a finding. Documented below.
         */
        workflowStatuses?: outputs.securityhub.AutomationRuleCriteriaWorkflowStatus[];
    }
    interface AutomationRuleCriteriaAwsAccountId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaAwsAccountName {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaCompanyName {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaComplianceAssociatedStandardsId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaComplianceSecurityControlId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaComplianceStatus {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaConfidence {
        eq?: number;
        gt?: number;
        gte?: number;
        lt?: number;
        lte?: number;
    }
    interface AutomationRuleCriteriaCreatedAt {
        dateRange?: outputs.securityhub.AutomationRuleCriteriaCreatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface AutomationRuleCriteriaCreatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface AutomationRuleCriteriaCriticality {
        eq?: number;
        gt?: number;
        gte?: number;
        lt?: number;
        lte?: number;
    }
    interface AutomationRuleCriteriaDescription {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaFirstObservedAt {
        dateRange?: outputs.securityhub.AutomationRuleCriteriaFirstObservedAtDateRange;
        end?: string;
        start?: string;
    }
    interface AutomationRuleCriteriaFirstObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface AutomationRuleCriteriaGeneratorId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaLastObservedAt {
        dateRange?: outputs.securityhub.AutomationRuleCriteriaLastObservedAtDateRange;
        end?: string;
        start?: string;
    }
    interface AutomationRuleCriteriaLastObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface AutomationRuleCriteriaNoteText {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaNoteUpdatedAt {
        dateRange?: outputs.securityhub.AutomationRuleCriteriaNoteUpdatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface AutomationRuleCriteriaNoteUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface AutomationRuleCriteriaNoteUpdatedBy {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaProductArn {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaProductName {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaRecordState {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaRelatedFindingsId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaRelatedFindingsProductArn {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceApplicationArn {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceApplicationName {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceDetailsOther {
        comparison: string;
        key: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceId {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourcePartition {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceRegion {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceTag {
        comparison: string;
        key: string;
        value: string;
    }
    interface AutomationRuleCriteriaResourceType {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaSeverityLabel {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaSourceUrl {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaTitle {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaType {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaUpdatedAt {
        dateRange?: outputs.securityhub.AutomationRuleCriteriaUpdatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface AutomationRuleCriteriaUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface AutomationRuleCriteriaUserDefinedField {
        comparison: string;
        key: string;
        value: string;
    }
    interface AutomationRuleCriteriaVerificationState {
        comparison: string;
        value: string;
    }
    interface AutomationRuleCriteriaWorkflowStatus {
        comparison: string;
        value: string;
    }
    interface ConfigurationPolicyConfigurationPolicy {
        /**
         * A list that defines which security standards are enabled in the configuration policy. It must be defined if `serviceEnabled` is set to true.
         */
        enabledStandardArns?: string[];
        /**
         * Defines which security controls are enabled in the configuration policy and any customizations to parameters affecting them. See below.
         */
        securityControlsConfiguration?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfiguration;
        /**
         * Indicates whether Security Hub is enabled in the policy.
         */
        serviceEnabled: boolean;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfiguration {
        /**
         * A list of security controls that are disabled in the configuration policy Security Hub enables all other controls (including newly released controls) other than the listed controls. Conflicts with `enabledControlIdentifiers`.
         */
        disabledControlIdentifiers?: string[];
        /**
         * A list of security controls that are enabled in the configuration policy. Security Hub disables all other controls (including newly released controls) other than the listed controls. Conflicts with `disabledControlIdentifiers`.
         */
        enabledControlIdentifiers?: string[];
        /**
         * A list of control parameter customizations that are included in a configuration policy. Include multiple blocks to define multiple control custom parameters. See below.
         */
        securityControlCustomParameters?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameter[];
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameter {
        /**
         * An object that specifies parameter values for a control in a configuration policy. See below.
         */
        parameters: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameter[];
        /**
         * The ID of the security control. For more information see the [Security Hub controls reference] documentation.
         */
        securityControlId: string;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameter {
        /**
         * The bool `value` for a Boolean-typed Security Hub Control Parameter.
         */
        bool?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterBool;
        /**
         * The float `value` for a Double-typed Security Hub Control Parameter.
         */
        double?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterDouble;
        /**
         * The string `value` for a Enum-typed Security Hub Control Parameter.
         */
        enum?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterEnum;
        /**
         * The string list `value` for a EnumList-typed Security Hub Control Parameter.
         */
        enumList?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterEnumList;
        /**
         * The int `value` for a Int-typed Security Hub Control Parameter.
         */
        int?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterInt;
        /**
         * The int list `value` for a IntList-typed Security Hub Control Parameter.
         */
        intList?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterIntList;
        /**
         * The name of the control parameter. For more information see the [Security Hub controls reference] documentation.
         */
        name: string;
        /**
         * The string `value` for a String-typed Security Hub Control Parameter.
         */
        string?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterString;
        /**
         * The string list `value` for a StringList-typed Security Hub Control Parameter.
         */
        stringList?: outputs.securityhub.ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterStringList;
        /**
         * Identifies whether a control parameter uses a custom user-defined value or subscribes to the default Security Hub behavior. Valid values: `DEFAULT`, `CUSTOM`.
         */
        valueType: string;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterBool {
        value: boolean;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterDouble {
        value: number;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterEnum {
        value: string;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterEnumList {
        values: string[];
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterInt {
        value: number;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterIntList {
        values: number[];
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterString {
        value: string;
    }
    interface ConfigurationPolicyConfigurationPolicySecurityControlsConfigurationSecurityControlCustomParameterParameterStringList {
        values: string[];
    }
    interface InsightFilters {
        /**
         * AWS account ID that a finding is generated in. See String_Filter below for more details.
         */
        awsAccountIds?: outputs.securityhub.InsightFiltersAwsAccountId[];
        /**
         * The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details.
         */
        companyNames?: outputs.securityhub.InsightFiltersCompanyName[];
        /**
         * Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details.
         */
        complianceStatuses?: outputs.securityhub.InsightFiltersComplianceStatus[];
        /**
         * A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
         */
        confidences?: outputs.securityhub.InsightFiltersConfidence[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details.
         */
        createdAts?: outputs.securityhub.InsightFiltersCreatedAt[];
        /**
         * The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
         */
        criticalities?: outputs.securityhub.InsightFiltersCriticality[];
        /**
         * A finding's description. See String Filter below for more details.
         */
        descriptions?: outputs.securityhub.InsightFiltersDescription[];
        /**
         * The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
         */
        findingProviderFieldsConfidences?: outputs.securityhub.InsightFiltersFindingProviderFieldsConfidence[];
        /**
         * The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
         */
        findingProviderFieldsCriticalities?: outputs.securityhub.InsightFiltersFindingProviderFieldsCriticality[];
        /**
         * The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details.
         */
        findingProviderFieldsRelatedFindingsIds?: outputs.securityhub.InsightFiltersFindingProviderFieldsRelatedFindingsId[];
        /**
         * The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details.
         */
        findingProviderFieldsRelatedFindingsProductArns?: outputs.securityhub.InsightFiltersFindingProviderFieldsRelatedFindingsProductArn[];
        /**
         * The finding provider value for the severity label. See String Filter below for more details.
         */
        findingProviderFieldsSeverityLabels?: outputs.securityhub.InsightFiltersFindingProviderFieldsSeverityLabel[];
        /**
         * The finding provider's original value for the severity. See String Filter below for more details.
         */
        findingProviderFieldsSeverityOriginals?: outputs.securityhub.InsightFiltersFindingProviderFieldsSeverityOriginal[];
        /**
         * One or more finding types that the finding provider assigned to the finding. Uses the format of `namespace/category/classifier` that classify a finding. Valid namespace values include: `Software and Configuration Checks`, `TTPs`, `Effects`, `Unusual Behaviors`, and `Sensitive Data Identifications`. See String Filter below for more details.
         */
        findingProviderFieldsTypes?: outputs.securityhub.InsightFiltersFindingProviderFieldsType[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details.
         */
        firstObservedAts?: outputs.securityhub.InsightFiltersFirstObservedAt[];
        /**
         * The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details.
         */
        generatorIds?: outputs.securityhub.InsightFiltersGeneratorId[];
        /**
         * The security findings provider-specific identifier for a finding. See String Filter below for more details.
         */
        ids?: outputs.securityhub.InsightFiltersId[];
        /**
         * A keyword for a finding. See Keyword Filter below for more details.
         */
        keywords?: outputs.securityhub.InsightFiltersKeyword[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details.
         */
        lastObservedAts?: outputs.securityhub.InsightFiltersLastObservedAt[];
        /**
         * The name of the malware that was observed. See String Filter below for more details.
         */
        malwareNames?: outputs.securityhub.InsightFiltersMalwareName[];
        /**
         * The filesystem path of the malware that was observed. See String Filter below for more details.
         */
        malwarePaths?: outputs.securityhub.InsightFiltersMalwarePath[];
        /**
         * The state of the malware that was observed. See String Filter below for more details.
         */
        malwareStates?: outputs.securityhub.InsightFiltersMalwareState[];
        /**
         * The type of the malware that was observed. See String Filter below for more details.
         */
        malwareTypes?: outputs.securityhub.InsightFiltersMalwareType[];
        /**
         * The destination domain of network-related information about a finding. See String Filter below for more details.
         */
        networkDestinationDomains?: outputs.securityhub.InsightFiltersNetworkDestinationDomain[];
        /**
         * The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkDestinationIpv4s?: outputs.securityhub.InsightFiltersNetworkDestinationIpv4[];
        /**
         * The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkDestinationIpv6s?: outputs.securityhub.InsightFiltersNetworkDestinationIpv6[];
        /**
         * The destination port of network-related information about a finding. See Number Filter below for more details.
         */
        networkDestinationPorts?: outputs.securityhub.InsightFiltersNetworkDestinationPort[];
        /**
         * Indicates the direction of network traffic associated with a finding. See String Filter below for more details.
         */
        networkDirections?: outputs.securityhub.InsightFiltersNetworkDirection[];
        /**
         * The protocol of network-related information about a finding. See String Filter below for more details.
         */
        networkProtocols?: outputs.securityhub.InsightFiltersNetworkProtocol[];
        /**
         * The source domain of network-related information about a finding. See String Filter below for more details.
         */
        networkSourceDomains?: outputs.securityhub.InsightFiltersNetworkSourceDomain[];
        /**
         * The source IPv4 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkSourceIpv4s?: outputs.securityhub.InsightFiltersNetworkSourceIpv4[];
        /**
         * The source IPv6 address of network-related information about a finding. See Ip Filter below for more details.
         */
        networkSourceIpv6s?: outputs.securityhub.InsightFiltersNetworkSourceIpv6[];
        /**
         * The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details.
         */
        networkSourceMacs?: outputs.securityhub.InsightFiltersNetworkSourceMac[];
        /**
         * The source port of network-related information about a finding. See Number Filter below for more details.
         */
        networkSourcePorts?: outputs.securityhub.InsightFiltersNetworkSourcePort[];
        /**
         * The text of a note. See String Filter below for more details.
         */
        noteTexts?: outputs.securityhub.InsightFiltersNoteText[];
        /**
         * The timestamp of when the note was updated. See Date Filter below for more details.
         */
        noteUpdatedAts?: outputs.securityhub.InsightFiltersNoteUpdatedAt[];
        /**
         * The principal that created a note. See String Filter below for more details.
         */
        noteUpdatedBies?: outputs.securityhub.InsightFiltersNoteUpdatedBy[];
        /**
         * The date/time that the process was launched. See Date Filter below for more details.
         */
        processLaunchedAts?: outputs.securityhub.InsightFiltersProcessLaunchedAt[];
        /**
         * The name of the process. See String Filter below for more details.
         */
        processNames?: outputs.securityhub.InsightFiltersProcessName[];
        /**
         * The parent process ID. See Number Filter below for more details.
         */
        processParentPids?: outputs.securityhub.InsightFiltersProcessParentPid[];
        /**
         * The path to the process executable. See String Filter below for more details.
         */
        processPaths?: outputs.securityhub.InsightFiltersProcessPath[];
        /**
         * The process ID. See Number Filter below for more details.
         */
        processPids?: outputs.securityhub.InsightFiltersProcessPid[];
        /**
         * The date/time that the process was terminated. See Date Filter below for more details.
         */
        processTerminatedAts?: outputs.securityhub.InsightFiltersProcessTerminatedAt[];
        /**
         * The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.
         */
        productArns?: outputs.securityhub.InsightFiltersProductArn[];
        /**
         * A data type where security-findings providers can include additional solution-specific details that aren't part of the defined `AwsSecurityFinding` format. See Map Filter below for more details.
         */
        productFields?: outputs.securityhub.InsightFiltersProductField[];
        /**
         * The name of the solution (product) that generates findings. See String Filter below for more details.
         */
        productNames?: outputs.securityhub.InsightFiltersProductName[];
        /**
         * The recommendation of what to do about the issue described in a finding. See String Filter below for more details.
         */
        recommendationTexts?: outputs.securityhub.InsightFiltersRecommendationText[];
        /**
         * The updated record state for the finding. See String Filter below for more details.
         */
        recordStates?: outputs.securityhub.InsightFiltersRecordState[];
        /**
         * The solution-generated identifier for a related finding. See String Filter below for more details.
         */
        relatedFindingsIds?: outputs.securityhub.InsightFiltersRelatedFindingsId[];
        /**
         * The ARN of the solution that generated a related finding. See String Filter below for more details.
         */
        relatedFindingsProductArns?: outputs.securityhub.InsightFiltersRelatedFindingsProductArn[];
        /**
         * The IAM profile ARN of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceIamInstanceProfileArns?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIamInstanceProfileArn[];
        /**
         * The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceImageIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceImageId[];
        /**
         * The IPv4 addresses associated with the instance. See Ip Filter below for more details.
         */
        resourceAwsEc2InstanceIpv4Addresses?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIpv4Address[];
        /**
         * The IPv6 addresses associated with the instance. See Ip Filter below for more details.
         */
        resourceAwsEc2InstanceIpv6Addresses?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceIpv6Address[];
        /**
         * The key name associated with the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceKeyNames?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceKeyName[];
        /**
         * The date and time the instance was launched. See Date Filter below for more details.
         */
        resourceAwsEc2InstanceLaunchedAts?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceLaunchedAt[];
        /**
         * The identifier of the subnet that the instance was launched in. See String Filter below for more details.
         */
        resourceAwsEc2InstanceSubnetIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceSubnetId[];
        /**
         * The instance type of the instance. See String Filter below for more details.
         */
        resourceAwsEc2InstanceTypes?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceType[];
        /**
         * The identifier of the VPC that the instance was launched in. See String Filter below for more details.
         */
        resourceAwsEc2InstanceVpcIds?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceVpcId[];
        /**
         * The creation date/time of the IAM access key related to a finding. See Date Filter below for more details.
         */
        resourceAwsIamAccessKeyCreatedAts?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyCreatedAt[];
        /**
         * The status of the IAM access key related to a finding. See String Filter below for more details.
         */
        resourceAwsIamAccessKeyStatuses?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyStatus[];
        /**
         * The user associated with the IAM access key related to a finding. See String Filter below for more details.
         */
        resourceAwsIamAccessKeyUserNames?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyUserName[];
        /**
         * The canonical user ID of the owner of the S3 bucket. See String Filter below for more details.
         */
        resourceAwsS3BucketOwnerIds?: outputs.securityhub.InsightFiltersResourceAwsS3BucketOwnerId[];
        /**
         * The display name of the owner of the S3 bucket. See String Filter below for more details.
         */
        resourceAwsS3BucketOwnerNames?: outputs.securityhub.InsightFiltersResourceAwsS3BucketOwnerName[];
        /**
         * The identifier of the image related to a finding. See String Filter below for more details.
         */
        resourceContainerImageIds?: outputs.securityhub.InsightFiltersResourceContainerImageId[];
        /**
         * The name of the image related to a finding. See String Filter below for more details.
         */
        resourceContainerImageNames?: outputs.securityhub.InsightFiltersResourceContainerImageName[];
        /**
         * The date/time that the container was started. See Date Filter below for more details.
         */
        resourceContainerLaunchedAts?: outputs.securityhub.InsightFiltersResourceContainerLaunchedAt[];
        /**
         * The name of the container related to a finding. See String Filter below for more details.
         */
        resourceContainerNames?: outputs.securityhub.InsightFiltersResourceContainerName[];
        /**
         * The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.
         */
        resourceDetailsOthers?: outputs.securityhub.InsightFiltersResourceDetailsOther[];
        /**
         * The canonical identifier for the given resource type. See String Filter below for more details.
         */
        resourceIds?: outputs.securityhub.InsightFiltersResourceId[];
        /**
         * The canonical AWS partition name that the Region is assigned to. See String Filter below for more details.
         */
        resourcePartitions?: outputs.securityhub.InsightFiltersResourcePartition[];
        /**
         * The canonical AWS external Region name where this resource is located. See String Filter below for more details.
         */
        resourceRegions?: outputs.securityhub.InsightFiltersResourceRegion[];
        /**
         * A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details.
         */
        resourceTags?: outputs.securityhub.InsightFiltersResourceTag[];
        /**
         * Specifies the type of the resource that details are provided for. See String Filter below for more details.
         */
        resourceTypes?: outputs.securityhub.InsightFiltersResourceType[];
        /**
         * The label of a finding's severity. See String Filter below for more details.
         */
        severityLabels?: outputs.securityhub.InsightFiltersSeverityLabel[];
        /**
         * A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.
         */
        sourceUrls?: outputs.securityhub.InsightFiltersSourceUrl[];
        /**
         * The category of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorCategories?: outputs.securityhub.InsightFiltersThreatIntelIndicatorCategory[];
        /**
         * The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details.
         */
        threatIntelIndicatorLastObservedAts?: outputs.securityhub.InsightFiltersThreatIntelIndicatorLastObservedAt[];
        /**
         * The URL for more details from the source of the threat intelligence. See String Filter below for more details.
         */
        threatIntelIndicatorSourceUrls?: outputs.securityhub.InsightFiltersThreatIntelIndicatorSourceUrl[];
        /**
         * The source of the threat intelligence. See String Filter below for more details.
         */
        threatIntelIndicatorSources?: outputs.securityhub.InsightFiltersThreatIntelIndicatorSource[];
        /**
         * The type of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorTypes?: outputs.securityhub.InsightFiltersThreatIntelIndicatorType[];
        /**
         * The value of a threat intelligence indicator. See String Filter below for more details.
         */
        threatIntelIndicatorValues?: outputs.securityhub.InsightFiltersThreatIntelIndicatorValue[];
        /**
         * A finding's title. See String Filter below for more details.
         */
        titles?: outputs.securityhub.InsightFiltersTitle[];
        /**
         * A finding type in the format of `namespace/category/classifier` that classifies a finding. See String Filter below for more details.
         */
        types?: outputs.securityhub.InsightFiltersType[];
        /**
         * An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details.
         */
        updatedAts?: outputs.securityhub.InsightFiltersUpdatedAt[];
        /**
         * A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details.
         */
        userDefinedValues?: outputs.securityhub.InsightFiltersUserDefinedValue[];
        /**
         * The veracity of a finding. See String Filter below for more details.
         */
        verificationStates?: outputs.securityhub.InsightFiltersVerificationState[];
        /**
         * The status of the investigation into a finding. See Workflow Status Filter below for more details.
         */
        workflowStatuses?: outputs.securityhub.InsightFiltersWorkflowStatus[];
    }
    interface InsightFiltersAwsAccountId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersCompanyName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersComplianceStatus {
        comparison: string;
        value: string;
    }
    interface InsightFiltersConfidence {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersCreatedAt {
        dateRange?: outputs.securityhub.InsightFiltersCreatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersCreatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersCriticality {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersDescription {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFindingProviderFieldsConfidence {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersFindingProviderFieldsCriticality {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersFindingProviderFieldsRelatedFindingsId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFindingProviderFieldsRelatedFindingsProductArn {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFindingProviderFieldsSeverityLabel {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFindingProviderFieldsSeverityOriginal {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFindingProviderFieldsType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersFirstObservedAt {
        dateRange?: outputs.securityhub.InsightFiltersFirstObservedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersFirstObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersGeneratorId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersKeyword {
        /**
         * A value for the keyword.
         */
        value: string;
    }
    interface InsightFiltersLastObservedAt {
        dateRange?: outputs.securityhub.InsightFiltersLastObservedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersLastObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersMalwareName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersMalwarePath {
        comparison: string;
        value: string;
    }
    interface InsightFiltersMalwareState {
        comparison: string;
        value: string;
    }
    interface InsightFiltersMalwareType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkDestinationDomain {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkDestinationIpv4 {
        cidr: string;
    }
    interface InsightFiltersNetworkDestinationIpv6 {
        cidr: string;
    }
    interface InsightFiltersNetworkDestinationPort {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersNetworkDirection {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkProtocol {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkSourceDomain {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkSourceIpv4 {
        cidr: string;
    }
    interface InsightFiltersNetworkSourceIpv6 {
        cidr: string;
    }
    interface InsightFiltersNetworkSourceMac {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNetworkSourcePort {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersNoteText {
        comparison: string;
        value: string;
    }
    interface InsightFiltersNoteUpdatedAt {
        dateRange?: outputs.securityhub.InsightFiltersNoteUpdatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersNoteUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersNoteUpdatedBy {
        comparison: string;
        value: string;
    }
    interface InsightFiltersProcessLaunchedAt {
        dateRange?: outputs.securityhub.InsightFiltersProcessLaunchedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersProcessLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersProcessName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersProcessParentPid {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersProcessPath {
        comparison: string;
        value: string;
    }
    interface InsightFiltersProcessPid {
        eq?: string;
        gte?: string;
        lte?: string;
    }
    interface InsightFiltersProcessTerminatedAt {
        dateRange?: outputs.securityhub.InsightFiltersProcessTerminatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersProcessTerminatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersProductArn {
        comparison: string;
        value: string;
    }
    interface InsightFiltersProductField {
        comparison: string;
        key: string;
        value: string;
    }
    interface InsightFiltersProductName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersRecommendationText {
        comparison: string;
        value: string;
    }
    interface InsightFiltersRecordState {
        comparison: string;
        value: string;
    }
    interface InsightFiltersRelatedFindingsId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersRelatedFindingsProductArn {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceIamInstanceProfileArn {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceImageId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceIpv4Address {
        cidr: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceIpv6Address {
        cidr: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceKeyName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceLaunchedAt {
        dateRange?: outputs.securityhub.InsightFiltersResourceAwsEc2InstanceLaunchedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersResourceAwsEc2InstanceSubnetId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsEc2InstanceVpcId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsIamAccessKeyCreatedAt {
        dateRange?: outputs.securityhub.InsightFiltersResourceAwsIamAccessKeyCreatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersResourceAwsIamAccessKeyCreatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersResourceAwsIamAccessKeyStatus {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsIamAccessKeyUserName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsS3BucketOwnerId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceAwsS3BucketOwnerName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceContainerImageId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceContainerImageName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceContainerLaunchedAt {
        dateRange?: outputs.securityhub.InsightFiltersResourceContainerLaunchedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersResourceContainerLaunchedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersResourceContainerName {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceDetailsOther {
        comparison: string;
        key: string;
        value: string;
    }
    interface InsightFiltersResourceId {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourcePartition {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceRegion {
        comparison: string;
        value: string;
    }
    interface InsightFiltersResourceTag {
        comparison: string;
        key: string;
        value: string;
    }
    interface InsightFiltersResourceType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersSeverityLabel {
        comparison: string;
        value: string;
    }
    interface InsightFiltersSourceUrl {
        comparison: string;
        value: string;
    }
    interface InsightFiltersThreatIntelIndicatorCategory {
        comparison: string;
        value: string;
    }
    interface InsightFiltersThreatIntelIndicatorLastObservedAt {
        dateRange?: outputs.securityhub.InsightFiltersThreatIntelIndicatorLastObservedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersThreatIntelIndicatorLastObservedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersThreatIntelIndicatorSource {
        comparison: string;
        value: string;
    }
    interface InsightFiltersThreatIntelIndicatorSourceUrl {
        comparison: string;
        value: string;
    }
    interface InsightFiltersThreatIntelIndicatorType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersThreatIntelIndicatorValue {
        comparison: string;
        value: string;
    }
    interface InsightFiltersTitle {
        comparison: string;
        value: string;
    }
    interface InsightFiltersType {
        comparison: string;
        value: string;
    }
    interface InsightFiltersUpdatedAt {
        dateRange?: outputs.securityhub.InsightFiltersUpdatedAtDateRange;
        end?: string;
        start?: string;
    }
    interface InsightFiltersUpdatedAtDateRange {
        /**
         * A date range unit for the date filter. Valid values: `DAYS`.
         */
        unit: string;
        /**
         * A date range value for the date filter, provided as an Integer.
         */
        value: number;
    }
    interface InsightFiltersUserDefinedValue {
        comparison: string;
        key: string;
        value: string;
    }
    interface InsightFiltersVerificationState {
        comparison: string;
        value: string;
    }
    interface InsightFiltersWorkflowStatus {
        comparison: string;
        value: string;
    }
    interface OrganizationConfigurationOrganizationConfiguration {
        /**
         * Indicates whether the organization uses local or central configuration. If using central configuration, `autoEnable` must be set to `false` and `autoEnableStandards` set to `NONE`. More information can be found in the [documentation for central configuration](https://docs.aws.amazon.com/securityhub/latest/userguide/central-configuration-intro.html). Valid values: `LOCAL`, `CENTRAL`.
         */
        configurationType: string;
    }
}
export declare namespace securitylake {
    interface AwsLogSourceSource {
        /**
         * Specify the AWS account information where you want to enable Security Lake.
         * If not specified, uses all accounts included in the Security Lake.
         */
        accounts: string[];
        /**
         * Specify the Regions where you want to enable Security Lake.
         */
        regions: string[];
        /**
         * The name for a AWS source. This must be a Regionally unique value. Valid values: `ROUTE53`, `VPC_FLOW`, `SH_FINDINGS`, `CLOUD_TRAIL_MGMT`, `LAMBDA_EXECUTION`, `S3_DATA`.
         */
        sourceName: string;
        /**
         * The version for a AWS source.
         * If not specified, the version will be the default.
         * This must be a Regionally unique value.
         */
        sourceVersion: string;
    }
    interface CustomLogSourceAttribute {
        /**
         * The ARN of the AWS Glue crawler.
         */
        crawlerArn: string;
        /**
         * The ARN of the AWS Glue database where results are written.
         */
        databaseArn: string;
        /**
         * The ARN of the AWS Glue table.
         */
        tableArn: string;
    }
    interface CustomLogSourceConfiguration {
        /**
         * The configuration for the Glue Crawler for the third-party custom source.
         */
        crawlerConfiguration?: outputs.securitylake.CustomLogSourceConfigurationCrawlerConfiguration;
        /**
         * The identity of the log provider for the third-party custom source.
         */
        providerIdentity?: outputs.securitylake.CustomLogSourceConfigurationProviderIdentity;
    }
    interface CustomLogSourceConfigurationCrawlerConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to be used by the AWS Glue crawler.
         */
        roleArn: string;
    }
    interface CustomLogSourceConfigurationProviderIdentity {
        /**
         * The external ID used to estalish trust relationship with the AWS identity.
         */
        externalId: string;
        /**
         * The AWS identity principal.
         */
        principal: string;
    }
    interface CustomLogSourceProviderDetail {
        /**
         * The location of the partition in the Amazon S3 bucket for Security Lake.
         */
        location: string;
        /**
         * The ARN of the IAM role to be used by the entity putting logs into your custom source partition.
         */
        roleArn: string;
    }
    interface DataLakeConfiguration {
        /**
         * Provides encryption details of Amazon Security Lake object.
         */
        encryptionConfigurations: outputs.securitylake.DataLakeConfigurationEncryptionConfiguration[];
        /**
         * Provides lifecycle details of Amazon Security Lake object.
         */
        lifecycleConfiguration?: outputs.securitylake.DataLakeConfigurationLifecycleConfiguration;
        /**
         * The AWS Regions where Security Lake is automatically enabled.
         */
        region: string;
        /**
         * Provides replication details of Amazon Security Lake object.
         */
        replicationConfiguration?: outputs.securitylake.DataLakeConfigurationReplicationConfiguration;
    }
    interface DataLakeConfigurationEncryptionConfiguration {
        /**
         * The id of KMS encryption key used by Amazon Security Lake to encrypt the Security Lake object.
         */
        kmsKeyId: string;
    }
    interface DataLakeConfigurationLifecycleConfiguration {
        /**
         * Provides data expiration details of Amazon Security Lake object.
         */
        expiration?: outputs.securitylake.DataLakeConfigurationLifecycleConfigurationExpiration;
        /**
         * Provides data storage transition details of Amazon Security Lake object.
         */
        transitions?: outputs.securitylake.DataLakeConfigurationLifecycleConfigurationTransition[];
    }
    interface DataLakeConfigurationLifecycleConfigurationExpiration {
        /**
         * Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
         */
        days?: number;
    }
    interface DataLakeConfigurationLifecycleConfigurationTransition {
        /**
         * Number of days before data transition to a different S3 Storage Class in the Amazon Security Lake object.
         */
        days?: number;
        /**
         * The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.
         */
        storageClass?: string;
    }
    interface DataLakeConfigurationReplicationConfiguration {
        /**
         * Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same AWS account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different AWS Regions or within the same Region as the source bucket.
         */
        regions?: string[];
        /**
         * Replication settings for the Amazon S3 buckets. This parameter uses the AWS Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct.
         */
        roleArn?: string;
    }
    interface DataLakeTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface SubscriberNotificationConfiguration {
        /**
         * The configurations for HTTPS subscriber notification.
         */
        httpsNotificationConfiguration?: outputs.securitylake.SubscriberNotificationConfigurationHttpsNotificationConfiguration;
        /**
         * The configurations for SQS subscriber notification.
         * There are no parameters within `sqsNotificationConfiguration`.
         */
        sqsNotificationConfiguration?: outputs.securitylake.SubscriberNotificationConfigurationSqsNotificationConfiguration;
    }
    interface SubscriberNotificationConfigurationHttpsNotificationConfiguration {
        /**
         * The API key name for the notification subscription.
         */
        authorizationApiKeyName?: string;
        /**
         * The API key value for the notification subscription.
         */
        authorizationApiKeyValue?: string;
        /**
         * The subscription endpoint in Security Lake.
         * If you prefer notification with an HTTPS endpoint, populate this field.
         */
        endpoint: string;
        /**
         * The HTTP method used for the notification subscription.
         * Valid values are `POST` and `PUT`.
         */
        httpMethod?: string;
        /**
         * The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.
         * For more information about ARNs and how to use them in policies, see Managing data access and AWS Managed Policies in the Amazon Security Lake User Guide.
         */
        targetRoleArn: string;
    }
    interface SubscriberNotificationConfigurationSqsNotificationConfiguration {
    }
    interface SubscriberSource {
        /**
         * Amazon Security Lake supports log and event collection for natively supported AWS services.
         */
        awsLogSourceResource?: outputs.securitylake.SubscriberSourceAwsLogSourceResource;
        /**
         * Amazon Security Lake supports custom source types.
         */
        customLogSourceResource?: outputs.securitylake.SubscriberSourceCustomLogSourceResource;
    }
    interface SubscriberSourceAwsLogSourceResource {
        /**
         * The name for a third-party custom source. This must be a Regionally unique value.
         */
        sourceName: string;
        /**
         * The version for a third-party custom source. This must be a Regionally unique value.
         */
        sourceVersion: string;
    }
    interface SubscriberSourceCustomLogSourceResource {
        /**
         * The attributes of a third-party custom source.
         */
        attributes: outputs.securitylake.SubscriberSourceCustomLogSourceResourceAttribute[];
        providers: outputs.securitylake.SubscriberSourceCustomLogSourceResourceProvider[];
        /**
         * The name for a third-party custom source. This must be a Regionally unique value.
         */
        sourceName: string;
        /**
         * The version for a third-party custom source. This must be a Regionally unique value.
         */
        sourceVersion: string;
    }
    interface SubscriberSourceCustomLogSourceResourceAttribute {
        /**
         * The ARN of the AWS Glue crawler.
         */
        crawlerArn: string;
        /**
         * The ARN of the AWS Glue database where results are written.
         */
        databaseArn: string;
        /**
         * The ARN of the AWS Glue table.
         */
        tableArn: string;
    }
    interface SubscriberSourceCustomLogSourceResourceProvider {
        /**
         * The location of the partition in the Amazon S3 bucket for Security Lake.
         */
        location: string;
        /**
         * The ARN of the IAM role to be used by the entity putting logs into your custom source partition.
         */
        roleArn: string;
    }
    interface SubscriberSubscriberIdentity {
        /**
         * The AWS Regions where Security Lake is automatically enabled.
         */
        externalId: string;
        /**
         * Provides encryption details of Amazon Security Lake object.
         */
        principal: string;
    }
    interface SubscriberTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
}
export declare namespace servicecatalog {
    interface GetLaunchPathsSummary {
        /**
         * Block for constraints on the portfolio-product relationship. See details below.
         */
        constraintSummaries: outputs.servicecatalog.GetLaunchPathsSummaryConstraintSummary[];
        /**
         * Name of the portfolio to which the path was assigned.
         */
        name: string;
        /**
         * Identifier of the product path.
         */
        pathId: string;
        /**
         * Tags associated with this product path.
         */
        tags: {
            [key: string]: string;
        };
    }
    interface GetLaunchPathsSummaryConstraintSummary {
        /**
         * Description of the constraint.
         */
        description: string;
        /**
         * Type of constraint. Valid values are `LAUNCH`, `NOTIFICATION`, `STACKSET`, and `TEMPLATE`.
         */
        type: string;
    }
    interface GetPortfolioConstraintsDetail {
        /**
         * Identifier of the constraint.
         */
        constraintId: string;
        /**
         * Description of the constraint.
         */
        description: string;
        owner: string;
        /**
         * Portfolio identifier.
         *
         * The following arguments are optional:
         */
        portfolioId: string;
        /**
         * Product identifier.
         */
        productId: string;
        /**
         * Type of constraint. Valid values are `LAUNCH`, `NOTIFICATION`, `STACKSET`, and `TEMPLATE`.
         */
        type: string;
    }
    interface GetProvisioningArtifactsProvisioningArtifactDetail {
        /**
         * Indicates whether the product version is active.
         */
        active: boolean;
        /**
         * The UTC time stamp of the creation time.
         */
        createdTime: string;
        /**
         * The description of the provisioning artifact.
         */
        description: string;
        /**
         * Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
         */
        guidance: string;
        /**
         * The identifier of the provisioning artifact.
         */
        id: string;
        /**
         * The name of the provisioning artifact.
         */
        name: string;
        /**
         * The type of provisioning artifact.
         */
        type: string;
    }
    interface ProductProvisioningArtifactParameters {
        /**
         * Description of the provisioning artifact (i.e., version), including how it differs from the previous provisioning artifact.
         */
        description?: string;
        /**
         * Whether AWS Service Catalog stops validating the specified provisioning artifact template even if it is invalid.
         */
        disableTemplateValidation?: boolean;
        /**
         * Name of the provisioning artifact (for example, `v1`, `v2beta`). No spaces are allowed.
         */
        name?: string;
        /**
         * Template source as the physical ID of the resource that contains the template. Currently only supports CloudFormation stack ARN. Specify the physical ID as `arn:[partition]:cloudformation:[region]:[account ID]:stack/[stack name]/[resource ID]`.
         */
        templatePhysicalId?: string;
        /**
         * Template source as URL of the CloudFormation template in Amazon S3.
         */
        templateUrl?: string;
        /**
         * Type of provisioning artifact. See [AWS Docs](https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ProvisioningArtifactProperties.html) for valid list of values.
         */
        type?: string;
    }
    interface ProvisionedProductOutput {
        /**
         * The description of the output.
         */
        description: string;
        /**
         * The output key.
         */
        key: string;
        /**
         * The output value.
         */
        value: string;
    }
    interface ProvisionedProductProvisioningParameter {
        /**
         * Parameter key.
         */
        key: string;
        /**
         * Whether to ignore `value` and keep the previous parameter value. Ignored when initially provisioning a product.
         */
        usePreviousValue?: boolean;
        /**
         * Parameter value.
         */
        value?: string;
    }
    interface ProvisionedProductStackSetProvisioningPreferences {
        /**
         * One or more AWS accounts that will have access to the provisioned product. The AWS accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the `awsServicecatalogProvisioningParameters` data source. If no values are specified, the default value is all accounts from the STACKSET constraint.
         */
        accounts?: string[];
        /**
         * Number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. You must specify either `failureToleranceCount` or `failureTolerancePercentage`, but not both. The default value is 0 if no value is specified.
         */
        failureToleranceCount?: number;
        /**
         * Percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. You must specify either `failureToleranceCount` or `failureTolerancePercentage`, but not both.
         */
        failureTolerancePercentage?: number;
        /**
         * Maximum number of accounts in which to perform this operation at one time. This is dependent on the value of `failureToleranceCount`. `maxConcurrencyCount` is at most one more than the `failureToleranceCount`. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. You must specify either `maxConcurrencyCount` or `maxConcurrencyPercentage`, but not both.
         */
        maxConcurrencyCount?: number;
        /**
         * Maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. You must specify either `maxConcurrencyCount` or `maxConcurrencyPercentage`, but not both.
         */
        maxConcurrencyPercentage?: number;
        /**
         * One or more AWS Regions where the provisioned product will be available. The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the `awsServicecatalogProvisioningParameters` data source. If no values are specified, the default value is all regions from the STACKSET constraint.
         */
        regions?: string[];
    }
    interface ServiceActionDefinition {
        /**
         * ARN of the role that performs the self-service actions on your behalf. For example, `arn:aws:iam::12345678910:role/ActionRole`. To reuse the provisioned product launch role, set to `LAUNCH_ROLE`.
         */
        assumeRole?: string;
        /**
         * Name of the SSM document. For example, `AWS-RestartEC2Instance`. If you are using a shared SSM document, you must provide the ARN instead of the name.
         */
        name: string;
        /**
         * List of parameters in JSON format. For example: `[{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}]` or `[{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}]`.
         */
        parameters?: string;
        /**
         * Service action definition type. Valid value is `SSM_AUTOMATION`. Default is `SSM_AUTOMATION`.
         */
        type?: string;
        /**
         * SSM document version. For example, `1`.
         */
        version: string;
    }
}
export declare namespace servicediscovery {
    interface GetServiceDnsConfig {
        /**
         * An array that contains one DnsRecord object for each resource record set.
         */
        dnsRecords: outputs.servicediscovery.GetServiceDnsConfigDnsRecord[];
        /**
         * ID of the namespace that the service belongs to.
         */
        namespaceId: string;
        /**
         * Routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
         */
        routingPolicy: string;
    }
    interface GetServiceDnsConfigDnsRecord {
        /**
         * Amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
         */
        ttl: number;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type: string;
    }
    interface GetServiceHealthCheckConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold: number;
        /**
         * Path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
         */
        resourcePath: string;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type: string;
    }
    interface GetServiceHealthCheckCustomConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold: number;
    }
    interface ServiceDnsConfig {
        /**
         * An array that contains one DnsRecord object for each resource record set.
         */
        dnsRecords: outputs.servicediscovery.ServiceDnsConfigDnsRecord[];
        /**
         * The ID of the namespace to use for DNS configuration.
         */
        namespaceId: string;
        /**
         * The routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
         */
        routingPolicy?: string;
    }
    interface ServiceDnsConfigDnsRecord {
        /**
         * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
         */
        ttl: number;
        /**
         * The type of the resource, which indicates the value that Amazon Route 53 returns in response to DNS queries. Valid Values: A, AAAA, SRV, CNAME
         */
        type: string;
    }
    interface ServiceHealthCheckConfig {
        /**
         * The number of consecutive health checks. Maximum value of 10.
         */
        failureThreshold?: number;
        /**
         * The path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
         */
        resourcePath?: string;
        /**
         * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
         */
        type?: string;
    }
    interface ServiceHealthCheckCustomConfig {
        /**
         * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
         */
        failureThreshold?: number;
    }
}
export declare namespace servicequotas {
    interface GetServiceQuotaUsageMetric {
        /**
         * The metric dimensions.
         */
        metricDimensions: outputs.servicequotas.GetServiceQuotaUsageMetricMetricDimension[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        metricNamespace: string;
        /**
         * The metric statistic that AWS recommend you use when determining quota usage.
         */
        metricStatisticRecommendation: string;
    }
    interface GetServiceQuotaUsageMetricMetricDimension {
        class: string;
        resource: string;
        service: string;
        type: string;
    }
    interface GetTemplatesTemplate {
        /**
         * Indicates whether the quota is global.
         */
        globalQuota: boolean;
        /**
         * Quota identifier.
         */
        quotaCode: string;
        /**
         * Quota name.
         */
        quotaName: string;
        /**
         * AWS Region to which the quota increases apply.
         */
        region: string;
        /**
         * (Required) Service identifier.
         */
        serviceCode: string;
        /**
         * Service name.
         */
        serviceName: string;
        /**
         * Unit of measurement.
         */
        unit: string;
        /**
         * (Required) The new, increased value for the quota.
         */
        value: number;
    }
    interface ServiceQuotaUsageMetric {
        /**
         * The metric dimensions.
         */
        metricDimensions: outputs.servicequotas.ServiceQuotaUsageMetricMetricDimension[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        metricNamespace: string;
        /**
         * The metric statistic that AWS recommend you use when determining quota usage.
         */
        metricStatisticRecommendation: string;
    }
    interface ServiceQuotaUsageMetricMetricDimension {
        class: string;
        resource: string;
        service: string;
        type: string;
    }
}
export declare namespace ses {
    interface ConfigurationSetDeliveryOptions {
        /**
         * Whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is `Require`, messages are only delivered if a TLS connection can be established. If the value is `Optional`, messages can be delivered in plain text if a TLS connection can't be established. Valid values: `Require` or `Optional`. Defaults to `Optional`.
         */
        tlsPolicy?: string;
    }
    interface ConfigurationSetTrackingOptions {
        /**
         * Custom subdomain that is used to redirect email recipients to the Amazon SES event tracking domain.
         */
        customRedirectDomain?: string;
    }
    interface EventDestinationCloudwatchDestination {
        /**
         * The default value for the event
         */
        defaultValue: string;
        /**
         * The name for the dimension
         */
        dimensionName: string;
        /**
         * The source for the value. May be any of `"messageTag"`, `"emailHeader"` or `"linkTag"`.
         */
        valueSource: string;
    }
    interface EventDestinationKinesisDestination {
        /**
         * The ARN of the role that has permissions to access the Kinesis Stream
         */
        roleArn: string;
        /**
         * The ARN of the Kinesis Stream
         */
        streamArn: string;
    }
    interface EventDestinationSnsDestination {
        /**
         * The ARN of the SNS topic
         */
        topicArn: string;
    }
    interface ReceiptRuleAddHeaderAction {
        /**
         * The name of the header to add
         */
        headerName: string;
        /**
         * The value of the header to add
         */
        headerValue: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
    }
    interface ReceiptRuleBounceAction {
        /**
         * The message to send
         */
        message: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The email address of the sender
         */
        sender: string;
        /**
         * The RFC 5321 SMTP reply code
         */
        smtpReplyCode: string;
        /**
         * The RFC 3463 SMTP enhanced status code
         */
        statusCode?: string;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }
    interface ReceiptRuleLambdaAction {
        /**
         * The ARN of the Lambda function to invoke
         */
        functionArn: string;
        /**
         * `Event` or `RequestResponse`
         */
        invocationType?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }
    interface ReceiptRuleS3Action {
        /**
         * The name of the S3 bucket
         */
        bucketName: string;
        /**
         * The ARN of the KMS key
         */
        kmsKeyArn?: string;
        /**
         * The key prefix of the S3 bucket
         */
        objectKeyPrefix?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }
    interface ReceiptRuleSnsAction {
        /**
         * The encoding to use for the email within the Amazon SNS notification. Default value is `UTF-8`.
         */
        encoding?: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn: string;
    }
    interface ReceiptRuleStopAction {
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The scope to apply. The only acceptable value is `RuleSet`.
         */
        scope: string;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }
    interface ReceiptRuleWorkmailAction {
        /**
         * The ARN of the WorkMail organization
         */
        organizationArn: string;
        /**
         * The position of the action in the receipt rule
         */
        position: number;
        /**
         * The ARN of an SNS topic to notify
         */
        topicArn?: string;
    }
}
export declare namespace sesv2 {
    interface AccountVdmAttributesDashboardAttributes {
        /**
         * Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
         */
        engagementMetrics?: string;
    }
    interface AccountVdmAttributesGuardianAttributes {
        /**
         * Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
         */
        optimizedSharedDelivery?: string;
    }
    interface ConfigurationSetDeliveryOptions {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName?: string;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). Valid values: `REQUIRE`, `OPTIONAL`.
         */
        tlsPolicy?: string;
    }
    interface ConfigurationSetEventDestinationEventDestination {
        /**
         * An object that defines an Amazon CloudWatch destination for email events. See cloudWatchDestination below
         */
        cloudWatchDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationCloudWatchDestination;
        /**
         * When the event destination is enabled, the specified event types are sent to the destinations. Default: `false`.
         */
        enabled?: boolean;
        /**
         * An object that defines an Amazon Kinesis Data Firehose destination for email events. See kinesisFirehoseDestination below.
         */
        kinesisFirehoseDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination;
        /**
         * An array that specifies which events the Amazon SES API v2 should send to the destinations. Valid values: `SEND`, `REJECT`, `BOUNCE`, `COMPLAINT`, `DELIVERY`, `OPEN`, `CLICK`, `RENDERING_FAILURE`, `DELIVERY_DELAY`, `SUBSCRIPTION`.
         *
         * The following arguments are optional:
         */
        matchingEventTypes: string[];
        /**
         * An object that defines an Amazon Pinpoint project destination for email events. See pinpointDestination below.
         */
        pinpointDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationPinpointDestination;
        /**
         * An object that defines an Amazon SNS destination for email events. See snsDestination below.
         */
        snsDestination?: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationSnsDestination;
    }
    interface ConfigurationSetEventDestinationEventDestinationCloudWatchDestination {
        /**
         * An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch. See dimensionConfiguration below.
         */
        dimensionConfigurations: outputs.sesv2.ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration[];
    }
    interface ConfigurationSetEventDestinationEventDestinationCloudWatchDestinationDimensionConfiguration {
        /**
         * The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email.
         */
        defaultDimensionValue: string;
        /**
         * The name of an Amazon CloudWatch dimension associated with an email sending metric.
         */
        dimensionName: string;
        /**
         * The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. Valid values: `MESSAGE_TAG`, `EMAIL_HEADER`, `LINK_TAG`.
         */
        dimensionValueSource: string;
    }
    interface ConfigurationSetEventDestinationEventDestinationKinesisFirehoseDestination {
        /**
         * The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email events to.
         */
        deliveryStreamArn: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email events to the Amazon Kinesis Data Firehose stream.
         */
        iamRoleArn: string;
    }
    interface ConfigurationSetEventDestinationEventDestinationPinpointDestination {
        applicationArn: string;
    }
    interface ConfigurationSetEventDestinationEventDestinationSnsDestination {
        /**
         * The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to.
         */
        topicArn: string;
    }
    interface ConfigurationSetReputationOptions {
        /**
         * The date and time (in Unix time) when the reputation metrics were last given a fresh start. When your account is given a fresh start, your reputation metrics are calculated starting from the date of the fresh start.
         */
        lastFreshStart: string;
        /**
         * If `true`, tracking of reputation metrics is enabled for the configuration set. If `false`, tracking of reputation metrics is disabled for the configuration set.
         */
        reputationMetricsEnabled: boolean;
    }
    interface ConfigurationSetSendingOptions {
        /**
         * If `true`, email sending is enabled for the configuration set. If `false`, email sending is disabled for the configuration set.
         */
        sendingEnabled: boolean;
    }
    interface ConfigurationSetSuppressionOptions {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account. Valid values: `BOUNCE`, `COMPLAINT`.
         */
        suppressedReasons?: string[];
    }
    interface ConfigurationSetTrackingOptions {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain: string;
    }
    interface ConfigurationSetVdmOptions {
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Dashboard.
         */
        dashboardOptions?: outputs.sesv2.ConfigurationSetVdmOptionsDashboardOptions;
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Guardian.
         */
        guardianOptions?: outputs.sesv2.ConfigurationSetVdmOptionsGuardianOptions;
    }
    interface ConfigurationSetVdmOptionsDashboardOptions {
        /**
         * Specifies the status of your VDM engagement metrics collection. Valid values: `ENABLED`, `DISABLED`.
         */
        engagementMetrics?: string;
    }
    interface ConfigurationSetVdmOptionsGuardianOptions {
        /**
         * Specifies the status of your VDM optimized shared delivery. Valid values: `ENABLED`, `DISABLED`.
         */
        optimizedSharedDelivery?: string;
    }
    interface ContactListTopic {
        /**
         * Default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
         */
        defaultSubscriptionStatus: string;
        /**
         * Description of what the topic is about, which the contact will see.
         */
        description?: string;
        /**
         * Name of the topic the contact will see.
         */
        displayName: string;
        /**
         * Name of the topic.
         *
         * The following arguments are optional:
         */
        topicName: string;
    }
    interface EmailIdentityDkimSigningAttributes {
        /**
         * [Easy DKIM] The key length of the DKIM key pair in use.
         */
        currentSigningKeyLength: string;
        /**
         * [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
         *
         * > **NOTE:** You have to delete the first and last lines ('-----BEGIN PRIVATE KEY-----' and '-----END PRIVATE KEY-----', respectively) of the generated private key. Additionally, you have to remove the line breaks in the generated private key. The resulting value is a string of characters with no spaces or line breaks.
         */
        domainSigningPrivateKey?: string;
        /**
         * [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
         */
        domainSigningSelector?: string;
        /**
         * [Easy DKIM] The last time a key pair was generated for this identity.
         */
        lastKeyGenerationTimestamp: string;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day. Valid values: `RSA_1024_BIT`, `RSA_2048_BIT`.
         */
        nextSigningKeyLength: string;
        /**
         * A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
         */
        signingAttributesOrigin: string;
        /**
         * Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
         */
        status: string;
        /**
         * If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
         */
        tokens: string[];
    }
    interface GetConfigurationSetDeliveryOption {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName: string;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS).
         */
        tlsPolicy: string;
    }
    interface GetConfigurationSetReputationOption {
        /**
         * The date and time (in Unix time) when the reputation metrics were last given a fresh start.
         */
        lastFreshStart: string;
        /**
         * Specifies whether tracking of reputation metrics is enabled.
         */
        reputationMetricsEnabled: boolean;
    }
    interface GetConfigurationSetSendingOption {
        /**
         * Specifies whether email sending is enabled.
         */
        sendingEnabled: boolean;
    }
    interface GetConfigurationSetSuppressionOption {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
         */
        suppressedReasons: string[];
    }
    interface GetConfigurationSetTrackingOption {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain: string;
    }
    interface GetConfigurationSetVdmOption {
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Dashboard.
         */
        dashboardOptions: outputs.sesv2.GetConfigurationSetVdmOptionDashboardOption[];
        /**
         * Specifies additional settings for your VDM configuration as applicable to the Guardian.
         */
        guardianOptions: outputs.sesv2.GetConfigurationSetVdmOptionGuardianOption[];
    }
    interface GetConfigurationSetVdmOptionDashboardOption {
        /**
         * Specifies the status of your VDM engagement metrics collection.
         */
        engagementMetrics: string;
    }
    interface GetConfigurationSetVdmOptionGuardianOption {
        /**
         * Specifies the status of your VDM optimized shared delivery.
         */
        optimizedSharedDelivery: string;
    }
    interface GetDedicatedIpPoolDedicatedIp {
        /**
         * IPv4 address.
         */
        ip: string;
        /**
         * Indicates how complete the dedicated IP warm-up process is. When this value equals `1`, the address has completed the warm-up process and is ready for use.
         */
        warmupPercentage: number;
        /**
         * The warm-up status of a dedicated IP address. Valid values: `IN_PROGRESS`, `DONE`.
         */
        warmupStatus: string;
    }
    interface GetEmailIdentityDkimSigningAttribute {
        /**
         * [Easy DKIM] The key length of the DKIM key pair in use.
         */
        currentSigningKeyLength: string;
        domainSigningPrivateKey: string;
        domainSigningSelector: string;
        /**
         * [Easy DKIM] The last time a key pair was generated for this identity.
         */
        lastKeyGenerationTimestamp: string;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
         */
        nextSigningKeyLength: string;
        /**
         * A string that indicates how DKIM was configured for the identity. `AWS_SES` indicates that DKIM was configured for the identity by using Easy DKIM. `EXTERNAL` indicates that DKIM was configured for the identity by using Bring Your Own DKIM (BYODKIM).
         */
        signingAttributesOrigin: string;
        /**
         * Describes whether or not Amazon SES has successfully located the DKIM records in the DNS records for the domain. See the [AWS SES API v2 Reference](https://docs.aws.amazon.com/ses/latest/APIReference-V2/API_DkimAttributes.html#SES-Type-DkimAttributes-Status) for supported statuses.
         */
        status: string;
        /**
         * If you used Easy DKIM to configure DKIM authentication for the domain, then this object contains a set of unique strings that you use to create a set of CNAME records that you add to the DNS configuration for your domain. When Amazon SES detects these records in the DNS configuration for your domain, the DKIM authentication process is complete. If you configured DKIM authentication for the domain by providing your own public-private key pair, then this object contains the selector for the public key.
         */
        tokens: string[];
    }
}
export declare namespace sfn {
    interface AliasRoutingConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the state machine version.
         */
        stateMachineVersionArn: string;
        /**
         * Percentage of traffic routed to the state machine version.
         */
        weight: number;
    }
    interface GetAliasRoutingConfiguration {
        stateMachineVersionArn: string;
        weight: number;
    }
    interface StateMachineLoggingConfiguration {
        /**
         * Determines whether execution data is included in your log. When set to `false`, data is excluded.
         */
        includeExecutionData?: boolean;
        /**
         * Defines which category of execution history events are logged. Valid values: `ALL`, `ERROR`, `FATAL`, `OFF`
         */
        level?: string;
        /**
         * Amazon Resource Name (ARN) of a CloudWatch log group. Make sure the State Machine has the correct IAM policies for logging. The ARN must end with `:*`
         */
        logDestination?: string;
    }
    interface StateMachineTracingConfiguration {
        /**
         * When set to `true`, AWS X-Ray tracing is enabled. Make sure the State Machine has the correct IAM policies for logging. See the [AWS Step Functions Developer Guide](https://docs.aws.amazon.com/step-functions/latest/dg/xray-iam.html) for details.
         */
        enabled?: boolean;
    }
}
export declare namespace shield {
    interface ApplicationLayerAutomaticResponseTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface DrtAccessLogBucketAssociationTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
    }
    interface DrtAccessRoleArnAssociationTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface ProactiveEngagementEmergencyContact {
        contactNotes?: string;
        emailAddress: string;
        phoneNumber?: string;
    }
}
export declare namespace signer {
    interface GetSigningJobRevocationRecord {
        reason: string;
        revokedAt: string;
        revokedBy: string;
    }
    interface GetSigningJobSignedObject {
        s3s: outputs.signer.GetSigningJobSignedObjectS3[];
    }
    interface GetSigningJobSignedObjectS3 {
        bucket: string;
        key: string;
    }
    interface GetSigningJobSource {
        s3s: outputs.signer.GetSigningJobSourceS3[];
    }
    interface GetSigningJobSourceS3 {
        bucket: string;
        key: string;
        version: string;
    }
    interface GetSigningProfileRevocationRecord {
        revocationEffectiveFrom: string;
        revokedAt: string;
        revokedBy: string;
    }
    interface GetSigningProfileSignatureValidityPeriod {
        type: string;
        value: number;
    }
    interface SigningJobDestination {
        /**
         * A configuration block describing the S3 Destination object: See S3 Destination below for details.
         */
        s3: outputs.signer.SigningJobDestinationS3;
    }
    interface SigningJobDestinationS3 {
        bucket: string;
        prefix?: string;
    }
    interface SigningJobRevocationRecord {
        reason: string;
        revokedAt: string;
        revokedBy: string;
    }
    interface SigningJobSignedObject {
        s3s: outputs.signer.SigningJobSignedObjectS3[];
    }
    interface SigningJobSignedObjectS3 {
        bucket: string;
        key: string;
    }
    interface SigningJobSource {
        /**
         * A configuration block describing the S3 Source object: See S3 Source below for details.
         */
        s3: outputs.signer.SigningJobSourceS3;
    }
    interface SigningJobSourceS3 {
        bucket: string;
        key: string;
        version: string;
    }
    interface SigningProfileRevocationRecord {
        /**
         * The time when revocation becomes effective.
         */
        revocationEffectiveFrom: string;
        /**
         * The time when the signing profile was revoked.
         */
        revokedAt: string;
        /**
         * The identity of the revoker.
         */
        revokedBy: string;
    }
    interface SigningProfileSignatureValidityPeriod {
        /**
         * The time unit for signature validity. Valid values: `DAYS`, `MONTHS`, `YEARS`.
         */
        type: string;
        /**
         * The numerical value of the time unit for signature validity.
         */
        value: number;
    }
    interface SigningProfileSigningMaterial {
        /**
         * The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
         */
        certificateArn: string;
    }
}
export declare namespace ssm {
    interface AssociationOutputLocation {
        /**
         * The S3 bucket name.
         */
        s3BucketName: string;
        /**
         * The S3 bucket prefix. Results stored in the root if not configured.
         */
        s3KeyPrefix?: string;
        /**
         * The S3 bucket region.
         *
         * Targets specify what instance IDs or tags to apply the document to and has these keys:
         */
        s3Region?: string;
    }
    interface AssociationTarget {
        /**
         * Either `InstanceIds` or `tag:Tag Name` to specify an EC2 tag.
         */
        key: string;
        /**
         * A list of instance IDs or tag values. AWS currently limits this list size to one value.
         */
        values: string[];
    }
    interface ContactsRotationRecurrence {
        dailySettings?: outputs.ssm.ContactsRotationRecurrenceDailySetting[];
        /**
         * (Optional) Information about on-call rotations that recur monthly. See Monthly Settings for more details.
         */
        monthlySettings?: outputs.ssm.ContactsRotationRecurrenceMonthlySetting[];
        /**
         * (Required) The number of contacts, or shift team members designated to be on call concurrently during a shift.
         */
        numberOfOnCalls: number;
        /**
         * (Required) The number of days, weeks, or months a single rotation lasts.
         */
        recurrenceMultiplier: number;
        /**
         * (Optional) Information about the days of the week that the on-call rotation coverage includes. See Shift Coverages for more details.
         */
        shiftCoverages?: outputs.ssm.ContactsRotationRecurrenceShiftCoverage[];
        /**
         * (Optional) Information about on-call rotations that recur weekly. See Weekly Settings for more details.
         */
        weeklySettings?: outputs.ssm.ContactsRotationRecurrenceWeeklySetting[];
    }
    interface ContactsRotationRecurrenceDailySetting {
        /**
         * (Required) The hour of the day.
         */
        hourOfDay: number;
        /**
         * (Required) The minutes of the hour.
         */
        minuteOfHour: number;
    }
    interface ContactsRotationRecurrenceMonthlySetting {
        /**
         * (Required) The day of the month when monthly recurring on-call rotations begin.
         */
        dayOfMonth: number;
        /**
         * (Required) The hand off time. See Hand Off Time for more details.
         */
        handOffTime?: outputs.ssm.ContactsRotationRecurrenceMonthlySettingHandOffTime;
    }
    interface ContactsRotationRecurrenceMonthlySettingHandOffTime {
        /**
         * (Required) The hour of the day.
         */
        hourOfDay: number;
        /**
         * (Required) The minutes of the hour.
         */
        minuteOfHour: number;
    }
    interface ContactsRotationRecurrenceShiftCoverage {
        /**
         * (Required) Information about when an on-call shift begins and ends. See Coverage Times for more details.
         */
        coverageTimes?: outputs.ssm.ContactsRotationRecurrenceShiftCoverageCoverageTime[];
        mapBlockKey: string;
    }
    interface ContactsRotationRecurrenceShiftCoverageCoverageTime {
        /**
         * (Required) The end time of the on-call shift. See Hand Off Time for more details.
         */
        end?: outputs.ssm.ContactsRotationRecurrenceShiftCoverageCoverageTimeEnd;
        /**
         * (Required) The start time of the on-call shift. See Hand Off Time for more details.
         */
        start?: outputs.ssm.ContactsRotationRecurrenceShiftCoverageCoverageTimeStart;
    }
    interface ContactsRotationRecurrenceShiftCoverageCoverageTimeEnd {
        /**
         * (Required) The hour of the day.
         */
        hourOfDay: number;
        /**
         * (Required) The minutes of the hour.
         */
        minuteOfHour: number;
    }
    interface ContactsRotationRecurrenceShiftCoverageCoverageTimeStart {
        /**
         * (Required) The hour of the day.
         */
        hourOfDay: number;
        /**
         * (Required) The minutes of the hour.
         */
        minuteOfHour: number;
    }
    interface ContactsRotationRecurrenceWeeklySetting {
        /**
         * (Required) The day of the week when the shift coverage occurs.
         */
        dayOfWeek: string;
        /**
         * (Required) The hand off time. See Hand Off Time for more details.
         */
        handOffTime?: outputs.ssm.ContactsRotationRecurrenceWeeklySettingHandOffTime;
    }
    interface ContactsRotationRecurrenceWeeklySettingHandOffTime {
        /**
         * (Required) The hour of the day.
         */
        hourOfDay: number;
        /**
         * (Required) The minutes of the hour.
         */
        minuteOfHour: number;
    }
    interface DocumentAttachmentsSource {
        /**
         * The key of a key-value pair that identifies the location of an attachment to the document. Valid values: `SourceUrl`, `S3FileUrl`, `AttachmentReference`.
         */
        key: string;
        /**
         * The name of the document attachment file.
         */
        name?: string;
        /**
         * The value of a key-value pair that identifies the location of an attachment to the document. The argument format is a list of a single string that depends on the type of key you specify - see the [API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_AttachmentsSource.html) for details.
         */
        values: string[];
    }
    interface DocumentParameter {
        /**
         * If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
         */
        defaultValue: string;
        /**
         * A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
         */
        description: string;
        /**
         * The name of the document.
         */
        name: string;
        /**
         * The type of parameter. Valid values: `String`, `StringList`.
         */
        type: string;
    }
    interface GetContactsRotationRecurrence {
        dailySettings: any[];
        monthlySettings: any[];
        numberOfOnCalls: number;
        recurrenceMultiplier: number;
        shiftCoverages: any[];
        weeklySettings: any[];
    }
    interface GetInstancesFilter {
        /**
         * Name of the filter field. Valid values can be found in the [SSM InstanceInformationStringFilter API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_InstanceInformationStringFilter.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetMaintenanceWindowsFilter {
        /**
         * Name of the filter field. Valid values can be found in the [SSM DescribeMaintenanceWindows API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribeMaintenanceWindows.html#API_DescribeMaintenanceWindows_RequestSyntax).
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetPatchBaselineApprovalRule {
        /**
         * Number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline.
         */
        approveAfterDays: number;
        /**
         * Cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approveAfterDays`
         */
        approveUntilDate: string;
        /**
         * Compliance level for patches approved by this rule.
         */
        complianceLevel: string;
        /**
         * Boolean enabling the application of non-security updates.
         */
        enableNonSecurity: boolean;
        /**
         * Patch filter group that defines the criteria for the rule.
         */
        patchFilters: outputs.ssm.GetPatchBaselineApprovalRulePatchFilter[];
    }
    interface GetPatchBaselineApprovalRulePatchFilter {
        /**
         * Key for the filter.
         */
        key: string;
        /**
         * Value for the filter.
         */
        values: string[];
    }
    interface GetPatchBaselineGlobalFilter {
        /**
         * Key for the filter.
         */
        key: string;
        /**
         * Value for the filter.
         */
        values: string[];
    }
    interface GetPatchBaselineSource {
        /**
         * Value of the yum repo configuration.
         */
        configuration: string;
        /**
         * Name specified to identify the patch source.
         */
        name: string;
        /**
         * Specific operating system versions a patch repository applies to.
         */
        products: string[];
    }
    interface MaintenanceWindowTargetTarget {
        key: string;
        values: string[];
    }
    interface MaintenanceWindowTaskTarget {
        key: string;
        values: string[];
    }
    interface MaintenanceWindowTaskTaskInvocationParameters {
        /**
         * The parameters for an AUTOMATION task type. Documented below.
         */
        automationParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersAutomationParameters;
        /**
         * The parameters for a LAMBDA task type. Documented below.
         */
        lambdaParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersLambdaParameters;
        /**
         * The parameters for a RUN_COMMAND task type. Documented below.
         */
        runCommandParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParameters;
        /**
         * The parameters for a STEP_FUNCTIONS task type. Documented below.
         */
        stepFunctionsParameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParameters;
    }
    interface MaintenanceWindowTaskTaskInvocationParametersAutomationParameters {
        /**
         * The version of an Automation document to use during task execution.
         */
        documentVersion?: string;
        /**
         * The parameters for the RUN_COMMAND task execution. Documented below.
         */
        parameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameter[];
    }
    interface MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The array of strings.
         */
        values: string[];
    }
    interface MaintenanceWindowTaskTaskInvocationParametersLambdaParameters {
        /**
         * Pass client-specific information to the Lambda function that you are invoking.
         */
        clientContext?: string;
        /**
         * JSON to provide to your Lambda function as input.
         */
        payload?: string;
        /**
         * Specify a Lambda function version or alias name.
         */
        qualifier?: string;
    }
    interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParameters {
        /**
         * Configuration options for sending command output to CloudWatch Logs. Documented below.
         */
        cloudwatchConfig?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfig;
        /**
         * Information about the command(s) to execute.
         */
        comment?: string;
        /**
         * The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
         */
        documentHash?: string;
        /**
         * SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: `Sha256` and `Sha1`
         */
        documentHashType?: string;
        documentVersion?: string;
        /**
         * Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
         */
        notificationConfig?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfig;
        /**
         * The name of the Amazon S3 bucket.
         */
        outputS3Bucket?: string;
        /**
         * The Amazon S3 bucket subfolder.
         */
        outputS3KeyPrefix?: string;
        /**
         * The parameters for the RUN_COMMAND task execution. Documented below.
         */
        parameters?: outputs.ssm.MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameter[];
        /**
         * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
         */
        serviceRoleArn?: string;
        /**
         * If this time is reached and the command has not already started executing, it doesn't run.
         */
        timeoutSeconds?: number;
    }
    interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfig {
        /**
         * The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
         */
        cloudwatchLogGroupName: string;
        /**
         * Enables Systems Manager to send command output to CloudWatch Logs.
         */
        cloudwatchOutputEnabled?: boolean;
    }
    interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfig {
        /**
         * An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
         */
        notificationArn?: string;
        /**
         * The different events for which you can receive notifications. Valid values: `All`, `InProgress`, `Success`, `TimedOut`, `Cancelled`, and `Failed`
         */
        notificationEvents?: string[];
        /**
         * When specified with `Command`, receive notification when the status of a command changes. When specified with `Invocation`, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: `Command` and `Invocation`
         */
        notificationType?: string;
    }
    interface MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The array of strings.
         */
        values: string[];
    }
    interface MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParameters {
        /**
         * The inputs for the STEP_FUNCTION task.
         */
        input?: string;
        /**
         * The name of the STEP_FUNCTION task.
         */
        name?: string;
    }
    interface PatchBaselineApprovalRule {
        /**
         * Number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline. Valid Range: 0 to 100. Conflicts with `approveUntilDate`.
         */
        approveAfterDays?: number;
        /**
         * Cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approveAfterDays`
         */
        approveUntilDate?: string;
        /**
         * Compliance level for patches approved by this rule. Valid values are `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `INFORMATIONAL`, and `UNSPECIFIED`. The default value is `UNSPECIFIED`.
         */
        complianceLevel?: string;
        /**
         * Boolean enabling the application of non-security updates. The default value is `false`. Valid for Linux instances only.
         */
        enableNonSecurity?: boolean;
        /**
         * Patch filter group that defines the criteria for the rule. Up to 5 patch filters can be specified per approval rule using Key/Value pairs. Valid combinations of these Keys and the `operatingSystem` value can be found in the [SSM DescribePatchProperties API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchProperties.html). Valid Values are exact values for the patch property given as the key, or a wildcard `*`, which matches all values. `PATCH_SET` defaults to `OS` if unspecified
         */
        patchFilters: outputs.ssm.PatchBaselineApprovalRulePatchFilter[];
    }
    interface PatchBaselineApprovalRulePatchFilter {
        key: string;
        values: string[];
    }
    interface PatchBaselineGlobalFilter {
        key: string;
        values: string[];
    }
    interface PatchBaselineSource {
        /**
         * Value of the yum repo configuration. For information about other options available for your yum repository configuration, see the [`dnf.conf` documentation](https://man7.org/linux/man-pages/man5/dnf.conf.5.html)
         */
        configuration: string;
        /**
         * Name specified to identify the patch source.
         */
        name: string;
        /**
         * Specific operating system versions a patch repository applies to, such as `"Ubuntu16.04"`, `"AmazonLinux2016.09"`, `"RedhatEnterpriseLinux7.2"` or `"Suse12.7"`. For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html).
         */
        products: string[];
    }
    interface ResourceDataSyncS3Destination {
        /**
         * Name of S3 bucket where the aggregated data is stored.
         */
        bucketName: string;
        /**
         * ARN of an encryption key for a destination in Amazon S3.
         */
        kmsKeyArn?: string;
        /**
         * Prefix for the bucket.
         */
        prefix?: string;
        /**
         * Region with the bucket targeted by the Resource Data Sync.
         */
        region: string;
        /**
         * A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
         */
        syncFormat?: string;
    }
}
export declare namespace ssmcontacts {
    interface ContactChannelDeliveryAddress {
        /**
         * Details to engage this contact channel. The expected format depends on the contact channel type and is described in the [`ContactChannelAddress` section of the SSM Contacts API Reference](https://docs.aws.amazon.com/incident-manager/latest/APIReference/API_SSMContacts_ContactChannelAddress.html).
         */
        simpleAddress: string;
    }
    interface GetContactChannelDeliveryAddress {
        simpleAddress: string;
    }
    interface GetPlanStage {
        durationInMinutes: number;
        targets: outputs.ssmcontacts.GetPlanStageTarget[];
    }
    interface GetPlanStageTarget {
        channelTargetInfos: outputs.ssmcontacts.GetPlanStageTargetChannelTargetInfo[];
        contactTargetInfos: outputs.ssmcontacts.GetPlanStageTargetContactTargetInfo[];
    }
    interface GetPlanStageTargetChannelTargetInfo {
        contactChannelId: string;
        retryIntervalInMinutes: number;
    }
    interface GetPlanStageTargetContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact or escalation plan.
         */
        contactId: string;
        isEssential: boolean;
    }
    interface PlanStage {
        /**
         * The time to wait until beginning the next stage. The duration can only be set to 0 if a target is specified.
         */
        durationInMinutes: number;
        /**
         * One or more configuration blocks for specifying the contacts or contact methods that the escalation plan or engagement plan is engaging. See Target below for more details.
         */
        targets?: outputs.ssmcontacts.PlanStageTarget[];
    }
    interface PlanStageTarget {
        /**
         * A configuration block for specifying information about the contact channel that Incident Manager engages. See Channel Target Info for more details.
         */
        channelTargetInfo?: outputs.ssmcontacts.PlanStageTargetChannelTargetInfo;
        /**
         * A configuration block for specifying information about the contact that Incident Manager engages. See Contact Target Info for more details.
         */
        contactTargetInfo?: outputs.ssmcontacts.PlanStageTargetContactTargetInfo;
    }
    interface PlanStageTargetChannelTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact channel.
         */
        contactChannelId: string;
        /**
         * The number of minutes to wait before retrying to send engagement if the engagement initially failed.
         */
        retryIntervalInMinutes?: number;
    }
    interface PlanStageTargetContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact.
         */
        contactId?: string;
        /**
         * A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
         */
        isEssential: boolean;
    }
}
export declare namespace ssmincidents {
    interface GetReplicationSetRegion {
        /**
         * The ARN of the AWS Key Management Service (AWS KMS) encryption key.
         */
        kmsKeyArn: string;
        /**
         * The name of the Region.
         */
        name: string;
        /**
         * The current status of the Region.
         * * Valid Values: `ACTIVE` | `CREATING` | `UPDATING` | `DELETING` | `FAILED`
         */
        status: string;
        /**
         * More information about the status of a Region.
         */
        statusMessage: string;
    }
    interface GetResponsePlanAction {
        /**
         * The Systems Manager automation document to start as the runbook at the beginning of the incident. The following values are supported:
         */
        ssmAutomations: outputs.ssmincidents.GetResponsePlanActionSsmAutomation[];
    }
    interface GetResponsePlanActionSsmAutomation {
        /**
         * The automation document's name.
         */
        documentName: string;
        /**
         * The version of the automation document to use at runtime.
         */
        documentVersion: string;
        /**
         * The key-value pair used to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
         */
        dynamicParameters: {
            [key: string]: string;
        };
        /**
         * The key-value pair parameters used when the automation document runs. The following values are supported:
         */
        parameters: outputs.ssmincidents.GetResponsePlanActionSsmAutomationParameter[];
        /**
         * The Amazon Resource Name (ARN) of the role that the automation document assumes when it runs commands.
         */
        roleArn: string;
        /**
         * The account that runs the automation document. This can be in either the management account or an application account.
         */
        targetAccount: string;
    }
    interface GetResponsePlanActionSsmAutomationParameter {
        /**
         * The name of the PagerDuty configuration.
         */
        name: string;
        /**
         * The values for the associated parameter name.
         */
        values: string[];
    }
    interface GetResponsePlanIncidentTemplate {
        /**
         * A string used to stop Incident Manager from creating multiple incident records for the same incident.
         */
        dedupeString: string;
        /**
         * The impact value of a generated incident. The following values are supported:
         */
        impact: number;
        /**
         * The tags assigned to an incident template. When an incident starts, Incident Manager assigns the tags specified in the template to the incident.
         */
        incidentTags: {
            [key: string]: string;
        };
        /**
         * The Amazon Simple Notification Service (Amazon SNS) targets that this incident notifies when it is updated. The `notificationTarget` configuration block supports the following argument:
         */
        notificationTargets: outputs.ssmincidents.GetResponsePlanIncidentTemplateNotificationTarget[];
        /**
         * The summary of an incident.
         */
        summary: string;
        /**
         * The title of a generated incident.
         */
        title: string;
    }
    interface GetResponsePlanIncidentTemplateNotificationTarget {
        /**
         * The ARN of the Amazon SNS topic.
         */
        snsTopicArn: string;
    }
    interface GetResponsePlanIntegration {
        /**
         * Details about the PagerDuty configuration for a response plan. The following values are supported:
         */
        pagerduties: outputs.ssmincidents.GetResponsePlanIntegrationPagerduty[];
    }
    interface GetResponsePlanIntegrationPagerduty {
        /**
         * The name of the PagerDuty configuration.
         */
        name: string;
        /**
         * The ID of the AWS Secrets Manager secret that stores your PagerDuty key &mdash; either a General Access REST API Key or User Token REST API Key &mdash; and other user credentials.
         */
        secretId: string;
        /**
         * The ID of the PagerDuty service that the response plan associates with an incident when it launches.
         */
        serviceId: string;
    }
    interface ReplicationSetRegion {
        /**
         * The Amazon Resource name (ARN) of the customer managed key. If omitted, AWS manages the AWS KMS keys for you, using an AWS owned key, as indicated by a default value of `DefaultKey`.
         *
         * The following arguments are optional:
         */
        kmsKeyArn?: string;
        /**
         * The name of the Region, such as `ap-southeast-2`.
         */
        name: string;
        /**
         * The current status of the Region.
         * * Valid Values: `ACTIVE` | `CREATING` | `UPDATING` | `DELETING` | `FAILED`
         */
        status: string;
        /**
         * More information about the status of a Region.
         */
        statusMessage: string;
    }
    interface ResponsePlanAction {
        ssmAutomations?: outputs.ssmincidents.ResponsePlanActionSsmAutomation[];
    }
    interface ResponsePlanActionSsmAutomation {
        documentName: string;
        documentVersion?: string;
        dynamicParameters?: {
            [key: string]: string;
        };
        parameters?: outputs.ssmincidents.ResponsePlanActionSsmAutomationParameter[];
        roleArn: string;
        targetAccount?: string;
    }
    interface ResponsePlanActionSsmAutomationParameter {
        /**
         * The name of the response plan.
         */
        name: string;
        values: string[];
    }
    interface ResponsePlanIncidentTemplate {
        /**
         * A string used to stop Incident Manager from creating multiple incident records for the same incident.
         */
        dedupeString?: string;
        /**
         * The impact value of a generated incident. The following values are supported:
         */
        impact: number;
        /**
         * The tags assigned to an incident template. When an incident starts, Incident Manager assigns the tags specified in the template to the incident.
         */
        incidentTags?: {
            [key: string]: string;
        };
        /**
         * The Amazon Simple Notification Service (Amazon SNS) targets that this incident notifies when it is updated. The `notificationTarget` configuration block supports the following argument:
         */
        notificationTargets?: outputs.ssmincidents.ResponsePlanIncidentTemplateNotificationTarget[];
        /**
         * The summary of an incident.
         */
        summary?: string;
        /**
         * The title of a generated incident.
         */
        title: string;
    }
    interface ResponsePlanIncidentTemplateNotificationTarget {
        /**
         * The ARN of the Amazon SNS topic.
         *
         * The following arguments are optional:
         */
        snsTopicArn: string;
    }
    interface ResponsePlanIntegration {
        pagerduties?: outputs.ssmincidents.ResponsePlanIntegrationPagerduty[];
    }
    interface ResponsePlanIntegrationPagerduty {
        /**
         * The name of the response plan.
         */
        name: string;
        secretId: string;
        serviceId: string;
    }
}
export declare namespace ssoadmin {
    interface ApplicationPortalOptions {
        /**
         * Sign-in options for the access portal. See `signInOptions` below.
         */
        signInOptions?: outputs.ssoadmin.ApplicationPortalOptionsSignInOptions;
        /**
         * Indicates whether this application is visible in the access portal. Valid values are `ENABLED` and `DISABLED`.
         */
        visibility: string;
    }
    interface ApplicationPortalOptionsSignInOptions {
        /**
         * URL that accepts authentication requests for an application.
         */
        applicationUrl?: string;
        /**
         * Determines how IAM Identity Center navigates the user to the target application.
         * Valid values are `APPLICATION` and `IDENTITY_CENTER`.
         * If `APPLICATION` is set, IAM Identity Center redirects the customer to the configured `applicationUrl`.
         * If `IDENTITY_CENTER` is set, IAM Identity Center uses SAML identity-provider initiated authentication to sign the customer directly into a SAML-based application.
         */
        origin: string;
    }
    interface CustomerManagedPolicyAttachmentCustomerManagedPolicyReference {
        /**
         * Name of the customer managed IAM Policy to be attached.
         */
        name: string;
        /**
         * The path to the IAM policy to be attached. The default is `/`. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) for more information.
         */
        path?: string;
    }
    interface GetApplicationAssignmentsApplicationAssignment {
        /**
         * ARN of the application.
         */
        applicationArn: string;
        /**
         * An identifier for an object in IAM Identity Center, such as a user or group.
         */
        principalId: string;
        /**
         * Entity type for which the assignment will be created. Valid values are `USER` or `GROUP`.
         */
        principalType: string;
    }
    interface GetApplicationPortalOption {
        signInOptions?: outputs.ssoadmin.GetApplicationPortalOptionSignInOption[];
        visibility: string;
    }
    interface GetApplicationPortalOptionSignInOption {
        applicationUrl: string;
        origin: string;
    }
    interface GetApplicationProvidersApplicationProvider {
        /**
         * ARN of the application provider.
         */
        applicationProviderArn: string;
        /**
         * An object describing how IAM Identity Center represents the application provider in the portal. See `displayData` below.
         */
        displayDatas?: outputs.ssoadmin.GetApplicationProvidersApplicationProviderDisplayData[];
        /**
         * Protocol that the application provider uses to perform federation. Valid values are `SAML` and `OAUTH`.
         */
        federationProtocol: string;
    }
    interface GetApplicationProvidersApplicationProviderDisplayData {
        /**
         * Description of the application provider.
         */
        description: string;
        /**
         * Name of the application provider.
         */
        displayName: string;
        /**
         * URL that points to an icon that represents the application provider.
         */
        iconUrl: string;
    }
    interface GetPrincipalApplicationAssignmentsApplicationAssignment {
        /**
         * ARN of the application.
         */
        applicationArn: string;
        /**
         * An identifier for an object in IAM Identity Center, such as a user or group.
         */
        principalId: string;
        /**
         * Entity type for which the assignment will be created. Valid values are `USER` or `GROUP`.
         */
        principalType: string;
    }
    interface InstanceAccessControlAttributesAttribute {
        key: string;
        values: outputs.ssoadmin.InstanceAccessControlAttributesAttributeValue[];
    }
    interface InstanceAccessControlAttributesAttributeValue {
        sources: string[];
    }
    interface PermissionsBoundaryAttachmentPermissionsBoundary {
        /**
         * Specifies the name and path of a customer managed policy. See below.
         */
        customerManagedPolicyReference?: outputs.ssoadmin.PermissionsBoundaryAttachmentPermissionsBoundaryCustomerManagedPolicyReference;
        /**
         * AWS-managed IAM policy ARN to use as the permissions boundary.
         */
        managedPolicyArn?: string;
    }
    interface PermissionsBoundaryAttachmentPermissionsBoundaryCustomerManagedPolicyReference {
        /**
         * Name of the customer managed IAM Policy to be attached.
         */
        name: string;
        /**
         * The path to the IAM policy to be attached. The default is `/`. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) for more information.
         */
        path?: string;
    }
    interface TrustedTokenIssuerTrustedTokenIssuerConfiguration {
        /**
         * A block that describes the settings for a trusted token issuer that works with OpenID Connect (OIDC) by using JSON Web Tokens (JWT). See Documented below below.
         */
        oidcJwtConfiguration?: outputs.ssoadmin.TrustedTokenIssuerTrustedTokenIssuerConfigurationOidcJwtConfiguration;
    }
    interface TrustedTokenIssuerTrustedTokenIssuerConfigurationOidcJwtConfiguration {
        /**
         * Specifies the path of the source attribute in the JWT from the trusted token issuer.
         */
        claimAttributePath: string;
        /**
         * Specifies path of the destination attribute in a JWT from IAM Identity Center. The attribute mapped by this JMESPath expression is compared against the attribute mapped by `claimAttributePath` when a trusted token issuer token is exchanged for an IAM Identity Center token.
         */
        identityStoreAttributePath: string;
        /**
         * Specifies the URL that IAM Identity Center uses for OpenID Discovery. OpenID Discovery is used to obtain the information required to verify the tokens that the trusted token issuer generates.
         */
        issuerUrl: string;
        /**
         * The method that the trusted token issuer can use to retrieve the JSON Web Key Set used to verify a JWT. Valid values are `OPEN_ID_DISCOVERY`
         */
        jwksRetrievalOption: string;
    }
}
export declare namespace storagegateway {
    interface FileSystemAssociationCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: `0` or `300` to `2592000` seconds (5 minutes to 30 days). Defaults to `0`
         */
        cacheStaleTimeoutInSeconds?: number;
    }
    interface GatewayGatewayNetworkInterface {
        /**
         * The Internet Protocol version 4 (IPv4) address of the interface.
         */
        ipv4Address: string;
    }
    interface GatewayMaintenanceStartTime {
        /**
         * The day of the month component of the maintenance start time represented as an ordinal number from 1 to 28, where 1 represents the first day of the month and 28 represents the last day of the month.
         */
        dayOfMonth?: string;
        /**
         * The day of the week component of the maintenance start time week represented as an ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.
         */
        dayOfWeek?: string;
        /**
         * The hour component of the maintenance start time represented as _hh_, where _hh_ is the hour (00 to 23). The hour of the day is in the time zone of the gateway.
         */
        hourOfDay: number;
        /**
         * The minute component of the maintenance start time represented as _mm_, where _mm_ is the minute (00 to 59). The minute of the hour is in the time zone of the gateway.
         */
        minuteOfHour?: number;
    }
    interface GatewaySmbActiveDirectorySettings {
        activeDirectoryStatus: string;
        /**
         * List of IPv4 addresses, NetBIOS names, or host names of your domain server.
         * If you need to specify the port number include it after the colon (“:”). For example, `mydc.mydomain.com:389`.
         */
        domainControllers?: string[];
        /**
         * The name of the domain that you want the gateway to join.
         */
        domainName: string;
        /**
         * The organizational unit (OU) is a container in an Active Directory that can hold users, groups,
         * computers, and other OUs and this parameter specifies the OU that the gateway will join within the AD domain.
         */
        organizationalUnit?: string;
        /**
         * The password of the user who has permission to add the gateway to the Active Directory domain.
         */
        password: string;
        /**
         * Specifies the time in seconds, in which the JoinDomain operation must complete. The default is `20` seconds.
         */
        timeoutInSeconds?: number;
        /**
         * The user name of user who has permission to add the gateway to the Active Directory domain.
         */
        username: string;
    }
    interface NfsFileShareCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
         */
        cacheStaleTimeoutInSeconds?: number;
    }
    interface NfsFileShareNfsFileShareDefaults {
        /**
         * The Unix directory mode in the string form "nnnn". Defaults to `"0777"`.
         */
        directoryMode?: string;
        /**
         * The Unix file mode in the string form "nnnn". Defaults to `"0666"`.
         */
        fileMode?: string;
        /**
         * The default group ID for the file share (unless the files have another group ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
         */
        groupId?: string;
        /**
         * The default owner ID for the file share (unless the files have another owner ID specified). Defaults to `65534` (`nfsnobody`). Valid values: `0` through `4294967294`.
         */
        ownerId?: string;
    }
    interface SmbFileShareCacheAttributes {
        /**
         * Refreshes a file share's cache by using Time To Live (TTL).
         * TTL is the length of time since the last refresh after which access to the directory would cause the file gateway
         * to first refresh that directory's contents from the Amazon S3 bucket. Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)
         */
        cacheStaleTimeoutInSeconds?: number;
    }
}
export declare namespace synthetics {
    interface CanaryArtifactConfig {
        /**
         * Configuration of the encryption-at-rest settings for artifacts that the canary uploads to Amazon S3. See S3 Encryption.
         */
        s3Encryption?: outputs.synthetics.CanaryArtifactConfigS3Encryption;
    }
    interface CanaryArtifactConfigS3Encryption {
        /**
         * The encryption method to use for artifacts created by this canary. Valid values are: `SSE_S3` and `SSE_KMS`.
         */
        encryptionMode?: string;
        /**
         * The ARN of the customer-managed KMS key to use, if you specify `SSE_KMS` for `encryptionMode`.
         */
        kmsKeyArn?: string;
    }
    interface CanaryRunConfig {
        /**
         * Whether this canary is to use active AWS X-Ray tracing when it runs. You can enable active tracing only for canaries that use version syn-nodejs-2.0 or later for their canary runtime.
         */
        activeTracing?: boolean;
        /**
         * Map of environment variables that are accessible from the canary during execution. Please see [AWS Docs](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime) for variables reserved for Lambda.
         */
        environmentVariables?: {
            [key: string]: string;
        };
        /**
         * Maximum amount of memory available to the canary while it is running, in MB. The value you specify must be a multiple of 64.
         */
        memoryInMb: number;
        /**
         * Number of seconds the canary is allowed to run before it must stop. If you omit this field, the frequency of the canary is used, up to a maximum of 840 (14 minutes).
         */
        timeoutInSeconds?: number;
    }
    interface CanarySchedule {
        /**
         * Duration in seconds, for the canary to continue making regular runs according to the schedule in the Expression value.
         */
        durationInSeconds?: number;
        /**
         * Rate expression or cron expression that defines how often the canary is to run. For rate expression, the syntax is `rate(number unit)`. _unit_ can be `minute`, `minutes`, or `hour`. For cron expression, the syntax is `cron(expression)`. For more information about the syntax for cron expressions, see [Scheduling canary runs using cron](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html).
         */
        expression: string;
    }
    interface CanaryTimeline {
        /**
         * Date and time the canary was created.
         */
        created: string;
        /**
         * Date and time the canary was most recently modified.
         */
        lastModified: string;
        /**
         * Date and time that the canary's most recent run started.
         */
        lastStarted: string;
        /**
         * Date and time that the canary's most recent run ended.
         */
        lastStopped: string;
    }
    interface CanaryVpcConfig {
        /**
         * IDs of the security groups for this canary.
         */
        securityGroupIds?: string[];
        /**
         * IDs of the subnets where this canary is to run.
         */
        subnetIds?: string[];
        /**
         * ID of the VPC where this canary is to run.
         */
        vpcId: string;
    }
}
export declare namespace timestreamwrite {
    interface TableMagneticStoreWriteProperties {
        /**
         * A flag to enable magnetic store writes.
         */
        enableMagneticStoreWrites?: boolean;
        /**
         * The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
         */
        magneticStoreRejectedDataLocation?: outputs.timestreamwrite.TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation;
    }
    interface TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation {
        /**
         * Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
         */
        s3Configuration?: outputs.timestreamwrite.TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration;
    }
    interface TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration {
        /**
         * Bucket name of the customer S3 bucket.
         */
        bucketName?: string;
        /**
         * Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
         */
        encryptionOption?: string;
        /**
         * KMS key arn for the customer s3 location when encrypting with a KMS managed key.
         */
        kmsKeyId?: string;
        /**
         * Object key prefix for the customer S3 location.
         */
        objectKeyPrefix?: string;
    }
    interface TableRetentionProperties {
        /**
         * The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
         */
        magneticStoreRetentionPeriodInDays: number;
        /**
         * The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
         */
        memoryStoreRetentionPeriodInHours: number;
    }
    interface TableSchema {
        /**
         * A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed. See Composite Partition Key below for more details.
         */
        compositePartitionKey: outputs.timestreamwrite.TableSchemaCompositePartitionKey;
    }
    interface TableSchemaCompositePartitionKey {
        /**
         * The level of enforcement for the specification of a dimension key in ingested records. Valid values: `REQUIRED`, `OPTIONAL`.
         */
        enforcementInRecord?: string;
        /**
         * The name of the attribute used for a dimension key.
         */
        name?: string;
        /**
         * The type of the partition key. Valid values: `DIMENSION`, `MEASURE`.
         */
        type: string;
    }
}
export declare namespace transcribe {
    interface LanguageModelInputDataConfig {
        /**
         * IAM role with access to S3 bucket.
         */
        dataAccessRoleArn: string;
        /**
         * S3 URI where training data is located.
         */
        s3Uri: string;
        /**
         * S3 URI where tuning data is located.
         *
         * The following arguments are optional:
         */
        tuningDataS3Uri: string;
    }
}
export declare namespace transfer {
    interface AccessHomeDirectoryMapping {
        /**
         * Represents an entry and a target.
         */
        entry: string;
        /**
         * Represents the map target.
         */
        target: string;
    }
    interface AccessPosixProfile {
        /**
         * The POSIX group ID used for all EFS operations by this user.
         */
        gid: number;
        /**
         * The secondary POSIX group IDs used for all EFS operations by this user.
         */
        secondaryGids?: number[];
        /**
         * The POSIX user ID used for all EFS operations by this user.
         */
        uid: number;
    }
    interface ConnectorAs2Config {
        compression: string;
        encryptionAlgorithm: string;
        localProfileId: string;
        mdnResponse: string;
        mdnSigningAlgorithm?: string;
        messageSubject?: string;
        partnerProfileId: string;
        signingAlgorithm: string;
    }
    interface ConnectorSftpConfig {
        trustedHostKeys?: string[];
        userSecretId?: string;
    }
    interface ServerEndpointDetails {
        /**
         * A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when `endpointType` is set to `VPC`.
         */
        addressAllocationIds?: string[];
        /**
         * A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when `endpointType` is set to `VPC`.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when `endpointType` is set to `VPC`.
         */
        subnetIds?: string[];
        /**
         * The ID of the VPC endpoint. This property can only be used when `endpointType` is set to `VPC_ENDPOINT`
         */
        vpcEndpointId: string;
        /**
         * The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when `endpointType` is set to `VPC`.
         */
        vpcId?: string;
    }
    interface ServerProtocolDetails {
        /**
         * Indicates the transport method for the AS2 messages. Currently, only `HTTP` is supported.
         */
        as2Transports: string[];
        /**
         * Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
         */
        passiveIp: string;
        /**
         * Use to ignore the error that is generated when the client attempts to use `SETSTAT` on a file you are uploading to an S3 bucket. Valid values: `DEFAULT`, `ENABLE_NO_OP`.
         */
        setStatOption: string;
        /**
         * A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: `DISABLED`, `ENABLED`, `ENFORCED`.
         */
        tlsSessionResumptionMode: string;
    }
    interface ServerS3StorageOptions {
        /**
         * Specifies whether or not performance for your Amazon S3 directories is optimized. Valid values are `DISABLED`, `ENABLED`.
         *
         * By default, home directory mappings have a `TYPE` of `DIRECTORY`. If you enable this option, you would then need to explicitly set the `HomeDirectoryMapEntry` Type to `FILE` if you want a mapping to have a file target. See [Using logical directories to simplify your Transfer Family directory structures](https://docs.aws.amazon.com/transfer/latest/userguide/logical-dir-mappings.html) for details.
         */
        directoryListingOptimization: string;
    }
    interface ServerWorkflowDetails {
        /**
         * A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below. See `onPartialUpload` block below for details.
         */
        onPartialUpload?: outputs.transfer.ServerWorkflowDetailsOnPartialUpload;
        /**
         * A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See `onUpload` block below for details.
         */
        onUpload?: outputs.transfer.ServerWorkflowDetailsOnUpload;
    }
    interface ServerWorkflowDetailsOnPartialUpload {
        /**
         * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
         */
        executionRole: string;
        /**
         * A unique identifier for the workflow.
         */
        workflowId: string;
    }
    interface ServerWorkflowDetailsOnUpload {
        /**
         * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
         */
        executionRole: string;
        /**
         * A unique identifier for the workflow.
         */
        workflowId: string;
    }
    interface UserHomeDirectoryMapping {
        /**
         * Represents an entry and a target.
         */
        entry: string;
        /**
         * Represents the map target.
         *
         * The `Restricted` option is achieved using the following mapping:
         *
         * ```
         * home_directory_mappings {
         * entry  = "/"
         * target = "/${aws_s3_bucket.foo.id}/$${Transfer:UserName}"
         * }
         * ```
         */
        target: string;
    }
    interface UserPosixProfile {
        /**
         * The POSIX group ID used for all EFS operations by this user.
         */
        gid: number;
        /**
         * The secondary POSIX group IDs used for all EFS operations by this user.
         */
        secondaryGids?: number[];
        /**
         * The POSIX user ID used for all EFS operations by this user.
         */
        uid: number;
    }
    interface WorkflowOnExceptionStep {
        copyStepDetails?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetails;
        customStepDetails?: outputs.transfer.WorkflowOnExceptionStepCustomStepDetails;
        decryptStepDetails?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetails;
        deleteStepDetails?: outputs.transfer.WorkflowOnExceptionStepDeleteStepDetails;
        tagStepDetails?: outputs.transfer.WorkflowOnExceptionStepTagStepDetails;
        type: string;
    }
    interface WorkflowOnExceptionStepCopyStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }
    interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationS3FileLocation;
    }
    interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }
    interface WorkflowOnExceptionStepCopyStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }
    interface WorkflowOnExceptionStepCustomStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: string;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: number;
    }
    interface WorkflowOnExceptionStepDecryptStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The type of encryption used. Currently, this value must be `"PGP"`.
         */
        type: string;
    }
    interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationS3FileLocation;
    }
    interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }
    interface WorkflowOnExceptionStepDecryptStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }
    interface WorkflowOnExceptionStepDeleteStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }
    interface WorkflowOnExceptionStepTagStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * Array that contains from 1 to 10 key/value pairs. See S3 Tags below.
         */
        tags?: outputs.transfer.WorkflowOnExceptionStepTagStepDetailsTag[];
    }
    interface WorkflowOnExceptionStepTagStepDetailsTag {
        key: string;
        value: string;
    }
    interface WorkflowStep {
        copyStepDetails?: outputs.transfer.WorkflowStepCopyStepDetails;
        customStepDetails?: outputs.transfer.WorkflowStepCustomStepDetails;
        decryptStepDetails?: outputs.transfer.WorkflowStepDecryptStepDetails;
        deleteStepDetails?: outputs.transfer.WorkflowStepDeleteStepDetails;
        tagStepDetails?: outputs.transfer.WorkflowStepTagStepDetails;
        type: string;
    }
    interface WorkflowStepCopyStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }
    interface WorkflowStepCopyStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowStepCopyStepDetailsDestinationFileLocationS3FileLocation;
    }
    interface WorkflowStepCopyStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }
    interface WorkflowStepCopyStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }
    interface WorkflowStepCustomStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: string;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: number;
    }
    interface WorkflowStepDecryptStepDetails {
        /**
         * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
         */
        destinationFileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocation;
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is `FALSE`. Valid values are `TRUE` and `FALSE`.
         */
        overwriteExisting?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * The type of encryption used. Currently, this value must be `"PGP"`.
         */
        type: string;
    }
    interface WorkflowStepDecryptStepDetailsDestinationFileLocation {
        /**
         * Specifies the details for the EFS file being copied.
         */
        efsFileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocationEfsFileLocation;
        /**
         * Specifies the details for the S3 file being copied.
         */
        s3FileLocation?: outputs.transfer.WorkflowStepDecryptStepDetailsDestinationFileLocationS3FileLocation;
    }
    interface WorkflowStepDecryptStepDetailsDestinationFileLocationEfsFileLocation {
        /**
         * The ID of the file system, assigned by Amazon EFS.
         */
        fileSystemId?: string;
        /**
         * The pathname for the folder being used by a workflow.
         */
        path?: string;
    }
    interface WorkflowStepDecryptStepDetailsDestinationFileLocationS3FileLocation {
        /**
         * Specifies the S3 bucket for the customer input file.
         */
        bucket?: string;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: string;
    }
    interface WorkflowStepDeleteStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
    }
    interface WorkflowStepTagStepDetails {
        /**
         * The name of the step, used as an identifier.
         */
        name?: string;
        /**
         * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
         */
        sourceFileLocation?: string;
        /**
         * Array that contains from 1 to 10 key/value pairs. See S3 Tags below.
         */
        tags?: outputs.transfer.WorkflowStepTagStepDetailsTag[];
    }
    interface WorkflowStepTagStepDetailsTag {
        key: string;
        value: string;
    }
}
export declare namespace verifiedaccess {
    interface EndpointLoadBalancerOptions {
        loadBalancerArn?: string;
        port?: number;
        protocol?: string;
        subnetIds?: string[];
    }
    interface EndpointNetworkInterfaceOptions {
        networkInterfaceId?: string;
        port?: number;
        protocol?: string;
    }
    interface EndpointSseSpecification {
        customerManagedKeyEnabled?: boolean;
        kmsKeyArn?: string;
    }
    interface GroupSseConfiguration {
        customerManagedKeyEnabled?: boolean;
        /**
         * ARN of the KMS key to use.
         */
        kmsKeyArn?: string;
    }
    interface InstanceLoggingConfigurationAccessLogs {
        /**
         * A block that specifies configures sending Verified Access logs to CloudWatch Logs. Detailed below.
         */
        cloudwatchLogs?: outputs.verifiedaccess.InstanceLoggingConfigurationAccessLogsCloudwatchLogs;
        /**
         * Include trust data sent by trust providers into the logs.
         */
        includeTrustContext: boolean;
        /**
         * A block that specifies configures sending Verified Access logs to Kinesis. Detailed below.
         */
        kinesisDataFirehose?: outputs.verifiedaccess.InstanceLoggingConfigurationAccessLogsKinesisDataFirehose;
        /**
         * The logging version to use. Refer to [VerifiedAccessLogOptions](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VerifiedAccessLogOptions.html) for the allowed values.
         */
        logVersion: string;
        /**
         * A block that specifies configures sending Verified Access logs to S3. Detailed below.
         */
        s3?: outputs.verifiedaccess.InstanceLoggingConfigurationAccessLogsS3;
    }
    interface InstanceLoggingConfigurationAccessLogsCloudwatchLogs {
        /**
         * Indicates whether logging is enabled.
         */
        enabled: boolean;
        /**
         * The name of the CloudWatch Logs Log Group.
         */
        logGroup?: string;
    }
    interface InstanceLoggingConfigurationAccessLogsKinesisDataFirehose {
        /**
         * The name of the delivery stream.
         */
        deliveryStream?: string;
        /**
         * Indicates whether logging is enabled.
         */
        enabled: boolean;
    }
    interface InstanceLoggingConfigurationAccessLogsS3 {
        /**
         * The name of S3 bucket.
         */
        bucketName?: string;
        /**
         * The ID of the AWS account that owns the Amazon S3 bucket.
         */
        bucketOwner: string;
        /**
         * Indicates whether logging is enabled.
         */
        enabled: boolean;
        /**
         * The bucket prefix.
         */
        prefix?: string;
    }
    interface InstanceVerifiedAccessTrustProvider {
        /**
         * A description for the AWS Verified Access Instance.
         */
        description: string;
        /**
         * The type of device-based trust provider.
         */
        deviceTrustProviderType: string;
        /**
         * The type of trust provider (user- or device-based).
         */
        trustProviderType: string;
        /**
         * The type of user-based trust provider.
         */
        userTrustProviderType: string;
        /**
         * The ID of the trust provider.
         */
        verifiedAccessTrustProviderId: string;
    }
    interface TrustProviderDeviceOptions {
        tenantId?: string;
    }
    interface TrustProviderOidcOptions {
        authorizationEndpoint?: string;
        clientId?: string;
        clientSecret: string;
        issuer?: string;
        scope?: string;
        tokenEndpoint?: string;
        userInfoEndpoint?: string;
    }
}
export declare namespace verifiedpermissions {
    interface GetPolicyStoreValidationSetting {
        mode: string;
    }
    interface PolicyDefinition {
        /**
         * The static policy statement. See Static below.
         */
        static?: outputs.verifiedpermissions.PolicyDefinitionStatic;
        /**
         * The template linked policy. See Template Linked below.
         */
        templateLinked?: outputs.verifiedpermissions.PolicyDefinitionTemplateLinked;
    }
    interface PolicyDefinitionStatic {
        /**
         * The description of the static policy.
         */
        description?: string;
        /**
         * The statement of the static policy.
         */
        statement: string;
    }
    interface PolicyDefinitionTemplateLinked {
        /**
         * The ID of the template.
         */
        policyTemplateId: string;
        /**
         * The principal of the template linked policy.
         */
        principal?: outputs.verifiedpermissions.PolicyDefinitionTemplateLinkedPrincipal;
        /**
         * The resource of the template linked policy.
         */
        resource?: outputs.verifiedpermissions.PolicyDefinitionTemplateLinkedResource;
    }
    interface PolicyDefinitionTemplateLinkedPrincipal {
        /**
         * The entity ID of the principal.
         */
        entityId: string;
        /**
         * The entity type of the principal.
         */
        entityType: string;
    }
    interface PolicyDefinitionTemplateLinkedResource {
        /**
         * The entity ID of the resource.
         */
        entityId: string;
        /**
         * The entity type of the resource.
         */
        entityType: string;
    }
    interface PolicyStoreValidationSettings {
        /**
         * The mode for the validation settings. Valid values: `OFF`, `STRICT`.
         *
         * The following arguments are optional:
         */
        mode: string;
    }
    interface SchemaDefinition {
        /**
         * A JSON string representation of the schema.
         */
        value: string;
    }
}
export declare namespace vpc {
    interface GetSecurityGroupRuleFilter {
        /**
         * Name of the filter field. Valid values can be found in the EC2 [`DescribeSecurityGroupRules`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroupRules.html) API Reference.
         */
        name: string;
        /**
         * Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
         */
        values: string[];
    }
    interface GetSecurityGroupRulesFilter {
        /**
         * Name of the field to filter by, as defined by
         * [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroupRules.html).
         */
        name: string;
        /**
         * Set of values that are accepted for the given field.
         * Security group rule IDs will be selected if any one of the given values match.
         */
        values: string[];
    }
}
export declare namespace vpclattice {
    interface GetListenerDefaultAction {
        fixedResponses: outputs.vpclattice.GetListenerDefaultActionFixedResponse[];
        forwards: outputs.vpclattice.GetListenerDefaultActionForward[];
    }
    interface GetListenerDefaultActionFixedResponse {
        statusCode: number;
    }
    interface GetListenerDefaultActionForward {
        targetGroups: outputs.vpclattice.GetListenerDefaultActionForwardTargetGroup[];
    }
    interface GetListenerDefaultActionForwardTargetGroup {
        targetGroupIdentifier: string;
        weight: number;
    }
    interface GetServiceDnsEntry {
        domainName: string;
        hostedZoneId: string;
    }
    interface ListenerDefaultAction {
        fixedResponse?: outputs.vpclattice.ListenerDefaultActionFixedResponse;
        /**
         * Route requests to one or more target groups. See Forward blocks below.
         *
         * > **NOTE:** You must specify exactly one of the following argument blocks: `fixedResponse` or `forward`.
         */
        forwards?: outputs.vpclattice.ListenerDefaultActionForward[];
    }
    interface ListenerDefaultActionFixedResponse {
        /**
         * Custom HTTP status code to return, e.g. a 404 response code. See [Listeners](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html) in the AWS documentation for a list of supported codes.
         */
        statusCode: number;
    }
    interface ListenerDefaultActionForward {
        /**
         * One or more target group blocks.
         */
        targetGroups?: outputs.vpclattice.ListenerDefaultActionForwardTargetGroup[];
    }
    interface ListenerDefaultActionForwardTargetGroup {
        targetGroupIdentifier?: string;
        weight?: number;
    }
    interface ListenerRuleAction {
        /**
         * Describes the rule action that returns a custom HTTP response.
         */
        fixedResponse?: outputs.vpclattice.ListenerRuleActionFixedResponse;
        /**
         * The forward action. Traffic that matches the rule is forwarded to the specified target groups.
         */
        forward?: outputs.vpclattice.ListenerRuleActionForward;
    }
    interface ListenerRuleActionFixedResponse {
        /**
         * The HTTP response code.
         */
        statusCode: number;
    }
    interface ListenerRuleActionForward {
        /**
         * The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
         *
         * The default value is 1 with maximum number of 2. If only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
         */
        targetGroups: outputs.vpclattice.ListenerRuleActionForwardTargetGroup[];
    }
    interface ListenerRuleActionForwardTargetGroup {
        targetGroupIdentifier: string;
        weight?: number;
    }
    interface ListenerRuleMatch {
        /**
         * The HTTP criteria that a rule must match.
         */
        httpMatch?: outputs.vpclattice.ListenerRuleMatchHttpMatch;
    }
    interface ListenerRuleMatchHttpMatch {
        /**
         * The header matches. Matches incoming requests with rule based on request header value before applying rule action.
         */
        headerMatches?: outputs.vpclattice.ListenerRuleMatchHttpMatchHeaderMatch[];
        /**
         * The HTTP method type.
         */
        method?: string;
        /**
         * The path match.
         */
        pathMatch?: outputs.vpclattice.ListenerRuleMatchHttpMatchPathMatch;
    }
    interface ListenerRuleMatchHttpMatchHeaderMatch {
        /**
         * Indicates whether the match is case sensitive. Defaults to false.
         */
        caseSensitive?: boolean;
        /**
         * The header match type.
         */
        match: outputs.vpclattice.ListenerRuleMatchHttpMatchHeaderMatchMatch;
        /**
         * The name of the header.
         */
        name: string;
    }
    interface ListenerRuleMatchHttpMatchHeaderMatchMatch {
        /**
         * Specifies a contains type match.
         */
        contains?: string;
        /**
         * Specifies an exact type match.
         */
        exact?: string;
        /**
         * Specifies a prefix type match. Matches the value with the prefix.
         */
        prefix?: string;
    }
    interface ListenerRuleMatchHttpMatchPathMatch {
        /**
         * Indicates whether the match is case sensitive. Defaults to false.
         */
        caseSensitive?: boolean;
        /**
         * The header match type.
         */
        match: outputs.vpclattice.ListenerRuleMatchHttpMatchPathMatchMatch;
    }
    interface ListenerRuleMatchHttpMatchPathMatchMatch {
        /**
         * Specifies an exact type match.
         */
        exact?: string;
        /**
         * Specifies a prefix type match. Matches the value with the prefix.
         */
        prefix?: string;
    }
    interface ServiceDnsEntry {
        domainName: string;
        hostedZoneId: string;
    }
    interface ServiceNetworkServiceAssociationDnsEntry {
        /**
         * The domain name of the service.
         */
        domainName: string;
        /**
         * The ID of the hosted zone.
         */
        hostedZoneId: string;
    }
    interface TargetGroupAttachmentTarget {
        /**
         * The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
         */
        id: string;
        /**
         * This port is used for routing traffic to the target, and defaults to the target group port. However, you can override the default and specify a custom port.
         */
        port: number;
    }
    interface TargetGroupConfig {
        /**
         * The health check configuration.
         */
        healthCheck?: outputs.vpclattice.TargetGroupConfigHealthCheck;
        /**
         * The type of IP address used for the target group. Valid values: `IPV4` | `IPV6`.
         */
        ipAddressType: string;
        /**
         * The version of the event structure that the Lambda function receives. Supported only if `type` is `LAMBDA`. Valid Values are `V1` | `V2`.
         */
        lambdaEventStructureVersion: string;
        /**
         * The port on which the targets are listening.
         */
        port: number;
        /**
         * The protocol to use for routing traffic to the targets. Valid Values are `HTTP` | `HTTPS`.
         */
        protocol: string;
        /**
         * The protocol version. Valid Values are `HTTP1` | `HTTP2` | `GRPC`. Default value is `HTTP1`.
         */
        protocolVersion: string;
        /**
         * The ID of the VPC.
         */
        vpcIdentifier?: string;
    }
    interface TargetGroupConfigHealthCheck {
        /**
         * Indicates whether health checking is enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
         */
        healthCheckIntervalSeconds?: number;
        /**
         * The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
         * * `healthyThresholdCount ` - (Optional) The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
         */
        healthCheckTimeoutSeconds?: number;
        healthyThresholdCount?: number;
        /**
         * The codes to use when checking for a successful response from a target. These are called _Success codes_ in the console.
         */
        matcher?: outputs.vpclattice.TargetGroupConfigHealthCheckMatcher;
        /**
         * The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is `/`. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
         */
        path?: string;
        /**
         * The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
         */
        port: number;
        /**
         * The protocol used when performing health checks on targets. The possible protocols are `HTTP` and `HTTPS`.
         */
        protocol: string;
        /**
         * The protocol version used when performing health checks on targets. The possible protocol versions are `HTTP1` and `HTTP2`. The default is `HTTP1`.
         */
        protocolVersion?: string;
        /**
         * The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
         */
        unhealthyThresholdCount?: number;
    }
    interface TargetGroupConfigHealthCheckMatcher {
        /**
         * The HTTP codes to use when checking for a successful response from a target.
         */
        value?: string;
    }
}
export declare namespace waf {
    interface ByteMatchSetByteMatchTuple {
        fieldToMatch: outputs.waf.ByteMatchSetByteMatchTupleFieldToMatch;
        positionalConstraint: string;
        targetString?: string;
        textTransformation: string;
    }
    interface ByteMatchSetByteMatchTupleFieldToMatch {
        data?: string;
        type: string;
    }
    interface GeoMatchSetGeoMatchConstraint {
        type: string;
        value: string;
    }
    interface IpSetIpSetDescriptor {
        type: string;
        value: string;
    }
    interface RateBasedRulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface RegexMatchSetRegexMatchTuple {
        /**
         * The part of a web request that you want to search, such as a specified header or a query string.
         */
        fieldToMatch: outputs.waf.RegexMatchSetRegexMatchTupleFieldToMatch;
        /**
         * The ID of a Regex Pattern Set.
         */
        regexPatternSetId: string;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }
    interface RegexMatchSetRegexMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }
    interface RuleGroupActivatedRule {
        action: outputs.waf.RuleGroupActivatedRuleAction;
        priority: number;
        ruleId: string;
        type?: string;
    }
    interface RuleGroupActivatedRuleAction {
        type: string;
    }
    interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.waf.SizeConstraintSetSizeConstraintFieldToMatch;
        size: number;
        textTransformation: string;
    }
    interface SizeConstraintSetSizeConstraintFieldToMatch {
        data?: string;
        type: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        /**
         * Specifies where in a web request to look for snippets of malicious SQL code.
         */
        fieldToMatch: outputs.waf.SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_SqlInjectionMatchTuple.html#WAF-Type-SqlInjectionMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch {
        data?: string;
        type: string;
    }
    interface WebAclDefaultAction {
        /**
         * Specifies how you want AWS WAF to respond to requests that don't match the criteria in any of the `rules`.
         * e.g., `ALLOW` or `BLOCK`
         */
        type: string;
    }
    interface WebAclLoggingConfiguration {
        /**
         * Amazon Resource Name (ARN) of Kinesis Firehose Delivery Stream
         */
        logDestination: string;
        /**
         * Configuration block containing parts of the request that you want redacted from the logs. Detailed below.
         */
        redactedFields?: outputs.waf.WebAclLoggingConfigurationRedactedFields;
    }
    interface WebAclLoggingConfigurationRedactedFields {
        /**
         * Set of configuration blocks for fields to redact. Detailed below.
         */
        fieldToMatches: outputs.waf.WebAclLoggingConfigurationRedactedFieldsFieldToMatch[];
    }
    interface WebAclLoggingConfigurationRedactedFieldsFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }
    interface WebAclRule {
        /**
         * The action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule. Not used if `type` is `GROUP`.
         */
        action?: outputs.waf.WebAclRuleAction;
        /**
         * Override the action that a group requests CloudFront or AWS WAF takes when a web request matches the conditions in the rule. Only used if `type` is `GROUP`.
         */
        overrideAction?: outputs.waf.WebAclRuleOverrideAction;
        /**
         * Specifies the order in which the rules in a WebACL are evaluated.
         * Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * ID of the associated WAF (Global) rule (e.g., `aws.waf.Rule`). WAF (Regional) rules cannot be used.
         */
        ruleId: string;
        /**
         * The rule type, either `REGULAR`, as defined by [Rule](http://docs.aws.amazon.com/waf/latest/APIReference/API_Rule.html), `RATE_BASED`, as defined by [RateBasedRule](http://docs.aws.amazon.com/waf/latest/APIReference/API_RateBasedRule.html), or `GROUP`, as defined by [RuleGroup](https://docs.aws.amazon.com/waf/latest/APIReference/API_RuleGroup.html). The default is REGULAR. If you add a RATE_BASED rule, you need to set `type` as `RATE_BASED`. If you add a GROUP rule, you need to set `type` as `GROUP`.
         */
        type?: string;
    }
    interface WebAclRuleAction {
        /**
         * valid values are: `BLOCK`, `ALLOW`, or `COUNT`
         */
        type: string;
    }
    interface WebAclRuleOverrideAction {
        /**
         * valid values are: `NONE` or `COUNT`
         */
        type: string;
    }
    interface XssMatchSetXssMatchTuple {
        /**
         * Specifies where in a web request to look for cross-site scripting attacks.
         */
        fieldToMatch: outputs.waf.XssMatchSetXssMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `targetString` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_XssMatchTuple.html#WAF-Type-XssMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }
    interface XssMatchSetXssMatchTupleFieldToMatch {
        data?: string;
        type: string;
    }
}
export declare namespace wafregional {
    interface ByteMatchSetByteMatchTuple {
        /**
         * Settings for the ByteMatchTuple. FieldToMatch documented below.
         */
        fieldToMatch: outputs.wafregional.ByteMatchSetByteMatchTupleFieldToMatch;
        /**
         * Within the portion of a web request that you want to search.
         */
        positionalConstraint: string;
        /**
         * The value that you want AWS WAF to search for. The maximum length of the value is 50 bytes.
         */
        targetString?: string;
        /**
         * The formatting way for web request.
         *
         * FieldToMatch(field_to_match) support following:
         */
        textTransformation: string;
    }
    interface ByteMatchSetByteMatchTupleFieldToMatch {
        /**
         * When the value of Type is HEADER, enter the name of the header that you want AWS WAF to search, for example, User-Agent or Referer. If the value of Type is any other value, omit Data.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         */
        type: string;
    }
    interface GeoMatchSetGeoMatchConstraint {
        type: string;
        value: string;
    }
    interface IpSetIpSetDescriptor {
        type: string;
        value: string;
    }
    interface RateBasedRulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface RegexMatchSetRegexMatchTuple {
        /**
         * The part of a web request that you want to search, such as a specified header or a query string.
         */
        fieldToMatch: outputs.wafregional.RegexMatchSetRegexMatchTupleFieldToMatch;
        /**
         * The ID of a Regex Pattern Set.
         */
        regexPatternSetId: string;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchTuple.html#WAF-Type-ByteMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }
    interface RegexMatchSetRegexMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](http://docs.aws.amazon.com/waf/latest/APIReference/API_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }
    interface RuleGroupActivatedRule {
        action: outputs.wafregional.RuleGroupActivatedRuleAction;
        priority: number;
        ruleId: string;
        type?: string;
    }
    interface RuleGroupActivatedRuleAction {
        type: string;
    }
    interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }
    interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.wafregional.SizeConstraintSetSizeConstraintFieldToMatch;
        size: number;
        textTransformation: string;
    }
    interface SizeConstraintSetSizeConstraintFieldToMatch {
        data?: string;
        type: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        /**
         * Specifies where in a web request to look for snippets of malicious SQL code.
         */
        fieldToMatch: outputs.wafregional.SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch;
        /**
         * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
         * If you specify a transformation, AWS WAF performs the transformation on `fieldToMatch` before inspecting a request for a match.
         * e.g., `CMD_LINE`, `HTML_ENTITY_DECODE` or `NONE`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_regional_SqlInjectionMatchTuple.html#WAF-Type-regional_SqlInjectionMatchTuple-TextTransformation)
         * for all supported values.
         */
        textTransformation: string;
    }
    interface SqlInjectionMatchSetSqlInjectionMatchTupleFieldToMatch {
        /**
         * When `type` is `HEADER`, enter the name of the header that you want to search, e.g., `User-Agent` or `Referer`.
         * If `type` is any other value, omit this field.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified string.
         * e.g., `HEADER`, `METHOD` or `BODY`.
         * See [docs](https://docs.aws.amazon.com/waf/latest/APIReference/API_regional_FieldToMatch.html)
         * for all supported values.
         */
        type: string;
    }
    interface WebAclDefaultAction {
        /**
         * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a ruleE.g., `ALLOW`, `BLOCK` or `COUNT`
         */
        type: string;
    }
    interface WebAclLoggingConfiguration {
        /**
         * Amazon Resource Name (ARN) of Kinesis Firehose Delivery Stream
         */
        logDestination: string;
        /**
         * Configuration block containing parts of the request that you want redacted from the logs. Detailed below.
         */
        redactedFields?: outputs.wafregional.WebAclLoggingConfigurationRedactedFields;
    }
    interface WebAclLoggingConfigurationRedactedFields {
        /**
         * Set of configuration blocks for fields to redact. Detailed below.
         */
        fieldToMatches: outputs.wafregional.WebAclLoggingConfigurationRedactedFieldsFieldToMatch[];
    }
    interface WebAclLoggingConfigurationRedactedFieldsFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }
    interface WebAclRule {
        /**
         * Configuration block of the action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Not used if `type` is `GROUP`. Detailed below.
         */
        action?: outputs.wafregional.WebAclRuleAction;
        /**
         * Configuration block of the override the action that a group requests CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Only used if `type` is `GROUP`. Detailed below.
         */
        overrideAction?: outputs.wafregional.WebAclRuleOverrideAction;
        /**
         * Specifies the order in which the rules in a WebACL are evaluated.
         * Rules with a lower value are evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * ID of the associated WAF (Regional) rule (e.g., `aws.wafregional.Rule`). WAF (Global) rules cannot be used.
         */
        ruleId: string;
        /**
         * The rule type, either `REGULAR`, as defined by [Rule](http://docs.aws.amazon.com/waf/latest/APIReference/API_Rule.html), `RATE_BASED`, as defined by [RateBasedRule](http://docs.aws.amazon.com/waf/latest/APIReference/API_RateBasedRule.html), or `GROUP`, as defined by [RuleGroup](https://docs.aws.amazon.com/waf/latest/APIReference/API_RuleGroup.html). The default is REGULAR. If you add a RATE_BASED rule, you need to set `type` as `RATE_BASED`. If you add a GROUP rule, you need to set `type` as `GROUP`.
         */
        type?: string;
    }
    interface WebAclRuleAction {
        /**
         * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a rule. Valid values for `action` are `ALLOW`, `BLOCK` or `COUNT`. Valid values for `overrideAction` are `COUNT` and `NONE`.
         */
        type: string;
    }
    interface WebAclRuleOverrideAction {
        type: string;
    }
    interface XssMatchSetXssMatchTuple {
        /**
         * Specifies where in a web request to look for cross-site scripting attacks.
         */
        fieldToMatch: outputs.wafregional.XssMatchSetXssMatchTupleFieldToMatch;
        /**
         * Which text transformation, if any, to perform on the web request before inspecting the request for cross-site scripting attacks.
         */
        textTransformation: string;
    }
    interface XssMatchSetXssMatchTupleFieldToMatch {
        /**
         * When the value of `type` is `HEADER`, enter the name of the header that you want the WAF to search, for example, `User-Agent` or `Referer`. If the value of `type` is any other value, omit `data`.
         */
        data?: string;
        /**
         * The part of the web request that you want AWS WAF to search for a specified stringE.g., `HEADER` or `METHOD`
         */
        type: string;
    }
}
export declare namespace wafv2 {
    interface GetRegexPatternSetRegularExpression {
        /**
         * (Required) String representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
         */
        regexString: string;
    }
    interface RegexPatternSetRegularExpression {
        /**
         * The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
         */
        regexString: string;
    }
    interface RuleGroupCustomResponseBody {
        /**
         * The payload of the custom response.
         */
        content: string;
        /**
         * The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
         */
        contentType: string;
        /**
         * A unique key identifying the custom response body. This is referenced by the `customResponseBodyKey` argument in the Custom Response block.
         */
        key: string;
    }
    interface RuleGroupRule {
        /**
         * The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `aws.wafv2.WebAcl` level can override the rule action setting. See Action below for details.
         */
        action: outputs.wafv2.RuleGroupRuleAction;
        /**
         * Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
         */
        captchaConfig?: outputs.wafv2.RuleGroupRuleCaptchaConfig;
        /**
         * A friendly name of the rule.
         */
        name: string;
        /**
         * If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
         */
        priority: number;
        /**
         * Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
         */
        ruleLabels?: outputs.wafv2.RuleGroupRuleRuleLabel[];
        /**
         * The AWS WAF processing statement for the rule, for example `byteMatchStatement` or `geoMatchStatement`. See Statement below for details.
         */
        statement: outputs.wafv2.RuleGroupRuleStatement;
        /**
         * Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
         */
        visibilityConfig: outputs.wafv2.RuleGroupRuleVisibilityConfig;
    }
    interface RuleGroupRuleAction {
        /**
         * Instructs AWS WAF to allow the web request. See Allow below for details.
         */
        allow?: outputs.wafv2.RuleGroupRuleActionAllow;
        /**
         * Instructs AWS WAF to block the web request. See Block below for details.
         */
        block?: outputs.wafv2.RuleGroupRuleActionBlock;
        /**
         * Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
         */
        captcha?: outputs.wafv2.RuleGroupRuleActionCaptcha;
        /**
         * Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
         */
        challenge?: outputs.wafv2.RuleGroupRuleActionChallenge;
        /**
         * Instructs AWS WAF to count the web request and allow it. See Count below for details.
         */
        count?: outputs.wafv2.RuleGroupRuleActionCount;
    }
    interface RuleGroupRuleActionAllow {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionAllowCustomRequestHandling;
    }
    interface RuleGroupRuleActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader[];
    }
    interface RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        value: string;
    }
    interface RuleGroupRuleActionBlock {
        /**
         * Defines a custom response for the web request. See Custom Response below for details.
         */
        customResponse?: outputs.wafv2.RuleGroupRuleActionBlockCustomResponse;
    }
    interface RuleGroupRuleActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
         */
        responseHeaders?: outputs.wafv2.RuleGroupRuleActionBlockCustomResponseResponseHeader[];
    }
    interface RuleGroupRuleActionBlockCustomResponseResponseHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        value: string;
    }
    interface RuleGroupRuleActionCaptcha {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionCaptchaCustomRequestHandling;
    }
    interface RuleGroupRuleActionCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader[];
    }
    interface RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        value: string;
    }
    interface RuleGroupRuleActionChallenge {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionChallengeCustomRequestHandling;
    }
    interface RuleGroupRuleActionChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader[];
    }
    interface RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        value: string;
    }
    interface RuleGroupRuleActionCount {
        /**
         * Defines custom handling for the web request. See Custom Request Handling below for details.
         */
        customRequestHandling?: outputs.wafv2.RuleGroupRuleActionCountCustomRequestHandling;
    }
    interface RuleGroupRuleActionCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
         */
        insertHeaders: outputs.wafv2.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader[];
    }
    interface RuleGroupRuleActionCountCustomRequestHandlingInsertHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        value: string;
    }
    interface RuleGroupRuleCaptchaConfig {
        /**
         * Defines custom immunity time. See Immunity Time Property below for details.
         */
        immunityTimeProperty?: outputs.wafv2.RuleGroupRuleCaptchaConfigImmunityTimeProperty;
    }
    interface RuleGroupRuleCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }
    interface RuleGroupRuleRuleLabel {
        /**
         * The label string.
         */
        name: string;
    }
    interface RuleGroupRuleStatement {
        /**
         * A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
         */
        andStatement?: outputs.wafv2.RuleGroupRuleStatementAndStatement;
        /**
         * A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
         */
        byteMatchStatement?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatement;
        /**
         * A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
         */
        geoMatchStatement?: outputs.wafv2.RuleGroupRuleStatementGeoMatchStatement;
        /**
         * A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementIpSetReferenceStatement;
        /**
         * A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
         */
        labelMatchStatement?: outputs.wafv2.RuleGroupRuleStatementLabelMatchStatement;
        /**
         * A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
         */
        notStatement?: outputs.wafv2.RuleGroupRuleStatementNotStatement;
        /**
         * A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
         */
        orStatement?: outputs.wafv2.RuleGroupRuleStatementOrStatement;
        /**
         * A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
         */
        rateBasedStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatement;
        /**
         * A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
         */
        regexMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatement;
        /**
         * A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatement;
        /**
         * A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
         */
        sqliMatchStatement?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatement;
        /**
         * A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
         */
        xssMatchStatement?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatement;
    }
    interface RuleGroupRuleStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementByteMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatch;
        /**
         * The area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementByteMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementGeoMatchStatement {
        /**
         * An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig;
    }
    interface RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface RuleGroupRuleStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }
    interface RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }
    interface RuleGroupRuleStatementLabelMatchStatement {
        /**
         * The string to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }
    interface RuleGroupRuleStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementRateBasedStatement {
        /**
         * Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
         */
        aggregateKeyType?: string;
        /**
         * Aggregate the request counts using one or more web request components as the aggregate keys. See `customKey` below for details.
         */
        customKeys?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKey[];
        /**
         * The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).
         *
         * **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
         */
        evaluationWindowSec?: number;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregateKeyType` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig;
        /**
         * The limit on requests per 5-minute period for a single originating IP address.
         */
        limit: number;
        /**
         * An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregateKeyType` is set to `CONSTANT`, this block is required.
         */
        scopeDownStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatement;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKey {
        /**
         * (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
         */
        cookie?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie;
        /**
         * (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwardedIp` below for details.
         */
        forwardedIp?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp;
        /**
         * (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
         */
        header?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader;
        /**
         * (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `httpMethod` below for details.
         */
        httpMethod?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod;
        /**
         * (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
         */
        ip?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyIp;
        /**
         * (Optional) Use the specified label namespace as an aggregate key. See RateLimit `labelNamespace` below for details.
         */
        labelNamespace?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace;
        /**
         * (Optional) Use the specified query argument as an aggregate key. See RateLimit `queryArgument` below for details.
         */
        queryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument;
        /**
         * (Optional) Use the request's query string as an aggregate key. See RateLimit `queryString` below for details.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString;
        /**
         * (Optional) Use the request's URI path as an aggregate key. See RateLimit `uriPath` below for details.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyCookie {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp {
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyHeader {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyIp {
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace {
        /**
         * The namespace to use for aggregation
         */
        namespace: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument {
        /**
         * A friendly name of the rule group.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString {
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath {
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See Text Transformation above for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatement {
        andStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement;
        byteMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement;
        ipSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement;
        notStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement;
        orStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement;
        regexMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * The area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement {
        /**
         * An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
         */
        forwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * The name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement {
        /**
         * The string to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.RuleGroupRuleStatement[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement {
        /**
         * The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatch;
        /**
         * The string representing the regular expression. **Note:** The fixed quota for the maximum number of characters in each regex pattern is 200, which can't be changed. See [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) for details.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRegexMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatement {
        /**
         * The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch;
        /**
         * The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementSizeConstraintStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementSqliMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleStatementXssMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
         */
        fieldToMatch?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
         * At least one required.
         * See Text Transformation below for details.
         */
        textTransformations: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementTextTransformation[];
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers.
         */
        body?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See Cookies below for details.
         */
        cookies?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect the request headers. See Header Order below for details.
         */
        headerOrders?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See Headers below for details.
         */
        headers?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader[];
        ja3Fingerprint?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See JSON Body for details.
         */
        jsonBody?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See Single Header below for details.
         */
        singleHeader?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See Single Query Argument below for details.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchBody {
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint {
        fallbackBehavior: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString {
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * The name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath {
    }
    interface RuleGroupRuleStatementXssMatchStatementTextTransformation {
        /**
         * The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface RuleGroupRuleVisibilityConfig {
        /**
         * A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }
    interface RuleGroupVisibilityConfig {
        /**
         * A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }
    interface WebAclAssociationConfig {
        /**
         * Customizes the request body that your protected resource forward to AWS WAF for inspection. See `requestBody` below for details.
         */
        requestBodies?: outputs.wafv2.WebAclAssociationConfigRequestBody[];
    }
    interface WebAclAssociationConfigRequestBody {
        /**
         * Customizes the request body that your protected CloudFront distributions forward to AWS WAF for inspection. See `cloudfront` below for details.
         */
        cloudfronts?: outputs.wafv2.WebAclAssociationConfigRequestBodyCloudfront[];
    }
    interface WebAclAssociationConfigRequestBodyCloudfront {
        /**
         * Specifies the maximum size of the web request body component that an associated CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
         */
        defaultSizeInspectionLimit: string;
    }
    interface WebAclCaptchaConfig {
        /**
         * Defines custom immunity time. See `immunityTimeProperty` below for details.
         */
        immunityTimeProperty?: outputs.wafv2.WebAclCaptchaConfigImmunityTimeProperty;
    }
    interface WebAclCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }
    interface WebAclChallengeConfig {
        /**
         * Defines custom immunity time. See `immunityTimeProperty` below for details.
         */
        immunityTimeProperty?: outputs.wafv2.WebAclChallengeConfigImmunityTimeProperty;
    }
    interface WebAclChallengeConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }
    interface WebAclCustomResponseBody {
        /**
         * Payload of the custom response.
         */
        content: string;
        /**
         * Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
         */
        contentType: string;
        /**
         * Unique key identifying the custom response body. This is referenced by the `customResponseBodyKey` argument in the `customResponse` block.
         */
        key: string;
    }
    interface WebAclDefaultAction {
        /**
         * Specifies that AWS WAF should allow requests by default. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclDefaultActionAllow;
        /**
         * Specifies that AWS WAF should block requests by default. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclDefaultActionBlock;
    }
    interface WebAclDefaultActionAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclDefaultActionAllowCustomRequestHandling;
    }
    interface WebAclDefaultActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader[];
    }
    interface WebAclDefaultActionAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclDefaultActionBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclDefaultActionBlockCustomResponse;
    }
    interface WebAclDefaultActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclDefaultActionBlockCustomResponseResponseHeader[];
    }
    interface WebAclDefaultActionBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclLoggingConfigurationLoggingFilter {
        /**
         * Default handling for logs that don't match any of the specified filtering conditions. Valid values for `defaultBehavior` are `KEEP` or `DROP`.
         */
        defaultBehavior: string;
        /**
         * Filter(s) that you want to apply to the logs. See Filter below for more details.
         */
        filters: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilter[];
    }
    interface WebAclLoggingConfigurationLoggingFilterFilter {
        /**
         * Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
         */
        behavior: string;
        /**
         * Match condition(s) for the filter. See Condition below for more details.
         */
        conditions: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterCondition[];
        /**
         * Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
         */
        requirement: string;
    }
    interface WebAclLoggingConfigurationLoggingFilterFilterCondition {
        /**
         * Configuration for a single action condition. See Action Condition below for more details.
         */
        actionCondition?: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition;
        /**
         * Condition for a single label name. See Label Name Condition below for more details.
         */
        labelNameCondition?: outputs.wafv2.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition;
    }
    interface WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition {
        /**
         * Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
         */
        action: string;
    }
    interface WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition {
        /**
         * Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
         */
        labelName: string;
    }
    interface WebAclLoggingConfigurationRedactedField {
        /**
         * HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldMethod;
        /**
         * Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldQueryString;
        /**
         * "singleHeader" refers to the redaction of a single header. For more information, please see the details below under Single Header.
         */
        singleHeader?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldSingleHeader;
        /**
         * Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclLoggingConfigurationRedactedFieldUriPath;
    }
    interface WebAclLoggingConfigurationRedactedFieldMethod {
    }
    interface WebAclLoggingConfigurationRedactedFieldQueryString {
    }
    interface WebAclLoggingConfigurationRedactedFieldSingleHeader {
        /**
         * Name of the query header to redact. This setting must be provided in lowercase characters.
         */
        name: string;
    }
    interface WebAclLoggingConfigurationRedactedFieldUriPath {
    }
    interface WebAclRule {
        /**
         * Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
         */
        action?: outputs.wafv2.WebAclRuleAction;
        /**
         * Specifies how AWS WAF should handle CAPTCHA evaluations. See `captchaConfig` below for details.
         */
        captchaConfig?: outputs.wafv2.WebAclRuleCaptchaConfig;
        /**
         * Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
         */
        name: string;
        /**
         * Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `ruleGroupReferenceStatement` and `managedRuleGroupStatement`. See `overrideAction` below for details.
         */
        overrideAction?: outputs.wafv2.WebAclRuleOverrideAction;
        /**
         * If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
         */
        priority: number;
        /**
         * Labels to apply to web requests that match the rule match statement. See `ruleLabel` below for details.
         */
        ruleLabels?: outputs.wafv2.WebAclRuleRuleLabel[];
        /**
         * The AWS WAF processing statement for the rule, for example `byteMatchStatement` or `geoMatchStatement`. See `statement` below for details.
         */
        statement: outputs.wafv2.WebAclRuleStatement;
        /**
         * Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibilityConfig` below for details.
         */
        visibilityConfig: outputs.wafv2.WebAclRuleVisibilityConfig;
    }
    interface WebAclRuleAction {
        /**
         * Instructs AWS WAF to allow the web request. See `allow` below for details.
         */
        allow?: outputs.wafv2.WebAclRuleActionAllow;
        /**
         * Instructs AWS WAF to block the web request. See `block` below for details.
         */
        block?: outputs.wafv2.WebAclRuleActionBlock;
        /**
         * Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
         */
        captcha?: outputs.wafv2.WebAclRuleActionCaptcha;
        /**
         * Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
         */
        challenge?: outputs.wafv2.WebAclRuleActionChallenge;
        /**
         * Instructs AWS WAF to count the web request and allow it. See `count` below for details.
         */
        count?: outputs.wafv2.WebAclRuleActionCount;
    }
    interface WebAclRuleActionAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionAllowCustomRequestHandling;
    }
    interface WebAclRuleActionAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionAllowCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleActionAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleActionBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleActionBlockCustomResponse;
    }
    interface WebAclRuleActionBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleActionBlockCustomResponseResponseHeader[];
    }
    interface WebAclRuleActionBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleActionCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionCaptchaCustomRequestHandling;
    }
    interface WebAclRuleActionCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleActionChallenge {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionChallengeCustomRequestHandling;
    }
    interface WebAclRuleActionChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleActionChallengeCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleActionCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleActionCountCustomRequestHandling;
    }
    interface WebAclRuleActionCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleActionCountCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleActionCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleCaptchaConfig {
        /**
         * Defines custom immunity time. See `immunityTimeProperty` below for details.
         */
        immunityTimeProperty?: outputs.wafv2.WebAclRuleCaptchaConfigImmunityTimeProperty;
    }
    interface WebAclRuleCaptchaConfigImmunityTimeProperty {
        /**
         * The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
         */
        immunityTime?: number;
    }
    interface WebAclRuleOverrideAction {
        /**
         * Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
         */
        count?: outputs.wafv2.WebAclRuleOverrideActionCount;
        /**
         * Don't override the rule action setting. Configured as an empty block `{}`.
         */
        none?: outputs.wafv2.WebAclRuleOverrideActionNone;
    }
    interface WebAclRuleOverrideActionCount {
    }
    interface WebAclRuleOverrideActionNone {
    }
    interface WebAclRuleRuleLabel {
        /**
         * Label string.
         */
        name: string;
    }
    interface WebAclRuleStatement {
        /**
         * Logical rule statement used to combine other rule statements with AND logic. See `andStatement` below for details.
         */
        andStatement?: outputs.wafv2.WebAclRuleStatementAndStatement;
        /**
         * Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byteMatchStatement` below for details.
         */
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementByteMatchStatement;
        /**
         * Rule statement used to identify web requests based on country of origin. See `geoMatchStatement` below for details.
         */
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementGeoMatchStatement;
        /**
         * Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ipSetReferenceStatement` below for details.
         */
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementIpSetReferenceStatement;
        /**
         * Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `labelMatchStatement` below for details.
         */
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementLabelMatchStatement;
        /**
         * Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managedRuleGroupStatement` below for details.
         */
        managedRuleGroupStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatement;
        /**
         * Logical rule statement used to negate the results of another rule statement. See `notStatement` below for details.
         */
        notStatement?: outputs.wafv2.WebAclRuleStatementNotStatement;
        /**
         * Logical rule statement used to combine other rule statements with OR logic. See `orStatement` below for details.
         */
        orStatement?: outputs.wafv2.WebAclRuleStatementOrStatement;
        /**
         * Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rateBasedStatement` below for details.
         */
        rateBasedStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatement;
        /**
         * Rule statement used to search web request components for a match against a single regular expression. See `regexMatchStatement` below for details.
         */
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementRegexMatchStatement;
        /**
         * Rule statement used to search web request components for matches with regular expressions. See `regexPatternSetReferenceStatement` below for details.
         */
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatement;
        /**
         * Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `ruleGroupReferenceStatement` below for details.
         */
        ruleGroupReferenceStatement?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatement;
        /**
         * Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `sizeConstraintStatement` below for more details.
         */
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatement;
        /**
         * An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqliMatchStatement` below for details.
         */
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementSqliMatchStatement;
        /**
         * Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xssMatchStatement` below for details.
         */
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementXssMatchStatement;
    }
    interface WebAclRuleStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementByteMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementByteMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementGeoMatchStatementForwardedIpConfig;
    }
    interface WebAclRuleStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface WebAclRuleStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }
    interface WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }
    interface WebAclRuleStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatement {
        /**
         * Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managedRuleGroupConfigs` for more details
         */
        managedRuleGroupConfigs?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig[];
        /**
         * Name of the managed rule group.
         */
        name: string;
        /**
         * Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `ruleActionOverride` below for details.
         */
        ruleActionOverrides?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride[];
        /**
         * Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
         */
        scopeDownStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement;
        /**
         * Name of the managed rule group vendor.
         */
        vendorName: string;
        /**
         * Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
         */
        version?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig {
        /**
         * Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
         */
        awsManagedRulesAcfpRuleSet?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet;
        /**
         * Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
         */
        awsManagedRulesAtpRuleSet?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet;
        /**
         * Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `awsManagedRulesBotControlRuleSet` for more details
         */
        awsManagedRulesBotControlRuleSet?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet;
        /**
         * The path of the login endpoint for your application.
         */
        loginPath?: string;
        /**
         * Details about your login page password field. See `passwordField` for more details.
         */
        passwordField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField;
        /**
         * The payload type for your login endpoint, either JSON or form encoded.
         */
        payloadType?: string;
        /**
         * Details about your login page username field. See `usernameField` for more details.
         */
        usernameField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet {
        /**
         * The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
         */
        creationPath: string;
        /**
         * Whether or not to allow the use of regular expressions in the login page path.
         */
        enableRegexInPath: boolean;
        /**
         * The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
         */
        registrationPagePath: string;
        /**
         * The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `requestInspection` for more details.
         */
        requestInspection: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection;
        /**
         * The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `responseInspection` for more details.
         */
        responseInspection?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection {
        /**
         * The names of the fields in the request payload that contain your customer's primary physical address. See `addressFields` for more details.
         */
        addressFields?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields;
        /**
         * The name of the field in the request payload that contains your customer's email. See `emailField` for more details.
         */
        emailField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField;
        /**
         * Details about your login page password field. See `passwordField` for more details.
         */
        passwordField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField;
        /**
         * The payload type for your login endpoint, either JSON or form encoded.
         */
        payloadType: string;
        /**
         * The names of the fields in the request payload that contain your customer's primary phone number. See `phoneNumberFields` for more details.
         */
        phoneNumberFields?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields;
        /**
         * Details about your login page username field. See `usernameField` for more details.
         */
        usernameField?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields {
        identifiers: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField {
        /**
         * The name of the field in the request payload that contains your customer's email.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField {
        /**
         * The name of the password field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields {
        identifiers: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField {
        /**
         * The name of the username field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection {
        /**
         * Configures inspection of the response body. See `bodyContains` for more details.
         */
        bodyContains?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains;
        /**
         * Configures inspection of the response header.See `header` for more details.
         */
        header?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader;
        /**
         * Configures inspection of the response JSON. See `json` for more details.
         */
        json?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson;
        /**
         * Configures inspection of the response status code.See `statusCode` for more details.
         */
        statusCode?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains {
        /**
         * Strings in the body of the response that indicate a failed login attempt.
         */
        failureStrings: string[];
        /**
         * Strings in the body of the response that indicate a successful login attempt.
         */
        successStrings: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader {
        /**
         * Values in the response header with the specified name that indicate a failed login attempt.
         */
        failureValues: string[];
        /**
         * The name of the header to use.
         */
        name: string;
        /**
         * Values in the response header with the specified name that indicate a successful login attempt.
         */
        successValues: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson {
        failureValues: string[];
        /**
         * The identifier for the value to match against in the JSON.
         */
        identifier: string;
        successValues: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode {
        /**
         * Status codes in the response that indicate a failed login attempt.
         */
        failureCodes: number[];
        /**
         * Status codes in the response that indicate a successful login attempt.
         */
        successCodes: number[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet {
        /**
         * Whether or not to allow the use of regular expressions in the login page path.
         */
        enableRegexInPath: boolean;
        /**
         * The path of the login endpoint for your application.
         */
        loginPath: string;
        /**
         * The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `requestInspection` for more details.
         */
        requestInspection?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection;
        /**
         * The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `responseInspection` for more details.
         */
        responseInspection?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection {
        /**
         * Details about your login page password field. See `passwordField` for more details.
         */
        passwordField: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField;
        /**
         * The payload type for your login endpoint, either JSON or form encoded.
         */
        payloadType: string;
        /**
         * Details about your login page username field. See `usernameField` for more details.
         */
        usernameField: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField {
        /**
         * The name of the password field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField {
        /**
         * The name of the username field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection {
        /**
         * Configures inspection of the response body. See `bodyContains` for more details.
         */
        bodyContains?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains;
        /**
         * Configures inspection of the response header.See `header` for more details.
         */
        header?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader;
        /**
         * Configures inspection of the response JSON. See `json` for more details.
         */
        json?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson;
        /**
         * Configures inspection of the response status code.See `statusCode` for more details.
         */
        statusCode?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains {
        /**
         * Strings in the body of the response that indicate a failed login attempt.
         */
        failureStrings: string[];
        /**
         * Strings in the body of the response that indicate a successful login attempt.
         */
        successStrings: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader {
        /**
         * Values in the response header with the specified name that indicate a failed login attempt.
         */
        failureValues: string[];
        /**
         * The name of the header to use.
         */
        name: string;
        /**
         * Values in the response header with the specified name that indicate a successful login attempt.
         */
        successValues: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson {
        failureValues: string[];
        /**
         * The identifier for the value to match against in the JSON.
         */
        identifier: string;
        successValues: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode {
        /**
         * Status codes in the response that indicate a failed login attempt.
         */
        failureCodes: number[];
        /**
         * Status codes in the response that indicate a successful login attempt.
         */
        successCodes: number[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet {
        /**
         * The inspection level to use for the Bot Control rule group.
         */
        inspectionLevel: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField {
        /**
         * The name of the password field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField {
        /**
         * The name of the username field.
         */
        identifier: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride {
        /**
         * Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
         */
        actionToUse: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse;
        /**
         * Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse {
        allow?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow;
        block?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock;
        captcha?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha;
        challenge?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge;
        count?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement {
        andStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement;
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement;
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement;
        notStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement;
        orStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement;
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementRateBasedStatement {
        /**
         * Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
         */
        aggregateKeyType?: string;
        /**
         * Aggregate the request counts using one or more web request components as the aggregate keys. See `customKey` below for details.
         */
        customKeys?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKey[];
        /**
         * The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. Valid values are `60`, `120`, `300`, and `600`. Defaults to `300` (5 minutes).
         *
         * **NOTE:** This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
         */
        evaluationWindowSec?: number;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregateKeyType` is set to `FORWARDED_IP`, this block is required. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementForwardedIpConfig;
        /**
         * Limit on requests per 5-minute period for a single originating IP address.
         */
        limit: number;
        /**
         * Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregateKeyType` is set to `CONSTANT`, this block is required.
         */
        scopeDownStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatement;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKey {
        /**
         * Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
         */
        cookie?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyCookie;
        /**
         * Use the first IP address in an HTTP header as an aggregate key. See `forwardedIp` below for details.
         */
        forwardedIp?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp;
        /**
         * Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
         */
        header?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyHeader;
        /**
         * Use the request's HTTP method as an aggregate key. See RateLimit `httpMethod` below for details.
         */
        httpMethod?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod;
        /**
         * Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
         */
        ip?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyIp;
        /**
         * Use the specified label namespace as an aggregate key. See RateLimit `labelNamespace` below for details.
         */
        labelNamespace?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace;
        /**
         * Use the specified query argument as an aggregate key. See RateLimit `queryArgument` below for details.
         */
        queryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument;
        /**
         * Use the request's query string as an aggregate key. See RateLimit `queryString` below for details.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyQueryString;
        /**
         * Use the request's URI path as an aggregate key. See RateLimit `uriPath` below for details.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyCookie {
        /**
         * The name of the cookie to use.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `textTransformation` above for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp {
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyHeader {
        /**
         * The name of the header to use.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `textTransformation` above for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod {
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyIp {
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace {
        /**
         * The namespace to use for aggregation
         */
        namespace: string;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument {
        /**
         * The name of the query argument to use.
         */
        name: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `textTransformation` above for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyQueryString {
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `textTransformation` above for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyUriPath {
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `textTransformation` above for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatement {
        andStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement;
        byteMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement;
        ipSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement;
        notStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement;
        orStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement;
        regexMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch;
        /**
         * Area within the portion of a web request that you want AWS WAF to search for `searchString`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
         */
        positionalConstraint: string;
        /**
         * String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `fieldToMatch`. The maximum length of the value is 50 bytes.
         */
        searchString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement {
        /**
         * Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
         */
        countryCodes: string[];
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwardedIpConfig` below for details.
         */
        forwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the IP Set that this statement references.
         */
        arn: string;
        /**
         * Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ipSetForwardedIpConfig` below for more details.
         */
        ipSetForwardedIpConfig?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig {
        /**
         * Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
        /**
         * Name of the HTTP header to use for the IP address.
         */
        headerName: string;
        /**
         * Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
         */
        position: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement {
        /**
         * String to match against.
         */
        key: string;
        /**
         * Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
         */
        scope: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement {
        /**
         * The statements to combine.
         */
        statements: outputs.wafv2.WebAclRuleStatement[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRegexMatchStatement {
        /**
         * The part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatch;
        /**
         * String representing the regular expression. Minimum of `1` and maximum of `512` characters.
         */
        regexString: string;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRegexMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRegexMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
         */
        arn: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation[];
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatement {
        /**
         * The Amazon Resource Name (ARN) of the `aws.wafv2.RuleGroup` resource.
         */
        arn: string;
        /**
         * Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `ruleActionOverride` below for details.
         */
        ruleActionOverrides?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride {
        /**
         * Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
         */
        actionToUse: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse;
        /**
         * Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
         */
        name: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse {
        allow?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow;
        block?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock;
        captcha?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha;
        challenge?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge;
        count?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock {
        /**
         * Defines a custom response for the web request. See `customResponse` below for details.
         */
        customResponse?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse {
        /**
         * References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `customResponseBody` block of this resource.
         */
        customResponseBodyKey?: string;
        /**
         * The HTTP status code to return to the client.
         */
        responseCode: number;
        /**
         * The `responseHeader` blocks used to define the HTTP response headers added to the response. See `responseHeader` below for details.
         */
        responseHeaders?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount {
        /**
         * Defines custom handling for the web request. See `customRequestHandling` below for details.
         */
        customRequestHandling?: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling;
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling {
        /**
         * The `insertHeader` blocks used to define HTTP headers added to the request. See `insertHeader` below for details.
         */
        insertHeaders: outputs.wafv2.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader[];
    }
    interface WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader {
        /**
         * Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
         */
        name: string;
        /**
         * Value of the custom header.
         */
        value: string;
    }
    interface WebAclRuleStatementSizeConstraintStatement {
        /**
         * Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
         */
        comparisonOperator: string;
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatch;
        /**
         * Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
         */
        size: number;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementTextTransformation[];
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementSizeConstraintStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementSqliMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementSqliMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementSqliMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleStatementXssMatchStatement {
        /**
         * Part of a web request that you want AWS WAF to inspect. See `fieldToMatch` below for details.
         */
        fieldToMatch?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatch;
        /**
         * Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `textTransformation` below for details.
         */
        textTransformations: outputs.wafv2.WebAclRuleStatementXssMatchStatementTextTransformation[];
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatch {
        /**
         * Inspect all query arguments.
         */
        allQueryArguments?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments;
        /**
         * Inspect the request body, which immediately follows the request headers. See `body` below for details.
         */
        body?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchBody;
        /**
         * Inspect the cookies in the web request. See `cookies` below for details.
         */
        cookies?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookies;
        /**
         * Inspect a string containing the list of the request's header names, ordered as they appear in the web request that AWS WAF receives for inspection. See `headerOrder` below for details.
         */
        headerOrders?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder[];
        /**
         * Inspect the request headers. See `headers` below for details.
         */
        headers?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeader[];
        /**
         * Inspect the JA3 fingerprint. See `ja3Fingerprint` below for details.
         */
        ja3Fingerprint?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint;
        /**
         * Inspect the request body as JSON. See `jsonBody` for details.
         */
        jsonBody?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchMethod;
        /**
         * Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
         */
        queryString?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString;
        /**
         * Inspect a single header. See `singleHeader` below for details.
         */
        singleHeader?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader;
        /**
         * Inspect a single query argument. See `singleQueryArgument` below for details.
         */
        singleQueryArgument?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
         */
        uriPath?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchBody {
        /**
         * What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchCookies {
        /**
         * The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `includedCookies` or `excludedCookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
         */
        matchPatterns: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern[];
        /**
         * The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
         */
        matchScope: string;
        /**
         * What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll;
        excludedCookies?: string[];
        includedCookies?: string[];
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchHeader {
        /**
         * The filter to use to identify the subset of headers to inspect in a web request. The `matchPattern` block supports only one of the following arguments:
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern;
        /**
         * The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
         */
        matchScope: string;
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern {
        /**
         * An empty configuration block that is used for inspecting all headers.
         */
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll;
        /**
         * An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
         */
        excludedHeaders?: string[];
        /**
         * An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
         */
        includedHeaders?: string[];
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder {
        /**
         * Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
         */
        oversizeHandling: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint {
        /**
         * The match status to assign to the web request if the request doesn't have a JA3 fingerprint. Valid values include: `MATCH` or `NO_MATCH`.
         */
        fallbackBehavior: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody {
        /**
         * What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
         */
        invalidFallbackBehavior?: string;
        /**
         * The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `includedPaths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
         */
        matchPattern: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern;
        /**
         * The parts of the JSON to match against using the `matchPattern`. Valid values are `ALL`, `KEY` and `VALUE`.
         */
        matchScope: string;
        /**
         * What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
         */
        oversizeHandling?: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern {
        all?: outputs.wafv2.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll;
        includedPaths?: string[];
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchMethod {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchQueryString {
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument {
        /**
         * Name of the query header to inspect. This setting must be provided as lower case characters.
         */
        name: string;
    }
    interface WebAclRuleStatementXssMatchStatementFieldToMatchUriPath {
    }
    interface WebAclRuleStatementXssMatchStatementTextTransformation {
        /**
         * Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
         */
        priority: number;
        /**
         * Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
         */
        type: string;
    }
    interface WebAclRuleVisibilityConfig {
        /**
         * Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }
    interface WebAclVisibilityConfig {
        /**
         * Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
         */
        cloudwatchMetricsEnabled: boolean;
        /**
         * A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
         */
        metricName: string;
        /**
         * Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
         */
        sampledRequestsEnabled: boolean;
    }
}
export declare namespace worklink {
    interface FleetIdentityProvider {
        /**
         * The SAML metadata document provided by the customer’s identity provider.
         */
        samlMetadata: string;
        /**
         * The type of identity provider.
         */
        type: string;
    }
    interface FleetNetwork {
        /**
         * A list of security group IDs associated with access to the provided subnets.
         *
         * **identity_provider** requires the following:
         *
         * > **NOTE:** `identityProvider` cannot be removed without force recreating.
         */
        securityGroupIds: string[];
        /**
         * A list of subnet IDs used for X-ENI connections from Amazon WorkLink rendering containers.
         */
        subnetIds: string[];
        /**
         * The VPC ID with connectivity to associated websites.
         */
        vpcId: string;
    }
}
export declare namespace workspaces {
    interface ConnectionAliasTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }
    interface DirectorySelfServicePermissions {
        /**
         * Whether WorkSpaces directory users can change the compute type (bundle) for their workspace. Default `false`.
         */
        changeComputeType?: boolean;
        /**
         * Whether WorkSpaces directory users can increase the volume size of the drives on their workspace. Default `false`.
         */
        increaseVolumeSize?: boolean;
        /**
         * Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state. Default `false`.
         */
        rebuildWorkspace?: boolean;
        /**
         * Whether WorkSpaces directory users can restart their workspace. Default `true`.
         */
        restartWorkspace?: boolean;
        /**
         * Whether WorkSpaces directory users can switch the running mode of their workspace. Default `false`.
         */
        switchRunningMode?: boolean;
    }
    interface DirectoryWorkspaceAccessProperties {
        /**
         * Indicates whether users can use Android devices to access their WorkSpaces.
         */
        deviceTypeAndroid?: string;
        /**
         * Indicates whether users can use Chromebooks to access their WorkSpaces.
         */
        deviceTypeChromeos?: string;
        /**
         * Indicates whether users can use iOS devices to access their WorkSpaces.
         */
        deviceTypeIos?: string;
        /**
         * Indicates whether users can use Linux clients to access their WorkSpaces.
         */
        deviceTypeLinux?: string;
        /**
         * Indicates whether users can use macOS clients to access their WorkSpaces.
         */
        deviceTypeOsx?: string;
        /**
         * Indicates whether users can access their WorkSpaces through a web browser.
         */
        deviceTypeWeb?: string;
        /**
         * Indicates whether users can use Windows clients to access their WorkSpaces.
         */
        deviceTypeWindows?: string;
        /**
         * Indicates whether users can use zero client devices to access their WorkSpaces.
         */
        deviceTypeZeroclient?: string;
    }
    interface DirectoryWorkspaceCreationProperties {
        /**
         * The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
         */
        customSecurityGroupId?: string;
        /**
         * The default organizational unit (OU) for your WorkSpace directories. Should conform `"OU=<value>,DC=<value>,...,DC=<value>"` pattern.
         */
        defaultOu?: string;
        /**
         * Indicates whether internet access is enabled for your WorkSpaces.
         */
        enableInternetAccess?: boolean;
        /**
         * Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html)..
         */
        enableMaintenanceMode?: boolean;
        /**
         * Indicates whether users are local administrators of their WorkSpaces.
         */
        userEnabledAsLocalAdministrator?: boolean;
    }
    interface GetBundleComputeType {
        /**
         * Name of the bundle. You cannot combine this parameter with `bundleId`.
         */
        name: string;
    }
    interface GetBundleRootStorage {
        /**
         * Size of the user storage.
         */
        capacity: string;
    }
    interface GetBundleUserStorage {
        /**
         * Size of the user storage.
         */
        capacity: string;
    }
    interface GetDirectorySelfServicePermission {
        /**
         * Whether WorkSpaces directory users can change the compute type (bundle) for their workspace.
         */
        changeComputeType: boolean;
        /**
         * Whether WorkSpaces directory users can increase the volume size of the drives on their workspace.
         */
        increaseVolumeSize: boolean;
        /**
         * Whether WorkSpaces directory users can rebuild the operating system of a workspace to its original state.
         */
        rebuildWorkspace: boolean;
        /**
         * Whether WorkSpaces directory users can restart their workspace.
         */
        restartWorkspace: boolean;
        /**
         * Whether WorkSpaces directory users can switch the running mode of their workspace.
         */
        switchRunningMode: boolean;
    }
    interface GetDirectoryWorkspaceAccessProperty {
        /**
         * (Optional) Indicates whether users can use Android devices to access their WorkSpaces.
         */
        deviceTypeAndroid: string;
        /**
         * (Optional) Indicates whether users can use Chromebooks to access their WorkSpaces.
         */
        deviceTypeChromeos: string;
        /**
         * (Optional) Indicates whether users can use iOS devices to access their WorkSpaces.
         */
        deviceTypeIos: string;
        /**
         * (Optional) Indicates whether users can use Linux clients to access their WorkSpaces.
         */
        deviceTypeLinux: string;
        /**
         * (Optional) Indicates whether users can use macOS clients to access their WorkSpaces.
         */
        deviceTypeOsx: string;
        /**
         * (Optional) Indicates whether users can access their WorkSpaces through a web browser.
         */
        deviceTypeWeb: string;
        /**
         * (Optional) Indicates whether users can use Windows clients to access their WorkSpaces.
         */
        deviceTypeWindows: string;
        /**
         * (Optional) Indicates whether users can use zero client devices to access their WorkSpaces.
         */
        deviceTypeZeroclient: string;
    }
    interface GetDirectoryWorkspaceCreationProperty {
        /**
         * The identifier of your custom security group. Should relate to the same VPC, where workspaces reside in.
         */
        customSecurityGroupId: string;
        /**
         * The default organizational unit (OU) for your WorkSpace directories.
         */
        defaultOu: string;
        /**
         * Indicates whether internet access is enabled for your WorkSpaces.
         */
        enableInternetAccess: boolean;
        /**
         * Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
         */
        enableMaintenanceMode: boolean;
        /**
         * Indicates whether users are local administrators of their WorkSpaces.
         */
        userEnabledAsLocalAdministrator: boolean;
    }
    interface GetWorkspaceWorkspaceProperty {
        /**
         * Compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO` and `GRAPHICSPRO`.
         */
        computeTypeName: string;
        /**
         * Size of the root volume.
         */
        rootVolumeSizeGib: number;
        /**
         * Running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
         */
        runningMode: string;
        /**
         * Time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
         */
        runningModeAutoStopTimeoutInMinutes: number;
        /**
         * Size of the user storage.
         */
        userVolumeSizeGib: number;
    }
    interface IpGroupRule {
        /**
         * The description of the IP group.
         */
        description?: string;
        source: string;
    }
    interface WorkspaceWorkspaceProperties {
        /**
         * The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles). Valid values are `VALUE`, `STANDARD`, `PERFORMANCE`, `POWER`, `GRAPHICS`, `POWERPRO`, `GRAPHICSPRO`, `GRAPHICS_G4DN`, and `GRAPHICSPRO_G4DN`.
         */
        computeTypeName?: string;
        /**
         * The size of the root volume.
         */
        rootVolumeSizeGib?: number;
        /**
         * The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). Valid values are `AUTO_STOP` and `ALWAYS_ON`.
         */
        runningMode?: string;
        /**
         * The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
         */
        runningModeAutoStopTimeoutInMinutes: number;
        /**
         * The size of the user storage.
         */
        userVolumeSizeGib?: number;
    }
}
export declare namespace xray {
    interface GroupInsightsConfiguration {
        /**
         * Specifies whether insights are enabled.
         */
        insightsEnabled: boolean;
        /**
         * Specifies whether insight notifications are enabled.
         */
        notificationsEnabled: boolean;
    }
}
