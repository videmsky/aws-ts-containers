import { ComponentResource } from "../resource";
import { ICallbackServer } from "./callbacks";
import * as engrpc from "../proto/engine_grpc_pb";
import * as resrpc from "../proto/resource_grpc_pb";
/**
 * excessiveDebugOutput enables, well, pretty excessive debug output pertaining to resources and properties.
 */
export declare const excessiveDebugOutput: boolean;
/**
 * Options is a bag of settings that controls the behavior of previews and deployments
 */
export interface Options {
    readonly project?: string;
    readonly stack?: string;
    readonly parallel?: number;
    readonly engineAddr?: string;
    readonly monitorAddr?: string;
    readonly dryRun?: boolean;
    readonly testModeEnabled?: boolean;
    readonly queryMode?: boolean;
    readonly legacyApply?: boolean;
    readonly cacheDynamicProviders?: boolean;
    readonly organization?: string;
    /**
     * Directory containing the send/receive files for making synchronous invokes to the engine.
     */
    readonly syncDir?: string;
}
export declare function resetOptions(project: string, stack: string, parallel: number, engineAddr: string, monitorAddr: string, preview: boolean, organization: string): void;
export declare function setMockOptions(mockMonitor: any, project?: string, stack?: string, preview?: boolean, organization?: string): void;
/**
 * Returns whether or not we are currently doing a preview.
 *
 * When writing unit tests, you can set this flag via either `setMocks` or `_setIsDryRun`.
 */
export declare function isDryRun(): boolean;
/**
 * Returns true if query mode is enabled.
 */
export declare function isQueryMode(): boolean;
/**
 * Returns true if we will resolve missing outputs to inputs during preview (PULUMI_ENABLE_LEGACY_APPLY).
 */
export declare function isLegacyApplyEnabled(): boolean;
/**
 * Returns true (default) if we will cache serialized dynamic providers on the program side
 */
export declare function cacheDynamicProviders(): boolean;
/**
 * Get the organization being run by the current update.
 */
export declare function getOrganization(): string;
/**
 * Get the project being run by the current update.
 */
export declare function getProject(): string;
/**
 * Get the stack being targeted by the current update.
 */
export declare function getStack(): string;
/**
 * hasMonitor returns true if we are currently connected to a resource monitoring service.
 */
export declare function hasMonitor(): boolean;
/**
 * getMonitor returns the current resource monitoring service client for RPC communications.
 */
export declare function getMonitor(): resrpc.IResourceMonitorClient | undefined;
/**
 * Waits for any pending stack transforms to register.
 */
export declare function awaitStackRegistrations(): Promise<void>;
/**
 * getCallbacks returns the current callbacks for RPC communications.
 */
export declare function getCallbacks(): ICallbackServer | undefined;
/**
 * hasEngine returns true if we are currently connected to an engine.
 */
export declare function hasEngine(): boolean;
/**
 * getEngine returns the current engine, if any, for RPC communications back to the resource engine.
 */
export declare function getEngine(): engrpc.IEngineClient | undefined;
export declare function terminateRpcs(): void;
/**
 * serialize returns true if resource operations should be serialized.
 */
export declare function serialize(): boolean;
/**
 * disconnect permanently disconnects from the server, closing the connections.  It waits for the existing RPC
 * queue to drain.  If any RPCs come in afterwards, however, they will crash the process.
 */
export declare function disconnect(): Promise<void>;
/**
 * getMaximumListeners returns the configured number of process listeners available
 */
export declare function getMaximumListeners(): number;
/**
 * disconnectSync permanently disconnects from the server, closing the connections. Unlike `disconnect`. it does not
 * wait for the existing RPC queue to drain. Any RPCs that come in after this call will crash the process.
 */
export declare function disconnectSync(): void;
/**
 * rpcKeepAlive registers a pending call to ensure that we don't prematurely disconnect from the server.  It returns
 * a function that, when invoked, signals that the RPC has completed.
 */
export declare function rpcKeepAlive(): () => void;
/**
 * setRootResource registers a resource that will become the default parent for all resources without explicit parents.
 */
export declare function setRootResource(res: ComponentResource): Promise<void>;
