"use strict";
// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const fs = __importStar(require("fs"));
const semver = __importStar(require("semver"));
const os = __importStar(require("os"));
const tmp = __importStar(require("tmp"));
const upath = __importStar(require("upath"));
const automation_1 = require("../../automation");
describe("automation/cmd", () => {
    it("calls onOutput when provided to runPulumiCmd", () => __awaiter(void 0, void 0, void 0, function* () {
        let output = "";
        let numCalls = 0;
        const pulumi = yield automation_1.PulumiCommand.get();
        yield pulumi.run(["--help"], ".", {}, (data) => {
            output += data;
            numCalls += 1;
        });
        assert.ok(numCalls > 0, `expected numCalls > 0, got ${numCalls}`);
        assert.match(output, new RegExp("Usage[:]"));
        assert.match(output, new RegExp("[-][-]verbose"));
    }));
    describe("CLI installation", () => {
        it("installs the requested version", () => __awaiter(void 0, void 0, void 0, function* () {
            const tmpDir = tmp.dirSync({ prefix: "automation-test-", unsafeCleanup: true });
            try {
                const cmd = yield automation_1.PulumiCommand.install({ root: tmpDir.name, version: new semver.SemVer("3.97.0") });
                assert.doesNotThrow(() => fs.statSync(upath.join(tmpDir.name, "bin", "pulumi")));
                const { stdout } = yield cmd.run(["version"], ".", {});
                assert.strictEqual(stdout.trim(), "3.97.0");
            }
            finally {
                tmpDir.removeCallback();
            }
        }));
        it("does not re-install the version if it already exists", () => __awaiter(void 0, void 0, void 0, function* () {
            const tmpDir = tmp.dirSync({ prefix: "automation-test-", unsafeCleanup: true });
            try {
                yield automation_1.PulumiCommand.install({ root: tmpDir.name, version: new semver.SemVer("3.97.0") });
                const binary1 = fs.statSync(upath.join(tmpDir.name, "bin", "pulumi"));
                yield automation_1.PulumiCommand.install({ root: tmpDir.name, version: new semver.SemVer("3.97.0") });
                const binary2 = fs.statSync(upath.join(tmpDir.name, "bin", "pulumi"));
                assert.strictEqual(binary1.ino, binary2.ino);
            }
            finally {
                tmpDir.removeCallback();
            }
        }));
        it("defaults to $HOME/.pulumi/versions/$VERSION if no root is provided", () => __awaiter(void 0, void 0, void 0, function* () {
            const version = new semver.SemVer("3.97.0");
            const cmd = yield automation_1.PulumiCommand.install({ version });
            assert.doesNotThrow(() => fs.statSync(upath.join(os.homedir(), ".pulumi", "versions", `${version}`, "bin", "pulumi")));
            const { stdout } = yield cmd.run(["version"], ".", {});
            assert.strictEqual(stdout.trim(), `${version}`);
        }));
        it("throws if the found version is not compatible with the requested version", () => __awaiter(void 0, void 0, void 0, function* () {
            const installedVersion = new semver.SemVer("3.97.0");
            yield automation_1.PulumiCommand.install({ version: installedVersion });
            const requestedVersion = new semver.SemVer("3.98.0");
            assert.rejects(automation_1.PulumiCommand.get({ version: requestedVersion }));
            assert.doesNotReject(automation_1.PulumiCommand.get({ version: installedVersion, skipVersionCheck: true }));
        }));
    });
    describe(`checkVersionIsValid`, () => {
        const MAJOR = /Major version mismatch./;
        const MINIMUM = /Minimum version requirement failed./;
        const PARSE = /Failed to parse/;
        const versionTests = [
            {
                name: "higher_major",
                currentVersion: "100.0.0",
                expectError: MAJOR,
                optOut: false,
            },
            {
                name: "lower_major",
                currentVersion: "1.0.0",
                expectError: MINIMUM,
                optOut: false,
            },
            {
                name: "higher_minor",
                currentVersion: "v2.22.0",
                expectError: null,
                optOut: false,
            },
            {
                name: "lower_minor",
                currentVersion: "v2.1.0",
                expectError: MINIMUM,
                optOut: false,
            },
            {
                name: "equal_minor_higher_patch",
                currentVersion: "v2.21.2",
                expectError: null,
                optOut: false,
            },
            {
                name: "equal_minor_equal_patch",
                currentVersion: "v2.21.1",
                expectError: null,
                optOut: false,
            },
            {
                name: "equal_minor_lower_patch",
                currentVersion: "v2.21.0",
                expectError: MINIMUM,
                optOut: false,
            },
            {
                name: "equal_minor_equal_patch_prerelease",
                // Note that prerelease < release so this case will error
                currentVersion: "v2.21.1-alpha.1234",
                expectError: MINIMUM,
                optOut: false,
            },
            {
                name: "opt_out_of_check_would_fail_otherwise",
                currentVersion: "v2.20.0",
                expectError: null,
                optOut: true,
            },
            {
                name: "opt_out_of_check_would_succeed_otherwise",
                currentVersion: "v2.22.0",
                expectError: null,
                optOut: true,
            },
            {
                name: "invalid_version",
                currentVersion: "invalid",
                expectError: PARSE,
                optOut: false,
            },
            {
                name: "invalid_version_opt_out",
                currentVersion: "invalid",
                expectError: null,
                optOut: true,
            },
        ];
        const minVersion = new semver.SemVer("v2.21.1");
        versionTests.forEach((test) => {
            it(`validates ${test.name} (${test.currentVersion})`, () => {
                const validate = () => automation_1.parseAndValidatePulumiVersion(minVersion, test.currentVersion, test.optOut);
                if (test.expectError) {
                    assert.throws(validate, test.expectError);
                }
                else {
                    assert.doesNotThrow(validate);
                }
            });
        });
    });
});
//# sourceMappingURL=cmd.spec.js.map